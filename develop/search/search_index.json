{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#population-activity-modeller","title":"Population Activity Modeller","text":"<p>PAM is a python library for population activity sequence modelling. Example use cases:</p> <ul> <li>Read an existing population then write to a new format.</li> <li>Modify an existing population, for example to model activity locations.</li> <li>Create your own activity-based model.</li> </ul> <p>PAM supports common travel and activity formats, including MATSim.</p>"},{"location":"#activity-sequences","title":"Activity Sequences?","text":"<p>Population activity sequences (sometimes called activity plans) are used to model the activities (where and when people are at home, work, education and so on) and associated travel of a population:</p> <p></p> <p>Activity sequences are used by transport planners to model travel demand, but can also be used in other domains, such as for virus transmission or energy use modelling.</p>"},{"location":"#brief-history","title":"Brief History","text":"<p>PAM was originally built and shared to rapidly modify existing activity models to respond to pandemic lock-down scenarios.</p> <p></p> <p>This functionality used a read-modify-write pattern. Where modifications are made by applying policies. Example policies might be (a) infected persons quarantine at home, (b) only critical workers travel to work, and (c) everyone shops locally.</p> <p></p>"},{"location":"#features","title":"Features","text":""},{"location":"#activity-modelling","title":"Activity Modelling","text":"<p>In addition to the original read-modify-write pattern and functionality, PAM has modules for:</p> <ul> <li>location modelling</li> <li>discretionary activity modelling</li> <li>mode choice modelling</li> <li>facility sampling</li> <li>vehicle ownership</li> </ul> <p>More generally the core PAM data structure and modules can be used as a library to support your own use cases, including building your own activity-based model.</p>"},{"location":"#matsim","title":"MATSim","text":"<p>PAM fully supports the MATSim population/plans format. This includes vehicles, unselected plans, leg routes and leg attributes. A core use case of PAM is to read-modify-write experienced plans from MATSim. This can allow new MATSim scenarios to be \"warm started\" from existing scenarios, significantly reducing MATSim compute time.</p>"},{"location":"#why-activity-plans","title":"Why Activity Plans?","text":"<ol> <li> <p>They are the ideal mechanism for applying changes, allowing for example, consideration of joint dis-aggregate features across an entire day.</p> </li> <li> <p>They can be post processed for many other output formats such as origin-destination matrices or activity diaries. These outputs can the be used in many different applications such as transport, utility demand, social impact and so on.</p> </li> </ol>"},{"location":"activity_plans/","title":"Activity Plans","text":"<p>PAM supports arbitrarily complex chains of activities connected by 'legs' (these are equivalent to 'trips'). The main rules are (i) that plans must consist of sequences of alternate  and  objects and (ii) that a plan must start and end with an <code>Activity</code>:</p> <pre><code>from pam.core import Person\nfrom pam.activity import Leg, Activity\nfrom pam\n\nperson = Person('Tony', attributes = {'age': 9, 'philosophy': 'stoicism'})\n\nperson.add(\n    Activity(\n        act='home',\n        area='zone A',\n    )\n)\n\nperson.add(\n    Leg(\n        mode='car',\n        start_time=utils.parse_time(600),  # (minutes)\n        end_time=utils.parse_time(630),\n    )\n)\n\nperson.add(\n    Activity(\n        act='work',\n        area='zone B',\n        )\n    )\n\nperson.add(\n    Leg(\n        mode='car',\n        start_time=utils.parse_time(1800),\n        end_time=utils.parse_time(1830),\n    )\n)\n\n# Continue adding Activities and Legs alternately.\n# A sequence must start and end with an activity.\n# ...\n\nperson.add(\n    Activity(\n        act='home',\n        area='zone B'\n    )\n)\n\nactivities = list(person.plan.activities)\ntrips = list(person.plan.legs)\n\nperson.print()\n</code></pre>"},{"location":"activity_plans/#how-travel-diaries-relate-to-activity-plans","title":"How travel diaries relate to activity plans","text":"<p>A key component of this project is the conversion of Travel Diaries to Activity Plans. We define a Travel Diary as a sequence of travel legs from zone to zone for a given purpose over a single day. The Activity Plan takes these legs and infers the activity types between. Example activity types are <code>home</code>, <code>work</code>, <code>education</code>, <code>escort_education</code> and so on.</p> <p>Activity Plan chains can be pretty complex, consider for example a business person attending meetings in many different locations and stopping to eat and shop. We always require the plan to last 24 hours and start and stop with an activity. We like these start and stop activities to both be the same and ideally <code>home</code>. We think of this as 'looping', but they don't have to. Night shift workers, for example, do not start or end the day at <code>home</code>.</p> <p>When we try to infer activity purpose from trip purpose, we expect a return trip to have the same purpose as the outbound trip, e.g.:</p> <p>trip1(work) + trip2(work) --&gt; activity1(home) + activity2(work) + activity3(home)</p> <p>But this logic is hard to follow for more complex chains, eg:</p> <p>trip1(work) + trip2(shop) + trip3(work) --&gt; activity1(home) + activity2(work) + activity3(shop) + activity4(home)</p> <p>The test cases in <code>test_3_parse_challenge</code> capture some of the difficult and edge cases observed so far.</p> <p>It is important to note that as a consequence of encoding outbound and return purpose as an activity, we never observe a trip purpose as <code>home</code>. Luckily we do know the home area from the travel diary data (<code>hzone</code>). But have to be careful with our logic, as travel between different activities locations can be intra-zonal, e.g.:</p> <p>activity1(home, zoneA) + activity2(shop, zoneA) + activity2(shop, zoneA)</p> <p>Activity Plans are represented in this project as regular python <code>lists()</code>, containing ordered <code>activity.Activity</code> and <code>activity.Leg</code> objects. Plans must start and end with a <code>activity.Activity</code>. Two <code>activity.Actvity</code> objects must be separated by a <code>core.Leg</code>.</p> <p>Plans belong to <code>core.People</code> which belong to <code>core.Households</code> which belong to a <code>core.Population</code>. For example:</p> <pre><code>from pam.core import Population, Household, Person\nfrom pam.activity import Activity, Leg\n\npopulation = Population()  # init\nhousehold = Household(hid=1)  # hid is household id\nperson = Person(pid=1)  # pid is person id\nperson.add(\n    Activity(seq=1, act='home', area='a', start_time=0, end_time=450)  # time in minutes\n)\nperson.add(\n    Leg(seq=1, mode='car', start_area='a', end_area='b', start_time=450, end_time=480)\n)\nperson.add(\n    Activity(2, 'work', 'b', 480, 880)\n)\nperson.add(\n    Leg(2, 'car', 'b', 'a', 880, 900)\n)\nperson.add(\n    Activity(3, 'home', 'a', 900, 24*60-1)  # last activity must end at 23:59(:59)\n)\nhousehold.add(person)\npopulation.add(household)\n</code></pre>"},{"location":"activity_plans/#a-note-on-the-pain-of-wrapping","title":"A note on the pain of wrapping","text":"<p>Activity Plans often enforce that a plan returns to the same activity (type and location) that they started at. Furthermore they sometimes enforce that this activity be <code>home</code>. Such plans can be thought of as wrapping plans. Where the last and first activity can be though of as linked. This need not be a <code>home</code> activity, for example in the case of night workers.</p> <p>We have encountered many variations of sequences for plans, including wrapping and wrapping. Although they are generally edge cases, they exists and generally represent real people. We are therefore endeavoring to support all these cases in our plan modifiers. This is resulting some difficult to follow logic (e.g., ).</p>"},{"location":"activity_plans/#plan-cropping","title":"Plan cropping","text":"<p>The <code>pam.operations.cropping</code> module allows to spatially subset populations, by simplifying plan components that take place outside the \"core\" area. Any activities or legs that do not affect that core area are removed from the agents' plans, and agents with fully-external plans are removed from the population. Examples of using the module can be found in the  notebook.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#setting-up-a-user-environment","title":"Setting up a user environment","text":"<p>As a PAM user, it is easiest to install PAM using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Create the PAM mamba environment and install <code>cml-pam</code> into it: <code>mamba create -n pam -c conda-forge -c city-modelling-lab cml-pam</code></li> <li>Activate the PAM mamba environment: <code>mamba activate pam</code></li> </ol> <p>All together:</p> <pre><code>mamba create -n pam -c conda-forge -c city-modelling-lab cml-pam\nmamba activate pam\n</code></pre> <p>We do not recommend trying to install PAM directly with pip (e.g. in a virtual environment) as you need to first install underlying native geospatial libraries, the method for which differs by operating system. If you choose to install into a virtual environment, ensure you have <code>libgdal</code> and <code>libspatialindex</code> installed on your device before installing with pip:</p> <pre><code>pip install cml-pam\n</code></pre>"},{"location":"installation/#running-the-example-notebooks","title":"Running the example notebooks","text":"<p>If you have followed the non-developer installation instructions above, you will need to install <code>jupyter</code> into your <code>pam</code> environment to run the example notebooks:</p> <pre><code>mamba install -n pam jupyter\n</code></pre> <p>With Jupyter installed, it's easiest to then add the environment as a jupyter kernel:</p> <pre><code>mamba activate pam\nipython kernel install --user --name=pam\njupyter notebook\n</code></pre>"},{"location":"installation/#choosing-a-different-environment-name","title":"Choosing a different environment name","text":"<p>If you would like to use a different name to <code>pam</code> for your mamba environment, the installation becomes (where <code>[my-env-name]</code> is your preferred name for the environment):</p> <pre><code>mamba create -n [my-env-name] -c conda-forge -c city-modelling-lab cml-pam\nmamba activate [my-env-name]\nipython kernel install --user --name=[my-env-name]\n</code></pre>"},{"location":"installation/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>The install instructions are slightly different to create a development environment compared to a user environment:</p> <pre><code>git clone git@github.com:arup-group/pam.git\ncd pam\nmamba create -n pam -c conda-forge -c city-modelling-lab --file requirements/base.txt --file requirements/dev.txt\nmamba activate pam\npip install --no-deps -e .\n</code></pre> <p>For more detailed installation instructions specific to developing the PAM codebase, see our development documentation.</p>"},{"location":"modelling_policy_impact/","title":"Modelling the impact of policies on populations","text":"<p>PAM uses policies to model change to a population. For example, based on social distancing requirements we might want to reflect that people are expected to make less shared shopping trips or tours. We can do this using the following policy, if you want to define the policy from first principles:</p> <pre><code>policy_reduce_shopping_activities = HouseholdPolicy(\n        ReduceSharedActivity(['shop', 'shop_food']),\n        ActivityProbability(['shop', 'shop_food'], 1)\n)\n</code></pre> <p>There exists a convenience class for this policy and an equivalent policy can be defined in the following way:</p> <pre><code>policy_reduce_shopping_activities = ReduceSharedHouseholdActivities(\n        ['shop', 'shop_food'],\n        ActivityProbability(['shop', 'shop_food'], 1)\n)\n</code></pre> <p>This policy removes all but one the household's shared shopping tours:</p> <p></p> <p>In general, a policy is defined in the following way:</p> <ol> <li>You first select the level at which is should be applied:<ul> <li>HouseholdPolicy</li> <li>PersonPolicy</li> <li>ActivityPolicy</li> </ul> </li> <li>You then select the modifier, which performs the actions to a person's activities<ul> <li>RemoveActivity</li> <li>ReduceSharedActivity</li> <li>MoveActivityTourToHomeLocation</li> </ul> </li> <li> <p>Finally, you give a likelihood value with which the policy should be applied with.     You have a few choices here:</p> <ul> <li> <p>a number greater than 0 and less or equal to 1. This will be understood to be at the level at which the policy is applied. E.g. <code>PersonPolicy(RemoveActivity(['work']), 0.5)</code> will give each person a fifty-fifty chance of having their work activities removed.</p> </li> <li> <p>you can explicitly define at which level a number greater than 0 and less or equal to 1 will be applied. E.g. <code>HouseholdPolicy(RemoveActivity(['work']), PersonProbability(0.5))</code> will apply a probability of 0.5 per person in a household, and apply the policy to all persons within a household if selected.</p> </li> <li> <p>you can also pass a function that operates on a Household, Person or Activity object and returns a number between 0 and 1. E.g. if our function is: <pre><code>def sampler(person):\n    if person.attributes['key_worker'] == True:\n        return 0\n    else:\n        return 1\n</code></pre> we can define <code>PersonPolicy(RemoveActivity(['work']), PersonProbability(sampler))</code> which will remove all work activities from anyone who is not a 'key_worker'</p> </li> <li> <p>you can choose from:</p> <ul> <li><code>HouseholdProbability</code></li> <li><code>PersonProbability</code></li> <li><code>ActivityProbability</code></li> </ul> </li> </ul> </li> </ol> <p>PAM allows multiple of such policies to be combined to build realistic and complex scenarios. Leveraging activity plans means that PAM can implement detailed policies that are dependent on:</p> <ul> <li>person attributes</li> <li>household attributes</li> <li>activity types</li> <li>travel modes</li> <li>times</li> <li>spatial locations</li> <li>sequences such as tours</li> <li>any combination of the above</li> </ul> <p>A full overview of policies and examples of the policies available are detailed in this example.</p>"},{"location":"modelling_policy_impact/#example-modifierspolicies","title":"Example modifiers/policies:","text":""},{"location":"modelling_policy_impact/#ill-and-self-quarantined","title":"Ill and self-quarantined","text":"<ul> <li>Person quarantine based on age</li> <li>Household quarantine based on household members</li> </ul>"},{"location":"modelling_policy_impact/#education-activities","title":"Education activities","text":"<p>Remove or reduce education based tours/trips including escorts:</p> <ul> <li>Remove education activities based on age</li> <li>Maintain education for 'care-constrained' households (critical workers)</li> </ul>"},{"location":"modelling_policy_impact/#work-activities","title":"Work activities","text":"<ul> <li>Furlough and unemployment based on sector</li> <li>Work from home based on sector</li> <li>Increase or reduce activities and activity durations based on sector</li> </ul>"},{"location":"modelling_policy_impact/#shopping-activities","title":"Shopping activities","text":"<ul> <li>Remove or reduce discretionary shopping</li> <li>Reduce food shopping</li> <li>Remove shared tours</li> <li>Move tours closer to home</li> </ul>"},{"location":"modelling_policy_impact/#discretionary-activities","title":"Discretionary activities","text":"<ul> <li>Remove or reduce discretionary activities such as leisure</li> <li>Move tours closer to home</li> <li>Select the location of discretionary activities, in relation to \"anchor\"/\"mandatory\" activities</li> </ul>"},{"location":"modelling_policy_impact/#in-progress-modifierspolicies","title":"In-progress modifiers/policies","text":"<p>Logic also be added to apply:</p> <ul> <li>mode shift</li> <li>location shift</li> <li>times</li> <li>durations</li> </ul>"},{"location":"read_data/","title":"Reading data","text":""},{"location":"read_data/#populations","title":"Populations","text":"<p>We have some read methods for common input data formats - but first let's take a quick look at the core pam data structure for populations:</p> <pre><code>from pam.core import Population, Household, Person\n\npopulation = Population()  # initialise an empty population\n\nhousehold = Household('hid0', attributes = {'struct': 'A', 'dogs': 2, ...})\npopulation.add(household)\n\nperson = Person('pid0', attributes = {'age': 33, 'height': 'tall', ...})\nhousehold.add(person)\n\nperson = Person('pid1', attributes = {'age': 35, 'cats_or_dogs?': 'dogs', ...})\nhousehold.add(person)\n\npopulation.print()\n</code></pre>"},{"location":"read_data/#read-methods","title":"Read methods","text":"<p>The first step in any application is to load your data into the core pam format (). We are trying to support common tabular formats ('travel diaries') using . A travel diary can be composed of three tables:</p> <ul> <li><code>trips</code> (required) -  a trip diary for all people in the population, with rows representing trips</li> <li><code>persons_attributes</code> (optional) - optionally include persons attributes (eg: <code>person income</code>)</li> <li><code>households_attributes</code> (optional) - optionally include households attributes (eg: <code>hh number of cars</code>)</li> </ul> <p>The input tables are expected as pandas.DataFrame, eg: <pre><code>import pandas as pd\nimport pam\n\ntrips_df = pd.read_csv(trips.csv)\npersons_df = pd.read_csv(persons.csv)\n\n# Fix headers and wrangle as required\n# ...\n\npopulation = pam.read.load_travel_diary(\n    trips = trips_df,\n    persons_attributes = persons_df,\n    hhs_attributes = None,\n    )\n\nprint(population.stats)\n\nexample_person = population.random_person\nexample_person.print()\nexample_person.plot()\n</code></pre></p> <p>PAM requires tabular inputs to follow a basic structure. Rows in the <code>trips</code> dataframe represent unique trips by all persons, rows in the <code>persons_attributes</code> dataframe represent unique persons and rows in the <code>hhs_attributes</code> dataframe represent unique households. Fields named <code>pid</code> (person ID) and <code>hid</code> (household ID) are used to provide unique identifiers to people and households.</p> <p>Trips Input:</p> <p>eg:</p> pid hid seq hzone ozone dzone purp mode tst tet freq 0 0 0 Harrow Harrow Camden work pt 444 473 4.54 0 0 1 Harrow Camden Harrow home pt 890 919 4.54 1 0 0 Harrow Harrow Tower Hamlets work car 507 528 2.2 1 0 1 Harrow Tower Hamlets Harrow home car 1065 1086 2.2 2 1 0 Islington Islington Hackney shop pt 422 425 12.33 2 1 1 Islington Hackney Hackney leisure walk 485 500 12.33 2 1 2 Islington Croydon Islington home pt 560 580 12.33 <p>A <code>trips</code> table is composed of rows representing unique trips for all persons in the population. Trips must be correctly ordered according to their sequence unless a numeric <code>seq</code> (trip sequence) field is provided, in which case trips will be ordered accordingly for each person.</p> <p>The <code>trips</code> input must include the following fields: - <code>pid</code> - person ID, used as a unique identifier to associate trips belonging to the same person and to join trips with person attributes if provided. - <code>ozone</code> - trip origin zone ID - <code>dzone</code> - trip destination zone ID - <code>mode</code> - trip mode - note that lower case strings are enforced - <code>tst</code> - trip start time in minutes (integer) or a datetime string (eg: \"2020-01-01 14:00:00\") - <code>tet</code> - trip end time in minutes (integer) or a datetime string (eg: \"2020-01-01 14:00:00\")</p> <p>The <code>trips</code> input must either: - <code>purp</code> - trip or tour purpose, eg 'work' - <code>oact</code> and <code>dact</code> - origin activity type and destination activity type, eg 'home' and 'work'</p> <p>Note that lower case strings are enforced and that 'home' activities should be encoded as <code>home</code>.</p> <p>The <code>trips</code> input may also include the following fields: - <code>hid</code> - household ID, used as a unique identifier to associate persons belonging to the same household and to join with household attributes if provided - <code>freq</code> - trip weighting for representative population - <code>seq</code> - trip sequence number, if omitted pam will assume that trips are already ordered - <code>hzone</code> - household zone</p> <p>'trip purpose' vs 'tour purpose':</p> <p>We've encountered a few different ways that trip purpose can be encoded. The preferred way being to encode a trip purpose as being the activity of the destination, so that a trip home would be encoded as <code>purp = home</code>. However we've also seen the more complex 'tour purpose' encoding, in which case a return trip from work to home is encoded as <code>purp = work</code>. Good news is that the  will deal ok with either. But it's worth checking.</p> <p>Using persons_attributes and /or households_attributes</p> <p>eg:</p> <p><code>persons.csv</code></p> pid hid hzone freq income age driver cats or dogs 0 0 Harrow 10.47 high high yes dogs 1 0 Harrow 0.034 low medium no dogs 2 1 Islington 8.9 medium low yes dogs <p><code>households.csv</code></p> hid hzone freq persons cars 0 Harrow 10.47 2 1 1 Islington 0.034 1 1 <p>If you are using persons_attributes (<code>persons_attributes</code>) this table must contain a <code>pid</code> field (person ID). If you are using persons_attributes (<code>households_attributes</code>) this table must contain a <code>hid</code> field (household ID). In both cases, the frequency field <code>freq</code> may be used. All other attributes can be included with column names to suit the attribute. Note that <code>hzone</code> (home zone) can optionally be provided in the attribute tables.</p> <p>A note about 'freq':</p> <p>Frequencies (aka 'weights') for trips, persons or households can optionally be added to the respective input tables using columns called <code>freq</code>. We generally assume a frequency to represent expected occurrences in a full population. For example if we use a person frequency () the the sum of all these frequencies (), will equal the expected population size.</p> <p>Because it is quite common to provide a person or household <code>freq</code> in the trips table, there are two special options (<code>trip_freq_as_person_freq = True</code> and <code>trip_freq_as_hh_freq = True</code>) that can be used to pass the <code>freq</code> field from the trips table to either the people or households table instead.</p> <p>Generally PAM will assume when you want some weighted output, that it should use household frequencies. If these have not been set then PAM will assume that the household frequency is the average frequency of persons within the household. If person frequencies are not set the PAM will assume that the person frequency is the average frequency of legs within the persons plan. If you wish to adjust frequencies of a population then you should use the <code>set_freq()</code> method, eg:</p> <pre><code>factor = 1.2\nhousehold.set_freq(household.freq * factor)\nfor pid, person in household:\n    person.set_freq(person.freq * factor)\n</code></pre>"},{"location":"read_data/#readwriteother-formats","title":"Read/Write/Other formats","text":"<p>PAM can read/write to tabular formats and MATSim xml ( and ). PAM can also write to segmented OD matrices using .</p> <p>Benchmark or summary data and cross-tabulations can be extracted with the benchmarking CLI method. For more fine-grain control, pandas dataframes for specific data field(s), dimension(s) and aggregation function(s) can be generated with . For example <code>pam.report.benchmarks.create_benchmark(population.trips_df(), dimensions = ['duration_category'], data_fields= ['freq'], aggfunc = [sum]</code> returns the frequency breakdown of trips' duration.</p> <p>Please get in touch if you would like additional support or feel free to add your own.</p>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"api/cli/#examples","title":"Examples","text":"<ul> <li>to get a summary or a MATSim plans file: <code>pam report summary tests/test_data/test_matsim_plansv12.xml</code>.</li> <li>plan cropping: <code>pam crop &lt;path_population_xml&gt; &lt;path_core_area_geojson&gt; &lt;path_output_directory&gt;</code>.</li> <li>down/up-sampling an xml population: <code>pam sample &lt;path_population_xml&gt; &lt;path_output_directory&gt; -s &lt;sample_percentage&gt; -v &lt;matsim_version&gt;</code>. For example, you can use: <code>pam sample tests/test_data/test_matsim_plansv12.xml tests/test_data/output/sampled -s 0.1</code> to create a downsampled (to 10%) version of the input (<code>test_matsim_plansv12.xml</code>) population.</li> <li>combining populations: <code>pam combine &lt;input_population_1&gt; &lt;input_population_2&gt; &lt;input_population_3...etc&gt; -o &lt;outpath_directory&gt; -m &lt;comment&gt; -v &lt;matsim_version&gt;</code>.</li> </ul>"},{"location":"api/cli/#pam","title":"pam","text":"<p>Population Activity Modeller (PAM) Command Line Tool.</p> <p>Usage:</p> <pre><code>pam [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-combine","title":"pam combine","text":"<p>Combine multiple populations (e.g. household, freight.. etc).</p> <p>Usage:</p> <pre><code>pam combine [OPTIONS] [POPULATION_PATHS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--population_output</code>, <code>-o</code> path Specify outpath for combined_population.xml, default is cwd <code>combined_population.xml</code> <code>--force</code>, <code>-f</code> boolean Forces overwrite of existing file. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-crop","title":"pam crop","text":"<p>Crop a population's plans outside a core area.</p> <p>Usage:</p> <pre><code>pam crop [OPTIONS] PATH_POPULATION_INPUT PATH_BOUNDARY DIR_POPULATION_OUTPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--buffer</code>, <code>-b</code> integer A buffer distance to (optionally) apply to the core area shapefile. <code>0</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report","title":"pam report","text":"<p>Various reporting for MATSim formatted plans.</p> <p>Usage:</p> <pre><code>pam report [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report-benchmarks","title":"pam report benchmarks","text":"<p>Write batch of benchmarks to directory.</p> <p>Usage:</p> <pre><code>pam report benchmarks [OPTIONS] POPULATION_INPUT_PATH OUTPUT_DIRECTORY\n</code></pre> <p>Options:</p> Name Type Description Default <code>--sample_size</code>, <code>-s</code> float Input sample size. Default 1. Required for downsampled populations. eg, use 0.1 for a 10% input population. <code>1</code> <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report-stringify","title":"pam report stringify","text":"<p>ASCII plot activity plans to terminal.</p> <p>Usage:</p> <pre><code>pam report stringify [OPTIONS] PATH_POPULATION_INPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>--colour</code> / <code>--bw</code> boolean Choose a colour or grey-scale (bw) output, default 'colour' <code>True</code> <code>--width</code>, <code>-w</code> integer Target character width for plot, default 72 <code>72</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to crop. <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report-summary","title":"pam report summary","text":"<p>Summarise a population.</p> <p>Usage:</p> <pre><code>pam report summary [OPTIONS] PATH_POPULATION_INPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--sample_size</code>, <code>-s</code> float Input sample size. Default 1. For example, use 0.1 to apply a 10% weighting to the input population. <code>1</code> <code>--attribute_key</code>, <code>-k</code> text Optional population attribute key to segment output, eg 'subpopulation'. None <code>--rich</code> / <code>--text</code> boolean Formatted (for terminal) or regular text output (for .txt). <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-sample","title":"pam sample","text":"<p>Down- or up-sample a PAM population.</p> <p>Usage:</p> <pre><code>pam sample [OPTIONS] PATH_POPULATION_INPUT DIR_POPULATION_OUTPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--sample_size</code>, <code>-s</code> text The sample size, eg, use 0.1 to produce a 10% version of the input population. None <code>--household_key</code>, <code>-h</code> text Household key, defaults to 'hid'. <code>hid</code> <code>--seed</code> text Random seed. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-wipe-all-links","title":"pam wipe-all-links","text":"<p>Clear all link information from agent plans. Including routes and activity locations.</p> <p>Usage:</p> <pre><code>pam wipe-all-links [OPTIONS] PATH_POPULATION_INPUT PATH_POPULATION_OUTPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-wipe-links","title":"pam wipe-links","text":"<p>Clear selected link information from agent plans. Includes routes and activity locations.</p> <p>eg: <code>pam wipe-links INPUT_PLANS.xml OUTPUT_PLANS.xml link_a link_b link_c</code></p> <p>Usage:</p> <pre><code>pam wipe-links [OPTIONS] PATH_POPULATION_INPUT PATH_POPULATION_OUTPUT\n               [LINKS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"contributing/","title":"Contributing","text":"<p>PAM is an actively maintained and utilised project.  Our goals are to enhance:</p> <ul> <li>Theoretical Quality: Expert driven features with research and open case studies.</li> <li>Feature Quality: Broadly useful and extendable features with good documentation and testing.</li> </ul> <p>Less abstractly, there are a good number of coding and non-coding tasks that you can contribute to.</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>to report issues, request features, or exchange with our community, just follow the links below.</p> <p>Is something not working?</p> <p> Report a bug</p> <p>Missing information in our docs?</p> <p> Report a docs issue</p> <p>Want to submit an idea?</p> <p> Request a change</p> <p>Have a question or need help?</p> <p> Ask a question</p>"},{"location":"contributing/coding/","title":"Coding contributions","text":"<p>To find beginner-friendly existing bugs and feature requests you may like to start out with, take a look at our good first issues.</p> <p>We need help to go faster as we would like to deal with populations in the tens of millions. This means we would like help with profiling and implementing parallel compute, in particular.</p>"},{"location":"contributing/coding/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>To create a development environment for PAM, with all libraries required for development and quality assurance installed, it is easiest to install PAM using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Download (a.k.a., clone) the PAM repository: <code>git clone git@github.com:arup-group/pam.git</code></li> <li>Change into the <code>pam</code> directory: <code>cd pam</code></li> <li>Create the PAM mamba environment: <code>mamba create -n pam -c conda-forge -c city-modelling-lab --file requirements/base.txt --file requirements/dev.txt</code></li> <li>Activate the PAM mamba environment: <code>mamba activate pam</code></li> <li>Install the PAM package into the environment, in editable mode and ignoring dependencies (we have dealt with those when creating the mamba environment): <code>pip install --no-deps -e .</code></li> </ol> <p>All together:</p> <pre><code>git clone git@github.com:arup-group/pam.git\ncd pam\nmamba create -n pam -c conda-forge -c city-modelling-lab --file requirements/base.txt --file requirements/dev.txt\nmamba activate pam\npip install --no-deps -e .\n</code></pre> <p>If installing directly with pip, you can install these libraries using the <code>dev</code> option, i.e., <code>pip install -e '.[dev]'</code> Either way, you should add your environment as a jupyter kernel, so the example notebooks can run in the tests: <code>ipython kernel install --user --name=pam</code></p> <p>If you plan to make changes to the code then please make regular use of the following tools to verify the codebase while you work:</p> <ul> <li><code>pre-commit</code>: run <code>pre-commit install</code> in your command line to load inbuilt checks that will run every time you commit your changes. The checks are: 1. check no large files have been staged, 2. lint python files for major errors, 3. format python files to conform with the PEP8 standard. You can also run these checks yourself at any time to ensure staged changes are clean by calling <code>pre-commit</code>.</li> <li><code>pytest</code> - run the unit test suite, check test coverage, and test that the example notebooks successfully run.</li> </ul> <p>Note</p> <p>If you already have an environment called <code>pam</code> on your system (e.g., for a stable installation of the package), you will need to chose a different environment name. You will then need to add this as a pytest argument when running the tests: <code>pytest --nbmake-kernel=[my-env-name]</code>.</p>"},{"location":"contributing/coding/#rapid-fire-testing","title":"Rapid-fire testing","text":"<p>The following options allow you to strip down the test suite to the bare essentials:</p> <ol> <li>The test suite includes unit tests and integration tests (in the form of jupyter notebooks found in the <code>examples</code> directory). The integration tests can be slow, so if you want to avoid them during development, you should run <code>pytest tests/</code>.</li> <li>You can avoid generating coverage reports, by adding the <code>--no-cov</code> argument: <code>pytest --no-cov</code>.</li> <li>By default, the tests run with up to two parallel threads, to increase this to e.g. 4 threads: <code>pytest -n4</code>.</li> </ol> <p>All together:</p> <pre><code>pytest tests/ --no-cov -n4\n</code></pre> <p>Note</p> <p>You cannot debug failing tests and have your tests run in parallel, you will need to set <code>-n0</code> if using the <code>--pdb</code> flag</p>"},{"location":"contributing/coding/#memory-profiling","title":"Memory profiling","text":"<p>Note</p> <p>When you open a pull request (PR), one of the GitHub actions will run memory profiling for you. This means you don't have to do any profiling locally. However, if you can, it is still good practice to do so as you will catch issues earlier.</p> <p>PAM can be memory intensive; we like to ensure that any development to the core code does not exacerbate this. If you are running on a UNIX device (i.e., not on Windows), you can test whether any changes you have made adversely impact memory and time performance as follows:</p> <ol> <li>Install memray in your <code>pam</code> mamba environment: <code>mamba install memray pytest-memray</code>.</li> <li>Run the memory profiling integration test: <code>pytest -p memray -m \"high_mem\" --no-cov</code>.</li> <li>Optionally, to visualise the memory allocation, run <code>pytest -p memray -m \"high_mem\" --no-cov --memray-bin-path=[my_path] --memray-bin-prefix=[my_prefix]</code> - where you must define <code>[my_path]</code> and <code>[my_prefix]</code> - followed by <code>memray flamegraph [my_path]/[my_prefix]-tests-test_100_memory_profiling.py-test_activity_loader.bin</code>. You will then find the HTML report at <code>[my_path]/memray-flamegraph-[my_prefix]-tests-test_100_memory_profiling.py-test_activity_loader.html</code>.</li> </ol> <p>All together:</p> <pre><code>mamba install memray pytest-memray\npytest -p memray -m \"high_mem\" --no-cov --memray-bin-path=[my_path] --memray-bin-prefix=[my_prefix]\nmemray flamegraph [my_path]/[my_prefix]-tests-test_100_memory_profiling.py-test_activity_loader.bin\n</code></pre> <p>For more information on using memray, refer to their documentation.</p>"},{"location":"contributing/coding/#submitting-changes","title":"Submitting changes","text":"<p>To contribute changes:</p> <ol> <li>Fork the project on GitHub.</li> <li>Create a feature branch to work on in your fork (<code>git checkout -b new-fix-or-feature</code>).</li> <li>Test your changes using <code>pytest</code>.</li> <li>Commit your changes to the feature branch (you should have <code>pre-commit</code> installed to ensure your code is correctly formatted when you commit changes).</li> <li>Push the branch to GitHub (<code>git push origin new-fix-or-feature</code>).</li> <li>On GitHub, create a new pull request from the feature branch.</li> </ol>"},{"location":"contributing/coding/#pull-requests","title":"Pull requests","text":"<p>Before submitting a pull request, check whether you have:</p> <ul> <li>Added your changes to <code>CHANGELOG.md</code>.</li> <li>Added or updated documentation for your changes.</li> <li>Added tests if you implemented new functionality.</li> </ul> <p>When opening a pull request, please provide a clear summary of your changes!</p>"},{"location":"contributing/coding/#commit-messages","title":"Commit messages","text":"<p>Please try to write clear commit messages. One-line messages are fine for small changes, but bigger changes should look like this:</p> <pre><code>A brief summary of the commit (max 50 characters)\n\nA paragraph or bullet-point list describing what changed and its impact,\ncovering as many lines as needed.\n</code></pre>"},{"location":"contributing/coding/#code-conventions","title":"Code conventions","text":"<p>Start reading our code and you'll get the hang of it.</p> <p>We mostly follow the official Style Guide for Python Code (PEP8).</p> <p>We have chosen to use the uncompromising code formatter <code>black</code> and the linter <code>ruff</code>. When run from the root directory of this repo, <code>pyproject.toml</code> should ensure that formatting and linting fixes are in line with our custom preferences (e.g., 100 character maximum line length). The philosophy behind using <code>black</code> is to have uniform style throughout the project dictated by code. Since <code>black</code> is designed to minimise diffs, and make patches more human readable, this also makes code reviews more efficient. To make this a smooth experience, you should run <code>pre-commit install</code> after setting up your development environment, so that <code>black</code> makes all the necessary fixes to your code each time you commit, and so that <code>ruff</code> will highlight any errors in your code. If you prefer, you can also set up your IDE to run these two tools whenever you save your files, and to have <code>ruff</code> highlight erroneous code directly as you type. Take a look at their documentation for more information on configuring this.</p> <p>We require all new contributions to have docstrings for all modules, classes and methods. When adding docstrings, we request you use the Google docstring style.</p>"},{"location":"contributing/coding/#release-checklist","title":"Release checklist","text":""},{"location":"contributing/coding/#pre-release","title":"Pre-release","text":"<ul> <li> Re-run tutorial Jupyter notebooks (<code>pytest examples/ --overwrite</code>).</li> <li> Make sure documentation builds without errors (<code>mike deploy [version]</code>, where <code>[version]</code> is the current patch release of the form <code>X.Y.Z</code>).</li> <li> Make sure the changelog is up-to-date, especially that new features and backward incompatible changes are clearly marked.</li> </ul>"},{"location":"contributing/coding/#create-release","title":"Create release","text":"<ul> <li> Bump the version number in <code>pam/__init__.py</code></li> <li> Update the changelog with final version number of the form <code>vX.Y.Z</code>, release date, and github <code>compare</code> link (at the bottom of the page).</li> <li> Commit with message <code>Release vX.Y.Z</code>, then add a <code>vX.Y.Z</code> tag.</li> <li> Create a release pull request to verify that the conda package builds successfully.</li> <li> Once the PR is approved and merged, create a release through the GitHub web interface, using the same tag, titling it <code>Release vX.Y.Z</code> and include all the changelog elements that are not flagged as internal.</li> </ul>"},{"location":"contributing/coding/#post-release","title":"Post-release","text":"<ul> <li> Update the changelog, adding a new <code>[Unreleased]</code> heading.</li> <li> Update <code>pam/__init__.py</code> to the next version appended with <code>.dev0</code>, in preparation for the next main commit.</li> </ul>"},{"location":"contributing/non_coding/","title":"Non-coding contributions","text":""},{"location":"contributing/non_coding/#literature-review","title":"Literature review","text":"<p>We still need validation of the overall approach. Much of the methodology (detailed in this document) is based on what can pragmatically be done, not what theoretically should be done. We'd appreciate links to relevant papers. Or even better we'd love a lit review - we'll add it to this document.</p>"},{"location":"contributing/non_coding/#research","title":"Research","text":"<p>We need help with designing useful features, applying them to real problems. As part of this we need:</p>"},{"location":"contributing/non_coding/#evidence-and-data-for-validation","title":"Evidence and data for validation","text":"<p>We know, for example, that many people have removed certain activities from their daily plans, such as to school or university. But we don't know how many. We'd like help finding and eventually applying validation data such as recent change in mobility.</p>"},{"location":"contributing/non_coding/#evidence-for-new-features","title":"Evidence for new features","text":"<p>We currently support the following activity plan modifications:</p> <ul> <li>probabilistic removal of all activities, i.e., full quarantine or isolation</li> <li>probabilistic removal of specific activities, i.e., education</li> <li>automatic extension of other (typically staying at home) activities</li> </ul> <p>But we'd like help to find evidence for other modifications that we think are occurring:</p> <ul> <li>changing duration of an activity</li> <li>moving activity closer to home, i.e., shopping trips</li> <li>changing travel choice, i.e., mode</li> <li>moving home location (i.e., national and local emigration)</li> <li>household shared activities/no longer shared activities, such as leisure</li> <li>defining key workers</li> </ul>"},{"location":"contributing/non_coding/#evidence-for-technical-methodology","title":"Evidence for technical methodology","text":"<p>Modifying a plan to remove an activity can cascade into other changes. In the case of people with complex chains of activities, the removal of a single activity requires adjustments to the remainder. Do people leave later of earlier if they have more time for example? The methods for this logic is in [pam.core].People.</p>"},{"location":"examples/01_basics/","title":"PAM Basics","text":"<p>This notebook demonstrates the core mechanics of PAM by creating a demonstration population.</p> In\u00a0[1]: Copied! <pre>from pam.core import Household, Person, Population\n</pre> from pam.core import Household, Person, Population In\u00a0[2]: Copied! <pre>population = Population()  # initialise an empty population\nhousehold = Household(hid=0)\nperson = Person(pid=0, attributes={\"income\": \"medium\"})\n\nhousehold.add(person)\npopulation.add(household)\n\npopulation.stats\n</pre> population = Population()  # initialise an empty population household = Household(hid=0) person = Person(pid=0, attributes={\"income\": \"medium\"})  household.add(person) population.add(household)  population.stats Out[2]: <pre>{'num_households': 1, 'num_people': 1, 'num_activities': 0, 'num_legs': 0}</pre> In\u00a0[3]: Copied! <pre># If you are not modelling household, the above is equivalent to:\npopulation = Population()\npopulation.add(Person(pid=0, attributes={\"income\": \"medium\"}))\npopulation.stats\n# In this case a unique household is created for the person with the same id.\n</pre> # If you are not modelling household, the above is equivalent to: population = Population() population.add(Person(pid=0, attributes={\"income\": \"medium\"})) population.stats # In this case a unique household is created for the person with the same id. Out[3]: <pre>{'num_households': 1, 'num_people': 1, 'num_activities': 0, 'num_legs': 0}</pre> In\u00a0[4]: Copied! <pre>from pam.activity import Activity, Trip\nfrom pam.utils import minutes_to_datetime as mtdt\n</pre> from pam.activity import Activity, Trip from pam.utils import minutes_to_datetime as mtdt In\u00a0[5]: Copied! <pre>activity = Activity(act=\"home\", area=\"A\", start_time=mtdt(0), end_time=mtdt(445))\ntrip = Trip(mode=\"car\", start_area=\"A\", end_area=\"B\", start_time=mtdt(445), end_time=mtdt(505))\nprint(activity)\nprint(trip)\n</pre> activity = Activity(act=\"home\", area=\"A\", start_time=mtdt(0), end_time=mtdt(445)) trip = Trip(mode=\"car\", start_area=\"A\", end_area=\"B\", start_time=mtdt(445), end_time=mtdt(505)) print(activity) print(trip) <pre>Activity(act:home, location:A, time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\nLeg(mode:car, area:A --&gt; B, time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n</pre> <p>Activities and Trips can be added to a Person object using <code>Person.add</code>:</p> In\u00a0[6]: Copied! <pre>person = Person(pid=0, attributes={\"type\": \"example\"})\n\nperson.add(Activity(act=\"home\", area=\"A\", start_time=mtdt(0), end_time=mtdt(445)))\nperson.add(Trip(mode=\"car\", start_area=\"A\", end_area=\"B\", start_time=mtdt(445), end_time=mtdt(505)))\nperson.add(Activity(act=\"hotel\", area=\"B\", start_time=mtdt(505), end_time=mtdt(1000)))\n\nperson.validate()  # the validate method check for consistency in the sequence of locations and times\nperson.print()\n</pre> person = Person(pid=0, attributes={\"type\": \"example\"})  person.add(Activity(act=\"home\", area=\"A\", start_time=mtdt(0), end_time=mtdt(445))) person.add(Trip(mode=\"car\", start_area=\"A\", end_area=\"B\", start_time=mtdt(445), end_time=mtdt(505))) person.add(Activity(act=\"hotel\", area=\"B\", start_time=mtdt(505), end_time=mtdt(1000)))  person.validate()  # the validate method check for consistency in the sequence of locations and times person.print() <pre>Person: 0\n{'type': 'example'}\n0:\tActivity(act:home, location:A, time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\n1:\tLeg(mode:car, area:A --&gt; B, time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n2:\tActivity(act:hotel, location:B, time:08:25:00 --&gt; 16:40:00, duration:8:15:00)\n</pre> In\u00a0[7]: Copied! <pre>person.plot()\n</pre> person.plot() In\u00a0[8]: Copied! <pre>from shapely.geometry import Point\n</pre> from shapely.geometry import Point In\u00a0[9]: Copied! <pre>person = Person(pid=0, attributes={\"type\": \"example\"})\n\nperson.add(\n    Activity(act=\"home\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(445))\n)\nperson.add(\n    Trip(\n        mode=\"car\",\n        start_area=\"A\",\n        end_area=\"B\",\n        start_loc=Point((0, 0)),\n        end_loc=Point((1234, 1234)),\n        start_time=mtdt(445),\n        end_time=mtdt(505),\n    )\n)\nperson.add(Activity(act=\"hotel\", area=\"B\", start_time=mtdt(505), end_time=mtdt(1000)))\n\nperson.validate()  # the validate method check for consistency in the sequence of locations and times\nperson.print()\n</pre> person = Person(pid=0, attributes={\"type\": \"example\"})  person.add(     Activity(act=\"home\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(445)) ) person.add(     Trip(         mode=\"car\",         start_area=\"A\",         end_area=\"B\",         start_loc=Point((0, 0)),         end_loc=Point((1234, 1234)),         start_time=mtdt(445),         end_time=mtdt(505),     ) ) person.add(Activity(act=\"hotel\", area=\"B\", start_time=mtdt(505), end_time=mtdt(1000)))  person.validate()  # the validate method check for consistency in the sequence of locations and times person.print() <pre>Person: 0\n{'type': 'example'}\n0:\tActivity(act:home, location:POINT (0 0), time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\n1:\tLeg(mode:car, area:POINT (0 0) --&gt; POINT (1234 1234), time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n2:\tActivity(act:hotel, location:B, time:08:25:00 --&gt; 16:40:00, duration:8:15:00)\n</pre> In\u00a0[10]: Copied! <pre>population = Population()  # create a new empty population\n</pre> population = Population()  # create a new empty population In\u00a0[11]: Copied! <pre>the_smiths = Household(\"Smiths\")\n\ntom = Person(\"Tom\", attributes={\"age\": \"low\"})\ntammy = Person(\"Tammy\", attributes={\"age\": \"low\"})\nthe_smiths.add([tom, tammy])\n\npopulation.add(the_smiths)  # and add the household to the population\n\ntammy.add(\n    [\n        Activity(act=\"home\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(445)),\n        Trip(\n            mode=\"car\",\n            start_area=\"A\",\n            end_area=\"B\",\n            start_loc=Point((0, 0)),\n            end_loc=Point((1234, 1234)),\n            start_time=mtdt(445),\n            end_time=mtdt(505),\n        ),\n        Activity(\n            act=\"work\", area=\"B\", loc=Point((1233, 1234)), start_time=mtdt(505), end_time=mtdt(990)\n        ),\n        Trip(\n            mode=\"car\",\n            start_area=\"B\",\n            end_area=\"A\",\n            start_loc=Point((1234, 1234)),\n            end_loc=Point((0, 0)),\n            start_time=mtdt(990),\n            end_time=mtdt(1050),\n        ),\n        Activity(\n            act=\"home\",\n            area=\"A\",\n            loc=Point((0, 0)),\n            start_time=mtdt(1050),\n            end_time=mtdt(24 * 60),  # assuming a 24 hour day\n        ),\n    ]\n)\n\ntom.add(\n    [\n        Activity(\n            act=\"home\",\n            area=\"A\",\n            loc=Point((0, 0)),\n            start_time=mtdt(0),\n            end_time=mtdt(24 * 60),  # assuming a 24 hour day\n        )\n    ]\n)\n</pre> the_smiths = Household(\"Smiths\")  tom = Person(\"Tom\", attributes={\"age\": \"low\"}) tammy = Person(\"Tammy\", attributes={\"age\": \"low\"}) the_smiths.add([tom, tammy])  population.add(the_smiths)  # and add the household to the population  tammy.add(     [         Activity(act=\"home\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(445)),         Trip(             mode=\"car\",             start_area=\"A\",             end_area=\"B\",             start_loc=Point((0, 0)),             end_loc=Point((1234, 1234)),             start_time=mtdt(445),             end_time=mtdt(505),         ),         Activity(             act=\"work\", area=\"B\", loc=Point((1233, 1234)), start_time=mtdt(505), end_time=mtdt(990)         ),         Trip(             mode=\"car\",             start_area=\"B\",             end_area=\"A\",             start_loc=Point((1234, 1234)),             end_loc=Point((0, 0)),             start_time=mtdt(990),             end_time=mtdt(1050),         ),         Activity(             act=\"home\",             area=\"A\",             loc=Point((0, 0)),             start_time=mtdt(1050),             end_time=mtdt(24 * 60),  # assuming a 24 hour day         ),     ] )  tom.add(     [         Activity(             act=\"home\",             area=\"A\",             loc=Point((0, 0)),             start_time=mtdt(0),             end_time=mtdt(24 * 60),  # assuming a 24 hour day         )     ] ) In\u00a0[12]: Copied! <pre>the_smiths.plot()\n</pre> the_smiths.plot() In\u00a0[13]: Copied! <pre>milkman = Person(\"milk_bot\", attributes={\"bot\": \"yes\", \"electric vehicle\": \"yes\"})\n\npopulation.add(\n    milkman\n)  # adding a person directly to the population is possible but a household with the same id will be auto generated\n\nmilkman.add(\n    [\n        Activity(act=\"depot\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(300)),\n        Trip(\n            mode=\"car\",\n            start_area=\"A\",\n            end_area=\"A\",\n            start_loc=Point((0, 0)),\n            end_loc=Point((1000, 1000)),\n            start_time=mtdt(300),\n            end_time=mtdt(310),\n        ),\n        Activity(\n            act=\"delivery\",\n            area=\"A\",\n            loc=Point((1000, 1000)),\n            start_time=mtdt(310),\n            end_time=mtdt(320),\n        ),\n        Trip(\n            mode=\"car\",\n            start_area=\"A\",\n            end_area=\"A\",\n            start_loc=Point((1000, 1000)),\n            end_loc=Point((0, 1000)),\n            start_time=mtdt(320),\n            end_time=mtdt(330),\n        ),\n        Activity(\n            act=\"delivery\", area=\"A\", loc=Point((0, 1000)), start_time=mtdt(330), end_time=mtdt(340)\n        ),\n        Trip(\n            mode=\"car\",\n            start_area=\"A\",\n            start_loc=Point((0, 1000)),\n            end_loc=Point((0, 0)),\n            end_area=\"A\",\n            start_time=mtdt(340),\n            end_time=mtdt(350),\n        ),\n        Activity(\n            act=\"depot\",\n            area=\"A\",\n            loc=Point((0, 0)),\n            start_time=mtdt(350),\n            end_time=mtdt(24 * 60),  # assuming a 24 hour day\n        ),\n    ]\n)\n</pre> milkman = Person(\"milk_bot\", attributes={\"bot\": \"yes\", \"electric vehicle\": \"yes\"})  population.add(     milkman )  # adding a person directly to the population is possible but a household with the same id will be auto generated  milkman.add(     [         Activity(act=\"depot\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(300)),         Trip(             mode=\"car\",             start_area=\"A\",             end_area=\"A\",             start_loc=Point((0, 0)),             end_loc=Point((1000, 1000)),             start_time=mtdt(300),             end_time=mtdt(310),         ),         Activity(             act=\"delivery\",             area=\"A\",             loc=Point((1000, 1000)),             start_time=mtdt(310),             end_time=mtdt(320),         ),         Trip(             mode=\"car\",             start_area=\"A\",             end_area=\"A\",             start_loc=Point((1000, 1000)),             end_loc=Point((0, 1000)),             start_time=mtdt(320),             end_time=mtdt(330),         ),         Activity(             act=\"delivery\", area=\"A\", loc=Point((0, 1000)), start_time=mtdt(330), end_time=mtdt(340)         ),         Trip(             mode=\"car\",             start_area=\"A\",             start_loc=Point((0, 1000)),             end_loc=Point((0, 0)),             end_area=\"A\",             start_time=mtdt(340),             end_time=mtdt(350),         ),         Activity(             act=\"depot\",             area=\"A\",             loc=Point((0, 0)),             start_time=mtdt(350),             end_time=mtdt(24 * 60),  # assuming a 24 hour day         ),     ] ) In\u00a0[14]: Copied! <pre>milkman.plot()\n</pre> milkman.plot() In\u00a0[15]: Copied! <pre># iterate through households and persons\nfor hid, household in population:\n    household.attributes[\"checked\"] = True\n    for pid, person in household:\n        person.attributes[\"checked\"] = True\n\n# iterate through persons only\nfor hid, pid, person in population.people():\n    person.attributes[\"checked_again\"] = True\n\n# access household directly\npopulation[\"Smiths\"].attributes[\"smiths_check\"] = True\n\n# access person directly\npopulation[\"Smiths\"][\"Tammy\"].attributes[\"tammy_check\"] = True\n\n# access a random household\npopulation.random_household().attributes[\"random_check\"] = True\n\n# access a random person\npopulation.random_person().attributes[\"random_check\"] = True\n</pre> # iterate through households and persons for hid, household in population:     household.attributes[\"checked\"] = True     for pid, person in household:         person.attributes[\"checked\"] = True  # iterate through persons only for hid, pid, person in population.people():     person.attributes[\"checked_again\"] = True  # access household directly population[\"Smiths\"].attributes[\"smiths_check\"] = True  # access person directly population[\"Smiths\"][\"Tammy\"].attributes[\"tammy_check\"] = True  # access a random household population.random_household().attributes[\"random_check\"] = True  # access a random person population.random_person().attributes[\"random_check\"] = True <p>Person plans can be similarly accessed and modified in a variety of ways:</p> In\u00a0[16]: Copied! <pre>from copy import deepcopy\n\nperson = population[\"Smiths\"][\"Tom\"]\n\n# modify a persons plan\nperson.plan = deepcopy(population[\"Smiths\"][\"Tammy\"].plan)\n\n# access plan components via index\nassert person.plan[0].act == \"home\"\n\n# iterate plan components\nfor component in person.plan:\n    print(component)\n\n# iterate plan activities\nfor activity in person.activities:\n    if activity.act == \"work\":\n        activity.act = \"golf\"\n\n# iterate plan legs\nfor leg in person.legs:\n    leg.mode = \"walk\"\n\nperson.plot()\n</pre> from copy import deepcopy  person = population[\"Smiths\"][\"Tom\"]  # modify a persons plan person.plan = deepcopy(population[\"Smiths\"][\"Tammy\"].plan)  # access plan components via index assert person.plan[0].act == \"home\"  # iterate plan components for component in person.plan:     print(component)  # iterate plan activities for activity in person.activities:     if activity.act == \"work\":         activity.act = \"golf\"  # iterate plan legs for leg in person.legs:     leg.mode = \"walk\"  person.plot() <pre>Activity(act:home, location:POINT (0 0), time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\nLeg(mode:car, area:POINT (0 0) --&gt; POINT (1234 1234), time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\nActivity(act:work, location:POINT (1233 1234), time:08:25:00 --&gt; 16:30:00, duration:8:05:00)\nLeg(mode:car, area:POINT (1234 1234) --&gt; POINT (0 0), time:16:30:00 --&gt; 17:30:00, duration:1:00:00)\nActivity(act:home, location:POINT (0 0), time:17:30:00 --&gt; 00:00:00, duration:6:30:00)\n</pre> In\u00a0[17]: Copied! <pre>from pam.write import write_matsim\nfrom pam.write.diary import to_csv\n</pre> from pam.write import write_matsim from pam.write.diary import to_csv In\u00a0[18]: Copied! <pre>to_csv(population=population, dir=\"tmp\")\nwrite_matsim(population=population, plans_path=\"tmp/plans.xml\")\n</pre> to_csv(population=population, dir=\"tmp\") write_matsim(population=population, plans_path=\"tmp/plans.xml\") <pre>Missing person weight in hh Smiths, returning None.\nMissing person weight in hh milk_bot, returning None.\n</pre>"},{"location":"examples/01_basics/#pam-basics","title":"PAM Basics\u00b6","text":""},{"location":"examples/01_basics/#the-core-objects","title":"The Core Objects\u00b6","text":"<p>PAM populations are built from three core objects:</p> <p><code>Population</code>, <code>Household</code> and <code>Person</code> objects. Persons belong to a <code>Household</code> and households belong to a <code>Population</code>. This relationship can be created using the <code>Population.add</code> and <code>Household.add</code> methods.</p> <p>Note that <code>Household</code> and <code>Person</code> objects require unique identifiers. households require a <code>hid</code> (household id) and persons a <code>pid</code> (person id).</p> <p>Households and Persons can also be given attributes as a simple dictionary. Attributes can include useful features such as income or car ownership.</p>"},{"location":"examples/01_basics/#activity-plans-or-sequences","title":"Activity Plans (or \"Sequences\")\u00b6","text":"<p><code>Person</code> activity plans use the <code>pam.activity.Plan</code> object. All Persons have a <code>Plan</code>, even if it is empty. A <code>Plan</code> is simply a sequence of <code>Activity</code> and <code>Trip</code> (or <code>Leg</code> if you prefer - they are equivalent) objects.</p> <p>Plans must start and end with an <code>Activity</code> and the two objects must alternate, for example; <code>Activity(\"home\")</code>, <code>Trip()</code>, <code>Activity(\"work\")</code>, <code>Trip()</code>, <code>Activity(\"home\")</code>.</p> <p>Both Activities and Trips can have start and end times (using datetime objects). Activities have locations whereas Trips have start and end locations. When manually creating your own sequences care should be taken to make these times and locations consistent. Such that, for example, a trip ends when the next activity starts and a trip start is at the same location as the preceding activity.</p> <p>Activities are expected to have a type, for example, <code>'work'</code> or <code>'golf'</code>. Trips are expected to have a mode, for example <code>'car'</code> etc. These examples generally use strings for these features but this is not a requirement.</p>"},{"location":"examples/01_basics/#locations","title":"Locations\u00b6","text":"<p>Pam uses <code>pam.location.Location</code> objects to keep track of <code>Activity</code> and <code>Trip</code> locations.</p> <p>These locations can be any combination of <code>area</code> or <code>loc</code> or <code>link</code>. Area is assumed to be spatial zone id, for example, \"City of London\".</p> <p><code>Loc</code> must be a coordinate (using a <code>shapely.geometry.Point</code>). <code>Link</code> is a network id. Locs and Links are only required for specific applications such as MATSim and can be added or sampled later, so are not covered further here.</p>"},{"location":"examples/01_basics/#all-together-now","title":"All Together Now\u00b6","text":"<p>PAM has read methods for common travel diary data formats and for MATSim. Pam also has modules for modelling new activity sequences. But below we show how you might create a simple demonstration population from scratch.</p> <p>Note that for conveneince the <code>add</code> methods will also try to unpack lists.</p>"},{"location":"examples/01_basics/#accessing-data","title":"Accessing Data\u00b6","text":"<p>Households and Persons can be accessed and modified in a variety of ways:</p>"},{"location":"examples/01_basics/#export","title":"Export\u00b6","text":"<p>Exports plans to csv or xml format for MATSim.</p>"},{"location":"examples/02a_tabular_read_write/","title":"Tabular Read-Write","text":"In\u00a0[1]: Copied! <pre>import os\n\nimport pandas as pd\n\nfrom pam import read\n</pre> import os  import pandas as pd  from pam import read In\u00a0[2]: Copied! <pre>trips = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\"\n)\npersons = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\"\n)\ntrips.head(10)\n</pre> trips = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\" ) persons = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\" ) trips.head(10) Out[2]: pid hid seq hzone ozone dzone purp mode tst tet freq uid 0 census_0 census_0 0 Harrow Harrow Camden work pt 444 473 1000 1 census_0 census_0 1 Harrow Camden Harrow work pt 890 919 1000 2 census_1 census_1 0 Greenwich Greenwich Tower Hamlets work pt 507 528 1000 3 census_1 census_1 1 Greenwich Tower Hamlets Greenwich work pt 1065 1086 1000 4 census_2 census_2 0 Croydon Croydon Croydon work pt 422 425 1000 5 census_2 census_2 1 Croydon Croydon Croydon work pt 917 920 1000 6 census_3 census_3 0 Haringey Haringey Redbridge work pt 428 447 1000 7 census_3 census_3 1 Haringey Redbridge Haringey work pt 1007 1026 1000 8 census_4 census_4 0 Hounslow Hounslow Westminster,City of London work car 483 516 1000 9 census_4 census_4 1 Hounslow Westminster,City of London Hounslow work car 1017 1050 1000 In\u00a0[3]: Copied! <pre>persons.head(10)\n</pre> persons.head(10) Out[3]: gender job occ inc pid census_0 female work white low census_1 female work white low census_2 male work blue high census_3 male work blue low census_4 male work blue medium census_5 other education white medium census_6 female work blue low census_7 male education white high census_8 female work blue medium census_9 female work white low In\u00a0[4]: Copied! <pre>population = read.load_travel_diary(trips, persons, trip_freq_as_person_freq=True)\n</pre> population = read.load_travel_diary(trips, persons, trip_freq_as_person_freq=True) <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all trips.\n</pre> In\u00a0[5]: Copied! <pre>household = population.households[\"census_12\"]\nperson = household.people[\"census_12\"]\nperson.print()\n</pre> household = population.households[\"census_12\"] person = household.people[\"census_12\"] person.print() <pre>Person: census_12\n{'gender': 'female', 'job': 'education', 'occ': 'white', 'inc': 'high', 'hzone': 'Croydon'}\n0:\tActivity(act:home, location:Croydon, time:00:00:00 --&gt; 07:06:00, duration:7:06:00)\n1:\tLeg(mode:pt, area:Croydon --&gt; Tower Hamlets, time:07:06:00 --&gt; 07:45:00, duration:0:39:00)\n2:\tActivity(act:education, location:Tower Hamlets, time:07:45:00 --&gt; 15:54:00, duration:8:09:00)\n3:\tLeg(mode:pt, area:Tower Hamlets --&gt; Croydon, time:15:54:00 --&gt; 16:33:00, duration:0:39:00)\n4:\tActivity(act:home, location:Croydon, time:16:33:00 --&gt; 00:00:00, duration:7:27:00)\n</pre> In\u00a0[6]: Copied! <pre>person.plot()\n</pre> person.plot() In\u00a0[7]: Copied! <pre>from pam import write\n\nwrite.to_csv(population, dir=\"tmp\")\n</pre> from pam import write  write.to_csv(population, dir=\"tmp\") <p>PAM can also write directly to O-D matrices using <code>pam.write.write_od_matrices</code>. This can optionally be segmented (read the docs). But does not currently support trip weighting (frequency).</p> In\u00a0[8]: Copied! <pre>write.write_od_matrices(population, \"tmp\")\n</pre> write.write_od_matrices(population, \"tmp\") In\u00a0[9]: Copied! <pre>population.pickle(os.path.join(\"tmp\", \"population.pickle\"))\n</pre> population.pickle(os.path.join(\"tmp\", \"population.pickle\"))"},{"location":"examples/02a_tabular_read_write/#tabular-read-write","title":"Tabular Read-Write\u00b6","text":"<p>This notebook is an introduction to the PAM tabular read-write methods. It has two parts:</p> <ol> <li>Read</li> <li>Write</li> </ol>"},{"location":"examples/02a_tabular_read_write/#read-tabular-format","title":"Read Tabular Format\u00b6","text":"<p>PAM can read from either tabular or MATSim formats. Tabular formats use the <code>pam.read.load_travel_diary</code> function, which will try to automatically infer trips and activities from commonly formatted travel diary data.</p> <p>Tabular data should include a trips table and then optionally, atributes tables for persons and/or households. Tabular data is expected as pandas DataFrames with column names as described in the docs and/or as in the following example.</p> <p>The following demonstration data is available in the <code>data/example_data</code> directory. All data paths in this example are relative to the notebook directory in the PAM repository.</p>"},{"location":"examples/02a_tabular_read_write/#step-1","title":"Step 1\u00b6","text":"<p>Load your trips (and attributes) data into pandas DataFrames. Reformat and rename the columns as required (please read the docs). The following example already has the required data types and column names:</p> <p>trips:</p> <p>Each row represents a trip, where:</p> <ul> <li>pid: person id of trip</li> <li>hid: household id of trip (optional)</li> <li>seq: sequence of trip within day (optional if order is already correct)</li> <li>hzone: home zone of person (optional)</li> <li>ozone: origin zone of trip</li> <li>dzone: destination zone of trip</li> <li>purp: purpose of trip (note that other ways of classifying purpose are supported - read the docs!)</li> <li>mode: trip mode</li> <li>tst: (integer) trip start time in minutes from start of day (typically from midnight)</li> <li>tet: (integer) trip end time as above</li> <li>freq: sample weighting (optional)</li> </ul> <p>persons:</p> <p>Each row represents a persons attributes. These can be arbitrary key - value pairs, with most types supported. The following are examples:</p> <ul> <li>pid: person id, must be consistent with trips data (required)</li> <li>gender: gender of person (example)</li> <li>job: employment status of person (example)</li> <li>occ: employment type of person (example)</li> <li>inc: income of person (example)</li> </ul>"},{"location":"examples/02a_tabular_read_write/#step-2","title":"Step 2:\u00b6","text":"<p>Load the travel diary data:</p>"},{"location":"examples/02a_tabular_read_write/#step-3","title":"Step 3:\u00b6","text":"<p>Check everything is as expected. PAM will try to infer activities from trip data, including for arbitrarily complex sequences of nested tours.</p> <p>However, trip purpose can be encoded in a variety of ways. PAM will try to make sensible inference based on the data provided. If something looks wrong then check the docs, then consider raising an issue. The team are keen to support you!</p>"},{"location":"examples/02a_tabular_read_write/#write-tabular-data","title":"Write Tabular Data\u00b6","text":"<p>PAM can write into a preferred tabular formats using <code>pam.write.to_csv</code>. This outputs trip legs, household attributes and person attributes tables. Where sufficient geometries are found, PAM will write spatial data as geojson.</p>"},{"location":"examples/02a_tabular_read_write/#pickle","title":"Pickle\u00b6","text":"<p>Not a tabular format but if you've read this far - you might like to know that there is a Population.pickle method:</p>"},{"location":"examples/02b_matsim_read_write/","title":"MATSim Read-Write","text":"In\u00a0[1]: Copied! <pre>import os\n\nfrom pam import read\n</pre> import os  from pam import read In\u00a0[2]: Copied! <pre>population = read.read_matsim(plans_path=os.path.join(\"data\", \"example_data\", \"example_plans.xml\"))\npopulation.stats\n</pre> population = read.read_matsim(plans_path=os.path.join(\"data\", \"example_data\", \"example_plans.xml\")) population.stats Out[2]: <pre>{'num_households': 51,\n 'num_people': 51,\n 'num_activities': 153,\n 'num_legs': 102}</pre> In\u00a0[3]: Copied! <pre>from pam import write\n\nwrite.write_matsim(population, plans_path=os.path.join(\"tmp\", \"plans.xml\"))\n</pre> from pam import write  write.write_matsim(population, plans_path=os.path.join(\"tmp\", \"plans.xml\")) In\u00a0[4]: Copied! <pre>from pam.read import stream_matsim_persons\nfrom pam.write import Writer\n\nread_path = os.path.join(\"data\", \"example_data\", \"example_plans.xml\")\nwrite_path = os.path.join(\"tmp\", \"plans.xml\")\n\nwith Writer(\n    path=write_path, keep_non_selected=True, coordinate_reference_system=\"EPSG:27700\"\n) as writer:\n    for person in stream_matsim_persons(\n        plans_path=read_path,\n        weight=10,\n        simplify_pt_trips=False,\n        leg_route=False,\n        keep_non_selected=True,\n    ):\n        # add age attribute\n        person.attributes[\"age\"] = \"unknown\"\n        writer.add_person(person)\n</pre> from pam.read import stream_matsim_persons from pam.write import Writer  read_path = os.path.join(\"data\", \"example_data\", \"example_plans.xml\") write_path = os.path.join(\"tmp\", \"plans.xml\")  with Writer(     path=write_path, keep_non_selected=True, coordinate_reference_system=\"EPSG:27700\" ) as writer:     for person in stream_matsim_persons(         plans_path=read_path,         weight=10,         simplify_pt_trips=False,         leg_route=False,         keep_non_selected=True,     ):         # add age attribute         person.attributes[\"age\"] = \"unknown\"         writer.add_person(person) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/02b_matsim_read_write/#matsim-read-write","title":"MATSim Read-Write\u00b6","text":"<p>This notebook is an introduction to the PAM MATSim read-write methods. It has four parts:</p> <ol> <li>Read</li> <li>Write</li> <li>Experienced Plans</li> <li>Streaming</li> </ol>"},{"location":"examples/02b_matsim_read_write/#read-matsim-format","title":"Read MATSim Format\u00b6","text":"<p>PAM can read from MATSim formatted xml using <code>pam.read.read_matsim</code>. <code>read_matsim</code> will except xml or gzipped xml (<code>.xml.gz</code>). It supports multiple additional options for your use-case (read the docs).</p>"},{"location":"examples/02b_matsim_read_write/#write-matsim-format","title":"Write MATSim Format\u00b6","text":"<p>PAM can write to MATSim formatted xml using <code>pam.write.write_matsim</code>.</p>"},{"location":"examples/02b_matsim_read_write/#experienced-plans","title":"Experienced Plans\u00b6","text":"<p>PAM supports MATSim experienced plans:</p> <ul> <li>unselected plans</li> <li>missing person attributes (attributes can be retrieved from regular MATSim plans)</li> <li>leg attributes</li> <li>leg routes</li> </ul> <p>The <code>read_matsim</code> and <code>write_matsim</code> functions support experienced plans. Reading, modifying and writing experienced plans is a useful way of building MATSim scenarios without loosing too much information from a previous scenario.</p>"},{"location":"examples/02b_matsim_read_write/#streaming","title":"Streaming\u00b6","text":"<p>Low memory applications can be created by streaming MATSim plans from <code>read.stream_matsim_persons</code> into your application logic and then back to disk using <code>write.Writer</code>. For example:</p>"},{"location":"examples/03_read_modify_write/","title":"PAM Read-Modify-Write","text":"In\u00a0[1]: Copied! <pre>import os\nfrom collections import defaultdict\n\nimport geopandas as gp\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom pam import policy, read\nfrom pam.policy import apply_policies\n\n%matplotlib inline\n</pre> import os from collections import defaultdict  import geopandas as gp import pandas as pd from matplotlib import pyplot as plt  from pam import policy, read from pam.policy import apply_policies  %matplotlib inline In\u00a0[2]: Copied! <pre>trips = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\"\n)\nattributes = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\"\n)\n</pre> trips = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\" ) attributes = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\" ) In\u00a0[3]: Copied! <pre>trips.head(10)\n</pre> trips.head(10) Out[3]: pid hid seq hzone ozone dzone purp mode tst tet freq uid 0 census_0 census_0 0 Harrow Harrow Camden work pt 444 473 1000 1 census_0 census_0 1 Harrow Camden Harrow work pt 890 919 1000 2 census_1 census_1 0 Greenwich Greenwich Tower Hamlets work pt 507 528 1000 3 census_1 census_1 1 Greenwich Tower Hamlets Greenwich work pt 1065 1086 1000 4 census_2 census_2 0 Croydon Croydon Croydon work pt 422 425 1000 5 census_2 census_2 1 Croydon Croydon Croydon work pt 917 920 1000 6 census_3 census_3 0 Haringey Haringey Redbridge work pt 428 447 1000 7 census_3 census_3 1 Haringey Redbridge Haringey work pt 1007 1026 1000 8 census_4 census_4 0 Hounslow Hounslow Westminster,City of London work car 483 516 1000 9 census_4 census_4 1 Hounslow Westminster,City of London Hounslow work car 1017 1050 1000 In\u00a0[4]: Copied! <pre>population = read.load_travel_diary(trips, attributes, trip_freq_as_person_freq=True)\n</pre> population = read.load_travel_diary(trips, attributes, trip_freq_as_person_freq=True) <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all trips.\n</pre> <p>Let's check out an example Activity Plan and Attributes:</p> In\u00a0[5]: Copied! <pre>household = population.households[\"census_12\"]\nperson = household.people[\"census_12\"]\nperson.print()\n</pre> household = population.households[\"census_12\"] person = household.people[\"census_12\"] person.print() <pre>Person: census_12\n{'gender': 'female', 'job': 'education', 'occ': 'white', 'inc': 'high', 'hzone': 'Croydon'}\n0:\tActivity(act:home, location:Croydon, time:00:00:00 --&gt; 07:06:00, duration:7:06:00)\n1:\tLeg(mode:pt, area:Croydon --&gt; Tower Hamlets, time:07:06:00 --&gt; 07:45:00, duration:0:39:00)\n2:\tActivity(act:education, location:Tower Hamlets, time:07:45:00 --&gt; 15:54:00, duration:8:09:00)\n3:\tLeg(mode:pt, area:Tower Hamlets --&gt; Croydon, time:15:54:00 --&gt; 16:33:00, duration:0:39:00)\n4:\tActivity(act:home, location:Croydon, time:16:33:00 --&gt; 00:00:00, duration:7:27:00)\n</pre> <p>Before we do any activity modification - we create a simple function to extract some example statistics. We include this as a simple demo, but would love to add more.</p> <p>Note that activity plans allow us to consider detailed joint segmentations, such as socio-economic, spatial, temporal, modal, activity sequence and so on.</p> In\u00a0[6]: Copied! <pre>def print_simple_stats(population):\n    \"\"\"Print some simple population statistics.\"\"\"\n    time_at_home = 0\n    travel_time = 0\n    low_income_central_trips = 0\n    high_income_central_trips = 0\n\n    for hh in population.households.values():\n        for person in hh.people.values():\n            freq = person.freq\n\n            for p in person.plan:\n                if p.act == \"travel\":\n                    duration = p.duration.seconds * freq / 3600\n                    travel_time += duration\n\n                    if p.end_location.area == \"Westminster,City of London\":\n                        if person.attributes[\"inc\"] == \"low\":\n                            low_income_central_trips += freq\n\n                        elif person.attributes[\"inc\"] == \"high\":\n                            high_income_central_trips += freq\n\n                else:  # activity\n                    if p.act == \"home\":\n                        duration = p.duration.seconds * freq / 3600\n                        time_at_home += duration\n\n    print(f\"Population total time at home: {time_at_home/1000000:.2f} million hours\")\n    print(f\"Population total travel time: {travel_time/1000000:.2f} million hours\")\n    print(f\"Low income trips to Central London: {low_income_central_trips} trips\")\n    print(f\"High income trips to Central London: {high_income_central_trips} trips\")\n</pre> def print_simple_stats(population):     \"\"\"Print some simple population statistics.\"\"\"     time_at_home = 0     travel_time = 0     low_income_central_trips = 0     high_income_central_trips = 0      for hh in population.households.values():         for person in hh.people.values():             freq = person.freq              for p in person.plan:                 if p.act == \"travel\":                     duration = p.duration.seconds * freq / 3600                     travel_time += duration                      if p.end_location.area == \"Westminster,City of London\":                         if person.attributes[\"inc\"] == \"low\":                             low_income_central_trips += freq                          elif person.attributes[\"inc\"] == \"high\":                             high_income_central_trips += freq                  else:  # activity                     if p.act == \"home\":                         duration = p.duration.seconds * freq / 3600                         time_at_home += duration      print(f\"Population total time at home: {time_at_home/1000000:.2f} million hours\")     print(f\"Population total travel time: {travel_time/1000000:.2f} million hours\")     print(f\"Low income trips to Central London: {low_income_central_trips} trips\")     print(f\"High income trips to Central London: {high_income_central_trips} trips\") In\u00a0[7]: Copied! <pre>print_simple_stats(population)\n</pre> print_simple_stats(population) <pre>Population total time at home: 0.76 million hours\nPopulation total travel time: 0.03 million hours\nLow income trips to Central London: 3000 trips\nHigh income trips to Central London: 4000 trips\n</pre> In\u00a0[8]: Copied! <pre>def plot_simple_stats(population):\n    \"\"\"Plot some simple population statistics.\"\"\"\n    geoms = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\"))\n\n    departures = defaultdict(int)\n    arrivals = defaultdict(int)\n\n    for _hid, hh in population.households.items():\n        for _pid, person in hh.people.items():\n            freq = person.freq\n\n            for p in person.plan:\n                if p.act == \"travel\":\n                    departures[p.start_location.area] += freq\n                    arrivals[p.end_location.area] += freq\n    geoms[\"departures\"] = geoms.NAME.map(departures)\n    geoms[\"arrivals\"] = geoms.NAME.map(arrivals)\n\n    fig, ax = plt.subplots(1, 2, figsize=(16, 6))\n    for i, name in enumerate([\"departures\", \"arrivals\"]):\n        ax[i].title.set_text(name)\n        geoms.plot(name, ax=ax[i])\n        ax[i].axis(\"off\")\n</pre> def plot_simple_stats(population):     \"\"\"Plot some simple population statistics.\"\"\"     geoms = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\"))      departures = defaultdict(int)     arrivals = defaultdict(int)      for _hid, hh in population.households.items():         for _pid, person in hh.people.items():             freq = person.freq              for p in person.plan:                 if p.act == \"travel\":                     departures[p.start_location.area] += freq                     arrivals[p.end_location.area] += freq     geoms[\"departures\"] = geoms.NAME.map(departures)     geoms[\"arrivals\"] = geoms.NAME.map(arrivals)      fig, ax = plt.subplots(1, 2, figsize=(16, 6))     for i, name in enumerate([\"departures\", \"arrivals\"]):         ax[i].title.set_text(name)         geoms.plot(name, ax=ax[i])         ax[i].axis(\"off\") In\u00a0[9]: Copied! <pre>plot_simple_stats(population)\n</pre> plot_simple_stats(population) In\u00a0[10]: Copied! <pre>policy1 = policy.HouseholdQuarantined(probability=0.025)\npolicy2 = policy.PersonStayAtHome(probability=0.1)\npolicy3 = policy.RemoveHouseholdActivities([\"education\", \"work\"], probability=0.9)\n\ndo_minimum = apply_policies(population, [policy1, policy2])\nlockdown = apply_policies(population, [policy1, policy2, policy3])\n</pre> policy1 = policy.HouseholdQuarantined(probability=0.025) policy2 = policy.PersonStayAtHome(probability=0.1) policy3 = policy.RemoveHouseholdActivities([\"education\", \"work\"], probability=0.9)  do_minimum = apply_policies(population, [policy1, policy2]) lockdown = apply_policies(population, [policy1, policy2, policy3]) In\u00a0[11]: Copied! <pre>print_simple_stats(do_minimum)\nplot_simple_stats(do_minimum)\n</pre> print_simple_stats(do_minimum) plot_simple_stats(do_minimum) <pre>Population total time at home: 0.70 million hours\nPopulation total travel time: 0.03 million hours\nLow income trips to Central London: 2000 trips\nHigh income trips to Central London: 4000 trips\n</pre> In\u00a0[12]: Copied! <pre>print_simple_stats(lockdown)\nplot_simple_stats(lockdown)\n</pre> print_simple_stats(lockdown) plot_simple_stats(lockdown) <pre>Population total time at home: 0.09 million hours\nPopulation total travel time: 0.00 million hours\nLow income trips to Central London: 1000 trips\nHigh income trips to Central London: 1000 trips\n</pre> In\u00a0[13]: Copied! <pre>do_minimum.to_csv(os.path.join(\"tmp\", \"do_min\"))\nlockdown.to_csv(os.path.join(\"tmp\", \"lockdown\"))\n</pre> do_minimum.to_csv(os.path.join(\"tmp\", \"do_min\")) lockdown.to_csv(os.path.join(\"tmp\", \"lockdown\"))"},{"location":"examples/03_read_modify_write/#pam-read-modify-write","title":"PAM Read-Modify-Write\u00b6","text":"<p>This notebook is an introduction to the basic read - modify - write use case of PAM:</p> <ul> <li>Read: Load activity plans from existing data (either tabular or MATSim)</li> <li>Modify: Use the PAM api to modify the activity plans</li> <li>Write: Write activity plans back to disk in the chosen format</li> </ul> <p>For this example, we use policies to make our modifications. But you might also try the following:</p> <ul> <li>spatial sampling</li> <li>location modelling</li> <li>rescheduling</li> <li>adding noise</li> <li>simulating aging or the passing of time</li> <li>and so on...</li> </ul>"},{"location":"examples/03_read_modify_write/#load-data","title":"Load Data\u00b6","text":"<p>Here we load simple travel diary data of London commuters. This is a very simple 0.1% sample of data about work and education commutes from the 2011 census. Because we're sharing this data, we've aggregated locations to borough level and randomized personal attributes; so, don't get too excited about the results.</p> <p>The data is available in the <code>data/example_data</code> sub-directory. All data paths in this example are relative to the notebook directory in the PAM repository</p>"},{"location":"examples/03_read_modify_write/#read","title":"Read\u00b6","text":"<p>First we load example travel diary data to Activity Plans. This data represents 2011 baseline London population of commuters.</p>"},{"location":"examples/03_read_modify_write/#modify","title":"Modify\u00b6","text":"<p>Our 2011 baseline London population of commuters seems sensible, they spend about 50 million hours at home and 1.6 million hours travelling.</p> <p>But what if we want to try and build some more up to date scenarios?</p> <p>We consider two scenarios from a combination of policies:</p> <p>Scenario A - Do Minimum:</p> <ol> <li>A household will be quarantined with p=0.025 (for example due to a possitive virus test within the household)</li> <li>A person will be staying at home (self isolating) with p=0.1 (for example due to being a vulnerable person)</li> </ol> <p>Scenario B - Lockdown:</p> <ol> <li>As above plus education and work activities will be removed and plans adjusted with p=0.9 (for example because schools and work places are closed)</li> </ol>"},{"location":"examples/03_read_modify_write/#write","title":"Write\u00b6","text":"<p>Assuming we are happy with our modified activity sequences we can write them to disk in our desired format. For this example we haven't prepared the population for MATSim so we write to disk as travel plans/diaries:</p>"},{"location":"examples/04_point_sampling/","title":"Point Sampling","text":"In\u00a0[1]: Copied! <pre>import os\n\nimport geopandas as gp\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom pam import read\nfrom pam.samplers.spatial import RandomPointSampler\n</pre> import os  import geopandas as gp import pandas as pd from matplotlib import pyplot as plt  from pam import read from pam.samplers.spatial import RandomPointSampler In\u00a0[2]: Copied! <pre>trips = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\"\n)\nattributes = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\"\n)\ntrips.head(10)\n</pre> trips = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\" ) attributes = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\" ) trips.head(10) Out[2]: pid hid seq hzone ozone dzone purp mode tst tet freq uid 0 census_0 census_0 0 Harrow Harrow Camden work pt 444 473 1000 1 census_0 census_0 1 Harrow Camden Harrow work pt 890 919 1000 2 census_1 census_1 0 Greenwich Greenwich Tower Hamlets work pt 507 528 1000 3 census_1 census_1 1 Greenwich Tower Hamlets Greenwich work pt 1065 1086 1000 4 census_2 census_2 0 Croydon Croydon Croydon work pt 422 425 1000 5 census_2 census_2 1 Croydon Croydon Croydon work pt 917 920 1000 6 census_3 census_3 0 Haringey Haringey Redbridge work pt 428 447 1000 7 census_3 census_3 1 Haringey Redbridge Haringey work pt 1007 1026 1000 8 census_4 census_4 0 Hounslow Hounslow Westminster,City of London work car 483 516 1000 9 census_4 census_4 1 Hounslow Westminster,City of London Hounslow work car 1017 1050 1000 In\u00a0[3]: Copied! <pre>population = read.load_travel_diary(trips, attributes)\npopulation.stats\n</pre> population = read.load_travel_diary(trips, attributes) population.stats <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all persons.\n</pre> Out[3]: <pre>{'num_households': 51,\n 'num_people': 51,\n 'num_activities': 152,\n 'num_legs': 101}</pre> In\u00a0[4]: Copied! <pre>zones = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\")).set_index(\"NAME\")\nzones.head()\n</pre> zones = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\")).set_index(\"NAME\") zones.head() Out[4]: HECTARES NONLD_AREA ONS_INNER SUB_2009 SUB_2006 geometry NAME Kingston upon Thames 3726.117 0.000 F None None POLYGON ((516401.600 160201.800, 516407.300 16... Croydon 8649.441 0.000 F None None POLYGON ((535009.200 159504.700, 535005.500 15... Bromley 15013.487 0.000 F None None POLYGON ((540373.600 157530.400, 540361.200 15... Hounslow 5658.541 60.755 F None None POLYGON ((521975.800 178100.000, 521967.700 17... Ealing 5554.428 0.000 F None None POLYGON ((510253.500 182881.600, 510249.900 18... In\u00a0[5]: Copied! <pre>random_sampler = RandomPointSampler(geoms=zones)\n</pre> random_sampler = RandomPointSampler(geoms=zones) In\u00a0[6]: Copied! <pre># test\nfig, ax = plt.subplots(1)\nzones.plot(ax=ax, color=\"grey\")\nzones.loc[[\"Camden\"]].plot(ax=ax)\npoint = random_sampler.sample(\"Camden\", activity=None)\nax.scatter(point.x, point.y, c=\"red\")\n</pre> # test fig, ax = plt.subplots(1) zones.plot(ax=ax, color=\"grey\") zones.loc[[\"Camden\"]].plot(ax=ax) point = random_sampler.sample(\"Camden\", activity=None) ax.scatter(point.x, point.y, c=\"red\") Out[6]: <pre>&lt;matplotlib.collections.PathCollection at 0x16b52aad0&gt;</pre> In\u00a0[7]: Copied! <pre>population.sample_locs(random_sampler)  # apply to whole population\n</pre> population.sample_locs(random_sampler)  # apply to whole population <p>Let's check out an example Activity Plan and Attributes:</p> In\u00a0[8]: Copied! <pre>person = population[\"census_0\"][\"census_0\"]\nperson.print()\nperson.plot()\n</pre> person = population[\"census_0\"][\"census_0\"] person.print() person.plot() <pre>Person: census_0\n{'gender': 'female', 'job': 'work', 'occ': 'white', 'inc': 'low', 'hzone': 'Harrow'}\n0:\tActivity(act:home, location:POINT (513495.3484428172 186270.18744166623), time:00:00:00 --&gt; 07:24:00, duration:7:24:00)\n1:\tLeg(mode:pt, area:POINT (513495.3484428172 186270.18744166623) --&gt; POINT (528597.1882704783 183610.4704643505), time:07:24:00 --&gt; 07:53:00, duration:0:29:00)\n2:\tActivity(act:work, location:POINT (528597.1882704783 183610.4704643505), time:07:53:00 --&gt; 14:50:00, duration:6:57:00)\n3:\tLeg(mode:pt, area:POINT (528597.1882704783 183610.4704643505) --&gt; POINT (513495.3484428172 186270.18744166623), time:14:50:00 --&gt; 15:19:00, duration:0:29:00)\n4:\tActivity(act:home, location:POINT (513495.3484428172 186270.18744166623), time:15:19:00 --&gt; 00:00:00, duration:8:41:00)\n</pre>"},{"location":"examples/04_point_sampling/#point-sampling","title":"Point Sampling\u00b6","text":"<p>MATSim requires point locations for all activities and trips. More generally it can be useful to assign geometries to activity location and/or trip origin and destinations. This notebook shows how to sample geometric locations from ozone/dzone regions using a simple random point sampler.</p> <p>More advanced samplers are available in <code>pam.samplers.spatial</code>.</p>"},{"location":"examples/04_point_sampling/#sample-geometries","title":"Sample Geometries\u00b6","text":"<p>Transform trip ozone/dzone to geographically sampled points</p>"},{"location":"examples/05_activity_plots/","title":"Plotting activity times","text":"In\u00a0[1]: Copied! <pre>import os\n\nimport pandas as pd\n\nfrom pam import read\nfrom pam.plot.stats import plot_activity_times, plot_leg_times\n</pre> import os  import pandas as pd  from pam import read from pam.plot.stats import plot_activity_times, plot_leg_times In\u00a0[2]: Copied! <pre>data_path = os.path.join(\"data\", \"example_data\")\ntrips = pd.read_csv(os.path.join(data_path, \"example_travel_diaries.csv\"))\nattributes = pd.read_csv(os.path.join(data_path, \"example_attributes.csv\"))\nattributes = attributes.set_index(\"pid\")\n</pre> data_path = os.path.join(\"data\", \"example_data\") trips = pd.read_csv(os.path.join(data_path, \"example_travel_diaries.csv\")) attributes = pd.read_csv(os.path.join(data_path, \"example_attributes.csv\")) attributes = attributes.set_index(\"pid\") In\u00a0[3]: Copied! <pre>population = read.load_travel_diary(trips, attributes)\n</pre> population = read.load_travel_diary(trips, attributes) <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all persons.\n</pre> In\u00a0[4]: Copied! <pre>population.random_household().plot()\n</pre> population.random_household().plot() In\u00a0[5]: Copied! <pre>fig1 = plot_activity_times(population)\n</pre> fig1 = plot_activity_times(population) In\u00a0[6]: Copied! <pre>fig2 = plot_leg_times(population)\n</pre> fig2 = plot_leg_times(population) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/05_activity_plots/#plotting-activity-times","title":"Plotting activity times\u00b6","text":"<p>In this example, we show how activity and trip times can be plotted.</p>"},{"location":"examples/05_policies_walk_through/","title":"Modifying the population using simple policies","text":"In\u00a0[1]: Copied! <pre>from copy import deepcopy\nfrom pprint import pprint\n\nfrom pam.activity import Activity, Leg\nfrom pam.core import Household, Person, Population\nfrom pam.policy import (\n    ActivityPolicy,\n    ActivityProbability,\n    HouseholdPolicy,\n    HouseholdQuarantined,\n    MoveActivityTourToHomeLocation,\n    PersonAttributeFilter,\n    PersonPolicy,\n    PersonProbability,\n    ReduceSharedActivity,\n    RemoveActivity,\n    apply_policies,\n)\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n</pre> from copy import deepcopy from pprint import pprint  from pam.activity import Activity, Leg from pam.core import Household, Person, Population from pam.policy import (     ActivityPolicy,     ActivityProbability,     HouseholdPolicy,     HouseholdQuarantined,     MoveActivityTourToHomeLocation,     PersonAttributeFilter,     PersonPolicy,     PersonProbability,     ReduceSharedActivity,     RemoveActivity,     apply_policies, ) from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY In\u00a0[2]: Copied! <pre>def hhld_apply(household, policy):\n    new_hhld = deepcopy(household)\n    policy.apply_to(new_hhld)\n    return new_hhld\n\n\ndef print_attributes(hhld, attribs=None):\n    if attribs is not None:\n        print(f\"Household: {hhld}\")\n        for pid, person in hhld.people.items():\n            print(f\"Person: {pid}\")\n            print(\"Attributes:\")\n            for attrib in attribs:\n                print(f\"\\t{attrib}: {person.attributes[attrib]}\")\n    else:\n        print(f\"Household: {hhld}\")\n        for pid, person in hhld.people.items():\n            print(f\"Person: {pid}\")\n            print(\"Attributes:\")\n            pprint(person.attributes)\n\n\ndef instantiate_household_with(persons: list):\n    household = Household(1)\n    for person in persons:\n        household.add(person)\n    return household\n\n\ndef Steve():\n    Steve = Person(\"Steve\", attributes={\"age\": 50, \"job\": \"work\", \"gender\": \"male\"})\n    Steve.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(5 * 60)))\n    Steve.add(Leg(1, \"car\", \"a\", \"b\", start_time=mtdt(5 * 60), end_time=mtdt(6 * 60)))\n    Steve.add(Activity(2, \"work\", \"b\", start_time=mtdt(6 * 60), end_time=mtdt(12 * 60)))\n    Steve.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 10)))\n    Steve.add(\n        Activity(3, \"leisure\", \"c\", start_time=mtdt(12 * 60 + 10), end_time=mtdt(13 * 60 - 10))\n    )\n    Steve.add(Leg(3, \"walk\", \"c\", \"b\", start_time=mtdt(13 * 60 - 10), end_time=mtdt(13 * 60)))\n    Steve.add(Activity(4, \"work\", \"b\", start_time=mtdt(13 * 60), end_time=mtdt(18 * 60)))\n    Steve.add(Leg(4, \"car\", \"b\", \"a\", start_time=mtdt(18 * 60), end_time=mtdt(19 * 60)))\n    Steve.add(Activity(5, \"home\", \"a\", start_time=mtdt(19 * 60), end_time=mtdt(20 * 60)))\n    Steve.add(Leg(5, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Steve.add(\n        Activity(6, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))\n    )\n    Steve.add(Leg(6, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Steve.add(Activity(7, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Steve.add(Leg(7, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Steve.add(Activity(8, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Steve\n\n\ndef Hilda():\n    Hilda = Person(\"Hilda\", attributes={\"age\": 45, \"job\": \"influencer\", \"gender\": \"female\"})\n    Hilda.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\n    Hilda.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))\n    Hilda.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30)))\n    Hilda.add(Leg(1, \"pt\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))\n    Hilda.add(Activity(2, \"shop\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(14 * 60)))\n    Hilda.add(Leg(2, \"pt\", \"b\", \"c\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))\n    Hilda.add(\n        Activity(3, \"leisure\", \"c\", start_time=mtdt(14 * 60 + 20), end_time=mtdt(16 * 60 - 20))\n    )\n    Hilda.add(Leg(3, \"pt\", \"c\", \"b\", start_time=mtdt(16 * 60 - 20), end_time=mtdt(16 * 60)))\n    Hilda.add(Activity(4, \"escort\", \"b\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))\n    Hilda.add(Leg(4, \"walk\", \"a\", \"b\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(17 * 60)))\n    Hilda.add(Activity(5, \"home\", \"a\", start_time=mtdt(17 * 60), end_time=mtdt(20 * 60)))\n    Hilda.add(Leg(5, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Hilda.add(\n        Activity(6, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))\n    )\n    Hilda.add(Leg(6, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Hilda.add(Activity(7, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Hilda.add(Leg(7, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Hilda.add(Activity(8, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Hilda\n\n\ndef Timmy():\n    Timmy = Person(\"Timmy\", attributes={\"age\": 18, \"job\": \"education\", \"gender\": \"male\"})\n    Timmy.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\n    Timmy.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))\n    Timmy.add(Activity(2, \"sport\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 55)))\n    Timmy.add(Leg(2, \"walk\", \"b\", \"a\", start_time=mtdt(8 * 60 + 55), end_time=mtdt(9 * 60)))\n    Timmy.add(Activity(3, \"home\", \"a\", start_time=mtdt(9 * 60), end_time=mtdt(10 * 60)))\n    Timmy.add(Leg(3, \"bike\", \"a\", \"b\", start_time=mtdt(10 * 60), end_time=mtdt(11 * 60)))\n    Timmy.add(Activity(4, \"education\", \"b\", start_time=mtdt(11 * 60), end_time=mtdt(13 * 60)))\n    Timmy.add(Leg(4, \"bike\", \"b\", \"c\", start_time=mtdt(13 * 60), end_time=mtdt(13 * 60 + 5)))\n    Timmy.add(Activity(5, \"shop\", \"c\", start_time=mtdt(13 * 60 + 5), end_time=mtdt(13 * 60 + 30)))\n    Timmy.add(Leg(5, \"bike\", \"c\", \"b\", start_time=mtdt(13 * 60 + 30), end_time=mtdt(13 * 60 + 35)))\n    Timmy.add(Activity(6, \"education\", \"b\", start_time=mtdt(13 * 60 + 35), end_time=mtdt(15 * 60)))\n    Timmy.add(Leg(6, \"bike\", \"b\", \"d\", start_time=mtdt(15 * 60), end_time=mtdt(15 * 60 + 10)))\n    Timmy.add(Activity(7, \"leisure\", \"d\", start_time=mtdt(15 * 60 + 10), end_time=mtdt(18 * 60)))\n    Timmy.add(Leg(7, \"bike\", \"d\", \"a\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))\n    Timmy.add(Activity(8, \"home\", \"a\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(20 * 60)))\n    Timmy.add(Leg(8, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Timmy.add(\n        Activity(9, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))\n    )\n    Timmy.add(Leg(9, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Timmy.add(Activity(10, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Timmy.add(Leg(10, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Timmy.add(Activity(11, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Timmy\n\n\ndef Bobby():\n    Bobby = Person(\"Bobby\", attributes={\"age\": 6, \"job\": \"education\", \"gender\": \"female\"})\n    Bobby.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\n    Bobby.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))\n    Bobby.add(Activity(2, \"education\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60)))\n    Bobby.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))\n    Bobby.add(Activity(3, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(20 * 60)))\n    Bobby.add(Leg(3, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Bobby.add(\n        Activity(4, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))\n    )\n    Bobby.add(Leg(4, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Bobby.add(Activity(5, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Bobby.add(Leg(5, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Bobby.add(Activity(6, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Bobby\n</pre> def hhld_apply(household, policy):     new_hhld = deepcopy(household)     policy.apply_to(new_hhld)     return new_hhld   def print_attributes(hhld, attribs=None):     if attribs is not None:         print(f\"Household: {hhld}\")         for pid, person in hhld.people.items():             print(f\"Person: {pid}\")             print(\"Attributes:\")             for attrib in attribs:                 print(f\"\\t{attrib}: {person.attributes[attrib]}\")     else:         print(f\"Household: {hhld}\")         for pid, person in hhld.people.items():             print(f\"Person: {pid}\")             print(\"Attributes:\")             pprint(person.attributes)   def instantiate_household_with(persons: list):     household = Household(1)     for person in persons:         household.add(person)     return household   def Steve():     Steve = Person(\"Steve\", attributes={\"age\": 50, \"job\": \"work\", \"gender\": \"male\"})     Steve.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(5 * 60)))     Steve.add(Leg(1, \"car\", \"a\", \"b\", start_time=mtdt(5 * 60), end_time=mtdt(6 * 60)))     Steve.add(Activity(2, \"work\", \"b\", start_time=mtdt(6 * 60), end_time=mtdt(12 * 60)))     Steve.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 10)))     Steve.add(         Activity(3, \"leisure\", \"c\", start_time=mtdt(12 * 60 + 10), end_time=mtdt(13 * 60 - 10))     )     Steve.add(Leg(3, \"walk\", \"c\", \"b\", start_time=mtdt(13 * 60 - 10), end_time=mtdt(13 * 60)))     Steve.add(Activity(4, \"work\", \"b\", start_time=mtdt(13 * 60), end_time=mtdt(18 * 60)))     Steve.add(Leg(4, \"car\", \"b\", \"a\", start_time=mtdt(18 * 60), end_time=mtdt(19 * 60)))     Steve.add(Activity(5, \"home\", \"a\", start_time=mtdt(19 * 60), end_time=mtdt(20 * 60)))     Steve.add(Leg(5, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Steve.add(         Activity(6, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))     )     Steve.add(Leg(6, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Steve.add(Activity(7, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Steve.add(Leg(7, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Steve.add(Activity(8, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Steve   def Hilda():     Hilda = Person(\"Hilda\", attributes={\"age\": 45, \"job\": \"influencer\", \"gender\": \"female\"})     Hilda.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))     Hilda.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))     Hilda.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30)))     Hilda.add(Leg(1, \"pt\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))     Hilda.add(Activity(2, \"shop\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(14 * 60)))     Hilda.add(Leg(2, \"pt\", \"b\", \"c\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))     Hilda.add(         Activity(3, \"leisure\", \"c\", start_time=mtdt(14 * 60 + 20), end_time=mtdt(16 * 60 - 20))     )     Hilda.add(Leg(3, \"pt\", \"c\", \"b\", start_time=mtdt(16 * 60 - 20), end_time=mtdt(16 * 60)))     Hilda.add(Activity(4, \"escort\", \"b\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))     Hilda.add(Leg(4, \"walk\", \"a\", \"b\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(17 * 60)))     Hilda.add(Activity(5, \"home\", \"a\", start_time=mtdt(17 * 60), end_time=mtdt(20 * 60)))     Hilda.add(Leg(5, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Hilda.add(         Activity(6, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))     )     Hilda.add(Leg(6, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Hilda.add(Activity(7, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Hilda.add(Leg(7, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Hilda.add(Activity(8, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Hilda   def Timmy():     Timmy = Person(\"Timmy\", attributes={\"age\": 18, \"job\": \"education\", \"gender\": \"male\"})     Timmy.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))     Timmy.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))     Timmy.add(Activity(2, \"sport\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 55)))     Timmy.add(Leg(2, \"walk\", \"b\", \"a\", start_time=mtdt(8 * 60 + 55), end_time=mtdt(9 * 60)))     Timmy.add(Activity(3, \"home\", \"a\", start_time=mtdt(9 * 60), end_time=mtdt(10 * 60)))     Timmy.add(Leg(3, \"bike\", \"a\", \"b\", start_time=mtdt(10 * 60), end_time=mtdt(11 * 60)))     Timmy.add(Activity(4, \"education\", \"b\", start_time=mtdt(11 * 60), end_time=mtdt(13 * 60)))     Timmy.add(Leg(4, \"bike\", \"b\", \"c\", start_time=mtdt(13 * 60), end_time=mtdt(13 * 60 + 5)))     Timmy.add(Activity(5, \"shop\", \"c\", start_time=mtdt(13 * 60 + 5), end_time=mtdt(13 * 60 + 30)))     Timmy.add(Leg(5, \"bike\", \"c\", \"b\", start_time=mtdt(13 * 60 + 30), end_time=mtdt(13 * 60 + 35)))     Timmy.add(Activity(6, \"education\", \"b\", start_time=mtdt(13 * 60 + 35), end_time=mtdt(15 * 60)))     Timmy.add(Leg(6, \"bike\", \"b\", \"d\", start_time=mtdt(15 * 60), end_time=mtdt(15 * 60 + 10)))     Timmy.add(Activity(7, \"leisure\", \"d\", start_time=mtdt(15 * 60 + 10), end_time=mtdt(18 * 60)))     Timmy.add(Leg(7, \"bike\", \"d\", \"a\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))     Timmy.add(Activity(8, \"home\", \"a\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(20 * 60)))     Timmy.add(Leg(8, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Timmy.add(         Activity(9, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))     )     Timmy.add(Leg(9, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Timmy.add(Activity(10, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Timmy.add(Leg(10, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Timmy.add(Activity(11, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Timmy   def Bobby():     Bobby = Person(\"Bobby\", attributes={\"age\": 6, \"job\": \"education\", \"gender\": \"female\"})     Bobby.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))     Bobby.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))     Bobby.add(Activity(2, \"education\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60)))     Bobby.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))     Bobby.add(Activity(3, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(20 * 60)))     Bobby.add(Leg(3, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Bobby.add(         Activity(4, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))     )     Bobby.add(Leg(4, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Bobby.add(Activity(5, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Bobby.add(Leg(5, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Bobby.add(Activity(6, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Bobby In\u00a0[3]: Copied! <pre>smiths = instantiate_household_with([Steve(), Hilda(), Timmy(), Bobby()])\n</pre> smiths = instantiate_household_with([Steve(), Hilda(), Timmy(), Bobby()]) In\u00a0[4]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() <p>$$P_{household} = 1 - (1-P_{person})^n$$</p> <p>If you have a probability that drives of any one person living in the household.</p> <p>The probability of the household being chosen is then $$1 - (1-P)^n$$ where $P$ is the probability any one person being chosen and $n$ is the number of people in the household; $(1-P)^n$ is the probability of no one being picked.</p> In\u00a0[5]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(RemoveActivity([\"education\"]), 1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(RemoveActivity([\"education\"]), 1)).plot() <p>If you have a probability that drives of any one activity a person does.</p> <p>The probability of the person being chosen is then $$1 - (1-P)^n$$ where $P$ is the probability any one (relevant) activity being chosen and $n$ is the number of (relevant) activities in the person's plan; $(1-P)^n$ is the probability of no relevant activities being picked.</p> In\u00a0[6]: Copied! <pre>hhld_apply(smiths, PersonPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 0.5)).plot()\n</pre> hhld_apply(smiths, PersonPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 0.5)).plot() <p>If you have a probability that drives of any one activity a person does and you want to affect particular activities with no consequence to the person or household.</p> <p>Notice that given a probability $P$ for an activity you can affect the whole household. The probability of the household being chosen is then $$1 - (1-P)^n$$ where $P$ is the probability any one (relevant) activity being chosen and $n$ is then the number of all (relevant) activities in all of the persons plans within a household; $(1-P)^n$ is the probability of no relevant activities being picked for the household.</p> In\u00a0[7]: Copied! <pre>hhld_apply(smiths, ActivityPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 0.5)).plot()\n</pre> hhld_apply(smiths, ActivityPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 0.5)).plot() <p>The Policies expect certain levels of probability. For example, performing a <code>HouseholdPolicy</code> is easy, you can affect a whole household using a probability at any level, <code>household</code>, <code>person</code> or <code>activity</code>. Performing an <code>ActivityPolicy</code> however means you need information at the level of the activities you want to affect.</p> HouseholdProbability PersonProbability ActivityProbability HouseholdPolicy Yes Yes Yes PersonPolicy --- Yes Yes ActivityPolicy --- --- Yes In\u00a0[8]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(RemoveActivity([\"education\"]), 1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(RemoveActivity([\"education\"]), 1)).plot() In\u00a0[9]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(ReduceSharedActivity([\"shop_1\"]), 1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(ReduceSharedActivity([\"shop_1\"]), 1)).plot() In\u00a0[10]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]), 1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]), 1)).plot() <p>The result of this modifier do not show up on the plot. Below are the details of Hilda's original plan.</p> In\u00a0[11]: Copied! <pre>smiths[\"Hilda\"].print()\n</pre> smiths[\"Hilda\"].print() <pre>Person: Hilda\n{'age': 45, 'job': 'influencer', 'gender': 'female'}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:escort, location:b, time:08:05:00 --&gt; 08:30:00, duration:0:25:00)\n3:\tLeg(mode:pt, area:a --&gt; b, time:08:00:00 --&gt; 08:30:00, duration:0:30:00)\n4:\tActivity(act:shop, location:b, time:08:30:00 --&gt; 14:00:00, duration:5:30:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:14:00:00 --&gt; 14:20:00, duration:0:20:00)\n6:\tActivity(act:leisure, location:c, time:14:20:00 --&gt; 15:40:00, duration:1:20:00)\n7:\tLeg(mode:pt, area:c --&gt; b, time:15:40:00 --&gt; 16:00:00, duration:0:20:00)\n8:\tActivity(act:escort, location:b, time:16:00:00 --&gt; 16:30:00, duration:0:30:00)\n9:\tLeg(mode:walk, area:a --&gt; b, time:16:30:00 --&gt; 17:00:00, duration:0:30:00)\n10:\tActivity(act:home, location:a, time:17:00:00 --&gt; 20:00:00, duration:3:00:00)\n11:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n12:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n13:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n14:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n15:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n16:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> <p>Here are details of Hilda's plan post application of.<code>MoveActivityTourToHomeLocation</code> to <code>'shop'</code> activities. Compare the location of Activities 6 and 7 with the ones above. At the moment only the Leg's destination and origin get updated, the mode choice and duration remains unchanged.</p> In\u00a0[12]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]), 1))[\n    \"Hilda\"\n].print()\n</pre> hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]), 1))[     \"Hilda\" ].print() <pre>Person: Hilda\n{'age': 45, 'job': 'influencer', 'gender': 'female'}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:escort, location:b, time:08:05:00 --&gt; 08:30:00, duration:0:25:00)\n3:\tLeg(mode:pt, area:a --&gt; b, time:08:00:00 --&gt; 08:30:00, duration:0:30:00)\n4:\tActivity(act:shop, location:b, time:08:30:00 --&gt; 14:00:00, duration:5:30:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:14:00:00 --&gt; 14:20:00, duration:0:20:00)\n6:\tActivity(act:leisure, location:c, time:14:20:00 --&gt; 15:40:00, duration:1:20:00)\n7:\tLeg(mode:pt, area:c --&gt; b, time:15:40:00 --&gt; 16:00:00, duration:0:20:00)\n8:\tActivity(act:escort, location:b, time:16:00:00 --&gt; 16:30:00, duration:0:30:00)\n9:\tLeg(mode:walk, area:a --&gt; b, time:16:30:00 --&gt; 17:00:00, duration:0:30:00)\n10:\tActivity(act:home, location:a, time:17:00:00 --&gt; 20:00:00, duration:3:00:00)\n11:\tLeg(mode:walk, area:a --&gt; a, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n12:\tActivity(act:shop_1, location:a, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n13:\tLeg(mode:walk, area:a --&gt; a, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n14:\tActivity(act:shop_2, location:a, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n15:\tLeg(mode:walk, area:a --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n16:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[13]: Copied! <pre>print_attributes(smiths, [\"gender\", \"age\", \"job\"])\n</pre> print_attributes(smiths, [\"gender\", \"age\", \"job\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\tgender: male\n\tage: 50\n\tjob: work\nPerson: Hilda\nAttributes:\n\tgender: female\n\tage: 45\n\tjob: influencer\nPerson: Timmy\nAttributes:\n\tgender: male\n\tage: 18\n\tjob: education\nPerson: Bobby\nAttributes:\n\tgender: female\n\tage: 6\n\tjob: education\n</pre> In\u00a0[14]: Copied! <pre>def is_male(attribute_value):\n    return attribute_value == \"male\"\n\n\ncondition = {\"gender\": is_male}\n\nhhld_apply(\n    smiths, PersonPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 1, PersonAttributeFilter(condition))\n).plot()\n</pre> def is_male(attribute_value):     return attribute_value == \"male\"   condition = {\"gender\": is_male}  hhld_apply(     smiths, PersonPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 1, PersonAttributeFilter(condition)) ).plot() In\u00a0[15]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[16]: Copied! <pre>policy_household_quarantine_per_person = HouseholdQuarantined(PersonProbability(0.01))\n</pre> policy_household_quarantine_per_person = HouseholdQuarantined(PersonProbability(0.01)) In\u00a0[17]: Copied! <pre>hhld_apply(smiths, policy_household_quarantine_per_person).plot()\n</pre> hhld_apply(smiths, policy_household_quarantine_per_person).plot() In\u00a0[18]: Copied! <pre>hhld_apply(smiths, HouseholdQuarantined(1)).plot()\n</pre> hhld_apply(smiths, HouseholdQuarantined(1)).plot() In\u00a0[19]: Copied! <pre>print_attributes(smiths, [\"age\", \"job\"])\n</pre> print_attributes(smiths, [\"age\", \"job\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\tage: 50\n\tjob: work\nPerson: Hilda\nAttributes:\n\tage: 45\n\tjob: influencer\nPerson: Timmy\nAttributes:\n\tage: 18\n\tjob: education\nPerson: Bobby\nAttributes:\n\tage: 6\n\tjob: education\n</pre> In\u00a0[20]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[21]: Copied! <pre>def over_17(attribute_value):\n    return attribute_value &gt; 17\n\n\npolicy_remove_higher_education = PersonPolicy(\n    RemoveActivity([\"education\"]),\n    PersonProbability(1),\n    PersonAttributeFilter({\"age\": over_17}, how=\"all\"),\n)\n</pre> def over_17(attribute_value):     return attribute_value &gt; 17   policy_remove_higher_education = PersonPolicy(     RemoveActivity([\"education\"]),     PersonProbability(1),     PersonAttributeFilter({\"age\": over_17}, how=\"all\"), ) In\u00a0[22]: Copied! <pre>hhld_apply(smiths, policy_remove_higher_education).plot()\n</pre> hhld_apply(smiths, policy_remove_higher_education).plot() In\u00a0[23]: Copied! <pre>smiths[\"Steve\"].attributes[\"wfh\"] = True\nsmiths[\"Steve\"].attributes[\"care_constrained\"] = False\nsmiths[\"Hilda\"].attributes[\"wfh\"] = True\nsmiths[\"Hilda\"].attributes[\"care_constrained\"] = False\nsmiths[\"Timmy\"].attributes[\"wfh\"] = False\nsmiths[\"Timmy\"].attributes[\"care_constrained\"] = False\nsmiths[\"Bobby\"].attributes[\"wfh\"] = False\nsmiths[\"Bobby\"].attributes[\"care_constrained\"] = False\n</pre> smiths[\"Steve\"].attributes[\"wfh\"] = True smiths[\"Steve\"].attributes[\"care_constrained\"] = False smiths[\"Hilda\"].attributes[\"wfh\"] = True smiths[\"Hilda\"].attributes[\"care_constrained\"] = False smiths[\"Timmy\"].attributes[\"wfh\"] = False smiths[\"Timmy\"].attributes[\"care_constrained\"] = False smiths[\"Bobby\"].attributes[\"wfh\"] = False smiths[\"Bobby\"].attributes[\"care_constrained\"] = False In\u00a0[24]: Copied! <pre>print_attributes(smiths, [\"wfh\", \"care_constrained\"])\n</pre> print_attributes(smiths, [\"wfh\", \"care_constrained\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: True\n\tcare_constrained: False\nPerson: Hilda\nAttributes:\n\twfh: True\n\tcare_constrained: False\nPerson: Timmy\nAttributes:\n\twfh: False\n\tcare_constrained: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tcare_constrained: False\n</pre> In\u00a0[25]: Copied! <pre>def attribute_False(attribute_value):\n    return not bool(attribute_value)\n\n\ndef attribute_True(attribute_value):\n    return bool(attribute_value)\n\n\nconditions = {\"care_constrained\": attribute_False, \"wfh\": attribute_True}\n\n# notice that the probability of the household (`HouseholdPolicy`) being chosen is driven\n# by the presence of education activities (`ActivityProbability(['education'], 0.95)`)\n# in the end the policy removes both education and escort (`RemoveActivity(['education', 'escort'])`)\n# but the presence of escort doesn't affect the likelihood\npolicy_remove_any_education = HouseholdPolicy(\n    RemoveActivity([\"education\", \"escort\"]),\n    ActivityProbability([\"education\"], 0.95),\n    PersonAttributeFilter(conditions),\n)\n</pre> def attribute_False(attribute_value):     return not bool(attribute_value)   def attribute_True(attribute_value):     return bool(attribute_value)   conditions = {\"care_constrained\": attribute_False, \"wfh\": attribute_True}  # notice that the probability of the household (`HouseholdPolicy`) being chosen is driven # by the presence of education activities (`ActivityProbability(['education'], 0.95)`) # in the end the policy removes both education and escort (`RemoveActivity(['education', 'escort'])`) # but the presence of escort doesn't affect the likelihood policy_remove_any_education = HouseholdPolicy(     RemoveActivity([\"education\", \"escort\"]),     ActivityProbability([\"education\"], 0.95),     PersonAttributeFilter(conditions), ) In\u00a0[26]: Copied! <pre>hhld_apply(smiths, policy_remove_any_education).plot()\n</pre> hhld_apply(smiths, policy_remove_any_education).plot() In\u00a0[27]: Copied! <pre>smiths[\"Steve\"].attributes[\"wfh\"] = False\nsmiths[\"Steve\"].attributes[\"care_constrained\"] = True\nsmiths[\"Hilda\"].attributes[\"wfh\"] = False\nsmiths[\"Hilda\"].attributes[\"care_constrained\"] = True\nsmiths[\"Timmy\"].attributes[\"wfh\"] = False\nsmiths[\"Timmy\"].attributes[\"care_constrained\"] = False\nsmiths[\"Bobby\"].attributes[\"wfh\"] = False\nsmiths[\"Bobby\"].attributes[\"care_constrained\"] = False\n\nprint_attributes(smiths, [\"wfh\", \"care_constrained\"])\n</pre> smiths[\"Steve\"].attributes[\"wfh\"] = False smiths[\"Steve\"].attributes[\"care_constrained\"] = True smiths[\"Hilda\"].attributes[\"wfh\"] = False smiths[\"Hilda\"].attributes[\"care_constrained\"] = True smiths[\"Timmy\"].attributes[\"wfh\"] = False smiths[\"Timmy\"].attributes[\"care_constrained\"] = False smiths[\"Bobby\"].attributes[\"wfh\"] = False smiths[\"Bobby\"].attributes[\"care_constrained\"] = False  print_attributes(smiths, [\"wfh\", \"care_constrained\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: False\n\tcare_constrained: True\nPerson: Hilda\nAttributes:\n\twfh: False\n\tcare_constrained: True\nPerson: Timmy\nAttributes:\n\twfh: False\n\tcare_constrained: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tcare_constrained: False\n</pre> In\u00a0[28]: Copied! <pre>hhld_apply(smiths, policy_remove_any_education).plot()\n</pre> hhld_apply(smiths, policy_remove_any_education).plot() In\u00a0[29]: Copied! <pre>policy_remove_leisure = PersonPolicy(RemoveActivity([\"leisure\"]), PersonProbability(1))\n</pre> policy_remove_leisure = PersonPolicy(RemoveActivity([\"leisure\"]), PersonProbability(1)) In\u00a0[30]: Copied! <pre>hhld_apply(smiths, policy_remove_leisure).plot()\n</pre> hhld_apply(smiths, policy_remove_leisure).plot() In\u00a0[31]: Copied! <pre>smiths[\"Timmy\"].print()\n</pre> smiths[\"Timmy\"].print() <pre>Person: Timmy\n{'age': 18, 'job': 'education', 'gender': 'male', 'wfh': False, 'care_constrained': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:sport, location:b, time:08:05:00 --&gt; 08:55:00, duration:0:50:00)\n3:\tLeg(mode:walk, area:b --&gt; a, time:08:55:00 --&gt; 09:00:00, duration:0:05:00)\n4:\tActivity(act:home, location:a, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:a --&gt; b, time:10:00:00 --&gt; 11:00:00, duration:1:00:00)\n6:\tActivity(act:education, location:b, time:11:00:00 --&gt; 13:00:00, duration:2:00:00)\n7:\tLeg(mode:bike, area:b --&gt; c, time:13:00:00 --&gt; 13:05:00, duration:0:05:00)\n8:\tActivity(act:shop, location:c, time:13:05:00 --&gt; 13:30:00, duration:0:25:00)\n9:\tLeg(mode:bike, area:c --&gt; b, time:13:30:00 --&gt; 13:35:00, duration:0:05:00)\n10:\tActivity(act:education, location:b, time:13:35:00 --&gt; 15:00:00, duration:1:25:00)\n11:\tLeg(mode:bike, area:b --&gt; d, time:15:00:00 --&gt; 15:10:00, duration:0:10:00)\n12:\tActivity(act:leisure, location:d, time:15:10:00 --&gt; 18:00:00, duration:2:50:00)\n13:\tLeg(mode:bike, area:d --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:18:20:00 --&gt; 20:00:00, duration:1:40:00)\n15:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n19:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[32]: Copied! <pre>policy_move_sport = PersonPolicy(MoveActivityTourToHomeLocation([\"sport\"]), PersonProbability(1))\n</pre> policy_move_sport = PersonPolicy(MoveActivityTourToHomeLocation([\"sport\"]), PersonProbability(1)) In\u00a0[33]: Copied! <pre>hhld_apply(smiths, policy_move_sport)[\"Timmy\"].print()\n</pre> hhld_apply(smiths, policy_move_sport)[\"Timmy\"].print() <pre>Person: Timmy\n{'age': 18, 'job': 'education', 'gender': 'male', 'wfh': False, 'care_constrained': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; a, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:sport, location:a, time:08:05:00 --&gt; 08:55:00, duration:0:50:00)\n3:\tLeg(mode:walk, area:a --&gt; a, time:08:55:00 --&gt; 09:00:00, duration:0:05:00)\n4:\tActivity(act:home, location:a, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:a --&gt; b, time:10:00:00 --&gt; 11:00:00, duration:1:00:00)\n6:\tActivity(act:education, location:b, time:11:00:00 --&gt; 13:00:00, duration:2:00:00)\n7:\tLeg(mode:bike, area:b --&gt; c, time:13:00:00 --&gt; 13:05:00, duration:0:05:00)\n8:\tActivity(act:shop, location:c, time:13:05:00 --&gt; 13:30:00, duration:0:25:00)\n9:\tLeg(mode:bike, area:c --&gt; b, time:13:30:00 --&gt; 13:35:00, duration:0:05:00)\n10:\tActivity(act:education, location:b, time:13:35:00 --&gt; 15:00:00, duration:1:25:00)\n11:\tLeg(mode:bike, area:b --&gt; d, time:15:00:00 --&gt; 15:10:00, duration:0:10:00)\n12:\tActivity(act:leisure, location:d, time:15:10:00 --&gt; 18:00:00, duration:2:50:00)\n13:\tLeg(mode:bike, area:d --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:18:20:00 --&gt; 20:00:00, duration:1:40:00)\n15:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n19:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[34]: Copied! <pre>def discrete_joint_distribution_sampler(person, mapping, distribution):\n    p = distribution\n    for key in mapping:\n        value = person.attributes.get(key)\n        if value is None:\n            msg = f\"Cannot find mapping: {key} in sampling features: {person.attributes}\"\n            raise KeyError(msg)\n        p = p.get(value)\n        if p is None:\n            msg = f\"Cannot find feature for {key}: {value} in distribution: {p}\"\n            raise KeyError(msg)\n    return p\n</pre> def discrete_joint_distribution_sampler(person, mapping, distribution):     p = distribution     for key in mapping:         value = person.attributes.get(key)         if value is None:             msg = f\"Cannot find mapping: {key} in sampling features: {person.attributes}\"             raise KeyError(msg)         p = p.get(value)         if p is None:             msg = f\"Cannot find feature for {key}: {value} in distribution: {p}\"             raise KeyError(msg)     return p In\u00a0[35]: Copied! <pre>vulnerable_mapping = [\"age\", \"gender\"]\nvulnerable_distribution = dict(\n    zip(\n        list(range(101)),\n        [{\"male\": i / 100, \"female\": i / 100, \"other\": i / 100} for i in range(101)],\n    )\n)\n</pre> vulnerable_mapping = [\"age\", \"gender\"] vulnerable_distribution = dict(     zip(         list(range(101)),         [{\"male\": i / 100, \"female\": i / 100, \"other\": i / 100} for i in range(101)],     ) ) In\u00a0[36]: Copied! <pre>dict(list(vulnerable_distribution.items())[0:15])\n</pre> dict(list(vulnerable_distribution.items())[0:15]) Out[36]: <pre>{0: {'male': 0.0, 'female': 0.0, 'other': 0.0},\n 1: {'male': 0.01, 'female': 0.01, 'other': 0.01},\n 2: {'male': 0.02, 'female': 0.02, 'other': 0.02},\n 3: {'male': 0.03, 'female': 0.03, 'other': 0.03},\n 4: {'male': 0.04, 'female': 0.04, 'other': 0.04},\n 5: {'male': 0.05, 'female': 0.05, 'other': 0.05},\n 6: {'male': 0.06, 'female': 0.06, 'other': 0.06},\n 7: {'male': 0.07, 'female': 0.07, 'other': 0.07},\n 8: {'male': 0.08, 'female': 0.08, 'other': 0.08},\n 9: {'male': 0.09, 'female': 0.09, 'other': 0.09},\n 10: {'male': 0.1, 'female': 0.1, 'other': 0.1},\n 11: {'male': 0.11, 'female': 0.11, 'other': 0.11},\n 12: {'male': 0.12, 'female': 0.12, 'other': 0.12},\n 13: {'male': 0.13, 'female': 0.13, 'other': 0.13},\n 14: {'male': 0.14, 'female': 0.14, 'other': 0.14}}</pre> In\u00a0[37]: Copied! <pre>policy_remove_health = PersonPolicy(\n    RemoveActivity([\"medical\"]),\n    [\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},\n        ),\n        ActivityProbability([\"medical\"], 0.5),\n    ],\n)\n</pre> policy_remove_health = PersonPolicy(     RemoveActivity([\"medical\"]),     [         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},         ),         ActivityProbability([\"medical\"], 0.5),     ], ) In\u00a0[38]: Copied! <pre>print_attributes(smiths, [\"age\", \"gender\"])\n</pre> print_attributes(smiths, [\"age\", \"gender\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\tage: 50\n\tgender: male\nPerson: Hilda\nAttributes:\n\tage: 45\n\tgender: female\nPerson: Timmy\nAttributes:\n\tage: 18\n\tgender: male\nPerson: Bobby\nAttributes:\n\tage: 6\n\tgender: female\n</pre> In\u00a0[39]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[40]: Copied! <pre>hhld_apply(smiths, policy_remove_health).plot()\n</pre> hhld_apply(smiths, policy_remove_health).plot() In\u00a0[41]: Copied! <pre>policy_unemployment_and_furlough = PersonPolicy(RemoveActivity([\"work\"]), PersonProbability(0.1))\n</pre> policy_unemployment_and_furlough = PersonPolicy(RemoveActivity([\"work\"]), PersonProbability(0.1)) In\u00a0[42]: Copied! <pre>hhld_apply(smiths, PersonPolicy(RemoveActivity([\"work\"]), 1)).plot()\n</pre> hhld_apply(smiths, PersonPolicy(RemoveActivity([\"work\"]), 1)).plot() In\u00a0[43]: Copied! <pre>smiths[\"Steve\"].attributes[\"wfh\"] = True\nsmiths[\"Steve\"].attributes[\"key_worker\"] = False\nsmiths[\"Hilda\"].attributes[\"wfh\"] = False\nsmiths[\"Hilda\"].attributes[\"key_worker\"] = False\nsmiths[\"Timmy\"].attributes[\"wfh\"] = False\nsmiths[\"Timmy\"].attributes[\"key_worker\"] = False\nsmiths[\"Bobby\"].attributes[\"wfh\"] = False\nsmiths[\"Bobby\"].attributes[\"key_worker\"] = False\n\nprint_attributes(smiths, [\"wfh\", \"key_worker\"])\n</pre> smiths[\"Steve\"].attributes[\"wfh\"] = True smiths[\"Steve\"].attributes[\"key_worker\"] = False smiths[\"Hilda\"].attributes[\"wfh\"] = False smiths[\"Hilda\"].attributes[\"key_worker\"] = False smiths[\"Timmy\"].attributes[\"wfh\"] = False smiths[\"Timmy\"].attributes[\"key_worker\"] = False smiths[\"Bobby\"].attributes[\"wfh\"] = False smiths[\"Bobby\"].attributes[\"key_worker\"] = False  print_attributes(smiths, [\"wfh\", \"key_worker\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: True\n\tkey_worker: False\nPerson: Hilda\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Timmy\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tkey_worker: False\n</pre> In\u00a0[44]: Copied! <pre>conditions = {\"key_worker\": attribute_False, \"wfh\": attribute_True}\n</pre> conditions = {\"key_worker\": attribute_False, \"wfh\": attribute_True} In\u00a0[45]: Copied! <pre>policy_work_from_home = PersonPolicy(\n    RemoveActivity([\"work\"]), PersonProbability(0.5), PersonAttributeFilter(conditions)\n)\n</pre> policy_work_from_home = PersonPolicy(     RemoveActivity([\"work\"]), PersonProbability(0.5), PersonAttributeFilter(conditions) ) In\u00a0[46]: Copied! <pre>hhld_apply(\n    smiths, PersonPolicy(RemoveActivity([\"work\"]), 1, PersonAttributeFilter(conditions))\n).plot()\n</pre> hhld_apply(     smiths, PersonPolicy(RemoveActivity([\"work\"]), 1, PersonAttributeFilter(conditions)) ).plot() In\u00a0[47]: Copied! <pre>smiths[\"Steve\"].attributes[\"wfh\"] = False\nsmiths[\"Steve\"].attributes[\"key_worker\"] = True\nsmiths[\"Hilda\"].attributes[\"wfh\"] = False\nsmiths[\"Hilda\"].attributes[\"key_worker\"] = False\nsmiths[\"Timmy\"].attributes[\"wfh\"] = False\nsmiths[\"Timmy\"].attributes[\"key_worker\"] = False\nsmiths[\"Bobby\"].attributes[\"wfh\"] = False\nsmiths[\"Bobby\"].attributes[\"key_worker\"] = False\n\nprint_attributes(smiths, [\"wfh\", \"key_worker\"])\n</pre> smiths[\"Steve\"].attributes[\"wfh\"] = False smiths[\"Steve\"].attributes[\"key_worker\"] = True smiths[\"Hilda\"].attributes[\"wfh\"] = False smiths[\"Hilda\"].attributes[\"key_worker\"] = False smiths[\"Timmy\"].attributes[\"wfh\"] = False smiths[\"Timmy\"].attributes[\"key_worker\"] = False smiths[\"Bobby\"].attributes[\"wfh\"] = False smiths[\"Bobby\"].attributes[\"key_worker\"] = False  print_attributes(smiths, [\"wfh\", \"key_worker\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: False\n\tkey_worker: True\nPerson: Hilda\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Timmy\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tkey_worker: False\n</pre> In\u00a0[48]: Copied! <pre>hhld_apply(\n    smiths, PersonPolicy(RemoveActivity([\"work\"]), 1, PersonAttributeFilter(conditions))\n).plot()\n</pre> hhld_apply(     smiths, PersonPolicy(RemoveActivity([\"work\"]), 1, PersonAttributeFilter(conditions)) ).plot() In\u00a0[49]: Copied! <pre>policy_reduced_work_activity = ActivityPolicy(\n    RemoveActivity([\"work\"]), ActivityProbability([\"work\"], 0.2)\n)\n</pre> policy_reduced_work_activity = ActivityPolicy(     RemoveActivity([\"work\"]), ActivityProbability([\"work\"], 0.2) ) In\u00a0[50]: Copied! <pre>hhld_apply(smiths, policy_reduced_work_activity).plot()\n</pre> hhld_apply(smiths, policy_reduced_work_activity).plot() In\u00a0[51]: Copied! <pre>policy_reduce_shopping_activities = HouseholdPolicy(\n    ReduceSharedActivity([\"shop\", \"shop_1\", \"shop_2\"]),\n    ActivityProbability([\"shop\", \"shop_1\", \"shop_2\"], 1),\n)\n</pre> policy_reduce_shopping_activities = HouseholdPolicy(     ReduceSharedActivity([\"shop\", \"shop_1\", \"shop_2\"]),     ActivityProbability([\"shop\", \"shop_1\", \"shop_2\"], 1), ) In\u00a0[52]: Copied! <pre>smiths_shop = hhld_apply(smiths, policy_reduce_shopping_activities)\n</pre> smiths_shop = hhld_apply(smiths, policy_reduce_shopping_activities) In\u00a0[53]: Copied! <pre>smiths_shop.plot()\n</pre> smiths_shop.plot() In\u00a0[54]: Copied! <pre>person_with_shopping = [\n    p for p in smiths_shop.people.values() if \"shop_1\" in [act.act for act in p.activities]\n][0].pid\n</pre> person_with_shopping = [     p for p in smiths_shop.people.values() if \"shop_1\" in [act.act for act in p.activities] ][0].pid In\u00a0[55]: Copied! <pre>smiths_shop.people[person_with_shopping].print()\n</pre> smiths_shop.people[person_with_shopping].print() <pre>Person: Timmy\n{'age': 18, 'job': 'education', 'gender': 'male', 'wfh': False, 'care_constrained': False, 'key_worker': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:sport, location:b, time:08:05:00 --&gt; 08:55:00, duration:0:50:00)\n3:\tLeg(mode:walk, area:b --&gt; a, time:08:55:00 --&gt; 09:00:00, duration:0:05:00)\n4:\tActivity(act:home, location:a, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:a --&gt; b, time:10:00:00 --&gt; 11:00:00, duration:1:00:00)\n6:\tActivity(act:education, location:b, time:11:00:00 --&gt; 13:00:00, duration:2:00:00)\n7:\tLeg(mode:bike, area:b --&gt; c, time:13:00:00 --&gt; 13:05:00, duration:0:05:00)\n8:\tActivity(act:shop, location:c, time:13:05:00 --&gt; 13:30:00, duration:0:25:00)\n9:\tLeg(mode:bike, area:c --&gt; b, time:13:30:00 --&gt; 13:35:00, duration:0:05:00)\n10:\tActivity(act:education, location:b, time:13:35:00 --&gt; 15:00:00, duration:1:25:00)\n11:\tLeg(mode:bike, area:b --&gt; d, time:15:00:00 --&gt; 15:10:00, duration:0:10:00)\n12:\tActivity(act:leisure, location:d, time:15:10:00 --&gt; 18:00:00, duration:2:50:00)\n13:\tLeg(mode:bike, area:d --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:18:20:00 --&gt; 20:00:00, duration:1:40:00)\n15:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n19:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[56]: Copied! <pre>policy_move_shopping = PersonPolicy(\n    MoveActivityTourToHomeLocation([\"shop_1\", \"shop\", \"shop_2\"]),\n    ActivityProbability([\"shop_1\", \"shop\", \"shop_2\"], 1.0),\n)\n</pre> policy_move_shopping = PersonPolicy(     MoveActivityTourToHomeLocation([\"shop_1\", \"shop\", \"shop_2\"]),     ActivityProbability([\"shop_1\", \"shop\", \"shop_2\"], 1.0), ) In\u00a0[57]: Copied! <pre>smiths_shop = hhld_apply(smiths_shop, policy_move_shopping)\n</pre> smiths_shop = hhld_apply(smiths_shop, policy_move_shopping) In\u00a0[58]: Copied! <pre>smiths_shop.plot()\n</pre> smiths_shop.plot() In\u00a0[59]: Copied! <pre>smiths.people[person_with_shopping].print()\n</pre> smiths.people[person_with_shopping].print() <pre>Person: Timmy\n{'age': 18, 'job': 'education', 'gender': 'male', 'wfh': False, 'care_constrained': False, 'key_worker': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:sport, location:b, time:08:05:00 --&gt; 08:55:00, duration:0:50:00)\n3:\tLeg(mode:walk, area:b --&gt; a, time:08:55:00 --&gt; 09:00:00, duration:0:05:00)\n4:\tActivity(act:home, location:a, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:a --&gt; b, time:10:00:00 --&gt; 11:00:00, duration:1:00:00)\n6:\tActivity(act:education, location:b, time:11:00:00 --&gt; 13:00:00, duration:2:00:00)\n7:\tLeg(mode:bike, area:b --&gt; c, time:13:00:00 --&gt; 13:05:00, duration:0:05:00)\n8:\tActivity(act:shop, location:c, time:13:05:00 --&gt; 13:30:00, duration:0:25:00)\n9:\tLeg(mode:bike, area:c --&gt; b, time:13:30:00 --&gt; 13:35:00, duration:0:05:00)\n10:\tActivity(act:education, location:b, time:13:35:00 --&gt; 15:00:00, duration:1:25:00)\n11:\tLeg(mode:bike, area:b --&gt; d, time:15:00:00 --&gt; 15:10:00, duration:0:10:00)\n12:\tActivity(act:leisure, location:d, time:15:10:00 --&gt; 18:00:00, duration:2:50:00)\n13:\tLeg(mode:bike, area:d --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:18:20:00 --&gt; 20:00:00, duration:1:40:00)\n15:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n19:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[60]: Copied! <pre>smiths_shop.people[person_with_shopping].print()\n</pre> smiths_shop.people[person_with_shopping].print() <pre>Person: Timmy\n{'age': 18, 'job': 'education', 'gender': 'male', 'wfh': False, 'care_constrained': False, 'key_worker': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:sport, location:b, time:08:05:00 --&gt; 08:55:00, duration:0:50:00)\n3:\tLeg(mode:walk, area:b --&gt; a, time:08:55:00 --&gt; 09:00:00, duration:0:05:00)\n4:\tActivity(act:home, location:a, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:a --&gt; b, time:10:00:00 --&gt; 11:00:00, duration:1:00:00)\n6:\tActivity(act:education, location:b, time:11:00:00 --&gt; 13:00:00, duration:2:00:00)\n7:\tLeg(mode:bike, area:b --&gt; c, time:13:00:00 --&gt; 13:05:00, duration:0:05:00)\n8:\tActivity(act:shop, location:c, time:13:05:00 --&gt; 13:30:00, duration:0:25:00)\n9:\tLeg(mode:bike, area:c --&gt; b, time:13:30:00 --&gt; 13:35:00, duration:0:05:00)\n10:\tActivity(act:education, location:b, time:13:35:00 --&gt; 15:00:00, duration:1:25:00)\n11:\tLeg(mode:bike, area:b --&gt; d, time:15:00:00 --&gt; 15:10:00, duration:0:10:00)\n12:\tActivity(act:leisure, location:d, time:15:10:00 --&gt; 18:00:00, duration:2:50:00)\n13:\tLeg(mode:bike, area:d --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:18:20:00 --&gt; 20:00:00, duration:1:40:00)\n15:\tLeg(mode:walk, area:a --&gt; a, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:a, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:a --&gt; a, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:a, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n19:\tLeg(mode:walk, area:a --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[61]: Copied! <pre>population = Population(1)\npopulation.add(smiths)\n\nall_together_pop = apply_policies(\n    population,\n    [\n        policy_household_quarantine_per_person,\n        policy_remove_higher_education,\n        policy_remove_any_education,\n        policy_remove_leisure,\n        policy_move_sport,\n        policy_remove_health,\n        policy_unemployment_and_furlough,\n        policy_work_from_home,\n        policy_reduced_work_activity,\n        policy_reduce_shopping_activities,\n        policy_move_shopping,\n    ],\n)\n</pre> population = Population(1) population.add(smiths)  all_together_pop = apply_policies(     population,     [         policy_household_quarantine_per_person,         policy_remove_higher_education,         policy_remove_any_education,         policy_remove_leisure,         policy_move_sport,         policy_remove_health,         policy_unemployment_and_furlough,         policy_work_from_home,         policy_reduced_work_activity,         policy_reduce_shopping_activities,         policy_move_shopping,     ], ) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/05_policies_walk_through/#modifying-the-population-using-simple-policies","title":"Modifying the population using simple policies\u00b6","text":"<p>This notebook shows how simple policies can be applied to people, households, and entire populations.</p>"},{"location":"examples/05_policies_walk_through/#sampling-and-policy-levels","title":"Sampling and Policy Levels\u00b6","text":""},{"location":"examples/05_policies_walk_through/#household","title":"Household\u00b6","text":""},{"location":"examples/05_policies_walk_through/#person","title":"Person\u00b6","text":""},{"location":"examples/05_policies_walk_through/#activity","title":"Activity\u00b6","text":""},{"location":"examples/05_policies_walk_through/#joint-distributions","title":"Joint distributions\u00b6","text":"<p>You can give the <code>SamplingProbability</code> classes custom samplers with joint (or not) distributions. That changes the following table</p> HouseholdProbability PersonProbability ActivityProbability HouseholdPolicy $$p$$ $$1-(1-p)^{n_p}$$ $$1-(1-p)^{n_{a,h}}$$ PersonPolicy $$-$$ $$p$$ $$1-(1-p)^{n_{a,p}}$$ ActivityPolicy $$-$$ $$-$$ $$p$$ <p>where</p> <ul> <li>$n_p$ is the number of people in a household</li> <li>$n_{a,p}$ is the number of (relevant) activities in a person's plan</li> <li>$n_{a,h}$ is the number of (relevant) activities in a household</li> </ul> <p>to</p> HouseholdProbability PersonProbability ActivityProbability HouseholdPolicy $$p$$ $$1-\\prod_x (1-p_x)^{n_x}$$ $$1-\\prod_{x,a}(1-p_{x,a})^{n_{x,a}}$$ PersonPolicy $$-$$ $$p_x$$ $$1-\\prod_a (1-p_a)^{n_a}$$ ActivityPolicy $$-$$ $$-$$ $$p_a, p_{x,a}$$ <p>where</p> <ul> <li>$p_x$ is the probability for person $x$</li> <li>$n_x$ is the number of people with probability $p_x$</li> <li>$p_a$ is the probability for activity $a$</li> <li>$n_a$ is the number of activities $a$ in a person's plan</li> <li>$p_{x,a}$ is the probability for activity $a$ for person $x$</li> <li>$n_{x,a}$ is the number of activities $a$ in a person $x$ plan</li> </ul>"},{"location":"examples/05_policies_walk_through/#modifiers","title":"Modifiers\u00b6","text":"<p>Modifier perform the actions of removing or moving activities on the chosen Policy Level and sampled using the chosen Sampling Level.</p>"},{"location":"examples/05_policies_walk_through/#removeactivity","title":"<code>RemoveActivity</code>\u00b6","text":"<p>Takes a list of activities to be removed.</p>"},{"location":"examples/05_policies_walk_through/#reducesharedactivity","title":"<code>ReduceSharedActivity</code>\u00b6","text":"<p>This is a <code>HouseholdPolicy</code> level modifier which takes a list of activities, checks the household for those being shared (like going shopping together) and selects a person at random to still perform those activities. Those activities will be deleted for everyone else in the household.</p>"},{"location":"examples/05_policies_walk_through/#moveactivitytourtohomelocation","title":"<code>MoveActivityTourToHomeLocation</code>\u00b6","text":"<p>Takes a list of activities and moves those to the home location if they form a tour. A tour is a chain of activities sandwiched by two home activities (or boundary of persons plan e.g. if person's activities are: <code>'work', 'home', 'shop', 'work', 'home'</code> (in that order), their tours are: <code>['work'] </code>and <code>['shop', work']</code>).</p>"},{"location":"examples/05_policies_walk_through/#attribute-filters","title":"Attribute Filters\u00b6","text":"<p><code>PersonAttributeFilter</code> is a conveniece class to apply policies to selected people in the population which satisfy given attributes.</p>"},{"location":"examples/05_policies_walk_through/#policies","title":"Policies\u00b6","text":""},{"location":"examples/05_policies_walk_through/#person-based-household-quarantine","title":"Person-based Household Quarantine\u00b6","text":""},{"location":"examples/05_policies_walk_through/#remove-higher-education","title":"Remove Higher Education\u00b6","text":"<p>Remove all education activity for persons over age of 17</p>"},{"location":"examples/05_policies_walk_through/#remove-education","title":"Remove Education\u00b6","text":"<p>Probabilistically remove education activities from a person, and escort from people who share the household. Contraint based on the house not being care constrainted and people being able to work from home.</p>"},{"location":"examples/05_policies_walk_through/#example-of-non-care-constrained-household","title":"Example of non care constrained household\u00b6","text":"<p>Let's make the Smiths household a non care constrained household with at least one adult is able to work from home and the household is not care constrained.</p>"},{"location":"examples/05_policies_walk_through/#non-care-constrained-household-is-affected","title":"Non care constrained household is affected\u00b6","text":""},{"location":"examples/05_policies_walk_through/#example-of-care-constrained-household","title":"Example of care constrained household\u00b6","text":""},{"location":"examples/05_policies_walk_through/#care-constrained-household-is-not-affected","title":"Care constrained household is not affected\u00b6","text":""},{"location":"examples/05_policies_walk_through/#remove-leisure-activities","title":"Remove Leisure Activities\u00b6","text":"<p>Remove all leisure activities</p>"},{"location":"examples/05_policies_walk_through/#move-sport-activities","title":"Move Sport Activities\u00b6","text":"<p>Probabilistically move Sport activities to home location</p>"},{"location":"examples/05_policies_walk_through/#remove-health-activities","title":"Remove Health Activities\u00b6","text":"<p>Probabilistically remove individual health activities from a person. Make vulnerable people more likely to have their health activities removed.</p>"},{"location":"examples/05_policies_walk_through/#unemploymentfurlough","title":"Unemployment/Furlough\u00b6","text":"<p>Probabilistically remove all work activities from a person</p>"},{"location":"examples/05_policies_walk_through/#work-from-home","title":"Work from Home\u00b6","text":"<p>Probabilistically remove all work activities from a person</p>"},{"location":"examples/05_policies_walk_through/#reduced-work-activity","title":"Reduced Work Activity\u00b6","text":"<p>Probabilistically remove individual work activities from a person</p>"},{"location":"examples/05_policies_walk_through/#shopping","title":"Shopping\u00b6","text":""},{"location":"examples/05_policies_walk_through/#reduce-shared-shopping-activities","title":"Reduce Shared Shopping Activities\u00b6","text":""},{"location":"examples/05_policies_walk_through/#move-shopping-activities-closer-to-home","title":"Move Shopping Activities closer to home\u00b6","text":""},{"location":"examples/05_policies_walk_through/#all-together-now","title":"All together now!\u00b6","text":""},{"location":"examples/06_travel_plots/","title":"Plot Activity Plan Travel","text":"In\u00a0[1]: Copied! <pre>import os\n\nfrom pam import read\n</pre> import os  from pam import read In\u00a0[2]: Copied! <pre>pop = read.read_matsim(\n    os.path.join(\"data\", \"example_data\", \"example_plans.xml\")\n)  # load small sample from the test suite\n</pre> pop = read.read_matsim(     os.path.join(\"data\", \"example_data\", \"example_plans.xml\") )  # load small sample from the test suite <p>You can generate <code>geopandas.GeoDataFrames</code> for <code>Population</code>'s, <code>Household</code>'s or <code>Person</code>'s travel. the <code>route_id</code>, <code>service_id</code> and <code>network_route</code> refer to the network used for running the simulation. <code>GeoDataFrame</code>s are very useful, they let you to generate geojsons simply and quickly, which you can then load up in kepler.</p> <pre><code>gdf.to_file('path/to/file/gdf.geojson'), driver='GeoJSON')\n</code></pre> <p>note that to use this geojson with kepler you will need the geometry to be in <code>'epsg:4326'</code>. You can do this with the method below.</p> In\u00a0[3]: Copied! <pre>pop.build_travel_geodataframe(from_epsg=\"epsg:27700\", to_epsg=\"epsg:4326\").head()\n</pre> pop.build_travel_geodataframe(from_epsg=\"epsg:27700\", to_epsg=\"epsg:4326\").head() Out[3]: mode purp seq freq start_time end_time start_location end_location geometry distance service_id route_id o_stop d_stop network_route pid hid 0 pt work 1 None 1900-01-01 07:24:52 1900-01-01 07:24:52 (515226.0, 188222.0) (529652.0, 183897.0) LINESTRING (-0.33840 51.58109, -0.13191 51.53909) 15060.381834 None None None None [] census_0 census_0 1 pt None 2 None 1900-01-01 14:50:52 1900-01-01 14:50:52 (529652.0, 183897.0) (515226.0, 188222.0) LINESTRING (-0.13191 51.53909, -0.33840 51.58109) 15060.381834 None None None None [] census_0 census_0 2 pt work 1 None 1900-01-01 08:27:33 1900-01-01 08:27:33 (542920.0, 174494.0) (534457.0, 181724.0) LINESTRING (0.05547 51.45140, -0.06349 51.51844) 11130.825172 None None None None [] census_1 census_1 3 pt None 2 None 1900-01-01 17:45:33 1900-01-01 17:45:33 (534457.0, 181724.0) (542920.0, 174494.0) LINESTRING (-0.06349 51.51844, 0.05547 51.45140) 11130.825172 None None None None [] census_1 census_1 4 pt work 1 None 1900-01-01 07:01:09 1900-01-01 07:01:09 (535063.0, 163365.0) (531998.0, 166080.0) LINESTRING (-0.06176 51.35331, -0.10474 51.37843) 4094.563469 None None None None [] census_10 census_10 <p>You can also plot travel using plotly. You will need a mapbox token, which you can get here: https://docs.mapbox.com/help/how-mapbox-works/access-tokens/. Be careful not to commit your token in the repo.</p> In\u00a0[4]: Copied! <pre>mapbox_access_token = \"token\"\n</pre> mapbox_access_token = \"token\" <p>You need to specify the coordinate system to plot it on a map. By default the plot will colour by mode:</p> pop.plot_travel_plotly(     epsg='epsg:27700',      mapbox_access_token=mapbox_access_token )  <p></p> <p>You can also colour by any column you see in the <code>GeoDataFrame</code> (see above). E.g. to colour by agent id (<code>pid</code>)</p> pop.plot_travel_plotly(     epsg='epsg:27700',     mapbox_access_token=mapbox_access_token,      colour_by='pid' )  <p></p>"},{"location":"examples/06_travel_plots/#plot-activity-plan-travel","title":"Plot Activity Plan Travel\u00b6","text":"<p>In this example, we show how plans can be plotted spatially using <code>plotly</code></p>"},{"location":"examples/07_travel_survey_to_matsim/","title":"Converting the National Travel Survey into a Simple MATSim Format Population","text":"In\u00a0[1]: Copied! <pre>import os\nfrom copy import deepcopy\n\nimport geopandas as gp\nimport pandas as pd\n\nfrom pam import read, write\nfrom pam.core import Population\nfrom pam.plot.stats import plot_activity_times, plot_leg_times\nfrom pam.samplers.basic import freq_sample\nfrom pam.samplers.spatial import RandomPointSampler\n</pre> import os from copy import deepcopy  import geopandas as gp import pandas as pd  from pam import read, write from pam.core import Population from pam.plot.stats import plot_activity_times, plot_leg_times from pam.samplers.basic import freq_sample from pam.samplers.spatial import RandomPointSampler In\u00a0[2]: Copied! <pre>use_dummy_data = True\n</pre> use_dummy_data = True In\u00a0[3]: Copied! <pre>out_dir = \"./outputs\"  # outputs are writen here\n\n# required inputs from the National Travel Survey\nif use_dummy_data:\n    households_csv = \"./data/dummyNTS/householdeul2017.tab\"\n    individuals_csv = \"./data/dummyNTS/individualeul2017.tab\"\n    trips_csv = \"./data/dummyNTS/tripeul2017.tab\"\n\nelse:\n    households_csv = \"~/Data/UKDA-5340-tab/tab/householdeul2017.tab\"\n    individuals_csv = \"~/Data/UKDA-5340-tab/tab/individualeul2017.tab\"\n    trips_csv = \"~/Data/UKDA-5340-tab/tab/tripeul2017.tab\"\n</pre> out_dir = \"./outputs\"  # outputs are writen here  # required inputs from the National Travel Survey if use_dummy_data:     households_csv = \"./data/dummyNTS/householdeul2017.tab\"     individuals_csv = \"./data/dummyNTS/individualeul2017.tab\"     trips_csv = \"./data/dummyNTS/tripeul2017.tab\"  else:     households_csv = \"~/Data/UKDA-5340-tab/tab/householdeul2017.tab\"     individuals_csv = \"~/Data/UKDA-5340-tab/tab/individualeul2017.tab\"     trips_csv = \"~/Data/UKDA-5340-tab/tab/tripeul2017.tab\" In\u00a0[4]: Copied! <pre>hh_in = pd.read_csv(\n    households_csv,\n    sep=\"\\t\",\n    usecols=[\n        \"HouseholdID\",\n        \"SurveyYear\",\n        \"PSUID\",\n        \"W2\",\n        \"OutCom_B02ID\",\n        \"HHIncome2002_B02ID\",\n        \"AddressType_B01ID\",\n        \"Ten1_B02ID\",\n        \"Landlord_B01ID\",\n        \"ResLength_B01ID\",\n        \"HHoldCountry_B01ID\",\n        \"HHoldGOR_B02ID\",\n        \"HHoldNumAdults\",\n        \"HHoldNumChildren\",\n        \"HHoldNumPeople\",\n        \"HHoldStruct_B02ID\",\n        \"NumLicHolders\",\n        \"HHoldEmploy_B01ID\",\n        \"NumVehicles\",\n        \"NumBike\",\n        \"NumCar\",\n        \"NumMCycle\",\n        \"NumVanLorry\",\n        \"NumCarVan\",\n        \"WalkBus_B01ID\",\n        \"Getbus_B01ID\",\n        \"WalkRail_B01ID\",\n        \"WalkRailAlt_B01ID\",\n        \"HRPWorkStat_B02ID\",\n        \"HRPSEGWorkStat_B01ID\",\n        \"HHoldOAClass2011_B03ID\",\n        \"Settlement2011EW_B03ID\",\n        \"Settlement2011EW_B04ID\",\n    ],\n)\n\nhh_in.HHIncome2002_B02ID = pd.to_numeric(hh_in.HHIncome2002_B02ID, errors=\"coerce\")\nhh_in.NumLicHolders = pd.to_numeric(hh_in.NumLicHolders, errors=\"coerce\")\nhh_in.NumVehicles = pd.to_numeric(hh_in.NumVehicles, errors=\"coerce\")\nhh_in.NumCar = pd.to_numeric(hh_in.NumCar, errors=\"coerce\")\nhh_in.NumMCycle = pd.to_numeric(hh_in.NumMCycle, errors=\"coerce\")\nhh_in.NumVanLorry = pd.to_numeric(hh_in.NumVanLorry, errors=\"coerce\")\nhh_in.NumCarVan = pd.to_numeric(hh_in.NumCarVan, errors=\"coerce\")\nhh_in.Settlement2011EW_B04ID = pd.to_numeric(hh_in.Settlement2011EW_B04ID, errors=\"coerce\")\n\nhh_in.head()\n</pre> hh_in = pd.read_csv(     households_csv,     sep=\"\\t\",     usecols=[         \"HouseholdID\",         \"SurveyYear\",         \"PSUID\",         \"W2\",         \"OutCom_B02ID\",         \"HHIncome2002_B02ID\",         \"AddressType_B01ID\",         \"Ten1_B02ID\",         \"Landlord_B01ID\",         \"ResLength_B01ID\",         \"HHoldCountry_B01ID\",         \"HHoldGOR_B02ID\",         \"HHoldNumAdults\",         \"HHoldNumChildren\",         \"HHoldNumPeople\",         \"HHoldStruct_B02ID\",         \"NumLicHolders\",         \"HHoldEmploy_B01ID\",         \"NumVehicles\",         \"NumBike\",         \"NumCar\",         \"NumMCycle\",         \"NumVanLorry\",         \"NumCarVan\",         \"WalkBus_B01ID\",         \"Getbus_B01ID\",         \"WalkRail_B01ID\",         \"WalkRailAlt_B01ID\",         \"HRPWorkStat_B02ID\",         \"HRPSEGWorkStat_B01ID\",         \"HHoldOAClass2011_B03ID\",         \"Settlement2011EW_B03ID\",         \"Settlement2011EW_B04ID\",     ], )  hh_in.HHIncome2002_B02ID = pd.to_numeric(hh_in.HHIncome2002_B02ID, errors=\"coerce\") hh_in.NumLicHolders = pd.to_numeric(hh_in.NumLicHolders, errors=\"coerce\") hh_in.NumVehicles = pd.to_numeric(hh_in.NumVehicles, errors=\"coerce\") hh_in.NumCar = pd.to_numeric(hh_in.NumCar, errors=\"coerce\") hh_in.NumMCycle = pd.to_numeric(hh_in.NumMCycle, errors=\"coerce\") hh_in.NumVanLorry = pd.to_numeric(hh_in.NumVanLorry, errors=\"coerce\") hh_in.NumCarVan = pd.to_numeric(hh_in.NumCarVan, errors=\"coerce\") hh_in.Settlement2011EW_B04ID = pd.to_numeric(hh_in.Settlement2011EW_B04ID, errors=\"coerce\")  hh_in.head() Out[4]: HouseholdID SurveyYear PSUID W2 OutCom_B02ID HHIncome2002_B02ID AddressType_B01ID Ten1_B02ID Landlord_B01ID ResLength_B01ID ... NumCarVan WalkBus_B01ID Getbus_B01ID WalkRail_B01ID WalkRailAlt_B01ID HRPWorkStat_B02ID HRPSEGWorkStat_B01ID HHoldOAClass2011_B03ID Settlement2011EW_B03ID Settlement2011EW_B04ID 0 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1 2 2002 1 1 1 1 3 1 -10 8 ... 0 1 5 2 -9 3 5 -10 1 1 2 3 2002 1 1 1 3 3 1 -10 8 ... 2 1 4 3 -9 1 3 -10 1 1 <p>3 rows \u00d7 33 columns</p> In\u00a0[5]: Copied! <pre>participation_mapping = dict(zip(hh_in.HouseholdID, hh_in.OutCom_B02ID))\nweight_mapping = dict(zip(hh_in.HouseholdID, hh_in.W2))\n</pre> participation_mapping = dict(zip(hh_in.HouseholdID, hh_in.OutCom_B02ID)) weight_mapping = dict(zip(hh_in.HouseholdID, hh_in.W2)) In\u00a0[6]: Copied! <pre>persons_in = pd.read_csv(\n    individuals_csv,\n    sep=\"\\t\",\n    usecols=[\n        \"SurveyYear\",\n        \"IndividualID\",\n        \"HouseholdID\",\n        \"PSUID\",\n        \"VehicleID\",\n        \"PersNo\",\n        \"Age_B01ID\",\n        \"OfPenAge_B01ID\",\n        \"Sex_B01ID\",\n        \"EdAttn1_B01ID\",\n        \"EdAttn2_B01ID\",\n        \"EdAttn3_B01ID\",\n        \"DrivLic_B02ID\",\n        \"CarAccess_B01ID\",\n        \"DrivDisable_B01ID\",\n        \"WkPlace_B01ID\",\n        \"ES2000_B01ID\",\n        \"NSSec_B03ID\",\n        \"SC_B01ID\",\n        \"Stat_B01ID\",\n        \"SVise_B01ID\",\n        \"EcoStat_B02ID\",\n        \"PossHom_B01ID\",\n    ],\n)\npersons_in.head()\n</pre> persons_in = pd.read_csv(     individuals_csv,     sep=\"\\t\",     usecols=[         \"SurveyYear\",         \"IndividualID\",         \"HouseholdID\",         \"PSUID\",         \"VehicleID\",         \"PersNo\",         \"Age_B01ID\",         \"OfPenAge_B01ID\",         \"Sex_B01ID\",         \"EdAttn1_B01ID\",         \"EdAttn2_B01ID\",         \"EdAttn3_B01ID\",         \"DrivLic_B02ID\",         \"CarAccess_B01ID\",         \"DrivDisable_B01ID\",         \"WkPlace_B01ID\",         \"ES2000_B01ID\",         \"NSSec_B03ID\",         \"SC_B01ID\",         \"Stat_B01ID\",         \"SVise_B01ID\",         \"EcoStat_B02ID\",         \"PossHom_B01ID\",     ], ) persons_in.head() Out[6]: SurveyYear IndividualID HouseholdID PSUID VehicleID PersNo Age_B01ID OfPenAge_B01ID Sex_B01ID EdAttn1_B01ID ... CarAccess_B01ID DrivDisable_B01ID WkPlace_B01ID ES2000_B01ID NSSec_B03ID SC_B01ID Stat_B01ID SVise_B01ID EcoStat_B02ID PossHom_B01ID 0 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1 2002 2 1 1 2 2 13 2 1 -10 ... 2 -9 1 7 3 4 1 2 1 2 2 2002 3 1 1 3 4 2 1 -10 ... 4 -9 -9 -9 -9 -9 -9 -9 -9 -9 3 2002 4 1 1 4 2 2 2 -10 ... 4 -9 -9 -9 -9 -9 -9 -9 -9 -9 4 2002 5 2 1 1 18 1 2 -10 ... 6 2 -9 6 1 3 1 1 4 -9 <p>5 rows \u00d7 23 columns</p> In\u00a0[7]: Copied! <pre>travel_diaries_in = pd.read_csv(\n    trips_csv,\n    sep=\"\\t\",\n    usecols=[\n        \"TripID\",\n        \"SurveyYear\",\n        \"DayID\",\n        \"IndividualID\",\n        \"HouseholdID\",\n        \"PSUID\",\n        \"PersNo\",\n        \"TravDay\",\n        \"JourSeq\",\n        \"ShortWalkTrip_B01ID\",\n        \"NumStages\",\n        \"MainMode_B04ID\",\n        \"TripPurpFrom_B01ID\",\n        \"TripPurpTo_B01ID\",\n        \"TripPurpose_B04ID\",\n        \"TripStart\",\n        \"TripEnd\",\n        \"TripOrigUA2009_B01ID\",\n        \"TripDestUA2009_B01ID\",\n    ],\n)\n\ntravel_diaries_in.TripStart = pd.to_numeric(travel_diaries_in.TripStart, errors=\"coerce\")\ntravel_diaries_in.TripEnd = pd.to_numeric(travel_diaries_in.TripEnd, errors=\"coerce\")\n\ntravel_diaries_in.head()\n</pre> travel_diaries_in = pd.read_csv(     trips_csv,     sep=\"\\t\",     usecols=[         \"TripID\",         \"SurveyYear\",         \"DayID\",         \"IndividualID\",         \"HouseholdID\",         \"PSUID\",         \"PersNo\",         \"TravDay\",         \"JourSeq\",         \"ShortWalkTrip_B01ID\",         \"NumStages\",         \"MainMode_B04ID\",         \"TripPurpFrom_B01ID\",         \"TripPurpTo_B01ID\",         \"TripPurpose_B04ID\",         \"TripStart\",         \"TripEnd\",         \"TripOrigUA2009_B01ID\",         \"TripDestUA2009_B01ID\",     ], )  travel_diaries_in.TripStart = pd.to_numeric(travel_diaries_in.TripStart, errors=\"coerce\") travel_diaries_in.TripEnd = pd.to_numeric(travel_diaries_in.TripEnd, errors=\"coerce\")  travel_diaries_in.head() Out[7]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay JourSeq ShortWalkTrip_B01ID NumStages MainMode_B04ID TripPurpose_B04ID TripPurpFrom_B01ID TripPurpTo_B01ID TripStart TripEnd TripOrigUA2009_B01ID TripDestUA2009_B01ID 0 1 2002 2 1 1 1 1 2 1 2 1 4 7 23 10 675 683 530 550 1 2 2002 2 1 1 1 1 2 2 2 1 4 6 10 8 720 735 530 550 2 3 2002 2 1 1 1 1 2 3 2 1 4 7 8 10 770 780 530 550 3 4 2002 2 1 1 1 1 2 4 2 1 12 7 10 23 1110 1130 530 550 4 5 2002 3 1 1 1 1 3 1 2 1 4 7 23 10 760 770 530 550 In\u00a0[8]: Copied! <pre>travel_diaries_in[\"participation\"] = travel_diaries_in.HouseholdID.map(participation_mapping)\ntravel_diaries_in[\"hh_weight\"] = travel_diaries_in.HouseholdID.map(weight_mapping)\n</pre> travel_diaries_in[\"participation\"] = travel_diaries_in.HouseholdID.map(participation_mapping) travel_diaries_in[\"hh_weight\"] = travel_diaries_in.HouseholdID.map(weight_mapping) In\u00a0[9]: Copied! <pre>travel_diaries = travel_diaries_in.loc[travel_diaries_in.participation.isin([1, 2])]\n</pre> travel_diaries = travel_diaries_in.loc[travel_diaries_in.participation.isin([1, 2])] In\u00a0[10]: Copied! <pre>travel_diaries.head()\n</pre> travel_diaries.head() Out[10]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay JourSeq ShortWalkTrip_B01ID ... MainMode_B04ID TripPurpose_B04ID TripPurpFrom_B01ID TripPurpTo_B01ID TripStart TripEnd TripOrigUA2009_B01ID TripDestUA2009_B01ID participation hh_weight 0 1 2002 2 1 1 1 1 2 1 2 ... 4 7 23 10 675 683 530 550 1 1 1 2 2002 2 1 1 1 1 2 2 2 ... 4 6 10 8 720 735 530 550 1 1 2 3 2002 2 1 1 1 1 2 3 2 ... 4 7 8 10 770 780 530 550 1 1 3 4 2002 2 1 1 1 1 2 4 2 ... 12 7 10 23 1110 1130 530 550 1 1 4 5 2002 3 1 1 1 1 3 1 2 ... 4 7 23 10 760 770 530 550 1 1 <p>5 rows \u00d7 21 columns</p> In\u00a0[11]: Copied! <pre>travel_diaries = travel_diaries.rename(\n    columns={  # rename data\n        \"JourSeq\": \"seq\",\n        \"TripOrigUA2009_B01ID\": \"ozone\",\n        \"TripDestUA2009_B01ID\": \"dzone\",\n        \"TripPurpFrom_B01ID\": \"oact\",\n        \"TripPurpTo_B01ID\": \"dact\",\n        \"MainMode_B04ID\": \"mode\",\n        \"TripStart\": \"tst\",\n        \"TripEnd\": \"tet\",\n    }\n)\n\ntravel_diaries.head()\n</pre> travel_diaries = travel_diaries.rename(     columns={  # rename data         \"JourSeq\": \"seq\",         \"TripOrigUA2009_B01ID\": \"ozone\",         \"TripDestUA2009_B01ID\": \"dzone\",         \"TripPurpFrom_B01ID\": \"oact\",         \"TripPurpTo_B01ID\": \"dact\",         \"MainMode_B04ID\": \"mode\",         \"TripStart\": \"tst\",         \"TripEnd\": \"tet\",     } )  travel_diaries.head() Out[11]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay seq ShortWalkTrip_B01ID ... mode TripPurpose_B04ID oact dact tst tet ozone dzone participation hh_weight 0 1 2002 2 1 1 1 1 2 1 2 ... 4 7 23 10 675 683 530 550 1 1 1 2 2002 2 1 1 1 1 2 2 2 ... 4 6 10 8 720 735 530 550 1 1 2 3 2002 2 1 1 1 1 2 3 2 ... 4 7 8 10 770 780 530 550 1 1 3 4 2002 2 1 1 1 1 2 4 2 ... 12 7 10 23 1110 1130 530 550 1 1 4 5 2002 3 1 1 1 1 3 1 2 ... 4 7 23 10 760 770 530 550 1 1 <p>5 rows \u00d7 21 columns</p> In\u00a0[12]: Copied! <pre>travel_diaries.dtypes\n</pre> travel_diaries.dtypes Out[12]: <pre>TripID                 int64\nSurveyYear             int64\nDayID                  int64\nIndividualID           int64\nHouseholdID            int64\nPSUID                  int64\nPersNo                 int64\nTravDay                int64\nseq                    int64\nShortWalkTrip_B01ID    int64\nNumStages              int64\nmode                   int64\nTripPurpose_B04ID      int64\noact                   int64\ndact                   int64\ntst                    int64\ntet                    int64\nozone                  int64\ndzone                  int64\nparticipation          int64\nhh_weight              int64\ndtype: object</pre> In\u00a0[13]: Copied! <pre>def check_uniques(df):\n    for c in df.columns:\n        print(c)\n        n = df[c].nunique()\n        if n &lt; 1000:\n            print(df[c].unique())\n</pre> def check_uniques(df):     for c in df.columns:         print(c)         n = df[c].nunique()         if n &lt; 1000:             print(df[c].unique()) In\u00a0[14]: Copied! <pre>check_uniques(travel_diaries)\n</pre> check_uniques(travel_diaries) <pre>TripID\n[  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n 145 146 147 148 149]\nSurveyYear\n[2002]\nDayID\n[ 2  3  5  6  7  8  9 10 11 12 13 14 16 17 19 20 21 23 24 26 27 28 29 30\n 33 35 36 37 38 39 40 41 42 43 44 45 46 47 49]\nIndividualID\n[1 2 3 4 5 6 7]\nHouseholdID\n[1 2 3]\nPSUID\n[1]\nPersNo\n[1 2 3 4]\nTravDay\n[2 3 5 6 7 1 4]\nseq\n[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]\nShortWalkTrip_B01ID\n[2 1]\nNumStages\n[1 4 3 2]\nmode\n[ 4 12  3  1 11  7]\nTripPurpose_B04ID\n[7 6 3 4 5 1 2]\noact\n[23 10  8 20  5  9 22  1 12  4  3  6 14  2 18]\ndact\n[10  8 23 20  5  9 22  1 12  4  3  6 14 18]\ntst\n[ 675  720  770 1110  760  790  810  845  865  908  922  940 1015 1080\n  905  738  755 1050 1220 1270  525  546  745  764 1060  833 1320  530\n 1265  605  620  960  970 1075  360  350  875  898 1310  345  870  900\n  923 1311  990  585  560  840  438 1010 1105 1112  440  965  921  980\n 1115  910  820  853 1013 1023 1298 1306  702  975 1087  495 1070 1052]\ntet\n[ 683  735  780 1130  770  805  825  852  873  914  926  955 1032 1108\n  785  917  752  761 1076 1223 1275  540  556  760  774 1127  836 1325\n  535 1272  608  675  690  962  972 1078  363 1080  355  890  912  931\n 1316  348  887  915  933 1314  855 1020  795  730  750  885  465 1036\n 1110 1120  984  950 1005  471  922  830  862  906 1023 1034 1305 1312\n  627  710  468  986 1085 1091  550 1100 1115  559]\nozone\n[530]\ndzone\n[550]\nparticipation\n[1]\nhh_weight\n[1]\n</pre> In\u00a0[15]: Copied! <pre>area_path = \"./data/dummyNTS/NTSareas.geojson\"\n</pre> area_path = \"./data/dummyNTS/NTSareas.geojson\" In\u00a0[16]: Copied! <pre>areas = gp.read_file(area_path)\nareas.head()\n</pre> areas = gp.read_file(area_path) areas.head() Out[16]: id name geometry 0 530.0 West Midlands POLYGON ((-1.95366 52.66273, -1.95457 52.66264... 1 550.0 West Yorkshire POLYGON ((-1.87994 53.95590, -1.87982 53.95681... In\u00a0[17]: Copied! <pre>areas.plot(figsize=(6, 6))\n</pre> areas.plot(figsize=(6, 6)) Out[17]: <pre>&lt;Axes: &gt;</pre> In\u00a0[18]: Copied! <pre>def remove_broken_plans(plan):\n    if plan.isnull().values.any():\n        return None\n    for col in [\"ozone\", \"dzone\"]:\n        if -8 in list(plan[col]):\n            return None\n    return plan\n</pre> def remove_broken_plans(plan):     if plan.isnull().values.any():         return None     for col in [\"ozone\", \"dzone\"]:         if -8 in list(plan[col]):             return None     return plan In\u00a0[19]: Copied! <pre>clean_travel_diaries = (\n    travel_diaries.groupby([\"IndividualID\", \"TravDay\"], group_keys=False)\n    .apply(remove_broken_plans)\n    .reset_index(drop=True)\n)\n</pre> clean_travel_diaries = (     travel_diaries.groupby([\"IndividualID\", \"TravDay\"], group_keys=False)     .apply(remove_broken_plans)     .reset_index(drop=True) ) In\u00a0[20]: Copied! <pre>clean_travel_diaries.head()\n</pre> clean_travel_diaries.head() Out[20]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay seq ShortWalkTrip_B01ID ... mode TripPurpose_B04ID oact dact tst tet ozone dzone participation hh_weight 0 1 2002 2 1 1 1 1 2 1 2 ... 4 7 23 10 675 683 530 550 1 1 1 2 2002 2 1 1 1 1 2 2 2 ... 4 6 10 8 720 735 530 550 1 1 2 3 2002 2 1 1 1 1 2 3 2 ... 4 7 8 10 770 780 530 550 1 1 3 4 2002 2 1 1 1 1 2 4 2 ... 12 7 10 23 1110 1130 530 550 1 1 4 5 2002 3 1 1 1 1 3 1 2 ... 4 7 23 10 760 770 530 550 1 1 <p>5 rows \u00d7 21 columns</p> In\u00a0[21]: Copied! <pre>print(len(travel_diaries))\nprint(len(clean_travel_diaries))\n</pre> print(len(travel_diaries)) print(len(clean_travel_diaries)) <pre>149\n149\n</pre> In\u00a0[22]: Copied! <pre>mode_mapping = {\n    1: \"walk\",\n    2: \"bike\",\n    3: \"car\",  #'Car/van driver'\n    4: \"car\",  #'Car/van driver'\n    5: \"car\",  #'Motorcycle',\n    6: \"car\",  #'Other private transport',\n    7: \"pt\",  # Bus in London',\n    8: \"pt\",  #'Other local bus',\n    9: \"pt\",  #'Non-local bus',\n    10: \"pt\",  #'London Underground',\n    11: \"pt\",  #'Surface Rail',\n    12: \"car\",  #'Taxi/minicab',\n    13: \"pt\",  #'Other public transport',\n    -10: \"DEAD\",\n    -8: \"NA\",\n}\n\npurp_mapping = {\n    1: \"work\",\n    2: \"work\",  #'In course of work',\n    3: \"education\",\n    4: \"shop\",  #'Food shopping',\n    5: \"shop\",  #'Non food shopping',\n    6: \"medical\",  #'Personal business medical',\n    7: \"other\",  #'Personal business eat/drink',\n    8: \"other\",  #'Personal business other',\n    9: \"other\",  #'Eat/drink with friends',\n    10: \"visit\",  #'Visit friends',\n    11: \"other\",  #'Other social',\n    12: \"other\",  #'Entertain/ public activity',\n    13: \"other\",  #'Sport: participate',\n    14: \"home\",  #'Holiday: base',\n    15: \"other\",  #'Day trip/just walk',\n    16: \"other\",  #'Other non-escort',\n    17: \"escort\",  #'Escort home',\n    18: \"escort\",  #'Escort work',\n    19: \"escort\",  #'Escort in course of work',\n    20: \"escort\",  #'Escort education',\n    21: \"escort\",  #'Escort shopping/personal business',\n    22: \"escort\",  #'Other escort',\n    23: \"home\",  #'Home',\n    -10: \"DEAD\",\n    -8: \"NA\",\n}\n\nclean_travel_diaries[\"mode\"] = clean_travel_diaries[\"mode\"].map(mode_mapping)\nclean_travel_diaries[\"oact\"] = clean_travel_diaries[\"oact\"].map(purp_mapping)\nclean_travel_diaries[\"dact\"] = clean_travel_diaries[\"dact\"].map(purp_mapping)\n</pre> mode_mapping = {     1: \"walk\",     2: \"bike\",     3: \"car\",  #'Car/van driver'     4: \"car\",  #'Car/van driver'     5: \"car\",  #'Motorcycle',     6: \"car\",  #'Other private transport',     7: \"pt\",  # Bus in London',     8: \"pt\",  #'Other local bus',     9: \"pt\",  #'Non-local bus',     10: \"pt\",  #'London Underground',     11: \"pt\",  #'Surface Rail',     12: \"car\",  #'Taxi/minicab',     13: \"pt\",  #'Other public transport',     -10: \"DEAD\",     -8: \"NA\", }  purp_mapping = {     1: \"work\",     2: \"work\",  #'In course of work',     3: \"education\",     4: \"shop\",  #'Food shopping',     5: \"shop\",  #'Non food shopping',     6: \"medical\",  #'Personal business medical',     7: \"other\",  #'Personal business eat/drink',     8: \"other\",  #'Personal business other',     9: \"other\",  #'Eat/drink with friends',     10: \"visit\",  #'Visit friends',     11: \"other\",  #'Other social',     12: \"other\",  #'Entertain/ public activity',     13: \"other\",  #'Sport: participate',     14: \"home\",  #'Holiday: base',     15: \"other\",  #'Day trip/just walk',     16: \"other\",  #'Other non-escort',     17: \"escort\",  #'Escort home',     18: \"escort\",  #'Escort work',     19: \"escort\",  #'Escort in course of work',     20: \"escort\",  #'Escort education',     21: \"escort\",  #'Escort shopping/personal business',     22: \"escort\",  #'Other escort',     23: \"home\",  #'Home',     -10: \"DEAD\",     -8: \"NA\", }  clean_travel_diaries[\"mode\"] = clean_travel_diaries[\"mode\"].map(mode_mapping) clean_travel_diaries[\"oact\"] = clean_travel_diaries[\"oact\"].map(purp_mapping) clean_travel_diaries[\"dact\"] = clean_travel_diaries[\"dact\"].map(purp_mapping) In\u00a0[23]: Copied! <pre># reweight and split ids for unique days\n\n\ndef reweight(group):\n    \"\"\"\n    Reweight based on multiple diary days, ie if an agent has two diary days, we will treat these as\n    two unique agents, so we half the original weighting.\n    \"\"\"\n    group[\"freq\"] = group.hh_weight / group.DayID.nunique()\n    return group\n\n\ntrips = clean_travel_diaries.groupby(\"IndividualID\", group_keys=False).apply(reweight)\ntrips[\"pid\"] = [f\"{p}_{d}\" for p, d in zip(trips.IndividualID, trips.TravDay)]\ntrips[\"hid\"] = [f\"{h}_{d}\" for h, d in zip(trips.HouseholdID, trips.TravDay)]\n</pre> # reweight and split ids for unique days   def reweight(group):     \"\"\"     Reweight based on multiple diary days, ie if an agent has two diary days, we will treat these as     two unique agents, so we half the original weighting.     \"\"\"     group[\"freq\"] = group.hh_weight / group.DayID.nunique()     return group   trips = clean_travel_diaries.groupby(\"IndividualID\", group_keys=False).apply(reweight) trips[\"pid\"] = [f\"{p}_{d}\" for p, d in zip(trips.IndividualID, trips.TravDay)] trips[\"hid\"] = [f\"{h}_{d}\" for h, d in zip(trips.HouseholdID, trips.TravDay)] In\u00a0[24]: Copied! <pre>trips.head()\n</pre> trips.head() Out[24]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay seq ShortWalkTrip_B01ID ... dact tst tet ozone dzone participation hh_weight freq pid hid 0 1 2002 2 1 1 1 1 2 1 2 ... visit 675 683 530 550 1 1 0.2 1_2 1_2 1 2 2002 2 1 1 1 1 2 2 2 ... other 720 735 530 550 1 1 0.2 1_2 1_2 2 3 2002 2 1 1 1 1 2 3 2 ... visit 770 780 530 550 1 1 0.2 1_2 1_2 3 4 2002 2 1 1 1 1 2 4 2 ... home 1110 1130 530 550 1 1 0.2 1_2 1_2 4 5 2002 3 1 1 1 1 3 1 2 ... visit 760 770 530 550 1 1 0.2 1_3 1_3 <p>5 rows \u00d7 24 columns</p> In\u00a0[25]: Copied! <pre>def expand_days(\n    trips, target, trips_on=\"Diary_number\", target_on=\"Diary_number\", new_id=\"pid\", trim=True\n):\n    \"\"\"\n    Expand target df based on mapping between trips target_on and new_id.\n    This is so slow. Fix\n    Set index to new_id.\n    \"\"\"\n    print(\"Building mapping.\")\n    mapping = {}\n    for i, person in trips.groupby(target_on):\n        mapping[i] = list(set(person[new_id]))\n    n = len(mapping)\n\n    if trim:\n        print(\"Trimming target.\")\n        selection = set(trips[trips_on])\n        target = target.loc[target[target_on].isin(selection)]\n\n    expanded = pd.DataFrame()\n    for p, (i, ids) in enumerate(mapping.items()):\n        if not p % 10:\n            print(f\"Building expanded data {p}/{n}\", end=\"\\r\", flush=True)\n        for idx in ids:\n            split = target.loc[target[target_on] == i]\n            expanded = pd.concat([expanded, split.assign(**{new_id: idx})])\n    expanded = expanded.set_index(new_id)\n    print(\"Done\")\n    return expanded\n</pre> def expand_days(     trips, target, trips_on=\"Diary_number\", target_on=\"Diary_number\", new_id=\"pid\", trim=True ):     \"\"\"     Expand target df based on mapping between trips target_on and new_id.     This is so slow. Fix     Set index to new_id.     \"\"\"     print(\"Building mapping.\")     mapping = {}     for i, person in trips.groupby(target_on):         mapping[i] = list(set(person[new_id]))     n = len(mapping)      if trim:         print(\"Trimming target.\")         selection = set(trips[trips_on])         target = target.loc[target[target_on].isin(selection)]      expanded = pd.DataFrame()     for p, (i, ids) in enumerate(mapping.items()):         if not p % 10:             print(f\"Building expanded data {p}/{n}\", end=\"\\r\", flush=True)         for idx in ids:             split = target.loc[target[target_on] == i]             expanded = pd.concat([expanded, split.assign(**{new_id: idx})])     expanded = expanded.set_index(new_id)     print(\"Done\")     return expanded In\u00a0[26]: Copied! <pre>hhs = expand_days(trips, hh_in, trips_on=\"HouseholdID\", target_on=\"HouseholdID\", new_id=\"hid\")\n</pre> hhs = expand_days(trips, hh_in, trips_on=\"HouseholdID\", target_on=\"HouseholdID\", new_id=\"hid\") <pre>Building mapping.\nTrimming target.\nDone\n</pre> In\u00a0[27]: Copied! <pre>hhs.head()\n</pre> hhs.head() Out[27]: HouseholdID SurveyYear PSUID W2 OutCom_B02ID HHIncome2002_B02ID AddressType_B01ID Ten1_B02ID Landlord_B01ID ResLength_B01ID ... NumCarVan WalkBus_B01ID Getbus_B01ID WalkRail_B01ID WalkRailAlt_B01ID HRPWorkStat_B02ID HRPSEGWorkStat_B01ID HHoldOAClass2011_B03ID Settlement2011EW_B03ID Settlement2011EW_B04ID hid 1_5 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_4 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_2 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_7 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_1 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 <p>5 rows \u00d7 33 columns</p> In\u00a0[28]: Copied! <pre>people = expand_days(\n    trips, persons_in, trips_on=\"IndividualID\", target_on=\"IndividualID\", new_id=\"pid\"\n)\n</pre> people = expand_days(     trips, persons_in, trips_on=\"IndividualID\", target_on=\"IndividualID\", new_id=\"pid\" ) <pre>Building mapping.\nTrimming target.\nDone\n</pre> In\u00a0[29]: Copied! <pre>people.head()\n</pre> people.head() Out[29]: SurveyYear IndividualID HouseholdID PSUID VehicleID PersNo Age_B01ID OfPenAge_B01ID Sex_B01ID EdAttn1_B01ID ... CarAccess_B01ID DrivDisable_B01ID WkPlace_B01ID ES2000_B01ID NSSec_B03ID SC_B01ID Stat_B01ID SVise_B01ID EcoStat_B02ID PossHom_B01ID pid 1_5 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_2 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_7 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_6 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_3 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 <p>5 rows \u00d7 23 columns</p> In\u00a0[30]: Copied! <pre>trips.tst = trips.tst.astype(int)\ntrips.tet = trips.tet.astype(int)\n</pre> trips.tst = trips.tst.astype(int) trips.tet = trips.tet.astype(int) In\u00a0[31]: Copied! <pre>population = read.load_travel_diary(\n    trips=trips, persons_attributes=people, hhs_attributes=hhs, trip_freq_as_person_freq=True\n)\n</pre> population = read.load_travel_diary(     trips=trips, persons_attributes=people, hhs_attributes=hhs, trip_freq_as_person_freq=True ) <pre>Using from-to activity parser using 'oact' and 'dact' columns\nAdding pid-&gt;hh mapping to persons_attributes from trips.\n\n        Unable to load household area ('hzone') - not found in trips_diary or unable to build from attributes.\n        Pam will try to infer home location from activities, but this behaviour is not recommended.\n        \nUsing freq of 'None' for all trips.\nUsing freq of 'None' for all households.\n Person pid:2_5 hid:1_5 plan does not start with 'home' activity: work\n Person pid:2_6 hid:1_6 plan does not start with 'home' activity: work\n Person pid:3_6 hid:1_6 plan does not start with 'home' activity: education\n Person pid:2_7 hid:1_7 plan does not start with 'home' activity: work\n</pre> In\u00a0[32]: Copied! <pre>population.fix_plans()\n</pre> population.fix_plans() In\u00a0[33]: Copied! <pre># this should be replaced with a more direct method\nfor hh in population.households.values():\n    for p in hh.people.values():\n        p.validate()\n</pre> # this should be replaced with a more direct method for hh in population.households.values():     for p in hh.people.values():         p.validate() In\u00a0[34]: Copied! <pre>population.size  # this also accounts for the weighting\n</pre> population.size  # this also accounts for the weighting Out[34]: <pre>3.285714285714285</pre> In\u00a0[35]: Copied! <pre>population.stats\n</pre> population.stats Out[35]: <pre>{'num_households': 18,\n 'num_people': 39,\n 'num_activities': 175,\n 'num_legs': 136}</pre> In\u00a0[36]: Copied! <pre>population.activity_classes\n</pre> population.activity_classes Out[36]: <pre>{'education', 'escort', 'home', 'medical', 'other', 'shop', 'visit', 'work'}</pre> In\u00a0[37]: Copied! <pre>population.mode_classes\n</pre> population.mode_classes Out[37]: <pre>{'car', 'pt', 'walk'}</pre> In\u00a0[38]: Copied! <pre>plot_activity_times(population)\n</pre> plot_activity_times(population) Out[38]: In\u00a0[39]: Copied! <pre>plot_leg_times(population)\n</pre> plot_leg_times(population) Out[39]: In\u00a0[40]: Copied! <pre># night shift @ 2016008863_6\n</pre> # night shift @ 2016008863_6 In\u00a0[41]: Copied! <pre>hh = population.random_household()\nhh.print()\nhh.plot()\n</pre> hh = population.random_household() hh.print() hh.plot() <pre>Household: 2_5\n{'HouseholdID': 2, 'SurveyYear': 2002, 'PSUID': 1, 'W2': 1, 'OutCom_B02ID': 1, 'HHIncome2002_B02ID': 1, 'AddressType_B01ID': 3, 'Ten1_B02ID': 1, 'Landlord_B01ID': -10, 'ResLength_B01ID': 8, 'HHoldCountry_B01ID': 1, 'HHoldGOR_B02ID': 7, 'HHoldNumAdults': 1, 'HHoldNumChildren': 0, 'HHoldNumPeople': 1, 'HHoldStruct_B02ID': 1, 'NumLicHolders': 0, 'HHoldEmploy_B01ID': 1, 'NumVehicles': 0, 'NumBike': 0, 'NumCar': 0, 'NumMCycle': 0, 'NumVanLorry': 0, 'NumCarVan': 0, 'WalkBus_B01ID': 1, 'Getbus_B01ID': 5, 'WalkRail_B01ID': 2, 'WalkRailAlt_B01ID': -9, 'HRPWorkStat_B02ID': 3, 'HRPSEGWorkStat_B01ID': 5, 'HHoldOAClass2011_B03ID': -10, 'Settlement2011EW_B03ID': 1, 'Settlement2011EW_B04ID': 1}\nPerson: 5_5\n{'SurveyYear': 2002, 'IndividualID': 5, 'HouseholdID': 2, 'PSUID': 1, 'VehicleID': ' ', 'PersNo': 1, 'Age_B01ID': 18, 'OfPenAge_B01ID': 1, 'Sex_B01ID': 2, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': 3, 'CarAccess_B01ID': 6, 'DrivDisable_B01ID': 2, 'WkPlace_B01ID': -9, 'ES2000_B01ID': 6, 'NSSec_B03ID': 1, 'SC_B01ID': 3, 'Stat_B01ID': 1, 'SVise_B01ID': 1, 'EcoStat_B02ID': 4, 'PossHom_B01ID': -9}\n0:\tActivity(act:home, location:530, time:00:00:00 --&gt; 09:20:00, duration:9:20:00)\n1:\tLeg(mode:pt, area:530 --&gt; 550, time:09:20:00 --&gt; 12:10:00, duration:2:50:00)\n2:\tActivity(act:home, location:550, time:12:10:00 --&gt; 00:00:00, duration:11:50:00)\n</pre> In\u00a0[42]: Copied! <pre>population.activity_classes\n</pre> population.activity_classes Out[42]: <pre>{'education', 'escort', 'home', 'medical', 'other', 'shop', 'visit', 'work'}</pre> In\u00a0[43]: Copied! <pre>population_sample = Population()\n\nfor _hid, household in population.households.items():\n    av_hh_weight = household.freq  # this is currently the av of person freq in the hh\n    freq = freq_sample(av_hh_weight, 10)\n\n    for idx in range(freq):\n        hh = deepcopy(household)\n        hh.hid = f\"{hh.hid}_{idx}\"\n        hh.people = {}\n        for pid, person in household.people.items():\n            p = deepcopy(person)\n            p.pid = f\"{pid}_{idx}\"\n            hh.add(p)\n        population_sample.add(hh)\n</pre> population_sample = Population()  for _hid, household in population.households.items():     av_hh_weight = household.freq  # this is currently the av of person freq in the hh     freq = freq_sample(av_hh_weight, 10)      for idx in range(freq):         hh = deepcopy(household)         hh.hid = f\"{hh.hid}_{idx}\"         hh.people = {}         for pid, person in household.people.items():             p = deepcopy(person)             p.pid = f\"{pid}_{idx}\"             hh.add(p)         population_sample.add(hh) In\u00a0[44]: Copied! <pre>population_sample.size\n</pre> population_sample.size Out[44]: <pre>6.321428571428575</pre> In\u00a0[45]: Copied! <pre>def load_facilities(path, from_crs=\"EPSG:4326\", to_crs=\"EPSG:27700\"):\n    facilities = gp.read_file(path)\n    facilities.crs = from_crs\n    facilities = facilities.to_crs(to_crs)\n    return facilities\n\n\ndef load_zones(zones_path, from_crs=\"EPSG:27700\", to_crs=\"EPSG:27700\"):\n    zones = gp.read_file(zones_path)\n    zones = zones.set_index(\"id\")\n    if from_crs != to_crs:\n        zones.crs = from_crs\n        zones = zones.to_crs(to_crs)\n    return zones\n</pre> def load_facilities(path, from_crs=\"EPSG:4326\", to_crs=\"EPSG:27700\"):     facilities = gp.read_file(path)     facilities.crs = from_crs     facilities = facilities.to_crs(to_crs)     return facilities   def load_zones(zones_path, from_crs=\"EPSG:27700\", to_crs=\"EPSG:27700\"):     zones = gp.read_file(zones_path)     zones = zones.set_index(\"id\")     if from_crs != to_crs:         zones.crs = from_crs         zones = zones.to_crs(to_crs)     return zones In\u00a0[46]: Copied! <pre>zones = load_zones(area_path, from_crs=\"EPSG:4326\")\nsampler = RandomPointSampler(geoms=zones)\n</pre> zones = load_zones(area_path, from_crs=\"EPSG:4326\") sampler = RandomPointSampler(geoms=zones) In\u00a0[47]: Copied! <pre>sampler.sample(530, None)\n</pre> sampler.sample(530, None) Out[47]: In\u00a0[48]: Copied! <pre>population_sample.sample_locs(sampler)\n</pre> population_sample.sample_locs(sampler) In\u00a0[49]: Copied! <pre>person = population_sample.random_person()\nperson.plot()\nperson.print()\n</pre> person = population_sample.random_person() person.plot() person.print() <pre>Person: 1_3_1\n{'SurveyYear': 2002, 'IndividualID': 1, 'HouseholdID': 1, 'PSUID': 1, 'VehicleID': '1', 'PersNo': 1, 'Age_B01ID': 13, 'OfPenAge_B01ID': 2, 'Sex_B01ID': 2, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': 1, 'CarAccess_B01ID': 2, 'DrivDisable_B01ID': -9, 'WkPlace_B01ID': 1, 'ES2000_B01ID': 7, 'NSSec_B03ID': 2, 'SC_B01ID': 3, 'Stat_B01ID': 1, 'SVise_B01ID': 2, 'EcoStat_B02ID': 2, 'PossHom_B01ID': 2}\n0:\tActivity(act:home, location:POINT (409621.73230264394 293748.65448012395), time:00:00:00 --&gt; 12:40:00, duration:12:40:00)\n1:\tLeg(mode:car, area:POINT (409621.73230264394 293748.65448012395) --&gt; POINT (425497.46173734165 409777.1632845471), time:12:40:00 --&gt; 12:50:00, duration:0:10:00)\n2:\tActivity(act:visit, location:POINT (425497.46173734165 409777.1632845471), time:12:50:00 --&gt; 13:10:00, duration:0:20:00)\n3:\tLeg(mode:car, area:POINT (425497.46173734165 409777.1632845471) --&gt; POINT (412797.6192836143 407334.606338873), time:13:10:00 --&gt; 13:25:00, duration:0:15:00)\n4:\tActivity(act:visit, location:POINT (412797.6192836143 407334.606338873), time:13:25:00 --&gt; 13:30:00, duration:0:05:00)\n5:\tLeg(mode:car, area:POINT (412797.6192836143 407334.606338873) --&gt; POINT (441981.01430106605 422966.42596138647), time:13:30:00 --&gt; 13:45:00, duration:0:15:00)\n6:\tActivity(act:other, location:POINT (441981.01430106605 422966.42596138647), time:13:45:00 --&gt; 14:05:00, duration:0:20:00)\n7:\tLeg(mode:car, area:POINT (441981.01430106605 422966.42596138647) --&gt; POINT (400547.9672927279 413350.80957095337), time:14:05:00 --&gt; 14:12:00, duration:0:07:00)\n8:\tActivity(act:other, location:POINT (400547.9672927279 413350.80957095337), time:14:12:00 --&gt; 14:25:00, duration:0:13:00)\n9:\tLeg(mode:car, area:POINT (400547.9672927279 413350.80957095337) --&gt; POINT (399624.7537899115 434480.31704158615), time:14:25:00 --&gt; 14:33:00, duration:0:08:00)\n10:\tActivity(act:visit, location:POINT (399624.7537899115 434480.31704158615), time:14:33:00 --&gt; 15:08:00, duration:0:35:00)\n11:\tLeg(mode:car, area:POINT (399624.7537899115 434480.31704158615) --&gt; POINT (441034.90834092686 437688.0984962487), time:15:08:00 --&gt; 15:14:00, duration:0:06:00)\n12:\tActivity(act:escort, location:POINT (441034.90834092686 437688.0984962487), time:15:14:00 --&gt; 15:22:00, duration:0:08:00)\n13:\tLeg(mode:car, area:POINT (441034.90834092686 437688.0984962487) --&gt; POINT (421333.20453176176 409052.7494448754), time:15:22:00 --&gt; 15:26:00, duration:0:04:00)\n14:\tActivity(act:home, location:POINT (421333.20453176176 409052.7494448754), time:15:26:00 --&gt; 15:40:00, duration:0:14:00)\n15:\tLeg(mode:car, area:POINT (421333.20453176176 409052.7494448754) --&gt; POINT (422338.2609308342 420076.11110860814), time:15:40:00 --&gt; 15:55:00, duration:0:15:00)\n16:\tActivity(act:shop, location:POINT (422338.2609308342 420076.11110860814), time:15:55:00 --&gt; 16:55:00, duration:1:00:00)\n17:\tLeg(mode:car, area:POINT (422338.2609308342 420076.11110860814) --&gt; POINT (439250.45804775297 444802.54213777994), time:16:55:00 --&gt; 17:12:00, duration:0:17:00)\n18:\tActivity(act:visit, location:POINT (439250.45804775297 444802.54213777994), time:17:12:00 --&gt; 18:00:00, duration:0:48:00)\n19:\tLeg(mode:car, area:POINT (439250.45804775297 444802.54213777994) --&gt; POINT (421333.20453176176 409052.7494448754), time:18:00:00 --&gt; 18:28:00, duration:0:28:00)\n20:\tActivity(act:home, location:POINT (421333.20453176176 409052.7494448754), time:18:28:00 --&gt; 00:00:00, duration:5:32:00)\n</pre> In\u00a0[50]: Copied! <pre>comment = \"NTS london prelim 24nov2020 epsg27700\"\n\nwrite.write_matsim(\n    population_sample, plans_path=os.path.join(out_dir, \"plans.xml\"), comment=comment\n)\npopulation_sample.to_csv(out_dir, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\")\n</pre> comment = \"NTS london prelim 24nov2020 epsg27700\"  write.write_matsim(     population_sample, plans_path=os.path.join(out_dir, \"plans.xml\"), comment=comment ) population_sample.to_csv(out_dir, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\")"},{"location":"examples/07_travel_survey_to_matsim/#converting-the-national-travel-survey-into-a-simple-matsim-format-population","title":"Converting the National Travel Survey into a Simple MATSim Format Population\u00b6","text":"<p>This notebook demonstrates an example workflow for converting tabular diary data from UK NTS (household attributes, person attributes and trip data) into MATSim formatted xml population data for London households.</p> <p>This includes:</p> <ul> <li>pre-processing of tabular inputs</li> <li>loading data into pam</li> <li>household sampling</li> <li>facility sampling</li> <li>preliminary investigation</li> <li>writing to xml</li> </ul> <p>This example is highly simplified. Of particular note: the diary data used is spatially very aggregate (trip locations are aggregated to inner/outer London). This creates significant variance in the sampled trip lengths. Generally we would expect more precise spatial data to be used. Alternately the complexity of the facility sampling step can be improved to better account for known trip features such as mode and duration.</p> <p>The diary data used is available from the UK Data Service (https://beta.ukdataservice.ac.uk/datacatalogue/studies/study?id=5340) and is described here:http://doc.ukdataservice.ac.uk/doc/5340/mrdoc/pdf/5340_nts_user_guidance_1995-2016.pdf</p>"},{"location":"examples/07_travel_survey_to_matsim/#load-data","title":"Load data\u00b6","text":""},{"location":"examples/07_travel_survey_to_matsim/#load-households-data","title":"Load households data\u00b6","text":"<ol> <li>Load household data into pandas DataFrame.</li> <li>Create some mappings of participation and weighting by household for use later. These are described in http://doc.ukdataservice.ac.uk/doc/5340/mrdoc/pdf/5340_nts_user_guidance_1995-2016.pdf</li> </ol>"},{"location":"examples/07_travel_survey_to_matsim/#load-person-data","title":"Load person data\u00b6","text":"<p>Load person attributes data into pandas DataFrame.</p>"},{"location":"examples/07_travel_survey_to_matsim/#load-trip-data","title":"load trip data\u00b6","text":"<ol> <li>Load trip data into pandas DataFrame format.</li> <li>Apply some preliminary formatting</li> <li>Replace headers so that we can use pam read method:</li> </ol> <ul> <li>pid - person ID</li> <li>hid - household ID</li> <li>seq - trip sequence number</li> <li>hzone - household zone</li> <li>ozone - trip origin zone</li> <li>dzone - trip destination zone</li> <li>purp - trip purpose</li> <li>mode - trip mode</li> <li>tst - trip start time (minutes)</li> <li>tet - trip end time (minutes)</li> <li>freq - weighting for representative population</li> </ul>"},{"location":"examples/07_travel_survey_to_matsim/#area-mapping","title":"Area Mapping\u00b6","text":"<p>The NTS documentation refers to a 'modified' 2009 Unitary Authorities. The Unmodified 2017 UAs are included below for reference. They 2017 UA names are similar but not the same as the NTS mappings.</p> <p>Found here: https://data.gov.uk/dataset/4e1d5b2c-bb91-42ad-b420-f7fcab638389/counties-and-unitary-authorities-december-2017-full-extent-boundaries-in-uk-wgs84.</p> <p>We have built our own geometry:</p>"},{"location":"examples/07_travel_survey_to_matsim/#clean-out-incomplete-plans","title":"Clean out incomplete plans\u00b6","text":""},{"location":"examples/07_travel_survey_to_matsim/#build-mappings-and-apply-to-common-fields","title":"Build Mappings and apply to common fields\u00b6","text":"<p>We simplify key trip variables such as mode and activity.</p>"},{"location":"examples/07_travel_survey_to_matsim/#reweight-and-split-days","title":"Reweight and Split Days\u00b6","text":"<p>In order to get the most from our small sample we treat individual diary days as new persons. In order to maintain the original household weighting we reduce this accordingly.</p>"},{"location":"examples/07_travel_survey_to_matsim/#load-into-pam","title":"Load into PAM\u00b6","text":"<p>We load the pandas formatted data into Pam using the <code>pam.read.load_travel_diary_from_to</code> read method. We do some very preliminary validation of plans and assurance.</p>"},{"location":"examples/07_travel_survey_to_matsim/#sample-the-population","title":"Sample the Population\u00b6","text":"<p>We sample a very small population based on the given NTS household weightings.</p>"},{"location":"examples/07_travel_survey_to_matsim/#facility-sampling","title":"Facility Sampling\u00b6","text":"<p>The facilities input is prepared using a separate project called OSM-Facility Sampler (OSMFS). This project woulbe be better names the OSM Facility Extractor. We use it to extract viable activity locations for each activity type for each zone. This project is not currently open source, but is described below:</p> <p>OSMFS joins osm data with the geographies of an area to create a mapping between zones, acts and facility locations (points). This is output as a geojson:</p> <p>{\"type\": \"FeatureCollection\", \"features\": [{\"id\": \"0\", \"type\": \"Feature\", \"properties\": {\"activity\": \"other\"}, \"geometry\": {\"type\": \"Point\", \"coordinates\": [-4.5235751, 54.1698685]}},</p> <p>todo: the current methodology does not support shared facilities, ie facilities with more than one activity (schools are places of education and work for example).</p> <p>todo: the above json has to be rejoined with the geography to create a spatial sampler. This is a duplicated operation which could be included in the Bench output, eg:</p> <p>zone_id: activity: (id, point)</p>"},{"location":"examples/07_travel_survey_to_matsim/#random-sampler","title":"Random Sampler\u00b6","text":"<p>Failing a facility sampler - we can use random sampling instead.</p>"},{"location":"examples/07_travel_survey_to_matsim/#write-to-disk","title":"Write to Disk\u00b6","text":"<ol> <li>write MATSim formats to disk (plans and attributes)</li> <li>write csv and geojson summaries to disk</li> <li>write MATSim formatted facilities to disk</li> </ol>"},{"location":"examples/08_toy_matsim_population/","title":"Demo - MATSim Population for West London","text":"<p>This notebook demonstrates an complex example workflow for creating a sample population for an area in West London. It creates agent plans for people and households using a random process.</p> <p>Steps:</p> <ol> <li>Import geographic data of Londinium;</li> <li>Facility sampling from OpenStreetMap data;</li> <li>Activity generation model with home based tours. Expand agents with different personal attributes, activities and trips;</li> <li>Perform Data Visualization and validation. Plot the activity plan, distance and duration of population;</li> <li>Export intermediate CSV tables of the population</li> </ol> In\u00a0[1]: Copied! <pre>import os\n\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nfrom pam.activity import Activity, Leg\nfrom pam.core import Household, Person, Population\nfrom pam.plot.stats import plot_activity_times\nfrom pam.read import load_travel_diary\nfrom pam.report.benchmarks import distance_counts, duration_counts\nfrom pam.samplers import facility\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\nfrom pam.write import to_csv, write_matsim, write_od_matrices\n\n%matplotlib inline\n</pre> import os  import geopandas as gp import matplotlib.pyplot as plt import numpy as np import pandas as pd  from pam.activity import Activity, Leg from pam.core import Household, Person, Population from pam.plot.stats import plot_activity_times from pam.read import load_travel_diary from pam.report.benchmarks import distance_counts, duration_counts from pam.samplers import facility from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY from pam.write import to_csv, write_matsim, write_od_matrices  %matplotlib inline In\u00a0[2]: Copied! <pre># Import geographic data of west london area\nnetwork_bb_path = os.path.join(\"data\", \"network_bounding_box.geojson\")\nlsoas_path = os.path.join(\"data\", \"lsoas\")  # lsoas: lower layer super output areas\n</pre> # Import geographic data of west london area network_bb_path = os.path.join(\"data\", \"network_bounding_box.geojson\") lsoas_path = os.path.join(\"data\", \"lsoas\")  # lsoas: lower layer super output areas <p>We will start by plotting Londinium boundary</p> In\u00a0[3]: Copied! <pre># Read the file and plot the boundary\nboundary = gp.read_file(network_bb_path)\n\n# Transform to epsg:27700\nboundary = boundary.to_crs(\"epsg:27700\")\nboundary.plot()\n</pre> # Read the file and plot the boundary boundary = gp.read_file(network_bb_path)  # Transform to epsg:27700 boundary = boundary.to_crs(\"epsg:27700\") boundary.plot() Out[3]: <pre>&lt;Axes: &gt;</pre> <p>Next we will plot Londinium outline shown above over a map of London to see where exactly it is located.</p> In\u00a0[4]: Copied! <pre># Plot boundary area in lsoas\nlsoas = gp.read_file(lsoas_path)\nlsoas.crs = \"EPSG:27700\"\nprint(lsoas.crs)\nlsoas = lsoas.set_index(\"LSOA_CODE\")\n\nfig, ax = plt.subplots(figsize=(10, 10))\nlsoas.plot(ax=ax)\nboundary.plot(ax=ax, color=\"red\")\n</pre> # Plot boundary area in lsoas lsoas = gp.read_file(lsoas_path) lsoas.crs = \"EPSG:27700\" print(lsoas.crs) lsoas = lsoas.set_index(\"LSOA_CODE\")  fig, ax = plt.subplots(figsize=(10, 10)) lsoas.plot(ax=ax) boundary.plot(ax=ax, color=\"red\") <pre>EPSG:27700\n</pre> Out[4]: <pre>&lt;Axes: &gt;</pre> <p>Finally, we will plot Londinium with LSOA boundaries included.</p> In\u00a0[5]: Copied! <pre># Overlay the area using geopandas package\nlsoas_clipped = gp.overlay(lsoas, boundary, how=\"intersection\")\nlsoas_clipped.plot()\n</pre> # Overlay the area using geopandas package lsoas_clipped = gp.overlay(lsoas, boundary, how=\"intersection\") lsoas_clipped.plot() <pre>/Users/bryn.pickering/mambaforge/envs/pam/lib/python3.11/site-packages/shapely/set_operations.py:133: RuntimeWarning: invalid value encountered in intersection\n  return lib.intersection(a, b, **kwargs)\n</pre> Out[5]: <pre>&lt;Axes: &gt;</pre> In\u00a0[6]: Copied! <pre>lsoas_clipped.head()\n</pre> lsoas_clipped.head() Out[6]: LSOA_NAME MSOA_CODE MSOA_NAME STWARDCODE STWARDNAME LA_CODE LA_NAME geometry 0 Hammersmith and Fulham 010A E02000381 Hammersmith and Fulham 010 00ANGA Addison 00AN Hammersmith and Fulham POLYGON ((523932.247 179242.842, 523959.439 17... 1 Hammersmith and Fulham 010B E02000381 Hammersmith and Fulham 010 00ANGA Addison 00AN Hammersmith and Fulham POLYGON ((524171.272 179363.077, 524212.654 17... 2 Hammersmith and Fulham 012A E02000383 Hammersmith and Fulham 012 00ANGC Avonmore and Brook Green 00AN Hammersmith and Fulham POLYGON ((524167.660 178997.302, 524060.845 17... 3 Hammersmith and Fulham 012B E02000383 Hammersmith and Fulham 012 00ANGC Avonmore and Brook Green 00AN Hammersmith and Fulham POLYGON ((523774.000 178714.003, 523831.847 17... 4 Hammersmith and Fulham 012C E02000383 Hammersmith and Fulham 012 00ANGC Avonmore and Brook Green 00AN Hammersmith and Fulham MULTIPOLYGON (((524422.688 178825.081, 524379.... In\u00a0[7]: Copied! <pre>facilities_path = \"data/londinium_facilities_sample.geojson\"\nfacilities = gp.read_file(facilities_path)\nfacilities = facilities.rename({\"activities\": \"activity\"}, axis=1)\nfacilities.crs = \"EPSG:27700\"\nfacilities.head()\n</pre> facilities_path = \"data/londinium_facilities_sample.geojson\" facilities = gp.read_file(facilities_path) facilities = facilities.rename({\"activities\": \"activity\"}, axis=1) facilities.crs = \"EPSG:27700\" facilities.head() Out[7]: activity area distance_to_nearest_education distance_to_nearest_medical distance_to_nearest_shop distance_to_nearest_transit floor_area id levels units geometry 0 home 574 617.965594 516.743962 77.712882 466.059745 1148.0 1084822608 2.0 1.0 POINT (524877.659 179721.080) 1 home 66 143.055807 115.674294 125.537224 286.017738 198.0 368319574 3.0 1.0 POINT (527830.357 174758.729) 2 home 103 54.946075 214.532285 41.572871 93.975944 412.0 1640220880 4.0 1.0 POINT (526060.994 178970.515) 3 home 192 164.455318 216.217139 111.674214 180.452314 768.0 1741392588 4.0 1.0 POINT (526698.625 178513.841) 4 home 123 173.648285 249.190465 188.276309 139.258340 246.0 984446626 2.0 1.0 POINT (526369.238 179166.396) <p>Start by plotting different facility types, e.g. educational and medical facilities</p> In\u00a0[8]: Copied! <pre>education = facilities[facilities[\"activity\"] == \"education\"]\nmedical = facilities[facilities[\"activity\"] == \"medical\"]\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 12))\n\nboundary.plot(ax=ax1, color=\"steelblue\")\neducation.plot(ax=ax1, color=\"orange\", label=\"Educational facilities\")\nax1.legend()\n\nboundary.plot(ax=ax2, color=\"steelblue\")\nmedical.plot(ax=ax2, color=\"red\", label=\"Medical facilities\")\nax2.legend()\n</pre> education = facilities[facilities[\"activity\"] == \"education\"] medical = facilities[facilities[\"activity\"] == \"medical\"]  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 12))  boundary.plot(ax=ax1, color=\"steelblue\") education.plot(ax=ax1, color=\"orange\", label=\"Educational facilities\") ax1.legend()  boundary.plot(ax=ax2, color=\"steelblue\") medical.plot(ax=ax2, color=\"red\", label=\"Medical facilities\") ax2.legend() Out[8]: <pre>&lt;matplotlib.legend.Legend at 0x13f575590&gt;</pre> In\u00a0[9]: Copied! <pre>lsoas_clipped.crs = \"EPSG:27700\"\nlen(lsoas_clipped)\n</pre> lsoas_clipped.crs = \"EPSG:27700\" len(lsoas_clipped) Out[9]: <pre>306</pre> In\u00a0[10]: Copied! <pre>lsoas_clipped = lsoas_clipped.set_index(\"LSOA_NAME\")\n</pre> lsoas_clipped = lsoas_clipped.set_index(\"LSOA_NAME\") In\u00a0[11]: Copied! <pre># build the sampler\nfacility_sampler = facility.FacilitySampler(\n    facilities=facilities, zones=lsoas_clipped, build_xml=True, fail=False, random_default=True\n)\n</pre> # build the sampler facility_sampler = facility.FacilitySampler(     facilities=facilities, zones=lsoas_clipped, build_xml=True, fail=False, random_default=True ) <pre>Joining facilities data to zones, this may take a while.\nBuilding sampler, this may take a while.\n</pre> In\u00a0[12]: Copied! <pre># Create random area sample\n\n\ndef random_area_sampler():\n    indexes = list(lsoas_clipped.index)\n    return np.random.choice(indexes)\n\n\nrandom_area_sampler()  # test\n</pre> # Create random area sample   def random_area_sampler():     indexes = list(lsoas_clipped.index)     return np.random.choice(indexes)   random_area_sampler()  # test Out[12]: <pre>'Hammersmith and Fulham 020A'</pre> <ul> <li>It is a simple home based tours within 24 hours.</li> <li>We create different activity types: work, leisure, education, shopping, etc. Different transport model types: car, bus, subway, etc.</li> <li>Random number is assigned to the duration for each activity and transport mode</li> </ul> In\u00a0[13]: Copied! <pre># mapping the MSOA and LAD with index\nmapping_dict = dict(zip(lsoas_clipped.index, lsoas_clipped.MSOA_CODE))\nmapping_dict1 = dict(zip(lsoas_clipped.index, lsoas_clipped.LA_NAME))\n</pre> # mapping the MSOA and LAD with index mapping_dict = dict(zip(lsoas_clipped.index, lsoas_clipped.MSOA_CODE)) mapping_dict1 = dict(zip(lsoas_clipped.index, lsoas_clipped.LA_NAME)) In\u00a0[14]: Copied! <pre># Generate agents in west london area\n\n\ndef generate_agents(no_of_agents):\n    \"\"\"\n    Randomly create agents with simple home-based tours.\n    The trip starts from home, has a random number of various acitivites, tranport modes would be added.\n    The trip finally ends at home.\n\n    \"\"\"\n    population = Population()  # Initialise an empty population\n\n    # Create simple personal attributes\n    income = [\"low\", \"medium\", \"high\"]\n    gender = [\"male\", \"female\"]\n    sort_age = [\n        \"0 to 4\",\n        \"5 to 10\",\n        \"11 to 15\",\n        \"16 to 20\",\n        \"21 to 25\",\n        \"26 to 29\",\n        \"30 to 39\",\n        \"40 to 49\",\n        \"50 to 59\",\n        \"60 to 64\",\n        \"65 to 69\",\n        \"70 to 74\",\n        \"75 to 79\",\n        \"80 to 84\",\n        \"85  and over\",\n    ]\n\n    # Create mode and activities\n    transport = [\"car\", \"bus\", \"ferry\", \"rail\", \"subway\", \"bike\", \"walk\"]\n    # Removed gym and park due to osmox problem\n    activity = [\n        \"leisure\",\n        \"work\",\n        \"shop\",\n        \"medical\",\n        \"education\",\n        \"park\",\n        \"pub\",\n        \"gym\",\n    ]  # Primary activity\n    sub_activity = [\n        \"shop\",\n        \"medical\",\n        \"pub\",\n        \"gym\",\n    ]  # People usually spend less time on sub activity\n\n    # Add activity plan for each person\n    for i in range(no_of_agents):\n        # Create different agents and household\n        agent_id = f\"agent_{i}\"\n        hh_id = f\"hh_{i}\"\n        hh = Household(hh_id, freq=1)\n\n        # Adding Activities and Legs alternately to different agents\n        # Activity 1 - home\n        leaves_home = (np.random.randint(6, 8) * 60) + np.random.randint(0, 100)  # minutes\n        location1 = random_area_sampler()\n        location1_loc = facility_sampler.sample(location1, \"home\")\n        lsoa_name = mapping_dict.get(location1)\n        lad_name = mapping_dict1.get(location1)\n\n        agent = Person(\n            agent_id,\n            freq=1,\n            attributes={\n                \"subpopulation\": np.random.choice(income) + \" income\",\n                \"gender\": np.random.choice(gender),\n                \"age\": np.random.choice(sort_age),\n                \"household_zone\": location1,\n                \"household_LSOA\": lsoa_name,\n                \"household_LAD\": lad_name,\n            },\n        )\n\n        hh.add(agent)\n        population.add(hh)\n\n        # Trip duration\n        trip_duration_main_activity = np.random.randint(3, 6) * 60\n        trip_duration_sub_activity = np.random.randint(1, 3) * 60\n\n        agent.add(\n            Activity(\n                seq=1,\n                act=\"home\",\n                area=location1,\n                loc=location1_loc,\n                start_time=mtdt(0),\n                end_time=mtdt(leaves_home),\n            )\n        )\n\n        # Initiated parameters\n        location_prev = location1\n        location_prev_loc = location1_loc\n        leave_time = leaves_home\n\n        # Add random numbers of activities\n        no_of_activities = np.random.randint(1, 5)\n\n        for i in range(no_of_activities):\n            arrives_primary = leave_time + np.random.randint(10, 90)  # minutes\n\n            # Activity 2.\n            if i &lt; 2:  # Start with main activity\n                random_act = np.random.choice(activity)\n            else:\n                random_act = np.random.choice(sub_activity)\n\n            if random_act == (\"work\"):\n                leaves_primary = arrives_primary + trip_duration_main_activity\n            else:\n                leaves_primary = arrives_primary + trip_duration_sub_activity\n\n            # Outbound leg\n            location_next = random_area_sampler()\n            location_next_loc = facility_sampler.sample(location_next, random_act)\n\n            agent.add(\n                Leg(\n                    seq=i + 1,\n                    mode=np.random.choice(transport),\n                    start_area=location_prev,\n                    start_loc=location_prev_loc,\n                    end_area=location_next,\n                    end_loc=location_next_loc,\n                    start_time=mtdt(leave_time),\n                    end_time=mtdt(arrives_primary),\n                )\n            )\n\n            agent.add(\n                Activity(\n                    seq=i + 2,\n                    act=random_act,\n                    area=location_next,\n                    loc=location_next_loc,\n                    start_time=mtdt(arrives_primary),\n                    end_time=mtdt(leaves_primary),\n                )\n            )\n\n            # Update parameters\n            leave_time = leaves_primary\n            location_prev = location_next\n            location_prev_loc = location_next_loc\n\n        # Inbound leg\n        arrives_home = leave_time + np.random.randint(10, 90)  # minutes\n        agent.add(\n            Leg(\n                seq=no_of_activities + 1,\n                mode=np.random.choice(transport),\n                start_area=location_next,\n                start_loc=location_next_loc,\n                end_area=location1,\n                end_loc=location1_loc,\n                start_time=mtdt(leave_time),\n                end_time=mtdt(arrives_home),\n            )\n        )\n\n        # Activity\n        agent.add(\n            Activity(\n                seq=no_of_activities + 2,\n                act=\"home\",\n                area=location1,\n                loc=location1_loc,\n                start_time=mtdt(arrives_home),\n                end_time=END_OF_DAY,\n            )\n        )\n\n    return population\n</pre> # Generate agents in west london area   def generate_agents(no_of_agents):     \"\"\"     Randomly create agents with simple home-based tours.     The trip starts from home, has a random number of various acitivites, tranport modes would be added.     The trip finally ends at home.      \"\"\"     population = Population()  # Initialise an empty population      # Create simple personal attributes     income = [\"low\", \"medium\", \"high\"]     gender = [\"male\", \"female\"]     sort_age = [         \"0 to 4\",         \"5 to 10\",         \"11 to 15\",         \"16 to 20\",         \"21 to 25\",         \"26 to 29\",         \"30 to 39\",         \"40 to 49\",         \"50 to 59\",         \"60 to 64\",         \"65 to 69\",         \"70 to 74\",         \"75 to 79\",         \"80 to 84\",         \"85  and over\",     ]      # Create mode and activities     transport = [\"car\", \"bus\", \"ferry\", \"rail\", \"subway\", \"bike\", \"walk\"]     # Removed gym and park due to osmox problem     activity = [         \"leisure\",         \"work\",         \"shop\",         \"medical\",         \"education\",         \"park\",         \"pub\",         \"gym\",     ]  # Primary activity     sub_activity = [         \"shop\",         \"medical\",         \"pub\",         \"gym\",     ]  # People usually spend less time on sub activity      # Add activity plan for each person     for i in range(no_of_agents):         # Create different agents and household         agent_id = f\"agent_{i}\"         hh_id = f\"hh_{i}\"         hh = Household(hh_id, freq=1)          # Adding Activities and Legs alternately to different agents         # Activity 1 - home         leaves_home = (np.random.randint(6, 8) * 60) + np.random.randint(0, 100)  # minutes         location1 = random_area_sampler()         location1_loc = facility_sampler.sample(location1, \"home\")         lsoa_name = mapping_dict.get(location1)         lad_name = mapping_dict1.get(location1)          agent = Person(             agent_id,             freq=1,             attributes={                 \"subpopulation\": np.random.choice(income) + \" income\",                 \"gender\": np.random.choice(gender),                 \"age\": np.random.choice(sort_age),                 \"household_zone\": location1,                 \"household_LSOA\": lsoa_name,                 \"household_LAD\": lad_name,             },         )          hh.add(agent)         population.add(hh)          # Trip duration         trip_duration_main_activity = np.random.randint(3, 6) * 60         trip_duration_sub_activity = np.random.randint(1, 3) * 60          agent.add(             Activity(                 seq=1,                 act=\"home\",                 area=location1,                 loc=location1_loc,                 start_time=mtdt(0),                 end_time=mtdt(leaves_home),             )         )          # Initiated parameters         location_prev = location1         location_prev_loc = location1_loc         leave_time = leaves_home          # Add random numbers of activities         no_of_activities = np.random.randint(1, 5)          for i in range(no_of_activities):             arrives_primary = leave_time + np.random.randint(10, 90)  # minutes              # Activity 2.             if i &lt; 2:  # Start with main activity                 random_act = np.random.choice(activity)             else:                 random_act = np.random.choice(sub_activity)              if random_act == (\"work\"):                 leaves_primary = arrives_primary + trip_duration_main_activity             else:                 leaves_primary = arrives_primary + trip_duration_sub_activity              # Outbound leg             location_next = random_area_sampler()             location_next_loc = facility_sampler.sample(location_next, random_act)              agent.add(                 Leg(                     seq=i + 1,                     mode=np.random.choice(transport),                     start_area=location_prev,                     start_loc=location_prev_loc,                     end_area=location_next,                     end_loc=location_next_loc,                     start_time=mtdt(leave_time),                     end_time=mtdt(arrives_primary),                 )             )              agent.add(                 Activity(                     seq=i + 2,                     act=random_act,                     area=location_next,                     loc=location_next_loc,                     start_time=mtdt(arrives_primary),                     end_time=mtdt(leaves_primary),                 )             )              # Update parameters             leave_time = leaves_primary             location_prev = location_next             location_prev_loc = location_next_loc          # Inbound leg         arrives_home = leave_time + np.random.randint(10, 90)  # minutes         agent.add(             Leg(                 seq=no_of_activities + 1,                 mode=np.random.choice(transport),                 start_area=location_next,                 start_loc=location_next_loc,                 end_area=location1,                 end_loc=location1_loc,                 start_time=mtdt(leave_time),                 end_time=mtdt(arrives_home),             )         )          # Activity         agent.add(             Activity(                 seq=no_of_activities + 2,                 act=\"home\",                 area=location1,                 loc=location1_loc,                 start_time=mtdt(arrives_home),                 end_time=END_OF_DAY,             )         )      return population In\u00a0[15]: Copied! <pre># Create 100 agents and check the population statistics\npopulation = generate_agents(20)\nprint(population.stats)\n</pre> # Create 100 agents and check the population statistics population = generate_agents(20) print(population.stats) <pre>Using random sample for zone:Lambeth 008B:work\nUsing random sample for zone:Hammersmith and Fulham 022C:pub\nUsing random sample for zone:Lambeth 013B:shop\nUsing random sample for zone:Wandsworth 017A:gym\nUsing random sample for zone:Wandsworth 015E:pub\nUsing random sample for zone:Wandsworth 003A:leisure\nUsing random sample for zone:Wandsworth 002C:medical\nUsing random sample for zone:Hammersmith and Fulham 013C:work\nUsing random sample for zone:Lambeth 004D:education\nUsing random sample for zone:Wandsworth 018B:gym\nUsing random sample for zone:Hammersmith and Fulham 020E:gym\nUsing random sample for zone:Kensington and Chelsea 015B:gym\nUsing random sample for zone:Wandsworth 015D:pub\nUsing random sample for zone:Kensington and Chelsea 008C:medical\nUsing random sample for zone:Wandsworth 007D:pub\nUsing random sample for zone:Wandsworth 001D:gym\nUsing random sample for zone:Kensington and Chelsea 017E:medical\nUsing random sample for zone:Kensington and Chelsea 017B:shop\nUsing random sample for zone:Wandsworth 001C:park\nUsing random sample for zone:Lambeth 017A:education\nUsing random sample for zone:Hammersmith and Fulham 017C:shop\nUsing random sample for zone:Wandsworth 009D:leisure\nUsing random sample for zone:Westminster 024C:pub\nUsing random sample for zone:Kensington and Chelsea 015B:pub\nUsing random sample for zone:Wandsworth 006A:gym\nUsing random sample for zone:Kensington and Chelsea 021A:gym\nUsing random sample for zone:Lambeth 013B:work\nUsing random sample for zone:Lambeth 012D:medical\nUsing random sample for zone:Kensington and Chelsea 014E:pub\nUsing random sample for zone:Lambeth 007A:work\nUsing random sample for zone:Hammersmith and Fulham 016D:park\nUsing random sample for zone:Hammersmith and Fulham 020B:gym\nUsing random sample for zone:Kensington and Chelsea 009B:shop\nUsing random sample for zone:Hammersmith and Fulham 023B:pub\nUsing random sample for zone:Wandsworth 007B:shop\nUsing random sample for zone:Kensington and Chelsea 015C:pub\nUsing random sample for zone:Westminster 021A:gym\nUsing random sample for zone:Hammersmith and Fulham 020C:park\nUsing random sample for zone:Wandsworth 006C:shop\nUsing random sample for zone:Kensington and Chelsea 012E:shop\nUsing random sample for zone:Kensington and Chelsea 015B:shop\nUsing random sample for zone:Westminster 023A:gym\nUsing random sample for zone:Kensington and Chelsea 013A:leisure\nUsing random sample for zone:Wandsworth 019C:park\nUsing random sample for zone:Hammersmith and Fulham 016D:pub\n</pre> <pre>{'num_households': 20, 'num_people': 20, 'num_activities': 92, 'num_legs': 72}\n</pre> In\u00a0[16]: Copied! <pre>population.random_person().print()\n</pre> population.random_person().print() <pre>Person: agent_14\n{'subpopulation': 'high income', 'gender': 'male', 'age': '5 to 10', 'household_zone': 'Westminster 023A', 'household_LSOA': 'E02000982', 'household_LAD': 'Westminster'}\n0:\tActivity(act:home, location:POINT (528674.754749049 178085.52007832748), time:00:00:00 --&gt; 08:24:00, duration:8:24:00)\n1:\tLeg(mode:car, area:POINT (528674.754749049 178085.52007832748) --&gt; POINT (524366.7278900618 179488.58531248264), time:08:24:00 --&gt; 09:46:00, duration:1:22:00)\n2:\tActivity(act:shop, location:POINT (524366.7278900618 179488.58531248264), time:09:46:00 --&gt; 11:46:00, duration:2:00:00)\n3:\tLeg(mode:bike, area:POINT (524366.7278900618 179488.58531248264) --&gt; POINT (527123.1724066776 177645.15136836463), time:11:46:00 --&gt; 13:01:00, duration:1:15:00)\n4:\tActivity(act:leisure, location:POINT (527123.1724066776 177645.15136836463), time:13:01:00 --&gt; 15:01:00, duration:2:00:00)\n5:\tLeg(mode:bus, area:POINT (527123.1724066776 177645.15136836463) --&gt; POINT (526077.4308400992 175824.41748798476), time:15:01:00 --&gt; 16:04:00, duration:1:03:00)\n6:\tActivity(act:pub, location:POINT (526077.4308400992 175824.41748798476), time:16:04:00 --&gt; 18:04:00, duration:2:00:00)\n7:\tLeg(mode:rail, area:POINT (526077.4308400992 175824.41748798476) --&gt; POINT (526679.9410896822 175589.59066244372), time:18:04:00 --&gt; 19:31:00, duration:1:27:00)\n8:\tActivity(act:shop, location:POINT (526679.9410896822 175589.59066244372), time:19:31:00 --&gt; 21:31:00, duration:2:00:00)\n9:\tLeg(mode:car, area:POINT (526679.9410896822 175589.59066244372) --&gt; POINT (528674.754749049 178085.52007832748), time:21:31:00 --&gt; 22:33:00, duration:1:02:00)\n10:\tActivity(act:home, location:POINT (528674.754749049 178085.52007832748), time:22:33:00 --&gt; 00:00:00, duration:1:27:00)\n</pre> In\u00a0[17]: Copied! <pre>population.random_person().attributes\n</pre> population.random_person().attributes Out[17]: <pre>{'subpopulation': 'high income',\n 'gender': 'male',\n 'age': '50 to 59',\n 'household_zone': 'Hammersmith and Fulham 010D',\n 'household_LSOA': 'E02000381',\n 'household_LAD': 'Hammersmith and Fulham'}</pre> In\u00a0[18]: Copied! <pre># Validation if it works\npopulation.validate()\n</pre> # Validation if it works population.validate() In\u00a0[19]: Copied! <pre># Print random person activity plan\npopulation.random_person().print()\n</pre> # Print random person activity plan population.random_person().print() <pre>Person: agent_7\n{'subpopulation': 'high income', 'gender': 'female', 'age': '65 to 69', 'household_zone': 'Lambeth 015C', 'household_LSOA': 'E02000632', 'household_LAD': 'Lambeth'}\n0:\tActivity(act:home, location:POINT (530210.4950919976 175462.92665453235), time:00:00:00 --&gt; 06:59:00, duration:6:59:00)\n1:\tLeg(mode:ferry, area:POINT (530210.4950919976 175462.92665453235) --&gt; POINT (531028.1389694853 177371.31543672664), time:06:59:00 --&gt; 08:19:00, duration:1:20:00)\n2:\tActivity(act:shop, location:POINT (531028.1389694853 177371.31543672664), time:08:19:00 --&gt; 09:19:00, duration:1:00:00)\n3:\tLeg(mode:rail, area:POINT (531028.1389694853 177371.31543672664) --&gt; POINT (530210.4950919976 175462.92665453235), time:09:19:00 --&gt; 10:07:00, duration:0:48:00)\n4:\tActivity(act:home, location:POINT (530210.4950919976 175462.92665453235), time:10:07:00 --&gt; 00:00:00, duration:13:53:00)\n</pre> <p>Plot the activities as a 24-hour diary schedules for 5 randomly chosen agents</p> In\u00a0[20]: Copied! <pre>for _i in range(5):\n    p = population.random_person()\n    p.plot()\n</pre> for _i in range(5):     p = population.random_person()     p.plot() <p>Plot the frequency with which each of the activity types happens throughout the 24-hour period.</p> In\u00a0[21]: Copied! <pre>fig = plot_activity_times(population)\n</pre> fig = plot_activity_times(population) In\u00a0[22]: Copied! <pre># Check the duration of trips\ndurations = duration_counts(population)\ndurations\n</pre> # Check the duration of trips durations = duration_counts(population) durations <pre>/Users/bryn.pickering/Repos/arup-group/pam/pam/report/benchmarks.py:128: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n  df = df.groupby(dimensions)[data_fields].agg(aggfunc).fillna(0)\n/Users/bryn.pickering/Repos/arup-group/pam/pam/report/benchmarks.py:128: FutureWarning: The provided callable &lt;built-in function sum&gt; is currently using SeriesGroupBy.sum. In a future version of pandas, the provided callable will be used directly. To keep current behavior pass 'sum' instead.\n  df = df.groupby(dimensions)[data_fields].agg(aggfunc).fillna(0)\n</pre> Out[22]: duration trips 0 0 to 5 min 0 1 5 to 10 min 0 2 10 to 15 min 3 3 15 to 30 min 5 4 30 to 45 min 11 5 45 to 60 min 10 6 60 to 90 min 43 7 90 to 120 min 0 8 120+ min 0 <p>Now plot a histogram for duration of the trips.</p> In\u00a0[23]: Copied! <pre>plt.barh(durations[\"duration\"], durations[\"trips\"])\nplt.xlabel(\"Counts\")\nplt.ylabel(\"Duration for trips\")\nplt.title(\"Duration for different trips\")\nplt.ylim(ymax=\"90 to 120 min\")\n</pre> plt.barh(durations[\"duration\"], durations[\"trips\"]) plt.xlabel(\"Counts\") plt.ylabel(\"Duration for trips\") plt.title(\"Duration for different trips\") plt.ylim(ymax=\"90 to 120 min\") Out[23]: <pre>(-0.8400000000000001, 7.0)</pre> In\u00a0[24]: Copied! <pre># Check the distance of trips\ndistances = distance_counts(population)\ndistances\n</pre> # Check the distance of trips distances = distance_counts(population) distances <pre>/Users/bryn.pickering/Repos/arup-group/pam/pam/report/benchmarks.py:128: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n  df = df.groupby(dimensions)[data_fields].agg(aggfunc).fillna(0)\n/Users/bryn.pickering/Repos/arup-group/pam/pam/report/benchmarks.py:128: FutureWarning: The provided callable &lt;built-in function sum&gt; is currently using SeriesGroupBy.sum. In a future version of pandas, the provided callable will be used directly. To keep current behavior pass 'sum' instead.\n  df = df.groupby(dimensions)[data_fields].agg(aggfunc).fillna(0)\n</pre> Out[24]: distance trips 0 0 to 1 km 3 1 1 to 5 km 59 2 5 to 10 km 10 3 10 to 25 km 0 4 25 to 50 km 0 5 50 to 100 km 0 6 100 to 200 km 0 7 200+ km 0 <p>Next we plot the distribution of trip distances.</p> In\u00a0[25]: Copied! <pre>plt.barh(distances[\"distance\"], distances[\"trips\"])\nplt.xlabel(\"Counts\")\nplt.ylabel(\"distance, km\")\nplt.title(\"distance for different trips\")\nplt.ylim(ymax=\"25 to 50 km\")\n</pre> plt.barh(distances[\"distance\"], distances[\"trips\"]) plt.xlabel(\"Counts\") plt.ylabel(\"distance, km\") plt.title(\"distance for different trips\") plt.ylim(ymax=\"25 to 50 km\") Out[25]: <pre>(-0.79, 4.0)</pre> In\u00a0[26]: Copied! <pre>to_csv(population, dir=\"outputs\", crs=\"epsg:27700\")\n</pre> to_csv(population, dir=\"outputs\", crs=\"epsg:27700\") <p>Plot the distribution of activities by type</p> In\u00a0[27]: Copied! <pre>df_activity = pd.read_csv(os.path.join(\"outputs\", \"activities.csv\"))\ntotals = df_activity.activity.value_counts()\nplt.barh(totals.index, totals)\nplt.title(\"activities count\")\n</pre> df_activity = pd.read_csv(os.path.join(\"outputs\", \"activities.csv\")) totals = df_activity.activity.value_counts() plt.barh(totals.index, totals) plt.title(\"activities count\") Out[27]: <pre>Text(0.5, 1.0, 'activities count')</pre> In\u00a0[28]: Copied! <pre>write_od_matrices(population, path=\"outputs\")\nod_matrices = pd.read_csv(\n    os.path.join(\"outputs\", \"total_od.csv\")\n)  # we should change this method to be consistent with other - ie return a dataframe\nod_matrices[\"total origins\"] = od_matrices.drop(\"Origin\", axis=1).sum(axis=1)\nod_matrices\n</pre> write_od_matrices(population, path=\"outputs\") od_matrices = pd.read_csv(     os.path.join(\"outputs\", \"total_od.csv\") )  # we should change this method to be consistent with other - ie return a dataframe od_matrices[\"total origins\"] = od_matrices.drop(\"Origin\", axis=1).sum(axis=1) od_matrices Out[28]: Origin Hammersmith and Fulham 010D Hammersmith and Fulham 013C Hammersmith and Fulham 015A Hammersmith and Fulham 016A Hammersmith and Fulham 016D Hammersmith and Fulham 017C Hammersmith and Fulham 020B Hammersmith and Fulham 020C Hammersmith and Fulham 020E ... Wandsworth 017A Wandsworth 018B Wandsworth 018D Wandsworth 019C Westminster 019A Westminster 020D Westminster 021A Westminster 023A Westminster 024C total origins 0 Hammersmith and Fulham 010D 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 1 Hammersmith and Fulham 013C 0 0 0 0 0 0 0 0 0 ... 0 0 1 0 0 0 0 0 0 1 2 Hammersmith and Fulham 015A 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 1 1 3 Hammersmith and Fulham 016A 0 0 0 0 0 0 0 1 0 ... 0 0 0 0 0 0 0 0 0 1 4 Hammersmith and Fulham 016D 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 1 0 0 0 2 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 59 Westminster 019A 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 60 Westminster 020D 0 0 0 0 0 0 1 0 0 ... 0 0 0 0 0 0 0 0 0 1 61 Westminster 021A 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 2 62 Westminster 023A 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 2 63 Westminster 024C 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 <p>64 rows \u00d7 66 columns</p> <p>Plot the number of trips originating from each LSOA</p> In\u00a0[29]: Copied! <pre>lsoas_clipped = lsoas_clipped.reset_index()\norigins_heat_map = lsoas_clipped.join(od_matrices[\"total origins\"])\n\nfig, ax = plt.subplots(figsize=(18, 10))\norigins_heat_map.plot(\"total origins\", legend=True, ax=ax)\nax.set_title(\"Total Origins\")\n</pre> lsoas_clipped = lsoas_clipped.reset_index() origins_heat_map = lsoas_clipped.join(od_matrices[\"total origins\"])  fig, ax = plt.subplots(figsize=(18, 10)) origins_heat_map.plot(\"total origins\", legend=True, ax=ax) ax.set_title(\"Total Origins\") <pre>/Users/bryn.pickering/mambaforge/envs/pam/lib/python3.11/site-packages/geopandas/plotting.py:732: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead\n  if pd.api.types.is_categorical_dtype(values.dtype):\n</pre> Out[29]: <pre>Text(0.5, 1.0, 'Total Origins')</pre> In\u00a0[30]: Copied! <pre>people = pd.read_csv(os.path.join(\"outputs\", \"people.csv\")).set_index(\"pid\")\nhhs = pd.read_csv(os.path.join(\"outputs\", \"households.csv\")).set_index(\"hid\")\ntrips = pd.read_csv(os.path.join(\"outputs\", \"legs.csv\")).drop([\"Unnamed: 0\"], axis=1)\n\ntrips = trips.rename(columns={\"origin activity\": \"oact\", \"destination activity\": \"dact\"})\ntrips.head()\n</pre> people = pd.read_csv(os.path.join(\"outputs\", \"people.csv\")).set_index(\"pid\") hhs = pd.read_csv(os.path.join(\"outputs\", \"households.csv\")).set_index(\"hid\") trips = pd.read_csv(os.path.join(\"outputs\", \"legs.csv\")).drop([\"Unnamed: 0\"], axis=1)  trips = trips.rename(columns={\"origin activity\": \"oact\", \"destination activity\": \"dact\"}) trips.head() Out[30]: pid hid freq ozone dzone purp oact dact mode seq tst tet duration 0 agent_0 hh_0 NaN Lambeth 010B Lambeth 008B NaN home work subway 1 1900-01-01 07:45:00 1900-01-01 09:01:00 1:16:00 1 agent_0 hh_0 NaN Lambeth 008B Hammersmith and Fulham 022C NaN work pub bus 2 1900-01-01 13:01:00 1900-01-01 14:27:00 1:26:00 2 agent_0 hh_0 NaN Hammersmith and Fulham 022C Lambeth 013B NaN pub shop car 3 1900-01-01 15:27:00 1900-01-01 16:37:00 1:10:00 3 agent_0 hh_0 NaN Lambeth 013B Wandsworth 017A NaN shop gym car 4 1900-01-01 17:37:00 1900-01-01 18:38:00 1:01:00 4 agent_0 hh_0 NaN Wandsworth 017A Lambeth 010B NaN gym home walk 5 1900-01-01 19:38:00 1900-01-01 20:47:00 1:09:00 In\u00a0[31]: Copied! <pre>population_reloaded = load_travel_diary(trips=trips, persons_attributes=people, hhs_attributes=hhs)\n</pre> population_reloaded = load_travel_diary(trips=trips, persons_attributes=people, hhs_attributes=hhs) <pre>Using from-to activity parser using 'oact' and 'dact' columns\n</pre> <p>Plot the activities as a 24-hour diary schedules</p> In\u00a0[32]: Copied! <pre>population[\"hh_0\"][\"agent_0\"].plot()\n</pre> population[\"hh_0\"][\"agent_0\"].plot() In\u00a0[33]: Copied! <pre>population_reloaded[\"hh_0\"][\"agent_0\"].plot()\n</pre> population_reloaded[\"hh_0\"][\"agent_0\"].plot() In\u00a0[34]: Copied! <pre>population == population_reloaded\n</pre> population == population_reloaded Out[34]: <pre>False</pre> <p>The populations are not the same because the csv files did not preserve the coordinates that we previously sampled, so we will sample them again. But the reloaded population will be different as for each location a new coordinate is sampled.</p> In\u00a0[35]: Copied! <pre>write_matsim(population=population, plans_path=os.path.join(\"outputs\", \"population.xml\"))\n</pre> write_matsim(population=population, plans_path=os.path.join(\"outputs\", \"population.xml\"))"},{"location":"examples/08_toy_matsim_population/#demo-matsim-population-for-west-london","title":"Demo - MATSim Population for West London\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#aim","title":"Aim\u00b6","text":"<p>Create a bigger and more realistic sample population automatically for the West London area called Londinium. The sample population includes various activities, personal attributes and modes; the population would be used as input for MATSim transport simulation.</p>"},{"location":"examples/08_toy_matsim_population/#import-geographic-data-of-londinium","title":"Import geographic data of Londinium\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#facility-sampler","title":"Facility sampler\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#activity-generation-model","title":"Activity generation model\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#data-visulazation-and-validation","title":"Data Visulazation and validation\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#readwrite-data","title":"Read/write data\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#export-intermediate-csv-tables-of-population","title":"Export intermediate CSV tables of population\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#reload-tabular-data","title":"Reload Tabular Data\u00b6","text":"<p>We load in the csv files we previously wrote to disk. This replicates a simple synthesis process we might typically use for travel diary survey data.</p>"},{"location":"examples/08_toy_matsim_population/#write-output-to-matsim-xml","title":"Write output to MATSim xml\u00b6","text":""},{"location":"examples/09_advanced_policies/","title":"Modifying the population using complex policies","text":"In\u00a0[1]: Copied! <pre>from pam.activity import Activity, Leg\nfrom pam.core import Household, Person, Population\nfrom pam.policy import (\n    ActivityPolicy,\n    ActivityProbability,\n    HouseholdPolicy,\n    MoveActivityTourToHomeLocation,\n    PersonAttributeFilter,\n    PersonPolicy,\n    PersonProbability,\n    ReduceSharedActivity,\n    RemoveActivity,\n    apply_policies,\n)\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n</pre> from pam.activity import Activity, Leg from pam.core import Household, Person, Population from pam.policy import (     ActivityPolicy,     ActivityProbability,     HouseholdPolicy,     MoveActivityTourToHomeLocation,     PersonAttributeFilter,     PersonPolicy,     PersonProbability,     ReduceSharedActivity,     RemoveActivity,     apply_policies, ) from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY In\u00a0[2]: Copied! <pre>def print_simple_stats(population):\n    \"\"\"Print some simple population statistics.\"\"\"\n    time_at_home = 0\n    travel_time = 0\n    low_income_central_trips = 0\n    high_income_central_trips = 0\n\n    for _hid, hh in population.households.items():\n        for _pid, person in hh.people.items():\n            freq = person.freq\n\n            for p in person.plan:\n                if p.act == \"travel\":\n                    duration = p.duration.seconds * freq / 3600\n                    travel_time += duration\n\n                    if p.end_location.area == \"Westminster,City of London\":\n                        if person.attributes[\"inc\"] == \"low\":\n                            low_income_central_trips += freq\n\n                        elif person.attributes[\"inc\"] == \"high\":\n                            high_income_central_trips += freq\n\n                else:  # activity\n                    if p.act == \"home\":\n                        duration = p.duration.seconds * freq / 3600\n                        time_at_home += duration\n\n    print(f\"Population total time at home: {time_at_home:.2f} hours\")\n    print(f\"Population total travel time: {travel_time:.2f} hours\")\n</pre> def print_simple_stats(population):     \"\"\"Print some simple population statistics.\"\"\"     time_at_home = 0     travel_time = 0     low_income_central_trips = 0     high_income_central_trips = 0      for _hid, hh in population.households.items():         for _pid, person in hh.people.items():             freq = person.freq              for p in person.plan:                 if p.act == \"travel\":                     duration = p.duration.seconds * freq / 3600                     travel_time += duration                      if p.end_location.area == \"Westminster,City of London\":                         if person.attributes[\"inc\"] == \"low\":                             low_income_central_trips += freq                          elif person.attributes[\"inc\"] == \"high\":                             high_income_central_trips += freq                  else:  # activity                     if p.act == \"home\":                         duration = p.duration.seconds * freq / 3600                         time_at_home += duration      print(f\"Population total time at home: {time_at_home:.2f} hours\")     print(f\"Population total travel time: {travel_time:.2f} hours\") In\u00a0[3]: Copied! <pre>population = Population()\n</pre> population = Population() In\u00a0[4]: Copied! <pre>smith_id = \"Smith\"\n\nBilly = Person(\n    \"Billy\",\n    freq=1,\n    attributes={\"age\": 26, \"job\": \"employed\", \"gender\": \"female\", \"key_worker\": False},\n)\n\nBilly.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\nBilly.add(\n    Leg(1, \"car\", start_area=\"a\", end_area=\"g\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20))\n)\nBilly.add(Activity(2, \"work\", \"g\", start_time=mtdt(8 * 60 + 20), end_time=mtdt(17 * 60)))\nBilly.add(\n    Leg(\n        2,\n        \"car\",\n        start_area=\"g\",\n        end_area=\"a\",\n        start_time=mtdt(17 * 60),\n        end_time=mtdt(17 * 60 + 25),\n    )\n)\nBilly.add(Activity(3, \"home\", \"a\", start_time=mtdt(17 * 60 + 25), end_time=END_OF_DAY))\n\n\nBobby = Person(\n    \"Bobby\",\n    freq=1,\n    attributes={\"age\": 6, \"job\": \"education\", \"gender\": \"male\", \"key_worker\": False},\n)\nBobby.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\nBobby.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30)))\nBobby.add(Activity(2, \"education\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60)))\nBobby.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 35)))\nBobby.add(Activity(3, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(18 * 60)))\nBobby.add(Leg(3, \"car\", \"a\", \"b\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))\nBobby.add(Activity(4, \"shop_1\", \"b\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50)))\nBobby.add(Leg(4, \"car\", \"b\", \"b\", start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60)))\nBobby.add(Activity(5, \"shop_2\", \"b\", start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50)))\nBobby.add(Leg(5, \"car\", \"b\", \"a\", start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10)))\nBobby.add(Activity(6, \"home\", \"a\", start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))\n\nBradly = Person(\n    \"Bradly\",\n    freq=1,\n    attributes={\"age\": 40, \"job\": \"employed\", \"gender\": \"male\", \"key_worker\": True},\n)\nBradly.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\n\nBradly.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20)))\nBradly.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 20), end_time=mtdt(8 * 60 + 30)))\nBradly.add(Leg(2, \"pt\", \"b\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(9 * 60)))\n\nBradly.add(Activity(4, \"work\", \"b\", start_time=mtdt(9 * 60), end_time=mtdt(10 * 60)))\nBradly.add(Leg(3, \"pt\", \"b\", \"c\", start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 20)))\nBradly.add(Activity(4, \"work\", \"b\", start_time=mtdt(10 * 60 + 20), end_time=mtdt(12 * 60)))\nBradly.add(Leg(4, \"pt\", \"b\", \"c\", start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 20)))\nBradly.add(Activity(5, \"work\", \"b\", start_time=mtdt(12 * 60 + 20), end_time=mtdt(14 * 60)))\nBradly.add(Leg(5, \"pt\", \"b\", \"c\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))\n\nBradly.add(Activity(6, \"leisure\", \"c\", start_time=mtdt(14 * 60 + 20), end_time=mtdt(15 * 60 + 30)))\nBradly.add(Leg(4, \"pt\", \"c\", \"b\", start_time=mtdt(15 * 60 + 30), end_time=mtdt(16 * 60 - 10)))\nBradly.add(Activity(5, \"escort\", \"b\", start_time=mtdt(16 * 60 - 10), end_time=mtdt(16 * 60)))\nBradly.add(Leg(5, \"walk\", \"b\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20)))\n\nBradly.add(Activity(8, \"home\", \"a\", start_time=mtdt(16 * 60 + 20), end_time=mtdt(18 * 60)))\nBradly.add(Leg(8, \"car\", \"a\", \"b\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))\nBradly.add(Activity(9, \"shop_1\", \"b\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50)))\nBradly.add(Leg(9, \"car\", \"b\", \"b\", start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60)))\nBradly.add(Activity(10, \"shop_2\", \"b\", start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50)))\nBradly.add(Leg(10, \"car\", \"b\", \"a\", start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10)))\nBradly.add(Activity(11, \"home\", \"a\", start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))\n\nsmiths = Household(smith_id)\nfor person in [Billy, Bradly, Bobby]:\n    smiths.add(person)\n\nsmiths.people\n</pre> smith_id = \"Smith\"  Billy = Person(     \"Billy\",     freq=1,     attributes={\"age\": 26, \"job\": \"employed\", \"gender\": \"female\", \"key_worker\": False}, )  Billy.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60))) Billy.add(     Leg(1, \"car\", start_area=\"a\", end_area=\"g\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20)) ) Billy.add(Activity(2, \"work\", \"g\", start_time=mtdt(8 * 60 + 20), end_time=mtdt(17 * 60))) Billy.add(     Leg(         2,         \"car\",         start_area=\"g\",         end_area=\"a\",         start_time=mtdt(17 * 60),         end_time=mtdt(17 * 60 + 25),     ) ) Billy.add(Activity(3, \"home\", \"a\", start_time=mtdt(17 * 60 + 25), end_time=END_OF_DAY))   Bobby = Person(     \"Bobby\",     freq=1,     attributes={\"age\": 6, \"job\": \"education\", \"gender\": \"male\", \"key_worker\": False}, ) Bobby.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60))) Bobby.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30))) Bobby.add(Activity(2, \"education\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60))) Bobby.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 35))) Bobby.add(Activity(3, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(18 * 60))) Bobby.add(Leg(3, \"car\", \"a\", \"b\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20))) Bobby.add(Activity(4, \"shop_1\", \"b\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50))) Bobby.add(Leg(4, \"car\", \"b\", \"b\", start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60))) Bobby.add(Activity(5, \"shop_2\", \"b\", start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50))) Bobby.add(Leg(5, \"car\", \"b\", \"a\", start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10))) Bobby.add(Activity(6, \"home\", \"a\", start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))  Bradly = Person(     \"Bradly\",     freq=1,     attributes={\"age\": 40, \"job\": \"employed\", \"gender\": \"male\", \"key_worker\": True}, ) Bradly.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))  Bradly.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20))) Bradly.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 20), end_time=mtdt(8 * 60 + 30))) Bradly.add(Leg(2, \"pt\", \"b\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(9 * 60)))  Bradly.add(Activity(4, \"work\", \"b\", start_time=mtdt(9 * 60), end_time=mtdt(10 * 60))) Bradly.add(Leg(3, \"pt\", \"b\", \"c\", start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 20))) Bradly.add(Activity(4, \"work\", \"b\", start_time=mtdt(10 * 60 + 20), end_time=mtdt(12 * 60))) Bradly.add(Leg(4, \"pt\", \"b\", \"c\", start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 20))) Bradly.add(Activity(5, \"work\", \"b\", start_time=mtdt(12 * 60 + 20), end_time=mtdt(14 * 60))) Bradly.add(Leg(5, \"pt\", \"b\", \"c\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))  Bradly.add(Activity(6, \"leisure\", \"c\", start_time=mtdt(14 * 60 + 20), end_time=mtdt(15 * 60 + 30))) Bradly.add(Leg(4, \"pt\", \"c\", \"b\", start_time=mtdt(15 * 60 + 30), end_time=mtdt(16 * 60 - 10))) Bradly.add(Activity(5, \"escort\", \"b\", start_time=mtdt(16 * 60 - 10), end_time=mtdt(16 * 60))) Bradly.add(Leg(5, \"walk\", \"b\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20)))  Bradly.add(Activity(8, \"home\", \"a\", start_time=mtdt(16 * 60 + 20), end_time=mtdt(18 * 60))) Bradly.add(Leg(8, \"car\", \"a\", \"b\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20))) Bradly.add(Activity(9, \"shop_1\", \"b\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50))) Bradly.add(Leg(9, \"car\", \"b\", \"b\", start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60))) Bradly.add(Activity(10, \"shop_2\", \"b\", start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50))) Bradly.add(Leg(10, \"car\", \"b\", \"a\", start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10))) Bradly.add(Activity(11, \"home\", \"a\", start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))  smiths = Household(smith_id) for person in [Billy, Bradly, Bobby]:     smiths.add(person)  smiths.people Out[4]: <pre>{'Billy': &lt;pam.core.Person at 0x1683f3890&gt;,\n 'Bradly': &lt;pam.core.Person at 0x1683fce50&gt;,\n 'Bobby': &lt;pam.core.Person at 0x1683fc110&gt;}</pre> In\u00a0[5]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[6]: Copied! <pre>population.add(smiths)\n</pre> population.add(smiths) In\u00a0[7]: Copied! <pre>jones_id = \"Jones\"\n\nHugh = Person(\n    \"Hugh\",\n    freq=1,\n    attributes={\"age\": 100, \"job\": \"unemployed\", \"gender\": \"male\", \"key_worker\": False},\n)\nHugh.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\nHugh.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))\nHugh.add(Activity(2, \"health\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(10 * 60)))\nHugh.add(Leg(2, \"walk\", \"b\", \"a\", start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 30)))\nHugh.add(Activity(3, \"home\", \"a\", start_time=mtdt(10 * 60 + 30), end_time=mtdt(14 * 60)))\nHugh.add(Leg(3, \"walk\", \"a\", \"b\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 30)))\nHugh.add(Activity(4, \"health\", \"b\", start_time=mtdt(14 * 60 + 30), end_time=mtdt(16 * 60)))\nHugh.add(Leg(4, \"walk\", \"b\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))\nHugh.add(Activity(5, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=END_OF_DAY))\n\nBridget = Person(\n    \"Bridget\",\n    freq=1,\n    attributes={\"age\": 35, \"job\": \"employed\", \"gender\": \"female\", \"key_worker\": False},\n)\nBridget.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\nBridget.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))\nBridget.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(10 * 60 + 30)))\nBridget.add(Leg(2, \"pt\", \"b\", \"c\", start_time=mtdt(10 * 60 + 30), end_time=mtdt(11 * 60)))\nBridget.add(Activity(3, \"work\", \"c\", start_time=mtdt(11 * 60), end_time=mtdt(16 * 60)))\nBridget.add(Leg(3, \"pt\", \"c\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20)))\nBridget.add(Activity(4, \"home\", \"a\", start_time=mtdt(16 * 60 + 20), end_time=mtdt(17 * 60 + 20)))\nBridget.add(Leg(4, \"pt\", \"c\", \"a\", start_time=mtdt(17 * 60 + 20), end_time=mtdt(17 * 60 + 50)))\nBridget.add(Activity(5, \"shop\", \"a\", start_time=mtdt(17 * 60 + 50), end_time=mtdt(18 * 60 + 30)))\nBridget.add(Leg(5, \"pt\", \"c\", \"a\", start_time=mtdt(18 * 60 + 30), end_time=mtdt(18 * 60 + 50)))\nBridget.add(Activity(6, \"home\", \"a\", start_time=mtdt(18 * 60 + 50), end_time=END_OF_DAY))\n\njones = Household(jones_id)\nfor person in [Hugh, Bridget]:\n    jones.add(person)\n\njones.people\n</pre> jones_id = \"Jones\"  Hugh = Person(     \"Hugh\",     freq=1,     attributes={\"age\": 100, \"job\": \"unemployed\", \"gender\": \"male\", \"key_worker\": False}, ) Hugh.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60))) Hugh.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30))) Hugh.add(Activity(2, \"health\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(10 * 60))) Hugh.add(Leg(2, \"walk\", \"b\", \"a\", start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 30))) Hugh.add(Activity(3, \"home\", \"a\", start_time=mtdt(10 * 60 + 30), end_time=mtdt(14 * 60))) Hugh.add(Leg(3, \"walk\", \"a\", \"b\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 30))) Hugh.add(Activity(4, \"health\", \"b\", start_time=mtdt(14 * 60 + 30), end_time=mtdt(16 * 60))) Hugh.add(Leg(4, \"walk\", \"b\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30))) Hugh.add(Activity(5, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=END_OF_DAY))  Bridget = Person(     \"Bridget\",     freq=1,     attributes={\"age\": 35, \"job\": \"employed\", \"gender\": \"female\", \"key_worker\": False}, ) Bridget.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60))) Bridget.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5))) Bridget.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(10 * 60 + 30))) Bridget.add(Leg(2, \"pt\", \"b\", \"c\", start_time=mtdt(10 * 60 + 30), end_time=mtdt(11 * 60))) Bridget.add(Activity(3, \"work\", \"c\", start_time=mtdt(11 * 60), end_time=mtdt(16 * 60))) Bridget.add(Leg(3, \"pt\", \"c\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20))) Bridget.add(Activity(4, \"home\", \"a\", start_time=mtdt(16 * 60 + 20), end_time=mtdt(17 * 60 + 20))) Bridget.add(Leg(4, \"pt\", \"c\", \"a\", start_time=mtdt(17 * 60 + 20), end_time=mtdt(17 * 60 + 50))) Bridget.add(Activity(5, \"shop\", \"a\", start_time=mtdt(17 * 60 + 50), end_time=mtdt(18 * 60 + 30))) Bridget.add(Leg(5, \"pt\", \"c\", \"a\", start_time=mtdt(18 * 60 + 30), end_time=mtdt(18 * 60 + 50))) Bridget.add(Activity(6, \"home\", \"a\", start_time=mtdt(18 * 60 + 50), end_time=END_OF_DAY))  jones = Household(jones_id) for person in [Hugh, Bridget]:     jones.add(person)  jones.people Out[7]: <pre>{'Hugh': &lt;pam.core.Person at 0x1686bc210&gt;,\n 'Bridget': &lt;pam.core.Person at 0x1686bca50&gt;}</pre> In\u00a0[8]: Copied! <pre>jones.plot()\n</pre> jones.plot() In\u00a0[9]: Copied! <pre>population.add(jones)\n</pre> population.add(jones) In\u00a0[10]: Copied! <pre>print_simple_stats(population)\n</pre> print_simple_stats(population) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[11]: Copied! <pre>def discrete_joint_distribution_sampler(obj, mapping, distribution):\n    \"\"\"\n    Randomly sample from a joint distribution based some discrete features.\n    Where features are a dictionary structure of features, eg: {'gender':'female'}\n    Distribution is a nested dict of probabilities based on possible features, eg:\n    {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': 1}}\n    Mapping provides the feature name for each level of the distribution, eg:\n    ['age', 'gender'].\n    \"\"\"\n    p = distribution\n    for key in mapping:\n        value = obj.attributes.get(key)\n        if value is None:\n            msg = f\"Cannot find mapping: {key} in sampling features: {obj.attributes}\"\n            raise KeyError(msg)\n        p = p.get(value)\n        if p is None:\n            msg = f\"Cannot find feature for {key}: {value} in distribution: {p}\"\n            raise KeyError(msg)\n\n    return p\n</pre> def discrete_joint_distribution_sampler(obj, mapping, distribution):     \"\"\"     Randomly sample from a joint distribution based some discrete features.     Where features are a dictionary structure of features, eg: {'gender':'female'}     Distribution is a nested dict of probabilities based on possible features, eg:     {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': 1}}     Mapping provides the feature name for each level of the distribution, eg:     ['age', 'gender'].     \"\"\"     p = distribution     for key in mapping:         value = obj.attributes.get(key)         if value is None:             msg = f\"Cannot find mapping: {key} in sampling features: {obj.attributes}\"             raise KeyError(msg)         p = p.get(value)         if p is None:             msg = f\"Cannot find feature for {key}: {value} in distribution: {p}\"             raise KeyError(msg)      return p In\u00a0[12]: Copied! <pre>vulnerable_mapping = [\"age\", \"gender\"]\nvulnerable_distribution = dict(\n    zip(\n        list(range(101)),\n        [{\"male\": i / 100, \"female\": i / 100, \"other\": i / 100} for i in range(101)],\n    )\n)\n</pre> vulnerable_mapping = [\"age\", \"gender\"] vulnerable_distribution = dict(     zip(         list(range(101)),         [{\"male\": i / 100, \"female\": i / 100, \"other\": i / 100} for i in range(101)],     ) ) In\u00a0[13]: Copied! <pre>dict(list(vulnerable_distribution.items())[0:15])\n</pre> dict(list(vulnerable_distribution.items())[0:15]) Out[13]: <pre>{0: {'male': 0.0, 'female': 0.0, 'other': 0.0},\n 1: {'male': 0.01, 'female': 0.01, 'other': 0.01},\n 2: {'male': 0.02, 'female': 0.02, 'other': 0.02},\n 3: {'male': 0.03, 'female': 0.03, 'other': 0.03},\n 4: {'male': 0.04, 'female': 0.04, 'other': 0.04},\n 5: {'male': 0.05, 'female': 0.05, 'other': 0.05},\n 6: {'male': 0.06, 'female': 0.06, 'other': 0.06},\n 7: {'male': 0.07, 'female': 0.07, 'other': 0.07},\n 8: {'male': 0.08, 'female': 0.08, 'other': 0.08},\n 9: {'male': 0.09, 'female': 0.09, 'other': 0.09},\n 10: {'male': 0.1, 'female': 0.1, 'other': 0.1},\n 11: {'male': 0.11, 'female': 0.11, 'other': 0.11},\n 12: {'male': 0.12, 'female': 0.12, 'other': 0.12},\n 13: {'male': 0.13, 'female': 0.13, 'other': 0.13},\n 14: {'male': 0.14, 'female': 0.14, 'other': 0.14}}</pre> In\u00a0[14]: Copied! <pre>discrete_joint_distribution_sampler(Bobby, vulnerable_mapping, vulnerable_distribution)\n</pre> discrete_joint_distribution_sampler(Bobby, vulnerable_mapping, vulnerable_distribution) Out[14]: <pre>0.06</pre> In\u00a0[15]: Copied! <pre>policy_quarantine = HouseholdPolicy(\n    RemoveActivity([\"work\", \"health\", \"leisure\", \"escort\", \"shop\", \"education\"]),\n    PersonProbability(0.0000000000001),\n)\n</pre> policy_quarantine = HouseholdPolicy(     RemoveActivity([\"work\", \"health\", \"leisure\", \"escort\", \"shop\", \"education\"]),     PersonProbability(0.0000000000001), ) In\u00a0[16]: Copied! <pre>q_pop = apply_policies(population, [policy_quarantine])\nprint_simple_stats(q_pop)\n</pre> q_pop = apply_policies(population, [policy_quarantine]) print_simple_stats(q_pop) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[17]: Copied! <pre>q_pop.households[\"Smith\"].plot()\n</pre> q_pop.households[\"Smith\"].plot() In\u00a0[18]: Copied! <pre>q_pop.households[\"Jones\"].plot()\n</pre> q_pop.households[\"Jones\"].plot() In\u00a0[19]: Copied! <pre>policy_quarantine = HouseholdPolicy(\n    RemoveActivity([\"work\", \"health\", \"escort\", \"leisure\", \"shop\", \"education\"]),\n    PersonProbability(\n        discrete_joint_distribution_sampler,\n        {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},\n    ),\n)\n</pre> policy_quarantine = HouseholdPolicy(     RemoveActivity([\"work\", \"health\", \"escort\", \"leisure\", \"shop\", \"education\"]),     PersonProbability(         discrete_joint_distribution_sampler,         {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},     ), ) In\u00a0[20]: Copied! <pre>q_pop = apply_policies(population, [policy_quarantine])\nprint_simple_stats(q_pop)\n</pre> q_pop = apply_policies(population, [policy_quarantine]) print_simple_stats(q_pop) <pre>Population total time at home: 43.67 hours\nPopulation total travel time: 1.67 hours\n</pre> In\u00a0[21]: Copied! <pre>q_pop.households[\"Jones\"].plot()\n</pre> q_pop.households[\"Jones\"].plot() In\u00a0[22]: Copied! <pre>policy_quarantine = HouseholdPolicy(\n    RemoveActivity([\"work\", \"health\", \"escort\", \"leisure\", \"shop\", \"education\"]),\n    [\n        PersonProbability(0.5),\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},\n        ),\n    ],\n)\n</pre> policy_quarantine = HouseholdPolicy(     RemoveActivity([\"work\", \"health\", \"escort\", \"leisure\", \"shop\", \"education\"]),     [         PersonProbability(0.5),         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},         ),     ], ) In\u00a0[23]: Copied! <pre>q_pop = apply_policies(population, [policy_quarantine])\nprint_simple_stats(q_pop)\n</pre> q_pop = apply_policies(population, [policy_quarantine]) print_simple_stats(q_pop) <pre>Population total time at home: 43.67 hours\nPopulation total travel time: 1.67 hours\n</pre> In\u00a0[24]: Copied! <pre>q_pop.households[\"Jones\"].plot()\n</pre> q_pop.households[\"Jones\"].plot() In\u00a0[25]: Copied! <pre>edu_mapping = [\"job\"]\nedu_distribution = {\"employed\": 0, \"unemployed\": 0, \"education\": 1}\n</pre> edu_mapping = [\"job\"] edu_distribution = {\"employed\": 0, \"unemployed\": 0, \"education\": 1} In\u00a0[26]: Copied! <pre>key_mapping = [\"key_worker\"]\nkey_distribution = {True: 0, False: 1}\n</pre> key_mapping = [\"key_worker\"] key_distribution = {True: 0, False: 1} In\u00a0[27]: Copied! <pre>edu_distribution, key_distribution\n</pre> edu_distribution, key_distribution Out[27]: <pre>({'employed': 0, 'unemployed': 0, 'education': 1}, {True: 0, False: 1})</pre> In\u00a0[28]: Copied! <pre>policy_remove_education_and_escort = HouseholdPolicy(\n    RemoveActivity([\"education\", \"escort\"]),\n    [\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": edu_mapping, \"distribution\": edu_distribution},\n        ),\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": key_mapping, \"distribution\": key_distribution},\n        ),\n    ],\n)\n</pre> policy_remove_education_and_escort = HouseholdPolicy(     RemoveActivity([\"education\", \"escort\"]),     [         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": edu_mapping, \"distribution\": edu_distribution},         ),         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": key_mapping, \"distribution\": key_distribution},         ),     ], ) In\u00a0[29]: Copied! <pre>edu_pop = apply_policies(population, [policy_remove_education_and_escort])\nprint_simple_stats(edu_pop)\n</pre> edu_pop = apply_policies(population, [policy_remove_education_and_escort]) print_simple_stats(edu_pop) <pre>Population total time at home: 84.25 hours\nPopulation total travel time: 7.83 hours\n</pre> In\u00a0[30]: Copied! <pre>edu_pop.households[\"Smith\"].people[\"Bradly\"].plan.print()\n</pre> edu_pop.households[\"Smith\"].people[\"Bradly\"].plan.print() <pre>0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:20:00, duration:0:20:00)\n2:\tActivity(act:work, location:b, time:08:20:00 --&gt; 09:20:00, duration:1:00:00)\n3:\tLeg(mode:pt, area:b --&gt; c, time:09:20:00 --&gt; 09:40:00, duration:0:20:00)\n4:\tActivity(act:work, location:b, time:09:40:00 --&gt; 11:20:00, duration:1:40:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:11:20:00 --&gt; 11:40:00, duration:0:20:00)\n6:\tActivity(act:work, location:b, time:11:40:00 --&gt; 13:20:00, duration:1:40:00)\n7:\tLeg(mode:pt, area:b --&gt; c, time:13:20:00 --&gt; 13:40:00, duration:0:20:00)\n8:\tActivity(act:leisure, location:c, time:13:40:00 --&gt; 14:50:00, duration:1:10:00)\n9:\tLeg(mode:pt, area:c --&gt; a, time:14:50:00 --&gt; 15:10:00, duration:0:20:00)\n10:\tActivity(act:home, location:a, time:15:10:00 --&gt; 16:50:00, duration:1:40:00)\n11:\tLeg(mode:car, area:a --&gt; b, time:16:50:00 --&gt; 17:10:00, duration:0:20:00)\n12:\tActivity(act:shop_1, location:b, time:17:10:00 --&gt; 17:40:00, duration:0:30:00)\n13:\tLeg(mode:car, area:b --&gt; b, time:17:40:00 --&gt; 17:50:00, duration:0:10:00)\n14:\tActivity(act:shop_2, location:b, time:17:50:00 --&gt; 18:40:00, duration:0:50:00)\n15:\tLeg(mode:car, area:b --&gt; a, time:18:40:00 --&gt; 19:00:00, duration:0:20:00)\n16:\tActivity(act:home, location:a, time:19:00:00 --&gt; 00:00:00, duration:5:00:00)\n</pre> In\u00a0[31]: Copied! <pre>q_pop.households[\"Smith\"].plot()\n</pre> q_pop.households[\"Smith\"].plot() In\u00a0[32]: Copied! <pre>edu_pop.households[\"Smith\"].plot()\n</pre> edu_pop.households[\"Smith\"].plot() In\u00a0[33]: Copied! <pre>edu_pop.households[\"Jones\"].plot()\n</pre> edu_pop.households[\"Jones\"].plot() In\u00a0[34]: Copied! <pre>edu_pop.households[\"Jones\"].people[\"Bridget\"].plan.print()\n</pre> edu_pop.households[\"Jones\"].people[\"Bridget\"].plan.print() <pre>0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:escort, location:b, time:08:05:00 --&gt; 10:30:00, duration:2:25:00)\n3:\tLeg(mode:pt, area:b --&gt; c, time:10:30:00 --&gt; 11:00:00, duration:0:30:00)\n4:\tActivity(act:work, location:c, time:11:00:00 --&gt; 16:00:00, duration:5:00:00)\n5:\tLeg(mode:pt, area:c --&gt; a, time:16:00:00 --&gt; 16:20:00, duration:0:20:00)\n6:\tActivity(act:home, location:a, time:16:20:00 --&gt; 17:20:00, duration:1:00:00)\n7:\tLeg(mode:pt, area:c --&gt; a, time:17:20:00 --&gt; 17:50:00, duration:0:30:00)\n8:\tActivity(act:shop, location:a, time:17:50:00 --&gt; 18:30:00, duration:0:40:00)\n9:\tLeg(mode:pt, area:c --&gt; a, time:18:30:00 --&gt; 18:50:00, duration:0:20:00)\n10:\tActivity(act:home, location:a, time:18:50:00 --&gt; 00:00:00, duration:5:10:00)\n</pre> In\u00a0[35]: Copied! <pre>def condition_job_education(val):\n    return val == \"education\"\n\n\npolicy_remove_education_and_escort = HouseholdPolicy(\n    RemoveActivity([\"education\", \"escort\"]),\n    PersonProbability(\n        discrete_joint_distribution_sampler,\n        {\"mapping\": key_mapping, \"distribution\": key_distribution},\n    ),\n    PersonAttributeFilter({\"job\": condition_job_education}),\n)\n</pre> def condition_job_education(val):     return val == \"education\"   policy_remove_education_and_escort = HouseholdPolicy(     RemoveActivity([\"education\", \"escort\"]),     PersonProbability(         discrete_joint_distribution_sampler,         {\"mapping\": key_mapping, \"distribution\": key_distribution},     ),     PersonAttributeFilter({\"job\": condition_job_education}), ) In\u00a0[36]: Copied! <pre>apply_policies(population, [policy_remove_education_and_escort]).households[\"Smith\"].plot()\n</pre> apply_policies(population, [policy_remove_education_and_escort]).households[\"Smith\"].plot() In\u00a0[37]: Copied! <pre>policy_remove_education_and_escort = HouseholdPolicy(\n    RemoveActivity([\"education\", \"escort\"]),\n    [\n        ActivityProbability([\"education\"], 0.9999),\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": edu_mapping, \"distribution\": edu_distribution},\n        ),\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": key_mapping, \"distribution\": key_distribution},\n        ),\n    ],\n)\n</pre> policy_remove_education_and_escort = HouseholdPolicy(     RemoveActivity([\"education\", \"escort\"]),     [         ActivityProbability([\"education\"], 0.9999),         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": edu_mapping, \"distribution\": edu_distribution},         ),         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": key_mapping, \"distribution\": key_distribution},         ),     ], ) In\u00a0[38]: Copied! <pre>apply_policies(population, [policy_remove_education_and_escort]).households[\"Smith\"].plot()\n</pre> apply_policies(population, [policy_remove_education_and_escort]).households[\"Smith\"].plot() In\u00a0[39]: Copied! <pre>policy_remove_leisure = PersonPolicy(RemoveActivity([\"leisure\"]), PersonProbability(1.0))\n</pre> policy_remove_leisure = PersonPolicy(RemoveActivity([\"leisure\"]), PersonProbability(1.0)) In\u00a0[40]: Copied! <pre>lei_pop = apply_policies(population, [policy_remove_leisure])\nprint_simple_stats(lei_pop)\n</pre> lei_pop = apply_policies(population, [policy_remove_leisure]) print_simple_stats(lei_pop) <pre>Population total time at home: 76.08 hours\nPopulation total travel time: 9.33 hours\n</pre> In\u00a0[41]: Copied! <pre>lei_pop.households[\"Smith\"].plot()\n</pre> lei_pop.households[\"Smith\"].plot() In\u00a0[42]: Copied! <pre>key_mapping = [\"key_worker\"]\nkey_distribution = {True: 0, False: 1}\n</pre> key_mapping = [\"key_worker\"] key_distribution = {True: 0, False: 1} In\u00a0[43]: Copied! <pre>policy_unemployment_and_furlough = PersonPolicy(\n    RemoveActivity([\"work\"]),\n    [\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": key_mapping, \"distribution\": key_distribution},\n        )\n    ],\n)\n</pre> policy_unemployment_and_furlough = PersonPolicy(     RemoveActivity([\"work\"]),     [         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": key_mapping, \"distribution\": key_distribution},         )     ], ) In\u00a0[44]: Copied! <pre>fur_pop = apply_policies(population, [policy_unemployment_and_furlough])\nprint_simple_stats(fur_pop)\n</pre> fur_pop = apply_policies(population, [policy_unemployment_and_furlough]) print_simple_stats(fur_pop) <pre>Population total time at home: 65.33 hours\nPopulation total travel time: 8.58 hours\n</pre> In\u00a0[45]: Copied! <pre>fur_pop.households[\"Smith\"].plot()\n</pre> fur_pop.households[\"Smith\"].plot() In\u00a0[46]: Copied! <pre>fur_pop.households[\"Jones\"].plot()\n</pre> fur_pop.households[\"Jones\"].plot() In\u00a0[47]: Copied! <pre>policy_reduced_work = ActivityPolicy(RemoveActivity([\"work\"]), ActivityProbability([\"work\"], 0.5))\n\napply_policies(population, [policy_reduced_work]).households[\"Smith\"].plot()\n</pre> policy_reduced_work = ActivityPolicy(RemoveActivity([\"work\"]), ActivityProbability([\"work\"], 0.5))  apply_policies(population, [policy_reduced_work]).households[\"Smith\"].plot() In\u00a0[48]: Copied! <pre>policy_remove_shopping = PersonPolicy(RemoveActivity([\"shop\"]), ActivityProbability([\"shop\"], 1.0))\n</pre> policy_remove_shopping = PersonPolicy(RemoveActivity([\"shop\"]), ActivityProbability([\"shop\"], 1.0)) In\u00a0[49]: Copied! <pre>shop_pop = apply_policies(population, [policy_remove_shopping])\nprint_simple_stats(shop_pop)\n</pre> shop_pop = apply_policies(population, [policy_remove_shopping]) print_simple_stats(shop_pop) <pre>Population total time at home: 76.08 hours\nPopulation total travel time: 8.83 hours\n</pre> In\u00a0[50]: Copied! <pre>shop_pop.households[\"Jones\"].people[\"Bridget\"].plot()\n</pre> shop_pop.households[\"Jones\"].people[\"Bridget\"].plot() In\u00a0[51]: Copied! <pre>policy_reduce_shopping_activities = HouseholdPolicy(\n    ReduceSharedActivity([\"shop_1\", \"shop_2\", \"shop\"]),\n    ActivityProbability([\"shop_1\", \"shop_2\", \"shop\"], 1.0),\n)\n</pre> policy_reduce_shopping_activities = HouseholdPolicy(     ReduceSharedActivity([\"shop_1\", \"shop_2\", \"shop\"]),     ActivityProbability([\"shop_1\", \"shop_2\", \"shop\"], 1.0), ) In\u00a0[52]: Copied! <pre>population[\"Smith\"].shared_activities()\n</pre> population[\"Smith\"].shared_activities() Out[52]: <pre>[&lt;pam.activity.Activity at 0x1683fcf50&gt;,\n &lt;pam.activity.Activity at 0x168362290&gt;,\n &lt;pam.activity.Activity at 0x1683fc910&gt;,\n &lt;pam.activity.Activity at 0x1683fcb50&gt;,\n &lt;pam.activity.Activity at 0x1683fcd90&gt;]</pre> In\u00a0[53]: Copied! <pre>shop_reduce_pop = apply_policies(population, [policy_reduce_shopping_activities])\nprint_simple_stats(shop_reduce_pop)\n</pre> shop_reduce_pop = apply_policies(population, [policy_reduce_shopping_activities]) print_simple_stats(shop_reduce_pop) <pre>Population total time at home: 76.75 hours\nPopulation total travel time: 8.83 hours\n</pre> In\u00a0[54]: Copied! <pre>shop_reduce_pop.households[\"Smith\"].plot()\n</pre> shop_reduce_pop.households[\"Smith\"].plot() In\u00a0[55]: Copied! <pre>shop_reduce_pop.households[\"Smith\"].people[\"Bobby\"].print()\n</pre> shop_reduce_pop.households[\"Smith\"].people[\"Bobby\"].print() <pre>Person: Bobby\n{'age': 6, 'job': 'education', 'gender': 'male', 'key_worker': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:25:00, duration:0:25:00)\n2:\tActivity(act:education, location:b, time:08:25:00 --&gt; 15:55:00, duration:7:30:00)\n3:\tLeg(mode:walk, area:b --&gt; c, time:15:55:00 --&gt; 16:30:00, duration:0:35:00)\n4:\tActivity(act:home, location:a, time:16:30:00 --&gt; 00:00:00, duration:7:30:00)\n</pre> In\u00a0[56]: Copied! <pre>policy_move_shopping_tours = PersonPolicy(\n    MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]),\n    [ActivityProbability([\"shop_1\", \"shop_2\"], 1.0)],\n)\n</pre> policy_move_shopping_tours = PersonPolicy(     MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]),     [ActivityProbability([\"shop_1\", \"shop_2\"], 1.0)], ) In\u00a0[57]: Copied! <pre>shop_tour_pop = apply_policies(population, [policy_move_shopping_tours])\nprint_simple_stats(shop_tour_pop)\n</pre> shop_tour_pop = apply_policies(population, [policy_move_shopping_tours]) print_simple_stats(shop_tour_pop) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[58]: Copied! <pre>shop_tour_pop.households[\"Smith\"].plot()\n</pre> shop_tour_pop.households[\"Smith\"].plot() In\u00a0[59]: Copied! <pre># above is equivalent to\npolicy_move_shopping_tours = PersonPolicy(\n    MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]),\n    [ActivityProbability([\"shop_1\"], 1.0), ActivityProbability([\"shop_2\"], 1.0)],\n)\n</pre> # above is equivalent to policy_move_shopping_tours = PersonPolicy(     MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]),     [ActivityProbability([\"shop_1\"], 1.0), ActivityProbability([\"shop_2\"], 1.0)], ) In\u00a0[60]: Copied! <pre>shop_tour_pop = apply_policies(population, [policy_move_shopping_tours])\nprint_simple_stats(shop_tour_pop)\n</pre> shop_tour_pop = apply_policies(population, [policy_move_shopping_tours]) print_simple_stats(shop_tour_pop) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[61]: Copied! <pre>shop_tour_pop.households[\"Smith\"].plot()\n</pre> shop_tour_pop.households[\"Smith\"].plot() In\u00a0[62]: Copied! <pre>shop_tour_pop.households[\"Smith\"].people[\"Bradly\"].print()\n</pre> shop_tour_pop.households[\"Smith\"].people[\"Bradly\"].print() <pre>Person: Bradly\n{'age': 40, 'job': 'employed', 'gender': 'male', 'key_worker': True}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:20:00, duration:0:20:00)\n2:\tActivity(act:escort, location:b, time:08:20:00 --&gt; 08:30:00, duration:0:10:00)\n3:\tLeg(mode:pt, area:b --&gt; b, time:08:30:00 --&gt; 09:00:00, duration:0:30:00)\n4:\tActivity(act:work, location:b, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:10:00:00 --&gt; 10:20:00, duration:0:20:00)\n6:\tActivity(act:work, location:b, time:10:20:00 --&gt; 12:00:00, duration:1:40:00)\n7:\tLeg(mode:pt, area:b --&gt; c, time:12:00:00 --&gt; 12:20:00, duration:0:20:00)\n8:\tActivity(act:work, location:b, time:12:20:00 --&gt; 14:00:00, duration:1:40:00)\n9:\tLeg(mode:pt, area:b --&gt; c, time:14:00:00 --&gt; 14:20:00, duration:0:20:00)\n10:\tActivity(act:leisure, location:c, time:14:20:00 --&gt; 15:30:00, duration:1:10:00)\n11:\tLeg(mode:pt, area:c --&gt; b, time:15:30:00 --&gt; 15:50:00, duration:0:20:00)\n12:\tActivity(act:escort, location:b, time:15:50:00 --&gt; 16:00:00, duration:0:10:00)\n13:\tLeg(mode:walk, area:b --&gt; a, time:16:00:00 --&gt; 16:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:16:20:00 --&gt; 18:00:00, duration:1:40:00)\n15:\tLeg(mode:walk, area:a --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:a, time:18:20:00 --&gt; 18:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:a --&gt; a, time:18:50:00 --&gt; 19:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:a, time:19:00:00 --&gt; 19:50:00, duration:0:50:00)\n19:\tLeg(mode:walk, area:a --&gt; a, time:19:50:00 --&gt; 20:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:20:10:00 --&gt; 00:00:00, duration:3:50:00)\n</pre> In\u00a0[63]: Copied! <pre>all_together_pop = apply_policies(\n    population,\n    [\n        policy_quarantine,\n        policy_remove_education_and_escort,\n        policy_remove_leisure,\n        policy_unemployment_and_furlough,\n        policy_remove_shopping,\n    ],\n)\n\nprint_simple_stats(all_together_pop)\n</pre> all_together_pop = apply_policies(     population,     [         policy_quarantine,         policy_remove_education_and_escort,         policy_remove_leisure,         policy_unemployment_and_furlough,         policy_remove_shopping,     ], )  print_simple_stats(all_together_pop) <pre>Population total time at home: 83.67 hours\nPopulation total travel time: 4.25 hours\n</pre>"},{"location":"examples/09_advanced_policies/#modifying-the-population-using-complex-policies","title":"Modifying the population using complex policies\u00b6","text":"<p>This notebook shows how complex policies can be applied to people, households, and entire populations.</p>"},{"location":"examples/09_advanced_policies/#create-example-population","title":"Create example Population\u00b6","text":""},{"location":"examples/09_advanced_policies/#add-smith-household","title":"Add Smith household\u00b6","text":""},{"location":"examples/09_advanced_policies/#add-jones-household","title":"Add Jones household\u00b6","text":""},{"location":"examples/09_advanced_policies/#pam-complex-policies","title":"PAM Complex Policies\u00b6","text":"<p>Based on link</p>"},{"location":"examples/09_advanced_policies/#household-quarantine","title":"Household Quarantine\u00b6","text":"<p>Probabilistically apply quarantine to a household (remove all activities - stay at home)</p>"},{"location":"examples/09_advanced_policies/#person-based-all-people-equal","title":"Person-based, all people equal\u00b6","text":"<p>If you have a probability of any person having to be quarantined</p>"},{"location":"examples/09_advanced_policies/#using-joint-distribution","title":"Using joint distribution\u00b6","text":""},{"location":"examples/09_advanced_policies/#chaining-probabilities","title":"Chaining probabilities\u00b6","text":""},{"location":"examples/09_advanced_policies/#remove-education","title":"Remove Education\u00b6","text":"<p>Probabilistically remove education activities from a person and escort from people in the same household</p>"},{"location":"examples/09_advanced_policies/#personattributefilter","title":"PersonAttributeFilter\u00b6","text":"<p>You can also use the <code>modify.PersonAttributeFilter</code> to only affect people with certain attributes.</p>"},{"location":"examples/09_advanced_policies/#remove-leisure-activities","title":"Remove Leisure Activities\u00b6","text":"<p>Remove all leisure activities</p>"},{"location":"examples/09_advanced_policies/#unemploymentfurlough","title":"Unemployment/Furlough\u00b6","text":"<p>Probabilistically remove all work activities from a person</p>"},{"location":"examples/09_advanced_policies/#remove-shopping","title":"Remove Shopping\u00b6","text":"<p>Probabilistically remove individual shopping activities from a person</p>"},{"location":"examples/09_advanced_policies/#reducing-shared-activities","title":"Reducing shared activities\u00b6","text":""},{"location":"examples/09_advanced_policies/#moving-shopping-tours","title":"Moving Shopping tours\u00b6","text":""},{"location":"examples/09_advanced_policies/#all-together-now","title":"All together now!\u00b6","text":""},{"location":"examples/10_advanced_spatial_sampling/","title":"Advanced Spatial Sampling","text":"<p>The purpose of this notebook is to demonstrate weighted and rule-based facility sampling methods.</p> <p>PAM offers a facility sampler, which can be called wtih <code>pam.samplers.facility.FacilitySampler(facilities, zones, ...)</code>, where <code>facilities</code> and <code>zones</code> are geodataframes containing the available activity locations and the model zoning system respectively.</p> <p>The <code>weight_on</code> option of the sampler allows to specify a column of the facilities dataset to be used for weighting the candidate locations (for example, by floorspace). nb: weighted sampling here samples with replacement, while the default (unweighted) option iterates across a shuffled list of the candidate locations instead).</p> <p>By providing a <code>max_walk</code> argument, we constrain activity locations accessed with PT modes (named as <code>bus</code>, <code>rail</code>, or <code>pt</code>) to be located within that distance (crow's fly) from a PT stop. The distance of each facility from a PT stop should be provided in the <code>facilities</code> dataset (under the <code>transit</code> field).</p> <p>We can sample facility locations for a PAM population, with the <code>population.sample_locs(sampler)</code> method, where sampler is an instance of <code>pam.samplers.facility.FacilitySampler</code>. Depending whether we <code>weight_on</code> option was activated for the sampler, it will undertake simple or weighted sampling.</p> <p>To accommodate more complex sampling techniques, we have introduced <code>population.sample_locs_complex(sampler)</code>. This method passes additional information to the sampler, such as the duration and mode of arriving trip and the previous activity location. The sampler then applies some extra rules:</p> <ul> <li>distance-weighted sampling: for the given trip duration, try to adjust candidate facility weights so that their distance from the previous location is consistent with the trip duration and mode speed. The weights are adjusted as $ adjusted\\_weight_j =  \\frac{weight_j}{expected\\_distance_{ij}^2}$, where $ expected\\_distance_{ij} = \\lvert{distance_{ij} - (duration * speed)}\\rvert $. The mode speeds (expressed in euclidean distance terms) are defined in <code>pam.variables.EXPECTED_EUCLIDEAN_SPEEDS</code> dictionary.</li> <li>distance from PT stop rule: if the mode is PT and <code>max_walk</code> has been provided, contrain the options within the specified radius from a stop</li> </ul> <p>Caveats</p> <ul> <li>The complex sampler is experimental at this stage and should be used with care.</li> <li>All distance units are calculated as euclidean distances. Expected speeds should also be expressed in euclidean measures. Distance calculations assume a linear-unit (meters) coordinate system. In the future, we should try to integrate model skims in the calculation.</li> <li>Distance-based weighting can be used to help better align sampled durations with locations. However, it only looks one trip ahead, and it is likely to be inconsistent for the last trip (ie the path doesn't necessarily \"close\" well).</li> </ul> In\u00a0[1]: Copied! <pre>import logging\n\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom shapely.geometry import Point, Polygon\n\nimport pam\nfrom pam.activity import Activity, Leg\nfrom pam.core import Household, Person, Population\nfrom pam.samplers import facility\nfrom pam.utils import minutes_to_datetime\n</pre> import logging  import geopandas as gp import matplotlib.pyplot as plt import numpy as np import pandas as pd from shapely.geometry import Point, Polygon  import pam from pam.activity import Activity, Leg from pam.core import Household, Person, Population from pam.samplers import facility from pam.utils import minutes_to_datetime <p>Create a dummy dataset of facilities and their locations:</p> In\u00a0[2]: Copied! <pre># create random spatial data\n\n# create zones\nlength = 10000  # square length in meters\npolygon_list = []\nzone_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"]\nactivities_list = [\"home\", \"work\", \"other\", \"shop\", \"escort\", \"education\"]\n\nfor y in [2 * length, length, 0]:\n    for x in [0, length, 2 * length]:\n        polygon_list.append(\n            Polygon([[x, y], [x + length, y], [x + length, y + length], [x, y + length], [x, y]])\n        )\n\nzones = gp.GeoDataFrame(geometry=polygon_list)\nzones[\"zone\"] = zone_list\nzones = zones.set_index(\"zone\")\n\n# create facilities\npoint_list = []\nfor activity in activities_list:\n    for _i in range(1000):\n        point = Point(np.random.rand() * 3 * length, np.random.rand() * 3 * length)\n        point_list.append(\n            {\n                \"activity\": activity,\n                \"floors\": np.random.randint(1, 4),\n                \"units\": np.random.randint(1, 20),\n                \"area\": np.random.randint(1, 100),\n                \"transit\": np.random.randint(1, 10000),\n                \"geometry\": point,\n            }\n        )\n\nfacilities = gp.GeoDataFrame(point_list)\nfacilities = gp.sjoin(facilities, zones.reset_index()).drop(columns=\"index_right\")\n\n\n# plot\nfig, ax = plt.subplots(1, 1, figsize=(10, 7))\nzones.boundary.plot(ax=ax)\nfacilities.plot(ax=ax, markersize=2, color=\"purple\")\nfor zone, centroid in zip(zones.index, zones.centroid):\n    ax.annotate(zone, xy=(centroid.x, centroid.y), size=15)\nax.axis(\"off\")\nplt.show()\n</pre> # create random spatial data  # create zones length = 10000  # square length in meters polygon_list = [] zone_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"] activities_list = [\"home\", \"work\", \"other\", \"shop\", \"escort\", \"education\"]  for y in [2 * length, length, 0]:     for x in [0, length, 2 * length]:         polygon_list.append(             Polygon([[x, y], [x + length, y], [x + length, y + length], [x, y + length], [x, y]])         )  zones = gp.GeoDataFrame(geometry=polygon_list) zones[\"zone\"] = zone_list zones = zones.set_index(\"zone\")  # create facilities point_list = [] for activity in activities_list:     for _i in range(1000):         point = Point(np.random.rand() * 3 * length, np.random.rand() * 3 * length)         point_list.append(             {                 \"activity\": activity,                 \"floors\": np.random.randint(1, 4),                 \"units\": np.random.randint(1, 20),                 \"area\": np.random.randint(1, 100),                 \"transit\": np.random.randint(1, 10000),                 \"geometry\": point,             }         )  facilities = gp.GeoDataFrame(point_list) facilities = gp.sjoin(facilities, zones.reset_index()).drop(columns=\"index_right\")   # plot fig, ax = plt.subplots(1, 1, figsize=(10, 7)) zones.boundary.plot(ax=ax) facilities.plot(ax=ax, markersize=2, color=\"purple\") for zone, centroid in zip(zones.index, zones.centroid):     ax.annotate(zone, xy=(centroid.x, centroid.y), size=15) ax.axis(\"off\") plt.show() In\u00a0[3]: Copied! <pre># facilities dataset:\nfacilities.head()\n</pre> # facilities dataset: facilities.head() Out[3]: activity floors units area transit geometry zone 0 home 2 10 87 3566 POINT (13815.320 28631.567) b 3 home 1 17 53 7338 POINT (14648.805 27657.722) b 13 home 2 4 33 6694 POINT (13782.958 20035.933) b 19 home 2 12 20 5225 POINT (15556.174 21831.573) b 22 home 1 15 75 4895 POINT (19978.664 25678.396) b <p>Let's assume a 30-min walking commute trip from home.</p> <p>The expected straight-line speed for the trip is:</p> In\u00a0[4]: Copied! <pre>print(\n    \"The expected straight-line speed for the trip is: {} kph\".format(\n        pam.variables.EXPECTED_EUCLIDEAN_SPEEDS[\"walk\"]\n    )\n)\n</pre> print(     \"The expected straight-line speed for the trip is: {} kph\".format(         pam.variables.EXPECTED_EUCLIDEAN_SPEEDS[\"walk\"]     ) ) <pre>The expected straight-line speed for the trip is: 1.3888888888888888 kph\n</pre> <p>Therefore, we expect the sampler to pick a workplace location approx 5 * 0.5=2.5km from home.</p> In\u00a0[5]: Copied! <pre>p1 = Person(\"p1\", attributes={\"age\": 40})\np1.add(\n    Activity(\n        seq=1,\n        act=\"home\",\n        area=\"a\",\n        start_time=minutes_to_datetime(0),\n        end_time=minutes_to_datetime(60),\n    )\n)\np1.add(\n    Leg(\n        seq=1,\n        mode=\"walk\",\n        start_area=\"a\",\n        end_area=\"a\",\n        start_time=minutes_to_datetime(60),\n        end_time=minutes_to_datetime(90),\n    )\n)\np1.add(\n    Activity(\n        seq=2,\n        act=\"work\",\n        area=\"a\",\n        start_time=minutes_to_datetime(90),\n        end_time=minutes_to_datetime(120),\n    )\n)\n\nhh1 = Household(0)\nhh1.add(p1)\n\npopulation = Population()\npopulation.add(hh1)\n</pre> p1 = Person(\"p1\", attributes={\"age\": 40}) p1.add(     Activity(         seq=1,         act=\"home\",         area=\"a\",         start_time=minutes_to_datetime(0),         end_time=minutes_to_datetime(60),     ) ) p1.add(     Leg(         seq=1,         mode=\"walk\",         start_area=\"a\",         end_area=\"a\",         start_time=minutes_to_datetime(60),         end_time=minutes_to_datetime(90),     ) ) p1.add(     Activity(         seq=2,         act=\"work\",         area=\"a\",         start_time=minutes_to_datetime(90),         end_time=minutes_to_datetime(120),     ) )  hh1 = Household(0) hh1.add(p1)  population = Population() population.add(hh1) In\u00a0[6]: Copied! <pre># supress logger warnings\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.CRITICAL)\n</pre> # supress logger warnings  logger = logging.getLogger() logger.setLevel(logging.CRITICAL) In\u00a0[7]: Copied! <pre>def test_sampler_distance(\n    population, sampler, n_iterations=20, complex_sampler=False, title=None\n):  # increase this\n    distance_commute = []\n\n    for _i in range(n_iterations):\n        if complex_sampler:\n            population.sample_locs_complex(sampler)\n        else:\n            population.sample_locs(sampler)\n        distance_commute.append(population.trips_df()[\"euclidean_distance\"][0])\n\n    pd.Series(distance_commute).hist(bins=20)\n    if title is not None:\n        plt.title(title)\n    plt.xlabel(\"distance\")\n    plt.ylabel(\"frequency\")\n    plt.show()\n</pre> def test_sampler_distance(     population, sampler, n_iterations=20, complex_sampler=False, title=None ):  # increase this     distance_commute = []      for _i in range(n_iterations):         if complex_sampler:             population.sample_locs_complex(sampler)         else:             population.sample_locs(sampler)         distance_commute.append(population.trips_df()[\"euclidean_distance\"][0])      pd.Series(distance_commute).hist(bins=20)     if title is not None:         plt.title(title)     plt.xlabel(\"distance\")     plt.ylabel(\"frequency\")     plt.show() In\u00a0[8]: Copied! <pre># simple sampling\n\n\nfacility_sampler_nonweighted = facility.FacilitySampler(\n    facilities=facilities, zones=zones, build_xml=True, fail=False, random_default=True\n)\n\ntest_sampler_distance(\n    population,\n    facility_sampler_nonweighted,\n    complex_sampler=False,\n    title=\"Commute distance, simple sampling\",\n)\n</pre> # simple sampling   facility_sampler_nonweighted = facility.FacilitySampler(     facilities=facilities, zones=zones, build_xml=True, fail=False, random_default=True )  test_sampler_distance(     population,     facility_sampler_nonweighted,     complex_sampler=False,     title=\"Commute distance, simple sampling\", ) In\u00a0[9]: Copied! <pre># distance-weighted sampling\n\ndistance_commute_weighted = []\n\nfacility_sampler_weighted = facility.FacilitySampler(\n    facilities=facilities.assign(weight1=1),\n    zones=zones,\n    build_xml=True,\n    fail=False,\n    random_default=True,\n    weight_on=\"weight1\",\n)\n\ntest_sampler_distance(\n    population,\n    facility_sampler_weighted,\n    complex_sampler=True,\n    title=\"Commute distance, distance-weighted sampling\",\n)\n</pre> # distance-weighted sampling  distance_commute_weighted = []  facility_sampler_weighted = facility.FacilitySampler(     facilities=facilities.assign(weight1=1),     zones=zones,     build_xml=True,     fail=False,     random_default=True,     weight_on=\"weight1\", )  test_sampler_distance(     population,     facility_sampler_weighted,     complex_sampler=True,     title=\"Commute distance, distance-weighted sampling\", ) <p>Similar experiment to above, with a 30-min car trip from zone a to zone b:</p> In\u00a0[10]: Copied! <pre>print(\n    \"The expected straight-line speed for the trip is: {} kph\".format(\n        pam.variables.EXPECTED_EUCLIDEAN_SPEEDS[\"car\"]\n    )\n)\n</pre> print(     \"The expected straight-line speed for the trip is: {} kph\".format(         pam.variables.EXPECTED_EUCLIDEAN_SPEEDS[\"car\"]     ) ) <pre>The expected straight-line speed for the trip is: 5.555555555555555 kph\n</pre> <p>--&gt; we should expect higher sampling of locations in a radius closer to 20 * 0.5= 10km.</p> In\u00a0[11]: Copied! <pre>p2 = Person(\"p2\", attributes={\"age\": 40})\np2.add(\n    Activity(\n        seq=1,\n        act=\"home\",\n        area=\"a\",\n        start_time=minutes_to_datetime(0),\n        end_time=minutes_to_datetime(60),\n    )\n)\np2.add(\n    Leg(\n        seq=1,\n        mode=\"car\",\n        start_area=\"a\",\n        end_area=\"b\",\n        start_time=minutes_to_datetime(60),\n        end_time=minutes_to_datetime(90),\n    )\n)\np2.add(\n    Activity(\n        seq=2,\n        act=\"work\",\n        area=\"b\",\n        start_time=minutes_to_datetime(90),\n        end_time=minutes_to_datetime(120),\n    )\n)\n\nhh2 = Household(0)\nhh2.add(p2)\n\npopulation2 = Population()\npopulation2.add(hh2)\n\ntest_sampler_distance(\n    population2,\n    facility_sampler_nonweighted,\n    complex_sampler=False,\n    title=\"Commute distance, simple sampling, car\",\n)\ntest_sampler_distance(\n    population2,\n    facility_sampler_weighted,\n    complex_sampler=True,\n    title=\"Commute distance, distance-weighted sampling, car\",\n)\n</pre> p2 = Person(\"p2\", attributes={\"age\": 40}) p2.add(     Activity(         seq=1,         act=\"home\",         area=\"a\",         start_time=minutes_to_datetime(0),         end_time=minutes_to_datetime(60),     ) ) p2.add(     Leg(         seq=1,         mode=\"car\",         start_area=\"a\",         end_area=\"b\",         start_time=minutes_to_datetime(60),         end_time=minutes_to_datetime(90),     ) ) p2.add(     Activity(         seq=2,         act=\"work\",         area=\"b\",         start_time=minutes_to_datetime(90),         end_time=minutes_to_datetime(120),     ) )  hh2 = Household(0) hh2.add(p2)  population2 = Population() population2.add(hh2)  test_sampler_distance(     population2,     facility_sampler_nonweighted,     complex_sampler=False,     title=\"Commute distance, simple sampling, car\", ) test_sampler_distance(     population2,     facility_sampler_weighted,     complex_sampler=True,     title=\"Commute distance, distance-weighted sampling, car\", ) <p>As expected, between long-distance alternatives (ie from zone a to zone i), deviation from expected distance makes less difference (but does slightly shift the distribution towards the correct direction).</p> In\u00a0[12]: Copied! <pre>p3 = Person(\"p3\", attributes={\"age\": 40})\np3.add(\n    Activity(\n        seq=1,\n        act=\"home\",\n        area=\"a\",\n        start_time=minutes_to_datetime(0),\n        end_time=minutes_to_datetime(60),\n    )\n)\np3.add(\n    Leg(\n        seq=1,\n        mode=\"car\",\n        start_area=\"a\",\n        end_area=\"c\",\n        start_time=minutes_to_datetime(60),\n        end_time=minutes_to_datetime(90),\n    )\n)\np3.add(\n    Activity(\n        seq=2,\n        act=\"work\",\n        area=\"c\",\n        start_time=minutes_to_datetime(90),\n        end_time=minutes_to_datetime(120),\n    )\n)\n\nhh3 = Household(0)\nhh3.add(p3)\n\npopulation3 = Population()\npopulation3.add(hh3)\n\ntest_sampler_distance(\n    population3,\n    facility_sampler_nonweighted,\n    complex_sampler=False,\n    title=\"Commute distance, simple sampling, car\",\n)\ntest_sampler_distance(\n    population3,\n    facility_sampler_weighted,\n    complex_sampler=True,\n    title=\"Commute distance, distance-weighted sampling, car\",\n)\n</pre> p3 = Person(\"p3\", attributes={\"age\": 40}) p3.add(     Activity(         seq=1,         act=\"home\",         area=\"a\",         start_time=minutes_to_datetime(0),         end_time=minutes_to_datetime(60),     ) ) p3.add(     Leg(         seq=1,         mode=\"car\",         start_area=\"a\",         end_area=\"c\",         start_time=minutes_to_datetime(60),         end_time=minutes_to_datetime(90),     ) ) p3.add(     Activity(         seq=2,         act=\"work\",         area=\"c\",         start_time=minutes_to_datetime(90),         end_time=minutes_to_datetime(120),     ) )  hh3 = Household(0) hh3.add(p3)  population3 = Population() population3.add(hh3)  test_sampler_distance(     population3,     facility_sampler_nonweighted,     complex_sampler=False,     title=\"Commute distance, simple sampling, car\", ) test_sampler_distance(     population3,     facility_sampler_weighted,     complex_sampler=True,     title=\"Commute distance, distance-weighted sampling, car\", )"},{"location":"examples/10_advanced_spatial_sampling/#advanced-spatial-sampling","title":"Advanced Spatial Sampling\u00b6","text":""},{"location":"examples/10_advanced_spatial_sampling/#generate-data","title":"Generate Data\u00b6","text":""},{"location":"examples/10_advanced_spatial_sampling/#geography","title":"Geography\u00b6","text":""},{"location":"examples/10_advanced_spatial_sampling/#population","title":"Population\u00b6","text":""},{"location":"examples/10_advanced_spatial_sampling/#distance-based-sampling","title":"Distance-based sampling\u00b6","text":""},{"location":"examples/11_Advanced_Plan_Rescheduling/","title":"Plan Rescheduling","text":"In\u00a0[1]: Copied! <pre>from pam.activity import Activity, Leg\nfrom pam.core import Person\nfrom pam.scoring import CharyparNagelPlanScorer\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n\n%matplotlib inline\n</pre> from pam.activity import Activity, Leg from pam.core import Person from pam.scoring import CharyparNagelPlanScorer from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY  %matplotlib inline In\u00a0[2]: Copied! <pre>default_config = {\n    \"mUM\": 1,\n    \"utilityOfLineSwitch\": -1,\n    \"performing\": 6,\n    \"waiting\": -1,\n    \"waitingPt\": -2,\n    \"lateArrival\": -18,\n    \"earlyDeparture\": -6,\n    \"work\": {\n        \"typicalDuration\": \"08:30:00\",\n        \"openingTime\": \"06:00:00\",\n        \"closingTime\": \"20:00:00\",\n        \"latestStartTime\": \"09:30:00\",\n        \"earliestEndTime\": \"16:00:00\",\n        \"minimalDuration\": \"08:00:00\",\n    },\n    \"home\": {\n        \"typicalDuration\": \"09:00:00\",\n        \"minimalDuration\": \"06:00:00\",\n        \"earliestEndTime\": \"06:00:00\",\n    },\n    \"shop\": {\n        \"openingTime\": \"06:00:00\",\n        \"closingTime\": \"20:00:00\",\n        \"typicalDuration\": \"00:30:00\",\n        \"minimalDuration\": \"00:30:00\",\n    },\n    \"car\": {\n        \"constant\": -5,\n        \"dailyMonetaryConstant\": -0,\n        \"dailyUtilityConstant\": -0,\n        \"marginalUtilityOfDistance\": -0,\n        \"marginalUtilityOfTravelling\": -0,\n        \"monetaryDistanceRate\": -0.0005,\n    },\n    \"walk\": {\"marginalUtilityOfTravelling\": -12},\n}\n\nconfig = {subpop: default_config for subpop in [\"default\"]}\n\nscorer = CharyparNagelPlanScorer(cnfg=config)\n</pre> default_config = {     \"mUM\": 1,     \"utilityOfLineSwitch\": -1,     \"performing\": 6,     \"waiting\": -1,     \"waitingPt\": -2,     \"lateArrival\": -18,     \"earlyDeparture\": -6,     \"work\": {         \"typicalDuration\": \"08:30:00\",         \"openingTime\": \"06:00:00\",         \"closingTime\": \"20:00:00\",         \"latestStartTime\": \"09:30:00\",         \"earliestEndTime\": \"16:00:00\",         \"minimalDuration\": \"08:00:00\",     },     \"home\": {         \"typicalDuration\": \"09:00:00\",         \"minimalDuration\": \"06:00:00\",         \"earliestEndTime\": \"06:00:00\",     },     \"shop\": {         \"openingTime\": \"06:00:00\",         \"closingTime\": \"20:00:00\",         \"typicalDuration\": \"00:30:00\",         \"minimalDuration\": \"00:30:00\",     },     \"car\": {         \"constant\": -5,         \"dailyMonetaryConstant\": -0,         \"dailyUtilityConstant\": -0,         \"marginalUtilityOfDistance\": -0,         \"marginalUtilityOfTravelling\": -0,         \"monetaryDistanceRate\": -0.0005,     },     \"walk\": {\"marginalUtilityOfTravelling\": -12}, }  config = {subpop: default_config for subpop in [\"default\"]}  scorer = CharyparNagelPlanScorer(cnfg=config) In\u00a0[3]: Copied! <pre>personA = Person(\"Ahmed\", attributes={\"age\": 20, \"subpopulation\": \"default\"})\npersonA.plan.day = [\n    Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(420)),\n    Leg(mode=\"car\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(act=\"shop\", area=2, start_time=mtdt(480), end_time=mtdt(510)),\n    Leg(mode=\"walk\", start_time=mtdt(510), end_time=mtdt(570), distance=1000),\n    Activity(act=\"work\", area=3, start_time=mtdt(570), end_time=mtdt(1140)),\n    Leg(mode=\"car\", start_time=mtdt(1140), end_time=mtdt(1200), distance=1000),\n    Activity(act=\"home\", area=1, start_time=mtdt(1200), end_time=END_OF_DAY),\n]\n\npersonB = Person(\"Brenda\", attributes={\"age\": 20, \"subpopulation\": \"default\"})\npersonB.plan.day = [\n    Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(300)),\n    Leg(mode=\"car\", start_time=mtdt(300), end_time=mtdt(360), distance=1000),\n    Activity(act=\"shop\", area=2, start_time=mtdt(360), end_time=mtdt(420)),\n    Leg(mode=\"walk\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(act=\"work\", area=3, start_time=mtdt(480), end_time=mtdt(1320)),\n    Leg(mode=\"car\", start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),\n    Activity(act=\"home\", area=1, start_time=mtdt(1380), end_time=END_OF_DAY),\n]\n\npersonC = Person(\"Cookie\", attributes={\"age\": 20, \"subpopulation\": \"default\"})\npersonC.plan.day = [\n    Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(120)),\n    Leg(mode=\"car\", start_time=mtdt(120), end_time=mtdt(180), distance=1000),\n    Activity(act=\"shop\", area=2, start_time=mtdt(180), end_time=mtdt(420)),\n    Leg(mode=\"walk\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(act=\"work\", area=3, start_time=mtdt(480), end_time=mtdt(1320)),\n    Leg(mode=\"car\", start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),\n    Activity(act=\"home\", area=1, start_time=mtdt(1380), end_time=END_OF_DAY),\n]\n\npersonA.plot()\npersonB.plot()\npersonC.plot()\n</pre> personA = Person(\"Ahmed\", attributes={\"age\": 20, \"subpopulation\": \"default\"}) personA.plan.day = [     Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(420)),     Leg(mode=\"car\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(act=\"shop\", area=2, start_time=mtdt(480), end_time=mtdt(510)),     Leg(mode=\"walk\", start_time=mtdt(510), end_time=mtdt(570), distance=1000),     Activity(act=\"work\", area=3, start_time=mtdt(570), end_time=mtdt(1140)),     Leg(mode=\"car\", start_time=mtdt(1140), end_time=mtdt(1200), distance=1000),     Activity(act=\"home\", area=1, start_time=mtdt(1200), end_time=END_OF_DAY), ]  personB = Person(\"Brenda\", attributes={\"age\": 20, \"subpopulation\": \"default\"}) personB.plan.day = [     Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(300)),     Leg(mode=\"car\", start_time=mtdt(300), end_time=mtdt(360), distance=1000),     Activity(act=\"shop\", area=2, start_time=mtdt(360), end_time=mtdt(420)),     Leg(mode=\"walk\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(act=\"work\", area=3, start_time=mtdt(480), end_time=mtdt(1320)),     Leg(mode=\"car\", start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),     Activity(act=\"home\", area=1, start_time=mtdt(1380), end_time=END_OF_DAY), ]  personC = Person(\"Cookie\", attributes={\"age\": 20, \"subpopulation\": \"default\"}) personC.plan.day = [     Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(120)),     Leg(mode=\"car\", start_time=mtdt(120), end_time=mtdt(180), distance=1000),     Activity(act=\"shop\", area=2, start_time=mtdt(180), end_time=mtdt(420)),     Leg(mode=\"walk\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(act=\"work\", area=3, start_time=mtdt(480), end_time=mtdt(1320)),     Leg(mode=\"car\", start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),     Activity(act=\"home\", area=1, start_time=mtdt(1380), end_time=END_OF_DAY), ]  personA.plot() personB.plot() personC.plot() In\u00a0[4]: Copied! <pre>print(f\"{personA.pid}'s score = {scorer.score_person(personA)}\")\nprint(f\"{personB.pid}'s score = {scorer.score_person(personB)}\")\nprint(f\"{personC.pid}'s score = {scorer.score_person(personC)}\")\n</pre> print(f\"{personA.pid}'s score = {scorer.score_person(personA)}\") print(f\"{personB.pid}'s score = {scorer.score_person(personB)}\") print(f\"{personC.pid}'s score = {scorer.score_person(personC)}\") <pre>Ahmed's score = 101.50872494557763\nBrenda's score = 220.77119050471717\nCookie's score = 162.59537925482084\n</pre> In\u00a0[5]: Copied! <pre>from pam.optimise import grid, random\n</pre> from pam.optimise import grid, random In\u00a0[6]: Copied! <pre>plans = [personA.plan, personB.plan, personC.plan]\n\nprint(\"Random search optimisation:\")\noptimised_by_random = []\nfor plan in plans:\n    optimised, _ = random.reschedule(\n        plan, plans_scorer=scorer, config=config[\"default\"], patience=5000\n    )\n    optimised_by_random.append(optimised)\nprint(\"Grid search optimisation:\")\noptimised_by_grid = []\nfor plan in plans:\n    optimised, _ = grid.grid_search(\n        plan, plans_scorer=scorer, config=config[\"default\"], step=1800  # step size is in seconds\n    )\n    optimised_by_grid.append(optimised)\n</pre> plans = [personA.plan, personB.plan, personC.plan]  print(\"Random search optimisation:\") optimised_by_random = [] for plan in plans:     optimised, _ = random.reschedule(         plan, plans_scorer=scorer, config=config[\"default\"], patience=5000     )     optimised_by_random.append(optimised) print(\"Grid search optimisation:\") optimised_by_grid = [] for plan in plans:     optimised, _ = grid.grid_search(         plan, plans_scorer=scorer, config=config[\"default\"], step=1800  # step size is in seconds     )     optimised_by_grid.append(optimised) <pre>Random search optimisation:\nScore improved from 101.50872494557763 to 216.04289233237552 in 5000 steps.\nFailed to improve score from initial 220.77119050471717 in 5000 steps.\nScore improved from 162.59537925482084 to 214.99751260850485 in 5000 steps.\nGrid search optimisation:\nScore improved from 101.50872494557763 to 242.61260211505845 using step size 1800s.\nScore improved from 220.77119050471717 to 242.61260211505845 using step size 1800s.\nScore improved from 162.59537925482084 to 242.61260211505845 using step size 1800s.\n</pre> <p>Note that the random search quality depends upon the level of patience and the grid search on the step size. Setting patience higher or using smaller grid steps may result in better scores but at the cost of more compute. We can think of better ways to implement these schedule optimisers, but we leave it as an exercise to the reader.</p> <p>In this case we can see that the grid search finds a schedule with a short shopping trip at 7.30 and the 10 hours at work. For our example grid search finds the same optima for all, because the plans have the same activities, sequence, and trips.</p> In\u00a0[7]: Copied! <pre>optimised_by_random[1].plot()\noptimised_by_grid[1].plot()\n</pre> optimised_by_random[1].plot() optimised_by_grid[1].plot() In\u00a0[8]: Copied! <pre>config[\"default\"][\"home\"][\"typicalDuration\"] = \"12:00:00\"  # previously \"09:00:00\"\nconfig[\"default\"][\"home\"][\"minimalDuration\"] = \"10:00:00\"  # previously \"06:00:00\"\nconfig[\"default\"][\"home\"][\"earliestEndTime\"] = \"07:00:00\"  # previously \"06:00:00\"\n\nscorer = CharyparNagelPlanScorer(cnfg=config)\n\noptimised, _ = grid.grid_search(\n    plans[0], plans_scorer=scorer, config=config[\"default\"], step=1800  # step size is in seconds\n)\noptimised.plot()\n</pre> config[\"default\"][\"home\"][\"typicalDuration\"] = \"12:00:00\"  # previously \"09:00:00\" config[\"default\"][\"home\"][\"minimalDuration\"] = \"10:00:00\"  # previously \"06:00:00\" config[\"default\"][\"home\"][\"earliestEndTime\"] = \"07:00:00\"  # previously \"06:00:00\"  scorer = CharyparNagelPlanScorer(cnfg=config)  optimised, _ = grid.grid_search(     plans[0], plans_scorer=scorer, config=config[\"default\"], step=1800  # step size is in seconds ) optimised.plot() <pre>Score improved from 102.4076882473681 to 244.0 using step size 1800s.\n</pre> <p>By adjusting our scorer to value time at home more, we can see that the grid search has found a new schedule with later start time and shorter work duration. We can use this approach to refine our configuration to one that we prefer.</p> In\u00a0[9]: Copied! <pre>from pam.array import distance, encode\n\nmapping = {\"home\": 0, \"travel\": 1, \"shop\": 2, \"work\": 3}  # activity type to column index map\n# Example one-hot encoding:\nencode.plan_to_one_hot(plans[0], mapping)\n</pre> from pam.array import distance, encode  mapping = {\"home\": 0, \"travel\": 1, \"shop\": 2, \"work\": 3}  # activity type to column index map # Example one-hot encoding: encode.plan_to_one_hot(plans[0], mapping) Out[9]: <pre>array([[1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 1., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.]])</pre> In\u00a0[10]: Copied! <pre>ranked = []\nfor name, plan, optimised in zip([\"Ahmed\", \"Brenda\", \"Cookie\"], plans, optimised_by_grid):\n    plan_encoded = encode.plan_to_one_hot(plan, mapping, bin_size=900)\n    optimised_encoded = encode.plan_to_one_hot(optimised, mapping, bin_size=900)\n    difference = distance.accuracy(plan_encoded, optimised_encoded)\n    ranked.append((name, difference))\n\nranked = sorted(ranked, key=lambda x: x[1], reverse=True)\n\nfor name, score in ranked:\n    print(name, score)\n</pre> ranked = [] for name, plan, optimised in zip([\"Ahmed\", \"Brenda\", \"Cookie\"], plans, optimised_by_grid):     plan_encoded = encode.plan_to_one_hot(plan, mapping, bin_size=900)     optimised_encoded = encode.plan_to_one_hot(optimised, mapping, bin_size=900)     difference = distance.accuracy(plan_encoded, optimised_encoded)     ranked.append((name, difference))  ranked = sorted(ranked, key=lambda x: x[1], reverse=True)  for name, score in ranked:     print(name, score) <pre>Ahmed 0.7916666666666666\nBrenda 0.75\nCookie 0.6041666666666666\n</pre> <p>Ahmed's plan has changed most. This could be interpretted as them having the \"worst configuration\".</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#plan-rescheduling","title":"Plan Rescheduling\u00b6","text":"<p>This notebook shows how plans can be rescheduled (activity start times and duration changed). For this example we change some example plans in order to optimise each plan score. We use a scoring function based on the MATSim Charypar-Nagel score.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#step-1","title":"Step 1\u00b6","text":"<p>Configure the CharyparNagelPlanScorer. We use the Charypar-Nagel score to be consistent with MATSim, but you mighty decide to create your own.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#step-2","title":"Step 2\u00b6","text":"<p>Load or create some activity plans. In this example we create three persons plans, all with the same sequence of activities and same travel times, but with different activity start times and durations.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#step-3","title":"Step 3\u00b6","text":"<p>Score our plans. Note that for our example Brenda has the highest score.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#step-4","title":"Step 4\u00b6","text":"<p>Seek to reschedule the plans to improve their scores. We do this with the optimisers from <code>pam.optimise</code>.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#considering-different-scorers","title":"Considering Different Scorers\u00b6","text":"<p>As an experiment lets make a small change to our config file and check the outcome:</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#measuring-change","title":"Measuring Change\u00b6","text":"<p>The planner.encode module supports endoding plans in a way that they can be quantitively compared. This might be used as a systematic way to identify plans that are \"wrong\" or not correctly scored. In the following example we use a one-hot encoding of plans to show which of our example plans changes most when resheduled using the grid search:</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/","title":"Adding vehicles to plans","text":"In\u00a0[1]: Copied! <pre>import logging\nimport random\nfrom pathlib import Path\nfrom pprint import pprint\n\nfrom pam import read, write\nfrom pam.core import Person\nfrom pam.vehicles import ElectricVehicle, Vehicle, VehicleType\n</pre> import logging import random from pathlib import Path from pprint import pprint  from pam import read, write from pam.core import Person from pam.vehicles import ElectricVehicle, Vehicle, VehicleType In\u00a0[2]: Copied! <pre># load up example population\ndata_path = Path(\"data/example_data/vehicles\")\npopulation = read.read_matsim(data_path / \"example_plans.xml\")\npopulation.stats\n</pre> # load up example population data_path = Path(\"data/example_data/vehicles\") population = read.read_matsim(data_path / \"example_plans.xml\") population.stats Out[2]: <pre>{'num_households': 51,\n 'num_people': 51,\n 'num_activities': 153,\n 'num_legs': 102}</pre> In\u00a0[3]: Copied! <pre># now we randomly assign some vehicles and electric vehicles using these types\n\nfor hid, pid, p in population.people():\n    if random.random() &lt; 0.2:  # 20% change of having an ev\n        # evs have the type \"small_car\"\n        p.vehicles = {\"car\": ElectricVehicle(pid, type_id=\"small_car\", battery_capacity=100)}\n    else:\n        if random.random() &lt; 0.5:  # 40% change of having a regular vehicle of type \"small_car\"\n            p.vehicles = {\"car\": Vehicle(pid, type_id=\"small_car\")}\n        else:  # 40% change of having a vehicle of type \"ev\"\n            p.vehicles = {\"car\": Vehicle(pid, type_id=\"large_car\")}\n\n    # note that we specify the key as \"car\" as this is the transport \"mode\"\n</pre> # now we randomly assign some vehicles and electric vehicles using these types  for hid, pid, p in population.people():     if random.random() &lt; 0.2:  # 20% change of having an ev         # evs have the type \"small_car\"         p.vehicles = {\"car\": ElectricVehicle(pid, type_id=\"small_car\", battery_capacity=100)}     else:         if random.random() &lt; 0.5:  # 40% change of having a regular vehicle of type \"small_car\"             p.vehicles = {\"car\": Vehicle(pid, type_id=\"small_car\")}         else:  # 40% change of having a vehicle of type \"ev\"             p.vehicles = {\"car\": Vehicle(pid, type_id=\"large_car\")}      # note that we specify the key as \"car\" as this is the transport \"mode\" <p>Pam expects each person to contain their vehicles as a dictionary, mapping the mode of the vehicle (eg \"car\") to the vehicle. Vehicles (both regular and electric) must minimally define a unique vehicle id (<code>vid</code>) and a type (<code>type_id</code>).</p> <p>Please note that MATSim will not support a person having more than one vehicle for a mode. However if we plan to run a complex multi-modal MATSim simulation, then we might define multiple modes (taking care to maintain unique identifiers for each vehicle):</p> In\u00a0[4]: Copied! <pre>person = Person(\"0\")\nperson.vehicles = {\n    \"car\": Vehicle(\"car_0\", \"small_car\"),\n    \"taxi\": Vehicle(\"taxi_0\", \"large_car\"),\n    \"bike\": Vehicle(\"bike_0\", \"pedal_bike\"),\n}\n</pre> person = Person(\"0\") person.vehicles = {     \"car\": Vehicle(\"car_0\", \"small_car\"),     \"taxi\": Vehicle(\"taxi_0\", \"large_car\"),     \"bike\": Vehicle(\"bike_0\", \"pedal_bike\"), } <p>Electric vehicles can contain additional information about the vehicle battery state and charger access. These are designed to work with the MATSim electric vehicles extension:</p> In\u00a0[5]: Copied! <pre>person = Person(\"1\")\nperson.vehicles = {\n    \"car\": ElectricVehicle(\n        vid=\"car_0\",\n        type_id=\"small_car\",\n        battery_capacity=60,  # kWh\n        initial_soc=60,  # kWh\n        charger_types=\"default\",  # supported charger types; comma-separated list: 'default,other'\n    )\n}\n</pre> person = Person(\"1\") person.vehicles = {     \"car\": ElectricVehicle(         vid=\"car_0\",         type_id=\"small_car\",         battery_capacity=60,  # kWh         initial_soc=60,  # kWh         charger_types=\"default\",  # supported charger types; comma-separated list: 'default,other'     ) } In\u00a0[6]: Copied! <pre># first define some vehicle types and add them to the population via the vehicles_manager\npopulation.add_veh_type(VehicleType(\"small_car\"))\npopulation.add_veh_type(VehicleType(\"large_car\", length=15, width=2))\npopulation.add_veh_type(VehicleType(\"pedal_bike\", length=2, width=1))\n</pre> # first define some vehicle types and add them to the population via the vehicles_manager population.add_veh_type(VehicleType(\"small_car\")) population.add_veh_type(VehicleType(\"large_car\", length=15, width=2)) population.add_veh_type(VehicleType(\"pedal_bike\", length=2, width=1)) <p>The population has a vehicles manager will be ultimately responsible for managing our vehicles and their types, including reading and writing them from MATSim format. We can check for consistency between person vehicles and population vehicle types:</p> In\u00a0[7]: Copied! <pre>assert population.check_vehicles()\n</pre> assert population.check_vehicles() <p>So far we are using a lot of default values (especially for the ElectricVehicles). Defaults follow the same defaults as defined in MATSim's dtd files; vehicleDefinitions_v2.0.xsd and electric_vehicles_v1.dtd.</p> In\u00a0[8]: Copied! <pre>logging.basicConfig()\nlogging.getLogger().setLevel(logging.INFO)\n\nwrite.write_matsim(\n    population,\n    plans_path=\"./tmp/plans.xml\",\n    vehs_path=\"./tmp/vehicles.xml\",\n    evs_path=\"./tmp/evs.xml\",\n)\n</pre> logging.basicConfig() logging.getLogger().setLevel(logging.INFO)  write.write_matsim(     population,     plans_path=\"./tmp/plans.xml\",     vehs_path=\"./tmp/vehicles.xml\",     evs_path=\"./tmp/evs.xml\", ) <pre>INFO:root:Building population vehicles output.\nINFO:root:Writing vehicle types to ./tmp/vehicles.xml\nINFO:root:Writing vehicles to ./tmp/vehicles.xml\nINFO:root:Writing electric vehicles to ./tmp/evs.xml\n</pre> <p>Because MATSim has very strict requirements about vehicle identities and types, we also provide a \"safer\" interface for adding vehicles, which ensures that vehicle ids are unique and types defined:</p> In\u00a0[9]: Copied! <pre>population.add_veh(\"census_0\", \"census_0\", \"car\", Vehicle(\"0\", \"large_car\"))\n\ntry:\n    population.add_veh(\"census_1\", \"census_1\", \"car\", Vehicle(\"0\", \"large_car\"))\nexcept Exception as e:\n    print(e)\n\ntry:\n    population.add_veh(\"census_1\", \"census_1\", \"car\", Vehicle(\"1\", \"flying_car\"))\nexcept Exception as e:\n    print(e)\n</pre> population.add_veh(\"census_0\", \"census_0\", \"car\", Vehicle(\"0\", \"large_car\"))  try:     population.add_veh(\"census_1\", \"census_1\", \"car\", Vehicle(\"0\", \"large_car\")) except Exception as e:     print(e)  try:     population.add_veh(\"census_1\", \"census_1\", \"car\", Vehicle(\"1\", \"flying_car\")) except Exception as e:     print(e) <pre>Unable to add vehicle with duplicate vehicle id (vid): 0\nUnable to add vehicle with unknown type: 'flying_car'.\n</pre> <p>This interface is a little clunky and slow (it checks all existing ids each time), so we don't use in the following example.</p> In\u00a0[10]: Copied! <pre>population = read.read_matsim(\n    plans_path=data_path / \"plans.xml\",\n    all_vehicles_path=data_path / \"vehicles.xml\",\n    electric_vehicles_path=data_path / \"evs.xml\",\n)\n</pre> population = read.read_matsim(     plans_path=data_path / \"plans.xml\",     all_vehicles_path=data_path / \"vehicles.xml\",     electric_vehicles_path=data_path / \"evs.xml\", ) In\u00a0[11]: Copied! <pre>pprint(population.vehicle_types)\nprint(\n    f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\"\n)\nprint(f\"Population has {len(list(population.evs()))} evs.\")\n</pre> pprint(population.vehicle_types) print(     f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\" ) print(f\"Population has {len(list(population.evs()))} evs.\") <pre>{'large_car': VehicleType(id='large_car',\n                          length=15.0,\n                          width=2.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0),\n 'small_car': VehicleType(id='small_car',\n                          length=7.5,\n                          width=1.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0)}\nPopulation has 31 small cars.\nPopulation has 11 evs.\n</pre> In\u00a0[12]: Copied! <pre># 50% chance of large_car type switching to small_car\nfor _, pid, person in population.people():\n    veh = person.vehicles.get(\"car\")\n    if isinstance(veh, Vehicle) and veh.type_id == \"large_car\":\n        if random.random() &lt; 0.5:\n            person.vehicles[\"car\"] = Vehicle(pid, \"small_car\")\n</pre> # 50% chance of large_car type switching to small_car for _, pid, person in population.people():     veh = person.vehicles.get(\"car\")     if isinstance(veh, Vehicle) and veh.type_id == \"large_car\":         if random.random() &lt; 0.5:             person.vehicles[\"car\"] = Vehicle(pid, \"small_car\") In\u00a0[13]: Copied! <pre>pprint(population.vehicle_types)\npprint(population.random_person().vehicles)\nprint(\n    f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\"\n)\nprint(f\"Population has {len(list(population.evs()))} evs.\")\n</pre> pprint(population.vehicle_types) pprint(population.random_person().vehicles) print(     f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\" ) print(f\"Population has {len(list(population.evs()))} evs.\") <pre>{'large_car': VehicleType(id='large_car',\n                          length=15.0,\n                          width=2.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0),\n 'small_car': VehicleType(id='small_car',\n                          length=7.5,\n                          width=1.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0)}\n{'car': Vehicle(vid='census_29', type_id='large_car')}\nPopulation has 37 small cars.\nPopulation has 11 evs.\n</pre> In\u00a0[14]: Copied! <pre># 10% chance of small_car type switching to electric vehicle\nfor _, pid, person in population.people():\n    veh = person.vehicles.get(\"car\")\n    if isinstance(veh, Vehicle) and veh.type_id == \"small_car\":\n        if random.random() &lt; 0.5:\n            person.vehicles[\"car\"] = ElectricVehicle(pid, \"small_car\")\n</pre> # 10% chance of small_car type switching to electric vehicle for _, pid, person in population.people():     veh = person.vehicles.get(\"car\")     if isinstance(veh, Vehicle) and veh.type_id == \"small_car\":         if random.random() &lt; 0.5:             person.vehicles[\"car\"] = ElectricVehicle(pid, \"small_car\") In\u00a0[15]: Copied! <pre>pprint(population.vehicle_types)\nprint(\n    f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\"\n)\nprint(f\"Population has {len(list(population.evs()))} evs.\")\n</pre> pprint(population.vehicle_types) print(     f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\" ) print(f\"Population has {len(list(population.evs()))} evs.\") <pre>{'large_car': VehicleType(id='large_car',\n                          length=15.0,\n                          width=2.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0),\n 'small_car': VehicleType(id='small_car',\n                          length=7.5,\n                          width=1.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0)}\nPopulation has 37 small cars.\nPopulation has 24 evs.\n</pre> In\u00a0[16]: Copied! <pre>logging.basicConfig()\nlogging.getLogger().setLevel(logging.INFO)\n\nwrite.write_matsim(\n    population,\n    plans_path=\"./tmp/plans.xml\",\n    vehs_path=\"./tmp/vehicles.xml\",\n    evs_path=\"./tmp/evs.xml\",\n)\n</pre> logging.basicConfig() logging.getLogger().setLevel(logging.INFO)  write.write_matsim(     population,     plans_path=\"./tmp/plans.xml\",     vehs_path=\"./tmp/vehicles.xml\",     evs_path=\"./tmp/evs.xml\", ) <pre>INFO:root:Building population vehicles output.\nINFO:root:Writing vehicle types to ./tmp/vehicles.xml\nINFO:root:Writing vehicles to ./tmp/vehicles.xml\nINFO:root:Writing electric vehicles to ./tmp/evs.xml\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/12_Advanced_Adding_Vehicles/#adding-vehicles-to-plans","title":"Adding vehicles to plans\u00b6","text":"<p>In this example, we show how an existing set of plans can be updated to include additional vehicles.</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/#giving-agents-vehicles","title":"Giving agents vehicles\u00b6","text":"<p>A simple approach is to create some vehicles and assign them to our agents</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/#vehicle-types","title":"Vehicle types\u00b6","text":"<p>If we want to write our vehicles to MATSim format, then we need to also define the vehicle types. In the above examples we described three vehicle types, a <code>small_car</code>, <code>large_car</code>, and <code>pedal_bike</code>. We define these types by adding them to the population:</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/#writing-to-matsim-format","title":"Writing to MATSim format\u00b6","text":"<p>We can use the standard pam.write to write these vehicle formats to disk by providing a vehicles and, optionally, an electric vehciles path.</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/#modifying-vehicles-in-existing-matsim-population","title":"Modifying vehicles in existing MATSim population\u00b6","text":"<p>Pam can also read vehicles (and electric vehicles) from an existing MATSim population. These can then be checked and/or modified before writing a new population.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/","title":"Freight Synthesis","text":"In\u00a0[1]: Copied! <pre>import os\nfrom datetime import date\n\nimport geopandas as gp\nimport matplotlib\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom pam.core import Household, Person, Population\nfrom pam.samplers import tour\nfrom pam.samplers.facility import FacilitySampler\n\nmatplotlib.style.use(\"ggplot\")\n</pre> import os from datetime import date  import geopandas as gp import matplotlib import numpy as np import pandas as pd from matplotlib import pyplot as plt  from pam.core import Household, Person, Population from pam.samplers import tour from pam.samplers.facility import FacilitySampler  matplotlib.style.use(\"ggplot\") In\u00a0[2]: Copied! <pre>output_path = \"./data/outputs\"\n</pre> output_path = \"./data/outputs\" In\u00a0[3]: Copied! <pre>zones = gp.read_file(\"./data/lsoas/LSOA_2004_London_Low_Resolution.shp\")\nzones = zones.set_crs(\"EPSG:27700\", allow_override=True)\nzones = zones.rename(columns={\"LSOA_CODE\": \"zone\"})\nzones.plot()\nplt.show()\n</pre> zones = gp.read_file(\"./data/lsoas/LSOA_2004_London_Low_Resolution.shp\") zones = zones.set_crs(\"EPSG:27700\", allow_override=True) zones = zones.rename(columns={\"LSOA_CODE\": \"zone\"}) zones.plot() plt.show() In\u00a0[4]: Copied! <pre># load facilities\nfacilities = gp.read_file(\"./data/londinium_facilities_sample.geojson\")\nfacilities = facilities.set_crs(\"EPSG:27700\", allow_override=True)\n\n# dummy create depots and deliveries\nfacilities[\"activity\"] = np.where(facilities[\"activity\"] == \"shop\", \"depot\", facilities[\"activity\"])\nfacilities[\"activity\"] = np.where(\n    facilities[\"activity\"] == \"leisure\", \"delivery\", facilities[\"activity\"]\n)\n\nfacilities.plot()\n</pre> # load facilities facilities = gp.read_file(\"./data/londinium_facilities_sample.geojson\") facilities = facilities.set_crs(\"EPSG:27700\", allow_override=True)  # dummy create depots and deliveries facilities[\"activity\"] = np.where(facilities[\"activity\"] == \"shop\", \"depot\", facilities[\"activity\"]) facilities[\"activity\"] = np.where(     facilities[\"activity\"] == \"leisure\", \"delivery\", facilities[\"activity\"] )  facilities.plot() Out[4]: <pre>&lt;Axes: &gt;</pre> <p>The zones data is for all of London, below, we crop the zones data to the Londinium study area.</p> In\u00a0[5]: Copied! <pre>cols = list(zones.columns)\n\nzones_londinium = gp.sjoin(zones, facilities, how=\"inner\", predicate=\"intersects\")\nzones_londinium = zones_londinium[cols]\nzones = zones_londinium.drop_duplicates()\nzones = zones.set_index(\"zone\")\n</pre> cols = list(zones.columns)  zones_londinium = gp.sjoin(zones, facilities, how=\"inner\", predicate=\"intersects\") zones_londinium = zones_londinium[cols] zones = zones_londinium.drop_duplicates() zones = zones.set_index(\"zone\") In\u00a0[6]: Copied! <pre>facility_sampler = FacilitySampler(\n    facilities=facilities, zones=zones, build_xml=True, fail=False, random_default=True\n)\n\nfacility_sampler.activities\n</pre> facility_sampler = FacilitySampler(     facilities=facilities, zones=zones, build_xml=True, fail=False, random_default=True )  facility_sampler.activities <pre>Joining facilities data to zones, this may take a while.\nBuilding sampler, this may take a while.\n</pre> Out[6]: <pre>['park',\n 'gym',\n 'pub',\n 'other',\n 'depot',\n 'medical',\n 'work',\n 'transit',\n 'education',\n 'home',\n 'delivery']</pre> In\u00a0[7]: Copied! <pre># Create a facility zone dataset to be used in samplers\nfacility_zone = gp.sjoin(facilities, zones, how=\"inner\", predicate=\"intersects\")\nfacility_zone = facility_zone.rename(columns={\"index_right\": \"zone\"})\nfacility_zone = facility_zone.set_index(\"zone\")\n</pre> # Create a facility zone dataset to be used in samplers facility_zone = gp.sjoin(facilities, zones, how=\"inner\", predicate=\"intersects\") facility_zone = facility_zone.rename(columns={\"index_right\": \"zone\"}) facility_zone = facility_zone.set_index(\"zone\") In\u00a0[8]: Copied! <pre>bins = range(3, 12)\npivots = {3: 36.0, 4: 28.0, 5: 15.0, 6: 7.0, 7: 4.0, 8: 2.5, 9: 2.5, 10: 1.0, 11: 4.0}\nstop_sampler = tour.PivotDistributionSampler(bins=bins, pivots=pivots)\nstop_sampler.plot(plot_title=\"Stops Distribution\", x_label=\"Stops\", y_label=\"Frequency\")\n</pre> bins = range(3, 12) pivots = {3: 36.0, 4: 28.0, 5: 15.0, 6: 7.0, 7: 4.0, 8: 2.5, 9: 2.5, 10: 1.0, 11: 4.0} stop_sampler = tour.PivotDistributionSampler(bins=bins, pivots=pivots) stop_sampler.plot(plot_title=\"Stops Distribution\", x_label=\"Stops\", y_label=\"Frequency\") Out[8]: In\u00a0[9]: Copied! <pre># Set up freight params for both LGV and HGV movements\nlgv_params = {\n    \"total\": 2500,\n    \"pivots\": {\n        7: 14,\n        8: 9,\n        9: 13,\n        10: 16,\n        11: 18,\n        12: 13,\n        13: 15,\n        14: 16,\n        15: 14,\n        16: 13,\n        17: 9,\n        18: 5,\n        19: 3,\n        20: 3,\n        21: 3,\n        22: 2,\n    },\n    \"agent_id\": \"LGV\",\n    \"agent_attributes\": \"lgv\",\n}\n</pre> # Set up freight params for both LGV and HGV movements lgv_params = {     \"total\": 2500,     \"pivots\": {         7: 14,         8: 9,         9: 13,         10: 16,         11: 18,         12: 13,         13: 15,         14: 16,         15: 14,         16: 13,         17: 9,         18: 5,         19: 3,         20: 3,         21: 3,         22: 2,     },     \"agent_id\": \"LGV\",     \"agent_attributes\": \"lgv\", } <p>Below, we decide if we will use the LGV or HGV parameters defined above.</p> In\u00a0[10]: Copied! <pre>freight_params = lgv_params.copy()\n</pre> freight_params = lgv_params.copy() In\u00a0[11]: Copied! <pre># Create Distribution\nbins = range(0, 24)\n\nhour_sampler = tour.PivotDistributionSampler(\n    bins=bins, pivots=freight_params[\"pivots\"], total=freight_params[\"total\"]\n)\nhour_sampler.plot(\n    plot_title=f\"{freight_params['agent_id']} Distribution\", x_label=\"Hour\", y_label=\"Frequency\"\n)\n</pre> # Create Distribution bins = range(0, 24)  hour_sampler = tour.PivotDistributionSampler(     bins=bins, pivots=freight_params[\"pivots\"], total=freight_params[\"total\"] ) hour_sampler.plot(     plot_title=f\"{freight_params['agent_id']} Distribution\", x_label=\"Hour\", y_label=\"Frequency\" ) Out[11]: In\u00a0[12]: Copied! <pre># Create a minute sampler\nminute_sampler = tour.FrequencySampler(range(60))\nminute_sampler.sample()\n</pre> # Create a minute sampler minute_sampler = tour.FrequencySampler(range(60)) minute_sampler.sample() Out[12]: <pre>24</pre> In\u00a0[13]: Copied! <pre>origin_density = tour.create_density_gdf(\n    facility_zone=facility_zone, zone=zones, activity=[\"depot\"]\n)\ndestination_density = tour.create_density_gdf(\n    facility_zone=facility_zone, zone=zones, activity=[\"delivery\"]\n)\n</pre> origin_density = tour.create_density_gdf(     facility_zone=facility_zone, zone=zones, activity=[\"depot\"] ) destination_density = tour.create_density_gdf(     facility_zone=facility_zone, zone=zones, activity=[\"delivery\"] ) In\u00a0[14]: Copied! <pre># Input Demand, in this case defined as facility density location\ndepot_sampler = tour.FrequencySampler(origin_density.index, origin_density.density)\n</pre> # Input Demand, in this case defined as facility density location depot_sampler = tour.FrequencySampler(origin_density.index, origin_density.density) In\u00a0[15]: Copied! <pre># Constraint, defined as distance between origin and destination centroids. This dataframe will be filtered based on threshold values defined later.\nzones_list = np.array(zones.centroid.apply(lambda x: [x.x, x.y]).to_list())\nod_matrix = np.linalg.norm(zones_list[:, None, :] - zones_list[None, :, :], axis=-1)\ndf_od = pd.DataFrame(od_matrix, index=zones.index, columns=zones.index)\n</pre> # Constraint, defined as distance between origin and destination centroids. This dataframe will be filtered based on threshold values defined later. zones_list = np.array(zones.centroid.apply(lambda x: [x.x, x.y]).to_list()) od_matrix = np.linalg.norm(zones_list[:, None, :] - zones_list[None, :, :], axis=-1) df_od = pd.DataFrame(od_matrix, index=zones.index, columns=zones.index) <pre>/Users/bryn.pickering/mambaforge/envs/pam/lib/python3.11/site-packages/geopandas/geoseries.py:645: FutureWarning: the convert_dtype parameter is deprecated and will be removed in a future version.  Do ``ser.astype(object).apply()`` instead if you want ``convert_dtype=False``.\n  result = super().apply(func, convert_dtype=convert_dtype, args=args, **kwargs)\n</pre> In\u00a0[16]: Copied! <pre># Factor to scale trips (To better match validation counts when needed)\nfactor = 1\n\n# Sample Size\nsamples = [0.1]  # increase\n\n# Set Distance threshold, in this case arbitrarily set to median distance of od dataframe.\nthreshold_value = df_od.median().agg(\"median\")\n\n# used for fnames\ntoday = date.today().strftime(\"%d%b%y\")\ntoday\n</pre> # Factor to scale trips (To better match validation counts when needed) factor = 1  # Sample Size samples = [0.1]  # increase  # Set Distance threshold, in this case arbitrarily set to median distance of od dataframe. threshold_value = df_od.median().agg(\"median\")  # used for fnames today = date.today().strftime(\"%d%b%y\") today Out[16]: <pre>'29Sep23'</pre> In\u00a0[17]: Copied! <pre>#### Sample Agents\n\n\ndef sample_agents(size):\n    facility_sampler.clear()\n    population = Population()\n\n    for i in range(size):\n        agent_id = f\"{freight_params['agent_id']}_{i}\"\n        hh = Household(agent_id)\n\n        agent = Person(\n            agent_id,\n            freq=100,\n            attributes={\n                \"subpopulation\": freight_params[\"agent_attributes\"],\n                \"CarType\": freight_params[\"agent_attributes\"],\n                \"CarCO2\": freight_params[\"agent_attributes\"],\n            },\n        )\n\n        hh.add(agent)\n        population.add(hh)\n\n        hour = hour_sampler.sample()\n        minute = minute_sampler.sample()\n        o_zone = depot_sampler.sample()\n\n        stops = stop_sampler.sample() if freight_params[\"agent_id\"] == \"LGV\" else 1\n\n        agent_plan = tour.TourPlanner(\n            stops=stops,\n            hour=hour,\n            minute=minute,\n            o_zone=o_zone,\n            d_dist=destination_density,\n            d_freq=\"density\",\n            threshold_matrix=df_od,\n            threshold_value=threshold_value,\n            facility_sampler=facility_sampler,\n            activity_params={\"o_activity\": \"depot\", \"d_activity\": \"delivery\"},\n        )\n\n        o_loc, d_zones, d_locs = agent_plan.sequence_stops()\n        agent_plan.apply(agent=agent, o_loc=o_loc, d_zones=d_zones, d_locs=d_locs)\n\n    return population\n</pre> #### Sample Agents   def sample_agents(size):     facility_sampler.clear()     population = Population()      for i in range(size):         agent_id = f\"{freight_params['agent_id']}_{i}\"         hh = Household(agent_id)          agent = Person(             agent_id,             freq=100,             attributes={                 \"subpopulation\": freight_params[\"agent_attributes\"],                 \"CarType\": freight_params[\"agent_attributes\"],                 \"CarCO2\": freight_params[\"agent_attributes\"],             },         )          hh.add(agent)         population.add(hh)          hour = hour_sampler.sample()         minute = minute_sampler.sample()         o_zone = depot_sampler.sample()          stops = stop_sampler.sample() if freight_params[\"agent_id\"] == \"LGV\" else 1          agent_plan = tour.TourPlanner(             stops=stops,             hour=hour,             minute=minute,             o_zone=o_zone,             d_dist=destination_density,             d_freq=\"density\",             threshold_matrix=df_od,             threshold_value=threshold_value,             facility_sampler=facility_sampler,             activity_params={\"o_activity\": \"depot\", \"d_activity\": \"delivery\"},         )          o_loc, d_zones, d_locs = agent_plan.sequence_stops()         agent_plan.apply(agent=agent, o_loc=o_loc, d_zones=d_zones, d_locs=d_locs)      return population In\u00a0[18]: Copied! <pre># Function to build population\n\n\ndef build_population(sample, factor):\n    population = sample_agents(int(factor * int(freight_params[\"total\"] * sample)))\n\n    return population\n</pre> # Function to build population   def build_population(sample, factor):     population = sample_agents(int(factor * int(freight_params[\"total\"] * sample)))      return population In\u00a0[19]: Copied! <pre># Build + Crop + Write Population for samples\nfor s in samples:\n    # build\n    population = build_population(s, factor)\n\n    # # Crop and Validate Plans\n    population.fix_plans()\n    population.validate()\n\n    # # Write to Disk\n    xml_comment = f\"prelim {s*100}% {freight_params['agent_id']} {today}\"\n    output_path = os.path.join(output_path)\n\n    population.to_csv(output_path, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\")\n</pre> # Build + Crop + Write Population for samples for s in samples:     # build     population = build_population(s, factor)      # # Crop and Validate Plans     population.fix_plans()     population.validate()      # # Write to Disk     xml_comment = f\"prelim {s*100}% {freight_params['agent_id']} {today}\"     output_path = os.path.join(output_path)      population.to_csv(output_path, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\") In\u00a0[20]: Copied! <pre>population.random_person().plot()\n</pre> population.random_person().plot() In\u00a0[21]: Copied! <pre>trips = pd.read_csv(os.path.join(output_path, \"legs.csv\"))\n\n\ndef get_hour(dt):\n    return int(dt.split(\" \")[1].split(\":\")[0])\n\n\ntrips[\"start_hour\"] = trips[\"tst\"].apply(get_hour)\n</pre> trips = pd.read_csv(os.path.join(output_path, \"legs.csv\"))   def get_hour(dt):     return int(dt.split(\" \")[1].split(\":\")[0])   trips[\"start_hour\"] = trips[\"tst\"].apply(get_hour) In\u00a0[22]: Copied! <pre>freight_density = tour.ValidateTourOD(\n    trips=trips,\n    zone=zones,\n    o_dist=origin_density,\n    d_dist=destination_density,\n    o_activity=\"depot\",\n    d_activity=\"delivery\",\n    o_freq=\"density\",\n    d_freq=\"density\",\n)\n</pre> freight_density = tour.ValidateTourOD(     trips=trips,     zone=zones,     o_dist=origin_density,     d_dist=destination_density,     o_activity=\"depot\",     d_activity=\"delivery\",     o_freq=\"density\",     d_freq=\"density\", ) In\u00a0[23]: Copied! <pre>freight_density.plot_validate_spatial_density(\n    title_1=\"Depot Density (origin)\",\n    title_2=\"Trips from Depot (origin)\",\n    density_metric=\"depot_density\",\n    density_trips=\"origin_trips\",\n)\n</pre> freight_density.plot_validate_spatial_density(     title_1=\"Depot Density (origin)\",     title_2=\"Trips from Depot (origin)\",     density_metric=\"depot_density\",     density_trips=\"origin_trips\", ) Out[23]: In\u00a0[24]: Copied! <pre>freight_density.plot_validate_spatial_density(\n    title_1=\"Delivery Density (destination)\",\n    title_2=\"Trips to Delivery (destination)\",\n    density_metric=\"delivery_density\",\n    density_trips=\"destination_trips\",\n)\n</pre> freight_density.plot_validate_spatial_density(     title_1=\"Delivery Density (destination)\",     title_2=\"Trips to Delivery (destination)\",     density_metric=\"delivery_density\",     density_trips=\"destination_trips\", ) Out[24]: In\u00a0[25]: Copied! <pre>freight_density.plot_compare_density(\n    title_1=\"Depot Density vs. Origin Trips\",\n    title_2=\"Delivery Density vs. Destination Trips\",\n    o_activity=\"depot_density\",\n    d_activity=\"delivery_density\",\n)\n</pre> freight_density.plot_compare_density(     title_1=\"Depot Density vs. Origin Trips\",     title_2=\"Delivery Density vs. Destination Trips\",     o_activity=\"depot_density\",     d_activity=\"delivery_density\", ) Out[25]:"},{"location":"examples/13_Advanced_Freight_Synthesis/#freight-synthesis","title":"Freight Synthesis\u00b6","text":"<p>This notebook simulates freight trips and generates a freight population file.</p> <p>The following steps are undertaken:</p> <ol> <li>Read, process, and plot data</li> <li>Input Assumptions &amp; Sampler Creation</li> <li>Create Activity Model &amp; Population</li> <li>Validation</li> </ol>"},{"location":"examples/13_Advanced_Freight_Synthesis/#1-read-process-plot-data","title":"1. Read, process, plot Data\u00b6","text":"<p>Below, we load in data required to build a tour plan: zones and facilities data.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#2-input-assumptions","title":"2. Input Assumptions\u00b6","text":"<p>We create a series of samplers that will serve as inputs into the activity model. These samplers include:</p> <ul> <li>Number of Stops</li> <li>Freight Hourly Demand</li> <li>Origin (in this case, Depot) location</li> </ul>"},{"location":"examples/13_Advanced_Freight_Synthesis/#number-of-stops","title":"Number of Stops\u00b6","text":"<p>Build a Stop Number distribution and corresponding sampler.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#freight-hourly-demand","title":"Freight Hourly Demand\u00b6","text":"<p>Hourly demand is a distribution created based on the pivots input. We use the class PivotDistributionSampler to translate 'pivots' into a distribution, plot, and sampler.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#input-demand-constraints","title":"Input Demand &amp; Constraints\u00b6","text":"<p>We calculate the density of depots and deliveries across all zones. This information will be utilised by the class FrequencySampler to create a distribution. We also create an origin/destination matrix of distances between centroids that will be used to selected the destination locations.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#3-activity-modeller","title":"3. Activity Modeller\u00b6","text":"<p>Parameters are defined to model a population of activity plans. Activities are encoded as \"car\". Subpopulation is encoded as \"lgv\" or \"hgv\".</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#population-parameters","title":"Population Parameters\u00b6","text":""},{"location":"examples/13_Advanced_Freight_Synthesis/#activity-modeller","title":"Activity Modeller\u00b6","text":""},{"location":"examples/13_Advanced_Freight_Synthesis/#4-validation","title":"4. Validation\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/","title":"Plan Cropping","text":"In\u00a0[1]: Copied! <pre>from copy import deepcopy\n\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Point, Polygon\n\nfrom pam.activity import Activity, Leg, Plan\nfrom pam.core import Household, Person, Population\nfrom pam.operations import cropping\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n</pre> from copy import deepcopy  import geopandas as gp import matplotlib.pyplot as plt from shapely.geometry import Point, Polygon  from pam.activity import Activity, Leg, Plan from pam.core import Household, Person, Population from pam.operations import cropping from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY <p>Create a simple zoning system:</p> In\u00a0[2]: Copied! <pre>def test_zoning_system() -&gt; gp.GeoDataFrame:\n    \"\"\"Dummy orthogonal zoning system.\"\"\"\n    zones = []\n    labels = [chr(x) for x in range(97, 106)]\n    for x in range(3):\n        for y in range(3):\n            zones.append(Polygon([(x, y), (x, y + 1), (x + 1, y + 1), (x + 1, y)]))\n    zones_gdf = gp.GeoDataFrame({\"zone\": labels}, geometry=zones)\n    zones_gdf.index = zones_gdf.zone\n\n    return zones_gdf\n\n\nzoning_system = test_zoning_system()\n</pre> def test_zoning_system() -&gt; gp.GeoDataFrame:     \"\"\"Dummy orthogonal zoning system.\"\"\"     zones = []     labels = [chr(x) for x in range(97, 106)]     for x in range(3):         for y in range(3):             zones.append(Polygon([(x, y), (x, y + 1), (x + 1, y + 1), (x + 1, y)]))     zones_gdf = gp.GeoDataFrame({\"zone\": labels}, geometry=zones)     zones_gdf.index = zones_gdf.zone      return zones_gdf   zoning_system = test_zoning_system() <p>Create a simple plan:</p> In\u00a0[3]: Copied! <pre>plan = Plan()\nplan.day = [\n    Activity(seq=1, act=\"home\", loc=Point(0.31, 0.81), start_time=mtdt(0), end_time=mtdt(420)),\n    Leg(\n        seq=1,\n        mode=\"car\",\n        start_loc=Point(0.31, 0.81),\n        end_loc=Point(0.12, 1.45),\n        start_time=mtdt(420),\n        end_time=mtdt(480),\n        distance=1000,\n    ),\n    Activity(seq=2, act=\"shop\", loc=Point(0.12, 1.45), start_time=mtdt(480), end_time=mtdt(510)),\n    Leg(\n        seq=2,\n        mode=\"car\",\n        start_loc=Point(0.12, 1.45),\n        end_loc=Point(0.84, 2.12),\n        start_time=mtdt(510),\n        end_time=mtdt(540),\n        distance=1000,\n    ),\n    Activity(seq=3, act=\"work\", loc=Point(0.84, 2.12), start_time=mtdt(540), end_time=mtdt(800)),\n    Leg(\n        seq=3,\n        mode=\"walk\",\n        start_loc=Point(0.84, 2.12),\n        end_loc=Point(1.90, 0.23),\n        start_time=mtdt(800),\n        end_time=mtdt(900),\n        distance=1000,\n    ),\n    Activity(seq=4, act=\"medical\", loc=Point(1.90, 0.23), start_time=mtdt(900), end_time=mtdt(960)),\n    Leg(\n        seq=4,\n        mode=\"walk\",\n        start_loc=Point(1.90, 0.23),\n        end_loc=Point(2.26, 0.24),\n        start_time=mtdt(960),\n        end_time=mtdt(990),\n        distance=1000,\n    ),\n    Activity(seq=5, act=\"other\", loc=Point(2.26, 0.24), start_time=mtdt(990), end_time=mtdt(1010)),\n    Leg(\n        seq=5,\n        mode=\"walk\",\n        start_loc=Point(2.26, 0.24),\n        end_loc=Point(2.77, 1.82),\n        start_time=mtdt(1010),\n        end_time=mtdt(1030),\n        distance=1000,\n    ),\n    Activity(seq=6, act=\"other\", loc=Point(2.77, 1.82), start_time=mtdt(1030), end_time=mtdt(1060)),\n    Leg(\n        seq=6,\n        mode=\"walk\",\n        start_loc=Point(2.77, 1.82),\n        end_loc=Point(1.88, 1.72),\n        start_time=mtdt(1060),\n        end_time=mtdt(1100),\n        distance=1000,\n    ),\n    Activity(seq=7, act=\"other\", loc=Point(1.88, 1.72), start_time=mtdt(1100), end_time=mtdt(1200)),\n    Leg(\n        seq=7,\n        mode=\"car\",\n        start_loc=Point(1.88, 1.72),\n        end_loc=Point(0.23, 0.10),\n        start_time=mtdt(1200),\n        end_time=mtdt(1210),\n        distance=1000,\n    ),\n    Activity(seq=8, act=\"home\", loc=Point(0.23, 0.10), start_time=mtdt(1210), end_time=END_OF_DAY),\n]\n\nhh = Household(1, loc=Point(0.31, 0.81))\npopulation = Population()\nperson = Person(1)\nperson.plan = plan\nhh.add(person)\npopulation.add(hh)\n</pre> plan = Plan() plan.day = [     Activity(seq=1, act=\"home\", loc=Point(0.31, 0.81), start_time=mtdt(0), end_time=mtdt(420)),     Leg(         seq=1,         mode=\"car\",         start_loc=Point(0.31, 0.81),         end_loc=Point(0.12, 1.45),         start_time=mtdt(420),         end_time=mtdt(480),         distance=1000,     ),     Activity(seq=2, act=\"shop\", loc=Point(0.12, 1.45), start_time=mtdt(480), end_time=mtdt(510)),     Leg(         seq=2,         mode=\"car\",         start_loc=Point(0.12, 1.45),         end_loc=Point(0.84, 2.12),         start_time=mtdt(510),         end_time=mtdt(540),         distance=1000,     ),     Activity(seq=3, act=\"work\", loc=Point(0.84, 2.12), start_time=mtdt(540), end_time=mtdt(800)),     Leg(         seq=3,         mode=\"walk\",         start_loc=Point(0.84, 2.12),         end_loc=Point(1.90, 0.23),         start_time=mtdt(800),         end_time=mtdt(900),         distance=1000,     ),     Activity(seq=4, act=\"medical\", loc=Point(1.90, 0.23), start_time=mtdt(900), end_time=mtdt(960)),     Leg(         seq=4,         mode=\"walk\",         start_loc=Point(1.90, 0.23),         end_loc=Point(2.26, 0.24),         start_time=mtdt(960),         end_time=mtdt(990),         distance=1000,     ),     Activity(seq=5, act=\"other\", loc=Point(2.26, 0.24), start_time=mtdt(990), end_time=mtdt(1010)),     Leg(         seq=5,         mode=\"walk\",         start_loc=Point(2.26, 0.24),         end_loc=Point(2.77, 1.82),         start_time=mtdt(1010),         end_time=mtdt(1030),         distance=1000,     ),     Activity(seq=6, act=\"other\", loc=Point(2.77, 1.82), start_time=mtdt(1030), end_time=mtdt(1060)),     Leg(         seq=6,         mode=\"walk\",         start_loc=Point(2.77, 1.82),         end_loc=Point(1.88, 1.72),         start_time=mtdt(1060),         end_time=mtdt(1100),         distance=1000,     ),     Activity(seq=7, act=\"other\", loc=Point(1.88, 1.72), start_time=mtdt(1100), end_time=mtdt(1200)),     Leg(         seq=7,         mode=\"car\",         start_loc=Point(1.88, 1.72),         end_loc=Point(0.23, 0.10),         start_time=mtdt(1200),         end_time=mtdt(1210),         distance=1000,     ),     Activity(seq=8, act=\"home\", loc=Point(0.23, 0.10), start_time=mtdt(1210), end_time=END_OF_DAY), ]  hh = Household(1, loc=Point(0.31, 0.81)) population = Population() person = Person(1) person.plan = plan hh.add(person) population.add(hh) <p>The core area scope is defined as a geometry:</p> In\u00a0[4]: Copied! <pre>def plot_legs(plan: Plan):\n    for i, leg in enumerate(plan.legs):\n        path = cropping.get_leg_path(leg)\n        plt.annotate(\n            i,\n            xy=(path.xy[0][1], path.xy[1][1]),\n            xytext=(path.xy[0][0], path.xy[1][0]),\n            arrowprops={\"arrowstyle\": \"-&gt;\", \"color\": \"gray\"},\n        )\n</pre> def plot_legs(plan: Plan):     for i, leg in enumerate(plan.legs):         path = cropping.get_leg_path(leg)         plt.annotate(             i,             xy=(path.xy[0][1], path.xy[1][1]),             xytext=(path.xy[0][0], path.xy[1][0]),             arrowprops={\"arrowstyle\": \"-&gt;\", \"color\": \"gray\"},         ) In\u00a0[5]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(10, 10))\nzoning_system.boundary.plot(ax=ax)\nfor _i, irow in zoning_system.iterrows():\n    x = irow.geometry.centroid.x\n    y = irow.geometry.centroid.y\n    plt.annotate(irow.zone, xy=(x, y))\nplot_legs(plan)\n\nplan.plot()\n</pre> fig, ax = plt.subplots(1, 1, figsize=(10, 10)) zoning_system.boundary.plot(ax=ax) for _i, irow in zoning_system.iterrows():     x = irow.geometry.centroid.x     y = irow.geometry.centroid.y     plt.annotate(irow.zone, xy=(x, y)) plot_legs(plan)  plan.plot() <p>Trips that enter or exit the core area (here, zone <code>h</code>) are kept in the agent's plan:</p> In\u00a0[6]: Copied! <pre>boundary = zoning_system.loc[\"h\"].geometry\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n</pre> boundary = zoning_system.loc[\"h\"].geometry  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary) In\u00a0[7]: Copied! <pre>def plot_results(plan: Plan, boundary: gp.GeoDataFrame):\n    fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n    zoning_system.boundary.plot(ax=ax)\n    for _i, irow in zoning_system.iterrows():\n        x = irow.geometry.centroid.x\n        y = irow.geometry.centroid.y\n        plt.annotate(irow.zone, xy=(x, y))\n    gp.GeoSeries([boundary]).boundary.plot(ax=ax, color=\"red\")\n    plot_legs(plan)\n    plt.title(\"Cropped plan\")\n\n    plan.plot()\n\n\nplot_results(plan_cropped, boundary)\n</pre> def plot_results(plan: Plan, boundary: gp.GeoDataFrame):     fig, ax = plt.subplots(1, 1, figsize=(10, 10))     zoning_system.boundary.plot(ax=ax)     for _i, irow in zoning_system.iterrows():         x = irow.geometry.centroid.x         y = irow.geometry.centroid.y         plt.annotate(irow.zone, xy=(x, y))     gp.GeoSeries([boundary]).boundary.plot(ax=ax, color=\"red\")     plot_legs(plan)     plt.title(\"Cropped plan\")      plan.plot()   plot_results(plan_cropped, boundary) <p>Any trips that are expected to go through the core area (as a straight-line path) are retained in the plan:</p> In\u00a0[8]: Copied! <pre># define boundary\nboundary = zoning_system.loc[\"e\"].geometry\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n\n\nplot_results(plan_cropped, boundary)\n</pre> # define boundary boundary = zoning_system.loc[\"e\"].geometry  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)   plot_results(plan_cropped, boundary) <pre>/Users/bryn.pickering/mambaforge/envs/pam/lib/python3.11/site-packages/shapely/predicates.py:798: RuntimeWarning: invalid value encountered in intersects\n  return lib.intersects(a, b, **kwargs)\n</pre> <p>By passing the <code>snap_to_boundary=True</code> argument, we can completely remove any leg parts that fall outside the core area:</p> In\u00a0[9]: Copied! <pre># crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary, snap_to_boundary=True)\n\n# plot\nplot_results(plan_cropped, boundary)\n</pre> # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary, snap_to_boundary=True)  # plot plot_results(plan_cropped, boundary) <pre>/Users/bryn.pickering/mambaforge/envs/pam/lib/python3.11/site-packages/shapely/predicates.py:798: RuntimeWarning: invalid value encountered in intersects\n  return lib.intersects(a, b, **kwargs)\n/Users/bryn.pickering/mambaforge/envs/pam/lib/python3.11/site-packages/shapely/set_operations.py:133: RuntimeWarning: invalid value encountered in intersection\n  return lib.intersection(a, b, **kwargs)\n</pre> <p>If no leg crosses the core area (here, zone i), then an empty plan is returned, and the person is removed from the population:</p> In\u00a0[10]: Copied! <pre>boundary = zoning_system.loc[\"i\"].geometry\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n\n# plot\nplot_results(plan_cropped, boundary)\n</pre> boundary = zoning_system.loc[\"i\"].geometry  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)  # plot plot_results(plan_cropped, boundary) <p>Any agents with fully external plans are dropped entirely:</p> In\u00a0[11]: Copied! <pre>population_cropped = deepcopy(population)\nassert len(population_cropped) == 1\n\n# after simplification, there are no agents left\ncropping.simplify_population(population_cropped, boundary)\nassert len(population_cropped) == 0\n</pre> population_cropped = deepcopy(population) assert len(population_cropped) == 1  # after simplification, there are no agents left cropping.simplify_population(population_cropped, boundary) assert len(population_cropped) == 0 <p>If all activities fall within the core area, plans remain unchanged:</p> In\u00a0[12]: Copied! <pre>boundary = zoning_system.dissolve().geometry[0]\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n\n# plot\nplot_results(plan_cropped, boundary)\n</pre> boundary = zoning_system.dissolve().geometry[0]  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)  # plot plot_results(plan_cropped, boundary)"},{"location":"examples/14_Advanced_Plan_Cropping/#plan-cropping","title":"Plan Cropping\u00b6","text":"<p>In this example, we show how you can simplify any activities happening outside a defined \"core\" area.</p> <p>Method:</p> <ol> <li>Identify which legs touch the core area</li> <li>Keep the relevant legs/activities and drop the remaining components</li> <li>Infill: create any new legs between external activities as necessary</li> <li>Ensure plan consistency: start/end times, sequences, etc</li> <li>(optional) : Rename activities to \"external\"</li> <li>(optional) : Crop the leg geometries to start/stop at the core area boundaries</li> </ol>"},{"location":"examples/14_Advanced_Plan_Cropping/#data","title":"Data\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#examples","title":"Examples\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-1-internal-external-trips","title":"Example 1 - Internal-external trips\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-2-through-trips","title":"Example 2 - Through trips\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-3-snap-trip-ends-to-zone-boundaries","title":"Example 3 - Snap trip ends to zone boundaries\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-3-fully-external-plan","title":"Example 3 - Fully external plan\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-4-fully-internal-plan","title":"Example 4 - Fully internal plan\u00b6","text":""},{"location":"examples/15_advanced_choice_modelling/","title":"Applying a location and mode choice model to populations","text":"In\u00a0[1]: Copied! <pre>import logging\nimport os\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom prettytable import PrettyTable\n\nfrom pam.operations.cropping import link_population\nfrom pam.planner import choice_location as choice\nfrom pam.planner.od import ODFactory, ODMatrix\nfrom pam.read import read_matsim\n\nlogging.basicConfig(level=logging.DEBUG)\nrandom.seed(0)\n</pre> import logging import os import random  import numpy as np import pandas as pd from prettytable import PrettyTable  from pam.operations.cropping import link_population from pam.planner import choice_location as choice from pam.planner.od import ODFactory, ODMatrix from pam.read import read_matsim  logging.basicConfig(level=logging.DEBUG) random.seed(0) <p>We read an example population, and set the location of all activities to zone <code>a</code>:</p> In\u00a0[2]: Copied! <pre>population = read_matsim(os.path.join(\"..\", \"tests\", \"test_data\", \"test_matsim_plansv12.xml\"))\nlink_population(population)\nfor _hid, _pid, person in population.people():\n    for act in person.activities:\n        act.location.area = \"a\"\n</pre> population = read_matsim(os.path.join(\"..\", \"tests\", \"test_data\", \"test_matsim_plansv12.xml\")) link_population(population) for _hid, _pid, person in population.people():     for act in person.activities:         act.location.area = \"a\" In\u00a0[3]: Copied! <pre>def print_activity_locs(population, act_scope=\"work\"):\n    summary = PrettyTable([\"pid\", \"seq\", \"location\", \"mode\"])\n    for _hid, pid, person in population.people():\n        for seq, act in enumerate(person.plan.activities):\n            if (act.act == act_scope) or (act_scope == \"all\"):\n                trmode = act.previous.mode if act.previous is not None else \"NA\"\n                summary.add_row([pid, seq, act.location.area, trmode])\n\n    print(summary)\n\n\nprint(\"Work locations and travel modes:\")\nprint_activity_locs(population, act_scope=\"work\")\n</pre> def print_activity_locs(population, act_scope=\"work\"):     summary = PrettyTable([\"pid\", \"seq\", \"location\", \"mode\"])     for _hid, pid, person in population.people():         for seq, act in enumerate(person.plan.activities):             if (act.act == act_scope) or (act_scope == \"all\"):                 trmode = act.previous.mode if act.previous is not None else \"NA\"                 summary.add_row([pid, seq, act.location.area, trmode])      print(summary)   print(\"Work locations and travel modes:\") print_activity_locs(population, act_scope=\"work\") <pre>Work locations and travel modes:\n+--------+-----+----------+------+\n|  pid   | seq | location | mode |\n+--------+-----+----------+------+\n| chris  |  1  |    a     | car  |\n| fatema |  1  |    a     | bike |\n|  fred  |  3  |    a     | walk |\n| gerry  |  3  |    a     | walk |\n|  nick  |  1  |    a     | car  |\n+--------+-----+----------+------+\n</pre> <p>Our <code>zones</code> dataset includes destination attraction data, for example the number of jobs or schools in each likely destination zone:</p> In\u00a0[4]: Copied! <pre>data_zones = pd.DataFrame({\"zone\": [\"a\", \"b\"], \"jobs\": [100, 200], \"schools\": [3, 1]}).set_index(\n    \"zone\"\n)\ndata_zones\n</pre> data_zones = pd.DataFrame({\"zone\": [\"a\", \"b\"], \"jobs\": [100, 200], \"schools\": [3, 1]}).set_index(     \"zone\" ) data_zones Out[4]: jobs schools zone a 100 3 b 200 1 <p>The <code>od</code> object holds origin-destination data, for example travel time and travel distance between each origin and destination, for each travel mode:</p> In\u00a0[5]: Copied! <pre>zone_labels = (\"a\", \"b\")\nod = ODFactory.from_matrices(\n    [\n        ODMatrix(\"time\", \"car\", zone_labels, zone_labels, np.array([[20, 40], [40, 20]])),\n        ODMatrix(\"time\", \"bus\", zone_labels, zone_labels, np.array([[30, 45], [45, 30]])),\n        ODMatrix(\"distance\", \"car\", zone_labels, zone_labels, np.array([[5, 8], [8, 5]])),\n        ODMatrix(\"distance\", \"bus\", zone_labels, zone_labels, np.array([[5, 9], [9, 5]])),\n    ]\n)\nod\n</pre> zone_labels = (\"a\", \"b\") od = ODFactory.from_matrices(     [         ODMatrix(\"time\", \"car\", zone_labels, zone_labels, np.array([[20, 40], [40, 20]])),         ODMatrix(\"time\", \"bus\", zone_labels, zone_labels, np.array([[30, 45], [45, 30]])),         ODMatrix(\"distance\", \"car\", zone_labels, zone_labels, np.array([[5, 8], [8, 5]])),         ODMatrix(\"distance\", \"bus\", zone_labels, zone_labels, np.array([[5, 9], [9, 5]])),     ] ) od Out[5]: <pre>Origin-destination dataset \n--------------------------------------------------\nLabels(vars=['time', 'distance'], origin_zones=('a', 'b'), destination_zones=('a', 'b'), mode=['car', 'bus'])\n--------------------------------------------------\ntime - car:\n[[20. 40.]\n [40. 20.]]\n--------------------------------------------------\ntime - bus:\n[[30. 45.]\n [45. 30.]]\n--------------------------------------------------\ndistance - car:\n[[5. 8.]\n [8. 5.]]\n--------------------------------------------------\ndistance - bus:\n[[5. 9.]\n [9. 5.]]\n--------------------------------------------------</pre> <p>The dimensions of the <code>od</code> object are always (in order): <code>variables</code>, <code>origin zone</code>, <code>destination zone</code>, and <code>mode</code>. It can be sliced using the respective labels under <code>od.labels</code>, for example:</p> In\u00a0[6]: Copied! <pre>od[\"time\", \"a\", \"b\", \"bus\"]\n</pre> od[\"time\", \"a\", \"b\", \"bus\"] Out[6]: <pre>45.0</pre> In\u00a0[7]: Copied! <pre>planner = choice.ChoiceMNL(population, od, data_zones)\n</pre> planner = choice.ChoiceMNL(population, od, data_zones) <pre>INFO:pam.planner.choice_location:Updated model configuration\nINFO:pam.planner.choice_location:ChoiceConfiguration(u=None, scope=None, func_probabilities=&lt;function calculate_mnl_probabilities at 0x16565d300&gt;, func_sampling=&lt;function sample_weighted at 0x16565d3a0&gt;)\n</pre> <p>We configure the model by specifying:</p> <ul> <li>the scope of the model. For example, work activities.</li> <li>the utility formulation of each alternative.</li> </ul> <p>Both settings are defined as strings. The stings may comprise mathematical operators, coefficients, planner data objects (<code>od</code> / <code>zones</code>), and/or PAM population objects (<code>person</code>/ <code>act</code>).</p> <p>Coefficients can be passed either as a number, or as a list, with each element in the list corresponding to one of the modes in the <code>od</code> object.</p> In\u00a0[8]: Copied! <pre>scope = \"act.act=='work'\"\nasc = [0, -1]  # one value for each mode, 0-&gt;car, -1-&gt;\nasc_shift_poor = [0, 2]  # one value for each mode\nbeta_time = [-0.05, -0.07]  # one value for each mode\nbeta_zones = 0.4\nu = f\"\"\" \\\n    {asc} + \\\n    (np.array({asc_shift_poor}) * (person.attributes['subpopulation']=='poor')) + \\\n    ({beta_time} * od['time', person.home.area]) + \\\n    ({beta_zones} * np.log(zones['jobs']))\n\"\"\"\n\nplanner.configure(u=u, scope=scope)\n</pre> scope = \"act.act=='work'\" asc = [0, -1]  # one value for each mode, 0-&gt;car, -1-&gt; asc_shift_poor = [0, 2]  # one value for each mode beta_time = [-0.05, -0.07]  # one value for each mode beta_zones = 0.4 u = f\"\"\" \\     {asc} + \\     (np.array({asc_shift_poor}) * (person.attributes['subpopulation']=='poor')) + \\     ({beta_time} * od['time', person.home.area]) + \\     ({beta_zones} * np.log(zones['jobs'])) \"\"\"  planner.configure(u=u, scope=scope) <pre>INFO:pam.planner.choice_location:Updated model configuration\nINFO:pam.planner.choice_location:ChoiceConfiguration(u=\"[0,-1]+(np.array([0,2])*(person.attributes['subpopulation']=='poor'))+([-0.05,-0.07]*od['time',person.home.area])+(0.4*np.log(zones['jobs']))\\n\", scope=\"act.act=='work'\", func_probabilities=&lt;function calculate_mnl_probabilities at 0x16565d300&gt;, func_sampling=&lt;function sample_weighted at 0x16565d3a0&gt;)\n</pre> <p>The <code>.get_choice_set()</code> provides with with the utilities of each alternative, as perceived by each agent.</p> In\u00a0[9]: Copied! <pre>choice_set = planner.get_choice_set()\nprint(\"Activities in scope: \\n\", choice_set.idxs)\nprint(\"\\nAlternatives: \\n\", choice_set.choice_labels)\nprint(\"\\nChoice set utilities: \\n\", choice_set.u_choices)\n</pre> choice_set = planner.get_choice_set() print(\"Activities in scope: \\n\", choice_set.idxs) print(\"\\nAlternatives: \\n\", choice_set.choice_labels) print(\"\\nChoice set utilities: \\n\", choice_set.u_choices) <pre>Activities in scope: \n [ChoiceIdx(pid='chris', hid='chris', seq=1, act=&lt;pam.activity.Activity object at 0x165694b90&gt;), ChoiceIdx(pid='fatema', hid='fatema', seq=1, act=&lt;pam.activity.Activity object at 0x165695690&gt;), ChoiceIdx(pid='fred', hid='fred', seq=3, act=&lt;pam.activity.Activity object at 0x165696ad0&gt;), ChoiceIdx(pid='gerry', hid='gerry', seq=3, act=&lt;pam.activity.Activity object at 0x1656a0250&gt;), ChoiceIdx(pid='nick', hid='nick', seq=1, act=&lt;pam.activity.Activity object at 0x1656a1250&gt;)]\n\nAlternatives: \n [ChoiceLabel(destination='a', mode='car'), ChoiceLabel(destination='a', mode='bus'), ChoiceLabel(destination='b', mode='car'), ChoiceLabel(destination='b', mode='bus')]\n\nChoice set utilities: \n [[ 0.84206807 -1.25793193  0.11932695 -2.03067305]\n [ 0.84206807  0.74206807  0.11932695 -0.03067305]\n [ 0.84206807  0.74206807  0.11932695 -0.03067305]\n [ 0.84206807  0.74206807  0.11932695 -0.03067305]\n [ 0.84206807 -1.25793193  0.11932695 -2.03067305]]\n</pre> <p>The <code>.apply()</code> method samples from the alternatives, and updates the location and mode of each activity accordingly:</p> In\u00a0[10]: Copied! <pre>planner.apply()\nprint(\"Sampled choices: \\n\", planner._selections.selections)\n</pre> planner.apply() print(\"Sampled choices: \\n\", planner._selections.selections) <pre>INFO:pam.planner.choice_location:Applying choice model...\nINFO:pam.planner.choice_location:Configuration: \nChoiceConfiguration(u=\"[0,-1]+(np.array([0,2])*(person.attributes['subpopulation']=='poor'))+([-0.05,-0.07]*od['time',person.home.area])+(0.4*np.log(zones['jobs']))\\n\", scope=\"act.act=='work'\", func_probabilities=&lt;function calculate_mnl_probabilities at 0x16565d300&gt;, func_sampling=&lt;function sample_weighted at 0x16565d3a0&gt;)\nINFO:pam.planner.choice_location:Choice model application complete.\n</pre> <pre>Sampled choices: \n [ChoiceLabel(destination='b', mode='car'), ChoiceLabel(destination='b', mode='car'), ChoiceLabel(destination='a', mode='bus'), ChoiceLabel(destination='a', mode='car'), ChoiceLabel(destination='a', mode='car')]\n</pre> <p>The population's activity locations and travel modes have now been updated accordingly:</p> In\u00a0[11]: Copied! <pre>print_activity_locs(planner.population)\n</pre> print_activity_locs(planner.population) <pre>+--------+-----+----------+------+\n|  pid   | seq | location | mode |\n+--------+-----+----------+------+\n| chris  |  1  |    b     | car  |\n| fatema |  1  |    b     | car  |\n|  fred  |  3  |    a     | bus  |\n| gerry  |  3  |    a     | car  |\n|  nick  |  1  |    a     | car  |\n+--------+-----+----------+------+\n</pre>"},{"location":"examples/15_advanced_choice_modelling/#applying-a-location-and-mode-choice-model-to-populations","title":"Applying a location and mode choice model to populations\u00b6","text":"<p>This notebook applies a simple location and mode choice model to a PAM population.</p> <p>The <code>pam.planner.choice.ChoiceMNL</code> class allows the user to apply an MNL specification for selecting the location of activities and the mode for accessing them, given person characteristics, network conditions and/or zone attraction data.</p> <p>The typical workflow goes as follows:</p> <pre>choice_model = ChoiceMNL(population, od, zones) # initialize the model and point to the data objects \nchoice_model.configure(u, scope) # configure the model by specifying a utility function and the scope of application.\nchoice_model.apply() # apply the model and update the population with the results.\n</pre>"},{"location":"examples/15_advanced_choice_modelling/#data","title":"Data\u00b6","text":""},{"location":"examples/15_advanced_choice_modelling/#choice-model","title":"Choice model\u00b6","text":""},{"location":"examples/16_advanced_matsim_warmstarting/","title":"MATSim Warm-Starting","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nfrom pam.read import read_matsim\nfrom pam.write import write_matsim\n</pre> from pathlib import Path  from pam.read import read_matsim from pam.write import write_matsim In\u00a0[2]: Copied! <pre>population = read_matsim(\n    plans_path=Path(\"data/example_data/output_experienced_plans.xml\"), keep_non_selected=True\n)\npopulation.stats\n</pre> population = read_matsim(     plans_path=Path(\"data/example_data/output_experienced_plans.xml\"), keep_non_selected=True ) population.stats Out[2]: <pre>{'num_households': 6, 'num_people': 6, 'num_activities': 23, 'num_legs': 18}</pre> In\u00a0[3]: Copied! <pre>removed_links = [\"1-5\", \"5-1\"]\n\n\ndef leg_filter(leg):\n    for link in removed_links:\n        if link in leg.route.network_route:\n            return True\n        if leg.route.get(\"start_link\") in removed_links:\n            return True\n        if leg.route.get(\"end_link\") in removed_links:\n            return True\n\n\ndef plan_filter(plan):\n    for leg in plan.legs:\n        if leg_filter(leg):\n            return True\n\n    for act in plan.activities:\n        if act.location.link in removed_links:\n            return True\n</pre> removed_links = [\"1-5\", \"5-1\"]   def leg_filter(leg):     for link in removed_links:         if link in leg.route.network_route:             return True         if leg.route.get(\"start_link\") in removed_links:             return True         if leg.route.get(\"end_link\") in removed_links:             return True   def plan_filter(plan):     for leg in plan.legs:         if leg_filter(leg):             return True      for act in plan.activities:         if act.location.link in removed_links:             return True In\u00a0[4]: Copied! <pre>for _, _, person in population.people():\n    if plan_filter(person.plan):\n        for leg in person.legs:\n            leg.route.xml = {}\n        for activity in person.activities:\n            activity.location.link = None\n\n    for plan in person.plans_non_selected:\n        if plan_filter(plan):\n            for leg in plan.legs:\n                leg.route.xml = {}\n            for activity in plan.activities:\n                activity.location.link = None\n</pre> for _, _, person in population.people():     if plan_filter(person.plan):         for leg in person.legs:             leg.route.xml = {}         for activity in person.activities:             activity.location.link = None      for plan in person.plans_non_selected:         if plan_filter(plan):             for leg in plan.legs:                 leg.route.xml = {}             for activity in plan.activities:                 activity.location.link = None In\u00a0[5]: Copied! <pre>write_matsim(population, Path(\"tmp/warm_plans.xml\"))\n</pre> write_matsim(population, Path(\"tmp/warm_plans.xml\")) <p>If we check these \"warm\" plans we will find that the agent \"Nick\" has had their plan modified. But all other agents have maintained all the original information.</p> <p>It is easy to get warm starting wrong. But it also has great potential to reduce MATSim compute in many cases. Common pitfalls include:</p> <ul> <li>failing to remove all the required information (remember that link and transit facility ids are also included in agent leg attributes and activity attributes)</li> <li>accidentally removing plans or activities (make sure that crop=False when reading plans)</li> <li>creating impossible plans (such as by using an unknown mode)</li> </ul> <p>We have added three common methods for warm starting to the PAM cli:</p> <ul> <li>crop (but note this does not currently support unselected plans)</li> <li>wipe_links</li> <li>wipe_all_links</li> </ul>"},{"location":"examples/16_advanced_matsim_warmstarting/#matsim-warm-starting","title":"MATSim Warm-Starting\u00b6","text":"<p>PAM can load experienced MATSim plans, make modifications, then write new input MATSim plans. This allows for changes to be made to a population or network without invalidating the MATSim plans.</p> <p>For example, consider the case where we have the outputs from a MATSim baseline simulation. We want to test a new scenario that makes a minor change to some parts of the network, this includes removing some links. We would like to reuse the output baseline plans. They contain our best initial guess for agent choices for times, modes and routes, including for unselected plans. However, we cannot resue these plans as they are, because they include routes that are now impossible due to our new scenario removing some links.</p> <p>PAM allows us to read in these experienced plans, remove routes from agents that use these links, then write back to a valid format for our new scenario.</p>"},{"location":"examples/16_advanced_matsim_warmstarting/#load","title":"Load\u00b6","text":""},{"location":"examples/16_advanced_matsim_warmstarting/#define-filters","title":"Define Filters\u00b6","text":""},{"location":"examples/16_advanced_matsim_warmstarting/#modify","title":"Modify\u00b6","text":""},{"location":"examples/16_advanced_matsim_warmstarting/#write","title":"Write\u00b6","text":""},{"location":"examples/17_advanced_discretionary_locations/","title":"Applying a location model to discretionary activities","text":"In\u00a0[1]: Copied! <pre>import logging\nimport random\nfrom copy import deepcopy\n\nimport numpy as np\nimport pandas as pd\nfrom prettytable import PrettyTable\nfrom shapely.geometry import Point\n\nfrom pam.activity import Activity, Leg, Plan\nfrom pam.location import Location\nfrom pam.planner.choice_location import DiscretionaryTripOD, DiscretionaryTrips\nfrom pam.planner.od import ODFactory, ODMatrix\nfrom pam.planner.utils_planner import get_trip_chains_either_anchor\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n\nlogging.getLogger(\"pam\").setLevel(logging.DEBUG)\nrandom.seed(0)\n</pre> import logging import random from copy import deepcopy  import numpy as np import pandas as pd from prettytable import PrettyTable from shapely.geometry import Point  from pam.activity import Activity, Leg, Plan from pam.location import Location from pam.planner.choice_location import DiscretionaryTripOD, DiscretionaryTrips from pam.planner.od import ODFactory, ODMatrix from pam.planner.utils_planner import get_trip_chains_either_anchor from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY  logging.getLogger(\"pam\").setLevel(logging.DEBUG) random.seed(0) <p>We start by identifying fixed mandatory locations (ie home, work, education), splitting the PAM plan into chains of activities.</p> <p>We then distinguish between 4 possible cases of trip chains:</p> <p></p> <p>Case 1 is a simple tour between mandatory activities, and may be approached with a discrete choice model (see 15_advanced_choice_modelling.ipynb).</p> <p>Case 2 selects a possible destination using origin-destination probabilities from the anchor location (saved under the <code>od_probs</code> variable of the <code>od</code> object)</p> <p>Case 3 weights candidate locations as a function of three elements:</p> <ul> <li>leg ratio, which captures how likely it is for the discretionary location to be closer to the previous or to the next fixed location (between 0 and 1)\u200b</li> <li>diversion factor, which captures the deviation from the straight path the individual is likely to accept in order to reach a discretionary activity location</li> <li>attraction (OD probabilities), which captures the number of opportunities in a destination</li> </ul> <p>The final destination probabilities are calculated by multiplying the three elements: $p_j = p\\_leg_{ij} * p\\_diversion_{ij} * p\\_attraction_{ij}$</p> <p>Case 4 solves the first location as case 2, and then the rest as case 3.</p> <p>Let's create a plan with the following activity sequence: home-&gt;work-&gt;shop-&gt;work</p> In\u00a0[2]: Copied! <pre>plan = Plan(home_area=\"h\", home_location=Location(loc=Point(0, 0), area=\"h\"))\nplan.add(\n    Activity(\n        seq=1, act=\"home\", area=\"h\", loc=Point(0, 0), start_time=mtdt(0), end_time=mtdt(5 * 60)\n    )\n)\nplan.add(\n    Leg(\n        seq=1,\n        mode=\"car\",\n        start_area=\"h\",\n        end_area=\"w\",\n        start_loc=Point(0, 0),\n        end_loc=Point(1, 2),\n        start_time=mtdt(5 * 60),\n        end_time=mtdt(6 * 60),\n    )\n)\nplan.add(\n    Activity(\n        seq=2,\n        act=\"visit\",\n        area=\"w\",\n        loc=Point(1, 2),\n        start_time=mtdt(6 * 60),\n        end_time=mtdt(17 * 60),\n    )\n)\nplan.add(\n    Leg(\n        seq=2,\n        mode=\"car\",\n        start_area=\"w\",\n        end_area=\"w\",\n        start_loc=Point(1, 2),\n        end_loc=Point(0, 0),\n        start_time=mtdt(17 * 60),\n        end_time=mtdt(18 * 60),\n    )\n)\nplan.add(\n    Activity(\n        seq=3,\n        act=\"work\",\n        area=\"w\",\n        loc=Point(0, 0),\n        start_time=mtdt(18 * 60),\n        end_time=mtdt(19 * 60),\n    )\n)\nplan.add(\n    Leg(\n        seq=3,\n        mode=\"car\",\n        start_area=\"w\",\n        end_area=\"na\",\n        start_loc=Point(0, 0),\n        end_loc=Point(1, 2),\n        start_time=mtdt(19 * 60),\n        end_time=mtdt(20 * 60),\n    )\n)\nplan.add(\n    Activity(\n        seq=4,\n        act=\"shop\",\n        area=\"na\",\n        loc=Point(2, 2),\n        start_time=mtdt(20 * 60),\n        end_time=mtdt(22 * 60),\n    )\n)\nplan.add(\n    Leg(\n        seq=4,\n        mode=\"car\",\n        start_area=\"na\",\n        end_area=\"h\",\n        start_loc=Point(2, 2),\n        end_loc=Point(0, 0),\n        start_time=mtdt(22 * 60),\n        end_time=mtdt(23 * 60),\n    )\n)\nplan.add(\n    Activity(\n        seq=5, act=\"home\", area=\"h\", loc=Point(0, 0), start_time=mtdt(23 * 60), end_time=END_OF_DAY\n    )\n)\nplan.plot()\n</pre> plan = Plan(home_area=\"h\", home_location=Location(loc=Point(0, 0), area=\"h\")) plan.add(     Activity(         seq=1, act=\"home\", area=\"h\", loc=Point(0, 0), start_time=mtdt(0), end_time=mtdt(5 * 60)     ) ) plan.add(     Leg(         seq=1,         mode=\"car\",         start_area=\"h\",         end_area=\"w\",         start_loc=Point(0, 0),         end_loc=Point(1, 2),         start_time=mtdt(5 * 60),         end_time=mtdt(6 * 60),     ) ) plan.add(     Activity(         seq=2,         act=\"visit\",         area=\"w\",         loc=Point(1, 2),         start_time=mtdt(6 * 60),         end_time=mtdt(17 * 60),     ) ) plan.add(     Leg(         seq=2,         mode=\"car\",         start_area=\"w\",         end_area=\"w\",         start_loc=Point(1, 2),         end_loc=Point(0, 0),         start_time=mtdt(17 * 60),         end_time=mtdt(18 * 60),     ) ) plan.add(     Activity(         seq=3,         act=\"work\",         area=\"w\",         loc=Point(0, 0),         start_time=mtdt(18 * 60),         end_time=mtdt(19 * 60),     ) ) plan.add(     Leg(         seq=3,         mode=\"car\",         start_area=\"w\",         end_area=\"na\",         start_loc=Point(0, 0),         end_loc=Point(1, 2),         start_time=mtdt(19 * 60),         end_time=mtdt(20 * 60),     ) ) plan.add(     Activity(         seq=4,         act=\"shop\",         area=\"na\",         loc=Point(2, 2),         start_time=mtdt(20 * 60),         end_time=mtdt(22 * 60),     ) ) plan.add(     Leg(         seq=4,         mode=\"car\",         start_area=\"na\",         end_area=\"h\",         start_loc=Point(2, 2),         end_loc=Point(0, 0),         start_time=mtdt(22 * 60),         end_time=mtdt(23 * 60),     ) ) plan.add(     Activity(         seq=5, act=\"home\", area=\"h\", loc=Point(0, 0), start_time=mtdt(23 * 60), end_time=END_OF_DAY     ) ) plan.plot() <p>The <code>od</code> object holds origin-destination data, for example travel time and travel distance between each origin and destination, for each travel mode.</p> <p>For the discretionary trips location choice, the <code>od</code> object needs to include the variable <code>od_probs</code>, which provides provides origin-destination probabilities to be considered -amongst others- as part of the location choice.</p> In\u00a0[3]: Copied! <pre>zone_labels = (\"h\", \"b\", \"w\")\nod = ODFactory.from_matrices(\n    [\n        ODMatrix(\n            \"time\",\n            \"car\",\n            zone_labels,\n            zone_labels,\n            np.array([[20, 30, 40], [30, 10, 30], [40, 30, 20]]),\n        ),\n        ODMatrix(\n            \"time\",\n            \"bus\",\n            zone_labels,\n            zone_labels,\n            np.array([[30, 40, 45], [40, 10, 40], [45, 40, 30]]),\n        ),\n        ODMatrix(\n            \"distance\", \"car\", zone_labels, zone_labels, np.array([[5, 6, 8], [6, 2, 6], [8, 6, 5]])\n        ),\n        ODMatrix(\n            \"distance\", \"bus\", zone_labels, zone_labels, np.array([[5, 7, 9], [7, 2, 7], [9, 7, 5]])\n        ),\n        ODMatrix(\n            \"od_probs\",\n            \"car\",\n            zone_labels,\n            zone_labels,\n            np.array([[500, 333, 250], [333, 1000, 333], [250, 333, 500]]),\n        ),\n        ODMatrix(\n            \"od_probs\",\n            \"bus\",\n            zone_labels,\n            zone_labels,\n            np.array([[333, 250, 222], [250, 1000, 250], [222, 250, 333]]),\n        ),\n    ]\n)\nod\n</pre> zone_labels = (\"h\", \"b\", \"w\") od = ODFactory.from_matrices(     [         ODMatrix(             \"time\",             \"car\",             zone_labels,             zone_labels,             np.array([[20, 30, 40], [30, 10, 30], [40, 30, 20]]),         ),         ODMatrix(             \"time\",             \"bus\",             zone_labels,             zone_labels,             np.array([[30, 40, 45], [40, 10, 40], [45, 40, 30]]),         ),         ODMatrix(             \"distance\", \"car\", zone_labels, zone_labels, np.array([[5, 6, 8], [6, 2, 6], [8, 6, 5]])         ),         ODMatrix(             \"distance\", \"bus\", zone_labels, zone_labels, np.array([[5, 7, 9], [7, 2, 7], [9, 7, 5]])         ),         ODMatrix(             \"od_probs\",             \"car\",             zone_labels,             zone_labels,             np.array([[500, 333, 250], [333, 1000, 333], [250, 333, 500]]),         ),         ODMatrix(             \"od_probs\",             \"bus\",             zone_labels,             zone_labels,             np.array([[333, 250, 222], [250, 1000, 250], [222, 250, 333]]),         ),     ] ) od Out[3]: <pre>Origin-destination dataset \n--------------------------------------------------\nLabels(vars=['time', 'distance', 'od_probs'], origin_zones=('h', 'b', 'w'), destination_zones=('h', 'b', 'w'), mode=['car', 'bus'])\n--------------------------------------------------\ntime - car:\n[[20. 30. 40.]\n [30. 10. 30.]\n [40. 30. 20.]]\n--------------------------------------------------\ntime - bus:\n[[30. 40. 45.]\n [40. 10. 40.]\n [45. 40. 30.]]\n--------------------------------------------------\ndistance - car:\n[[5. 6. 8.]\n [6. 2. 6.]\n [8. 6. 5.]]\n--------------------------------------------------\ndistance - bus:\n[[5. 7. 9.]\n [7. 2. 7.]\n [9. 7. 5.]]\n--------------------------------------------------\nod_probs - car:\n[[ 500.  333.  250.]\n [ 333. 1000.  333.]\n [ 250.  333.  500.]]\n--------------------------------------------------\nod_probs - bus:\n[[ 333.  250.  222.]\n [ 250. 1000.  250.]\n [ 222.  250.  333.]]\n--------------------------------------------------</pre> <p>Initially, the <code>shop</code> activity was allocated to zone <code>na</code>:</p> In\u00a0[4]: Copied! <pre>def print_activity_locs(plan):\n    summary = PrettyTable([\"seq\", \"purpose\", \"location\"])\n    for seq, act in enumerate(plan.activities):\n        summary.add_row([seq, act.act, act.location.area])\n    print(summary)\n\n\nprint(\"Work locations and travel modes:\")\nprint_activity_locs(plan)\n</pre> def print_activity_locs(plan):     summary = PrettyTable([\"seq\", \"purpose\", \"location\"])     for seq, act in enumerate(plan.activities):         summary.add_row([seq, act.act, act.location.area])     print(summary)   print(\"Work locations and travel modes:\") print_activity_locs(plan) <pre>Work locations and travel modes:\n+-----+---------+----------+\n| seq | purpose | location |\n+-----+---------+----------+\n|  0  |   home  |    h     |\n|  1  |  visit  |    w     |\n|  2  |   work  |    w     |\n|  3  |   shop  |    na    |\n|  4  |   home  |    h     |\n+-----+---------+----------+\n</pre> <p>We apply the discretionary location choice model:</p> In\u00a0[5]: Copied! <pre>plan_new = deepcopy(plan)\nplanner = DiscretionaryTrips(plan=plan_new, od=od)\nplanner.update_plan()\n</pre> plan_new = deepcopy(plan) planner = DiscretionaryTrips(plan=plan_new, od=od) planner.update_plan() <p>The location of the shop trip has now been updated:</p> In\u00a0[6]: Copied! <pre>print_activity_locs(plan_new)\n</pre> print_activity_locs(plan_new) <pre>+-----+---------+----------+\n| seq | purpose | location |\n+-----+---------+----------+\n|  0  |   home  |    h     |\n|  1  |  visit  |    w     |\n|  2  |   work  |    w     |\n|  3  |   shop  |    w     |\n|  4  |   home  |    h     |\n+-----+---------+----------+\n</pre> <p>This section goes through some of the calculations behind the model application.</p> <p>We select the work-&gt;shop-&gt;home chain:</p> In\u00a0[7]: Copied! <pre>plan_new = deepcopy(plan)\nchains = get_trip_chains_either_anchor(plan_new)\nchain = chains[-1]\n</pre> plan_new = deepcopy(plan) chains = get_trip_chains_either_anchor(plan_new) chain = chains[-1] In\u00a0[8]: Copied! <pre>[act.act for act in chain]\n</pre> [act.act for act in chain] Out[8]: <pre>['work', 'travel', 'shop', 'travel', 'home']</pre> In\u00a0[9]: Copied! <pre>model = DiscretionaryTripOD(chain, od)\n</pre> model = DiscretionaryTripOD(chain, od) <p>The durations of the two trips are one hour each:</p> In\u00a0[10]: Copied! <pre>[x.duration for x in chain if isinstance(x, Leg)]\n</pre> [x.duration for x in chain if isinstance(x, Leg)] Out[10]: <pre>[datetime.timedelta(seconds=3600), datetime.timedelta(seconds=3600)]</pre> <p>... and therefore, the observed leg ratio is 0.5:</p> In\u00a0[11]: Copied! <pre>model.observed_leg_ratio\n</pre> model.observed_leg_ratio Out[11]: <pre>0.5</pre> <p>Of the possible destination zones (h/b/w), zone b has the closest-to-observed leg ratio:</p> In\u00a0[12]: Copied! <pre>model.leg_ratios\n</pre> model.leg_ratios Out[12]: <pre>array([0.66666667, 0.5       , 0.33333333])</pre> <p>... and therefore, offers the highest \"leg_ratio\" probability:</p> In\u00a0[13]: Copied! <pre>model.leg_ratio_p\n</pre> model.leg_ratio_p Out[13]: <pre>array([0.66666667, 1.        , 0.66666667])</pre> <p>The diversion factors are the same each destination:</p> In\u00a0[14]: Copied! <pre>model.diversion_factors\n</pre> model.diversion_factors Out[14]: <pre>array([1.5, 1.5, 1.5])</pre> <p>... and therefore the diversion probabilities are equal:</p> In\u00a0[15]: Copied! <pre>model.diversion_p\n</pre> model.diversion_p Out[15]: <pre>array([0.54545455, 0.54545455, 0.54545455])</pre> <p>Attraction probabilities reflect the data in the <code>od</code> object:</p> In\u00a0[16]: Copied! <pre>model.od[\"od_probs\", \"w\", :, \"car\"]\n</pre> model.od[\"od_probs\", \"w\", :, \"car\"] Out[16]: <pre>array([250., 333., 500.])</pre> <p>.. the more opportunities it offers, the higher the probability of a destination:</p> In\u00a0[17]: Copied! <pre>model.attraction_p\n</pre> model.attraction_p Out[17]: <pre>array([0.23084026, 0.30747922, 0.46168052])</pre> <p>The final probabilities are defined as the product of the three elements:</p> In\u00a0[18]: Copied! <pre>probs = model.leg_ratio_p * model.diversion_p * model.attraction_p\nprobs /= probs.sum()\nprobs\n</pre> probs = model.leg_ratio_p * model.diversion_p * model.attraction_p probs /= probs.sum() probs Out[18]: <pre>array([0.20008003, 0.3997599 , 0.40016006])</pre> In\u00a0[19]: Copied! <pre>model.destination_p\n</pre> model.destination_p Out[19]: <pre>array([0.20008003, 0.3997599 , 0.40016006])</pre> <p>Running the model multiple times gives us the same probabilities:</p> In\u00a0[20]: Copied! <pre>res = []\nfor i in range(10**3):\n    planner = DiscretionaryTrips(plan=plan_new, od=od)\n    planner.update_plan()\n    res.append(list(plan_new.activities)[3].location.area)\nres = pd.Series(res)\nres.value_counts(normalize=True).loc[list(od.labels.destination_zones)]\n</pre> res = [] for i in range(10**3):     planner = DiscretionaryTrips(plan=plan_new, od=od)     planner.update_plan()     res.append(list(plan_new.activities)[3].location.area) res = pd.Series(res) res.value_counts(normalize=True).loc[list(od.labels.destination_zones)] Out[20]: <pre>h    0.200\nb    0.403\nw    0.397\nName: proportion, dtype: float64</pre>"},{"location":"examples/17_advanced_discretionary_locations/#applying-a-location-model-to-discretionary-activities","title":"Applying a location model to discretionary activities\u00b6","text":"<p>This notebook applies a time-prism approach for choosing the location of non-mandatory activities. With this approach, agents try to sensibly combine the location of their discretionary activities around the locations of \u201canchor points\u201d (defined as the locations of mandatory activities \u2013 home, employment, education).</p> <p>The <code>pam.planner.choice_location.DiscretionaryTrips</code> class allows the user to apply the time-space prism approach on a PAM plan, given accessibility and attraction data.</p> <p>The typical workflow goes as follows:</p> <pre>model = DiscretionaryTrips(population, od) # initialize the model and point to the data objects \nmodel.update_plan() # apply the model and update the location of each non-mandatory activity in the plan\n</pre>"},{"location":"examples/17_advanced_discretionary_locations/#methodology","title":"Methodology\u00b6","text":""},{"location":"examples/17_advanced_discretionary_locations/#data","title":"Data\u00b6","text":""},{"location":"examples/17_advanced_discretionary_locations/#model-application","title":"Model application\u00b6","text":""},{"location":"examples/17_advanced_discretionary_locations/#breaking-down-the-calculation","title":"Breaking down the calculation\u00b6","text":""},{"location":"examples/18_advanced_ipf/","title":"Introduction","text":"<p>This notebook demonstrates the creation of a synthetic population using an Iterative Proportional Fitting (IPF) approach.</p> <p>IPF is a statistical technique that tries to adjust the values of a matrix (joint distribution) in order to match the values of expected single distributions (marginals) for each matrix dimension. We use this approach to sample from a set of persons with certain demographic attributes in a way that the observed distributions in each zone (ie from census) are met.</p> In\u00a0[1]: Copied! <pre>import itertools\n\nimport pandas as pd\n\nfrom pam.core import Person, Population\nfrom pam.planner import ipf\n</pre> import itertools  import pandas as pd  from pam.core import Person, Population from pam.planner import ipf <p>We start with some demographic data for each zone, as shown below. The zones dataframe includes the zone name as the index, and its columns follow a <code>variable|class</code> naming convention. Alternatively, they could be provided with a mutltiIndex column, with the first level being the variable and the second level indicating the class. The controlled variables should be part of the seed population's attributes.</p> In\u00a0[2]: Copied! <pre>zone_data = pd.DataFrame(\n    {\n        \"zone\": [\"a\", \"b\"],\n        \"hhincome|high\": [30, 80],\n        \"hhincome|medium\": [40, 100],\n        \"hhincome|low\": [30, 20],\n        \"age|minor\": [40, 90],\n        \"age|adult\": [60, 110],\n        \"carAvail|yes\": [90, 180],\n        \"carAvail|no\": [10, 20],\n    }\n).set_index(\"zone\")\nzone_data\n</pre> zone_data = pd.DataFrame(     {         \"zone\": [\"a\", \"b\"],         \"hhincome|high\": [30, 80],         \"hhincome|medium\": [40, 100],         \"hhincome|low\": [30, 20],         \"age|minor\": [40, 90],         \"age|adult\": [60, 110],         \"carAvail|yes\": [90, 180],         \"carAvail|no\": [10, 20],     } ).set_index(\"zone\") zone_data Out[2]: hhincome|high hhincome|medium hhincome|low age|minor age|adult carAvail|yes carAvail|no zone a 30 40 30 40 60 90 10 b 80 100 20 90 110 180 20 <p>Let's create a seed population which includes every possible combination of attributes:</p> In\u00a0[3]: Copied! <pre>dims = {\"hhincome\": [\"low\", \"medium\", \"high\"], \"age\": [\"minor\", \"adult\"], \"carAvail\": [\"yes\", \"no\"]}\nlist(itertools.product(*dims.values()))\n\n# %%\nseed_pop = Population()\nn = 0\nfor attributes in list(itertools.product(*dims.values())):\n    hhincome, age, carAvail = attributes\n    person = Person(\n        pid=n, attributes={\"hhincome\": hhincome, \"age\": age, \"carAvail\": carAvail, \"hzone\": pd.NA}\n    )\n    n += 1\n    seed_pop.add(person)\n\nseed_pop.random_person().attributes\n</pre> dims = {\"hhincome\": [\"low\", \"medium\", \"high\"], \"age\": [\"minor\", \"adult\"], \"carAvail\": [\"yes\", \"no\"]} list(itertools.product(*dims.values()))  # %% seed_pop = Population() n = 0 for attributes in list(itertools.product(*dims.values())):     hhincome, age, carAvail = attributes     person = Person(         pid=n, attributes={\"hhincome\": hhincome, \"age\": age, \"carAvail\": carAvail, \"hzone\": pd.NA}     )     n += 1     seed_pop.add(person)  seed_pop.random_person().attributes Out[3]: <pre>{'hhincome': 'high', 'age': 'adult', 'carAvail': 'yes', 'hzone': &lt;NA&gt;}</pre> <p>Now let's create a population that matches the demographic distribution of each zone:</p> In\u00a0[4]: Copied! <pre>pop = ipf.generate_population(seed_pop, zone_data)\n</pre> pop = ipf.generate_population(seed_pop, zone_data) <p>The resulting population comprises 300 persons (as defined in the zone data):</p> In\u00a0[5]: Copied! <pre>len(pop)\n</pre> len(pop) Out[5]: <pre>300</pre> <p>And each person in the population is assigned a household zone:</p> In\u00a0[6]: Copied! <pre>pop.random_person().attributes\n</pre> pop.random_person().attributes Out[6]: <pre>{'hhincome': 'medium', 'age': 'adult', 'carAvail': 'yes', 'hzone': 'b'}</pre> <p>The resulting joint demographic distributions in each zone are shown below:</p> In\u00a0[7]: Copied! <pre>summary = (\n    pd.DataFrame([person.attributes for hid, pid, person in pop.people()])\n    .value_counts()\n    .reorder_levels([3, 0, 1, 2])\n    .sort_index()\n)\n\nsummary\n</pre> summary = (     pd.DataFrame([person.attributes for hid, pid, person in pop.people()])     .value_counts()     .reorder_levels([3, 0, 1, 2])     .sort_index() )  summary Out[7]: <pre>hzone  hhincome  age    carAvail\na      high      adult  no           2\n                        yes         16\n                 minor  no           1\n                        yes         11\n       low       adult  no           2\n                        yes         16\n                 minor  no           1\n                        yes         11\n       medium    adult  no           2\n                        yes         22\n                 minor  no           2\n                        yes         14\nb      high      adult  no           4\n                        yes         40\n                 minor  no           4\n                        yes         32\n       low       adult  no           1\n                        yes         10\n                 minor  no           1\n                        yes          8\n       medium    adult  no           6\n                        yes         50\n                 minor  no           4\n                        yes         40\nName: count, dtype: int64</pre> <p>The aggregate demographic distributions match the marginals in <code>zone_data</code>:</p> In\u00a0[8]: Copied! <pre>summary_aggregate = []\nfor var in dims:\n    df = summary.groupby(level=[\"hzone\", var]).sum().unstack(level=var)\n    df.columns = [f\"{var}|{x}\" for x in df.columns]\n    summary_aggregate.append(df)\nsummary_aggregate = pd.concat(summary_aggregate, axis=1)\nsummary_aggregate.index.name = \"zone\"\nsummary_aggregate = summary_aggregate[zone_data.columns]\nsummary_aggregate\n</pre> summary_aggregate = [] for var in dims:     df = summary.groupby(level=[\"hzone\", var]).sum().unstack(level=var)     df.columns = [f\"{var}|{x}\" for x in df.columns]     summary_aggregate.append(df) summary_aggregate = pd.concat(summary_aggregate, axis=1) summary_aggregate.index.name = \"zone\" summary_aggregate = summary_aggregate[zone_data.columns] summary_aggregate Out[8]: hhincome|high hhincome|medium hhincome|low age|minor age|adult carAvail|yes carAvail|no zone a 30 40 30 40 60 90 10 b 80 100 20 89 111 180 20 In\u00a0[9]: Copied! <pre>pd.testing.assert_frame_equal(\n    summary_aggregate, zone_data, check_exact=False, atol=1\n)  # test passes\n</pre> pd.testing.assert_frame_equal(     summary_aggregate, zone_data, check_exact=False, atol=1 )  # test passes"},{"location":"examples/18_advanced_ipf/#introduction","title":"Introduction\u00b6","text":""},{"location":"examples/18_advanced_ipf/#data","title":"Data\u00b6","text":""},{"location":"examples/18_advanced_ipf/#ipf","title":"IPF\u00b6","text":""},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>internal conda upload CI script.</li> <li>public fix person attributes type conversion bug (#263)</li> </ul>"},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>internal PyPI build and upload CI scripts (triggered on tagging and releasing new versions).</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>User install instructions to prefer direct install from mamba (or PyPI if a user is willing to deal with installing non-python libs themselves).</li> </ul>"},{"location":"CHANGELOG/#v030-2023-09-27","title":"v0.3.0 - 2023-09-27","text":""},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>readme CI badge (#248)</li> <li>plan cropping as per issue #241 (#240).</li> <li> (#239).</li> <li><code>TourPlanner</code> prevents sampling of duplicate destinations, and prevents origin being sampled as a destination (#231).</li> <li> as per issue #221, improving \"pt simplification\" (#222)</li> <li>Slow loading of data with e.g., pam.read.load_travel_diary when using pandas v2.1.1 (caused by <code>pandas.MultiIndex.groupby</code>, see pandas issue #55256). (#258)</li> </ul>"},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>MATSim warm starting example (#239).</li> <li>Support for MATSim vehicles files (#215).</li> <li>Anaconda package of PAM, available on the <code>city-modelling-lab</code> channel (#211).</li> <li>Python versions 3.9 to 3.11 support (#192, #210).</li> <li>Documentation, now available at https://arup-group.github.io/pam (#197).</li> <li>Time-space prism method for selecting the location of non-mandatory activities (#252).</li> <li>Simple IPF approach for generating synthetic populations (#253).</li> <li>More control over the look of activity plan plots, with keyword arguments for  (accessed via e.g. [pam.core.Person.plot]) extended to allow figure width and per-activity label font sizes to be updated (#249).</li> <li>internal Codecov and pre-commit CI bots (#202).</li> <li>internal Github action job to build PAM and run tests on Windows and MacOS machines (#192).</li> <li>internal Contribution guidelines and issue/pull request templates (#207).</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Documentation and examples improved (#239).</li> <li><code>TourPlanner</code> class sequences stops using GreedyTSP algorithm, rather than previous method sorting by distance from depot (#231).</li> <li>Minor changes to docs for zsh users (eg <code>pip install '.[dev]'</code>)(#219).</li> <li>Recommended installation instructions, to use mamba instead of pip (#192, #211).</li> <li>Docker image entry point from python to bash (#230).</li> <li>internal Source code and example notebook code layout to align with pep8 guidelines and to remove unused dependency imports (#196, #201).</li> <li>internal Docstrings to Google style (#208)</li> <li>internal development toolkit, moving from internal scripts to pytest plugins (#193).</li> <li>internal CI actions link to reusable ones from <code>arup-group/actions-city-modelling-lab/</code>, including new memory profiling and multi-OS / python version tests (#243).</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Example data files not accessed by any example notebook (#196).</li> <li><code>ActivityDuration</code> class, replaced with methods in <code>TourPlanner</code> and in <code>pam.samplers.tour</code> (#231).</li> <li>internal Unused scripts that were outside the source code directory (#199).</li> </ul>"},{"location":"CHANGELOG/#v024-2023-06-08","title":"v0.2.4 - 2023-06-08","text":"<p>This version is a pre-release</p>"},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Option to skip existing facility locations during facility sampling, by adding the <code>location_override</code> argument to the <code>sample_locs</code> method (#190).</li> </ul>"},{"location":"CHANGELOG/#v023-2023-06-07","title":"v0.2.3 - 2023-06-07","text":"<p>This version is a pre-release</p>"},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>A bug when creating origin-destination (OD) matrices within the <code>ODFactory</code> class (#191).</li> </ul>"},{"location":"CHANGELOG/#v022-2023-05-30","title":"v0.2.2 - 2023-05-30","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Abstract mode and location choice modules, available within the <code>pam.planner.choice_location</code> module (#189).</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>internal Docker base image to ensure successful CodeBuild CD pipeline builds (#188).</li> </ul>"},{"location":"CHANGELOG/#v021-2023-05-11","title":"v0.2.1 - 2023-05-11","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>internal initialisation files, such that PAM submodules can be accessed after installing the repository as a package with pip (#187).</li> </ul>"},{"location":"CHANGELOG/#v020-2023-05-10","title":"v0.2.0 - 2023-05-10","text":"<p>This is the first version of PAM which follows semantic versioning and can be considered the first official release of the package.</p>"},{"location":"reference/pam/activity/","title":"pam.activity","text":""},{"location":"reference/pam/activity/#pam.activity.Activity","title":"<code>Activity(seq=None, act=None, area=None, link=None, loc=None, start_time=None, end_time=None, freq=None)</code>","text":"<p>             Bases: <code>PlanComponent</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(\n    self,\n    seq=None,\n    act=None,\n    area=None,\n    link=None,\n    loc=None,\n    start_time=None,\n    end_time=None,\n    freq=None,\n):\n    self.seq = seq\n    self.act = act\n    self.location = Location(loc=loc, link=link, area=area)\n    self.start_time = start_time\n    self.end_time = end_time\n    self.freq = freq\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Activity.act","title":"<code>act = act</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Activity.duration","title":"<code>duration</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Activity.end_time","title":"<code>end_time = end_time</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Activity.freq","title":"<code>freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Activity.hours","title":"<code>hours</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Activity.location","title":"<code>location = Location(loc=loc, link=link, area=area)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Activity.seq","title":"<code>seq = seq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Activity.start_time","title":"<code>start_time = start_time</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Activity.is_exact","title":"<code>is_exact(other)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def is_exact(self, other):\n    return (\n        (self.location == other.location)\n        and (self.act == other.act)\n        and (self.start_time == other.start_time)\n        and (self.end_time == other.end_time)\n    )\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Activity.isin_exact","title":"<code>isin_exact(activities)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def isin_exact(self, activities: list):\n    for other in activities:\n        if self.is_exact(other):\n            return True\n    return False\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Activity.shift_duration","title":"<code>shift_duration(new_duration, new_start_time=None)</code>","text":"<p>Given a new duration and optionally start time, set start time &amp; set end time based on duration.</p> PARAMETER  DESCRIPTION <code>new_duration</code> <p> TYPE: <code>timedelta</code> </p> <code>new_start_time</code> <p>Defaults to None.</p> <p> TYPE: <code>datetime64</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new end time.</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_duration(\n    self, new_duration: timedelta, new_start_time: Optional[datetime64] = None\n) -&gt; datetime64:\n    \"\"\"Given a new duration and optionally start time, set start time &amp; set end time based on duration.\n\n    Args:\n      new_duration (timedelta):\n      new_start_time (datetime64, optional): Defaults to None.\n\n    Returns:\n      datetime64: new end time.\n\n    \"\"\"\n    if new_start_time is not None:\n        self.start_time = new_start_time\n    self.end_time = self.start_time + new_duration\n    return self.end_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Activity.shift_end_time","title":"<code>shift_end_time(new_end_time)</code>","text":"<p>Given a new end time, set end time &amp; start time based on previous duration.</p> PARAMETER  DESCRIPTION <code>new_end_time</code> <p> TYPE: <code>datetime64</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new start time.</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_end_time(self, new_end_time: datetime64) -&gt; datetime64:\n    \"\"\"Given a new end time, set end time &amp; start time based on previous duration.\n\n    Args:\n      new_end_time (datetime64):\n\n    Returns:\n      datetime64: new start time.\n\n    \"\"\"\n    duration = self.duration\n    self.end_time = new_end_time\n    self.start_time = new_end_time - duration\n    return self.start_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Activity.shift_start_time","title":"<code>shift_start_time(new_start_time)</code>","text":"<p>Given a new start time, set start time &amp; end time based on previous duration.</p> PARAMETER  DESCRIPTION <code>new_start_time</code> <p> TYPE: <code>datetime64</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new end time</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_start_time(self, new_start_time: datetime64) -&gt; datetime64:\n    \"\"\"Given a new start time, set start time &amp; end time based on previous duration.\n\n    Args:\n        new_start_time (datetime64):\n\n    Returns:\n        datetime64: new end time\n\n    \"\"\"\n    duration = self.duration\n    self.start_time = new_start_time\n    self.end_time = new_start_time + duration\n    return self.end_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Activity.validate_matsim","title":"<code>validate_matsim()</code>","text":"<p>Checks if activity has required fields for a valid matsim plan.</p> Source code in <code>pam/activity.py</code> <pre><code>def validate_matsim(self) -&gt; None:\n    \"\"\"Checks if activity has required fields for a valid matsim plan.\"\"\"\n    if self.act is None:\n        raise InvalidMATSimError(\"Activity requires a type.\")\n    if self.start_time is None and self.end_time is None:\n        raise InvalidMATSimError(\"Activity requires either start time or end_time.\")\n    if self.location.loc is None and self.location.link is None:\n        raise InvalidMATSimError(\"Activity requires link id or x,y coordinates.\")\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Leg","title":"<code>Leg(seq=None, mode=None, start_area=None, end_area=None, start_link=None, end_link=None, start_loc=None, end_loc=None, start_time=None, end_time=None, distance=None, purp=None, freq=None, attributes={}, route=None)</code>","text":"<p>             Bases: <code>PlanComponent</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(\n    self,\n    seq=None,\n    mode=None,\n    start_area=None,\n    end_area=None,\n    start_link=None,\n    end_link=None,\n    start_loc=None,\n    end_loc=None,\n    start_time=None,\n    end_time=None,\n    distance=None,\n    purp=None,\n    freq=None,\n    attributes={},\n    route=None,\n):\n    self.seq = seq\n    self.purp = purp\n    self.mode = mode\n    self.start_location = Location(loc=start_loc, link=start_link, area=start_area)\n    self.end_location = Location(loc=end_loc, link=end_link, area=end_area)\n    self.start_time = start_time\n    self.end_time = end_time\n    self.freq = freq\n    self._distance = distance\n    # relevant for simulated plans\n    self.attributes = attributes\n    if route is not None:\n        self.route = route\n    else:\n        self.route = Route()\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Leg.act","title":"<code>act = 'travel'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.attributes","title":"<code>attributes = attributes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.boarding_time","title":"<code>boarding_time</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.d_stop","title":"<code>d_stop</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.distance","title":"<code>distance</code>  <code>property</code>","text":"<p>Distance, assumed to be in m in either case.</p>"},{"location":"reference/pam/activity/#pam.activity.Leg.duration","title":"<code>duration</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.end_location","title":"<code>end_location = Location(loc=end_loc, link=end_link, area=end_area)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.end_time","title":"<code>end_time = end_time</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.euclidean_distance","title":"<code>euclidean_distance</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.freq","title":"<code>freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.hours","title":"<code>hours</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.mode","title":"<code>mode = mode</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.network_route","title":"<code>network_route</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.o_stop","title":"<code>o_stop</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.purp","title":"<code>purp = purp</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.route","title":"<code>route = route</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.route_id","title":"<code>route_id</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.seq","title":"<code>seq = seq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.service_id","title":"<code>service_id</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.start_location","title":"<code>start_location = Location(loc=start_loc, link=start_link, area=start_area)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.start_time","title":"<code>start_time = start_time</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Leg.shift_duration","title":"<code>shift_duration(new_duration, new_start_time=None)</code>","text":"<p>Given a new duration and optionally start time, set start time &amp; set end time based on duration.</p> PARAMETER  DESCRIPTION <code>new_duration</code> <p> TYPE: <code>timedelta</code> </p> <code>new_start_time</code> <p>Defaults to None.</p> <p> TYPE: <code>datetime64</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new end time.</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_duration(\n    self, new_duration: timedelta, new_start_time: Optional[datetime64] = None\n) -&gt; datetime64:\n    \"\"\"Given a new duration and optionally start time, set start time &amp; set end time based on duration.\n\n    Args:\n      new_duration (timedelta):\n      new_start_time (datetime64, optional): Defaults to None.\n\n    Returns:\n      datetime64: new end time.\n\n    \"\"\"\n    if new_start_time is not None:\n        self.start_time = new_start_time\n    self.end_time = self.start_time + new_duration\n    return self.end_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Leg.shift_end_time","title":"<code>shift_end_time(new_end_time)</code>","text":"<p>Given a new end time, set end time &amp; start time based on previous duration.</p> PARAMETER  DESCRIPTION <code>new_end_time</code> <p> TYPE: <code>datetime64</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new start time.</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_end_time(self, new_end_time: datetime64) -&gt; datetime64:\n    \"\"\"Given a new end time, set end time &amp; start time based on previous duration.\n\n    Args:\n      new_end_time (datetime64):\n\n    Returns:\n      datetime64: new start time.\n\n    \"\"\"\n    duration = self.duration\n    self.end_time = new_end_time\n    self.start_time = new_end_time - duration\n    return self.start_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Leg.shift_start_time","title":"<code>shift_start_time(new_start_time)</code>","text":"<p>Given a new start time, set start time &amp; end time based on previous duration.</p> PARAMETER  DESCRIPTION <code>new_start_time</code> <p> TYPE: <code>datetime64</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new end time</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_start_time(self, new_start_time: datetime64) -&gt; datetime64:\n    \"\"\"Given a new start time, set start time &amp; end time based on previous duration.\n\n    Args:\n        new_start_time (datetime64):\n\n    Returns:\n        datetime64: new end time\n\n    \"\"\"\n    duration = self.duration\n    self.start_time = new_start_time\n    self.end_time = new_start_time + duration\n    return self.end_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan","title":"<code>Plan(home_area=None, home_location=None, home_loc=None, freq=None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def __init__(\n    self, home_area=None, home_location: Optional[Location] = None, home_loc=None, freq=None\n):\n    self.day = []\n    if home_location:\n        self.home_location = home_location\n    else:\n        self.home_location = Location()\n    if home_area:\n        self.home_location.area = home_area\n    if home_loc:\n        self.home_location.loc = home_loc\n    self.logger = logging.getLogger(__name__)\n    self.plan_freq = freq\n    self.score = None\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.activities","title":"<code>activities</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.activity_classes","title":"<code>activity_classes: set</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.closed","title":"<code>closed: bool</code>  <code>property</code>","text":"<p>Check if plan starts and stops at the same facility (based on activity and location).</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pam/activity/#pam.activity.Plan.day","title":"<code>day = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.first","title":"<code>first</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.home","title":"<code>home</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.home_based","title":"<code>home_based</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.home_location","title":"<code>home_location = home_location</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.is_valid","title":"<code>is_valid: bool</code>  <code>property</code>","text":"<p>Check for sequence, time and location structure and consistency. Note that this also checks that plan ends at END_OF_DAY.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pam/activity/#pam.activity.Plan.last","title":"<code>last</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.legs","title":"<code>legs</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.length","title":"<code>length</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.mode_classes","title":"<code>mode_classes: set</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.plan_freq","title":"<code>plan_freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.score","title":"<code>score = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Plan.valid_end_of_day_time","title":"<code>valid_end_of_day_time: bool</code>  <code>property</code>","text":"<p>Check that start and end time of Activities and Legs are consistent.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pam/activity/#pam.activity.Plan.valid_locations","title":"<code>valid_locations: bool</code>  <code>property</code>","text":"<p>Check that locations are consistent across Activities and Legs.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pam/activity/#pam.activity.Plan.valid_sequence","title":"<code>valid_sequence: bool</code>  <code>property</code>","text":"<p>Check sequence of Activities and Legs.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pam/activity/#pam.activity.Plan.valid_start_of_day_time","title":"<code>valid_start_of_day_time: bool</code>  <code>property</code>","text":"<p>Check that start and end time of Activities and Legs are consistent.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pam/activity/#pam.activity.Plan.valid_time_sequence","title":"<code>valid_time_sequence: bool</code>  <code>property</code>","text":"<p>Check that start and end time of Activities and Legs are consistent.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pam/activity/#pam.activity.Plan.activity_tours","title":"<code>activity_tours()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def activity_tours(self):\n    tours = []\n    tour = []\n    for act in self.activities:\n        if act.act == \"home\":\n            if tour:\n                tours.append(tour)\n            tour = []\n        else:\n            tour.append(act)\n    if tour:\n        tours.append(tour)\n    return tours\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.add","title":"<code>add(p)</code>","text":"<p>Safely add a new component to the plan.</p> PARAMETER  DESCRIPTION <code>p</code> <p>component to add.</p> <p> TYPE: <code>Union[Activity, Leg, Trip, list[Activity, Leg, Trip]]</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def add(self, p: Union[Activity, Leg, Trip, list[Activity, Leg, Trip]]) -&gt; None:\n    \"\"\"Safely add a new component to the plan.\n\n    Args:\n      p (Union[Activity, Leg, Trip, list[Activity, Leg, Trip]]): component to add.\n\n    \"\"\"\n    if isinstance(p, list):\n        for c in p:\n            self.add(c)\n\n    elif isinstance(p, Activity):\n        if self.day and isinstance(self.day[-1], Activity):  # enforce act-leg-act seq\n            raise PAMSequenceValidationError(\n                \"Failed to add to plan, next component must be a Trip or Leg.\"\n            )\n        self.day.append(p)\n\n    elif isinstance(p, Leg) or isinstance(p, Trip):\n        if not self.day:\n            raise PAMSequenceValidationError(\n                \"Failed to add to plan, first component must be Activity instance.\"\n            )\n        if not isinstance(self.day[-1], Activity):  # enforce act-leg-act seq\n            raise PAMSequenceValidationError(\n                \"Failed to add to plan, next component must be Activity instance.\"\n            )\n        self.day.append(p)\n\n    else:\n        raise UserWarning(f\"Cannot add type: {type(p)} to plan.\")\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.autocomplete_matsim","title":"<code>autocomplete_matsim()</code>","text":"<p>Complete leg start and end locations.</p> Source code in <code>pam/activity.py</code> <pre><code>def autocomplete_matsim(self):\n    \"\"\"Complete leg start and end locations.\"\"\"\n    for seq, component in enumerate(self):\n        if isinstance(component, Leg):\n            self.day[seq].start_location = self.day[seq - 1].location\n            self.day[seq].end_location = self.day[seq + 1].location\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.change_duration","title":"<code>change_duration(seq, shift_duration)</code>","text":"<p>Change the duration of a leg and shift subsequent activities/legs forward.</p> PARAMETER  DESCRIPTION <code>seq</code> <p>leg index in self.day.</p> <p> TYPE: <code>int</code> </p> <code>shift_duration</code> <p>the number of seconds to change the leg duration by.</p> <p> TYPE: <code>timedelta</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def change_duration(self, seq: int, shift_duration: timedelta) -&gt; None:\n    \"\"\"Change the duration of a leg and shift subsequent activities/legs forward.\n\n    Args:\n        seq (int): leg index in self.day.\n        shift_duration (timedelta): the number of seconds to change the leg duration by.\n\n    \"\"\"\n    # change leg duration\n    self.day[seq].end_time = self.day[seq].end_time + shift_duration\n\n    # shift all subsequent legs and activities\n    for idx in range(seq + 1, len(self.day)):\n        start_time = self.day[idx].start_time\n        self.day[idx].shift_start_time(start_time + shift_duration)\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.clear","title":"<code>clear()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def clear(self):\n    self.day = []\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.closed_duration","title":"<code>closed_duration(idx)</code>","text":"<p>Check duration of plan component at idx, if closed plan, combine first and last durations.</p> PARAMETER  DESCRIPTION <code>idx</code> <p>index along plan component to check.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def closed_duration(self, idx: int) -&gt; datetime64:\n    \"\"\"Check duration of plan component at idx, if closed plan, combine first and last durations.\n\n    Args:\n      idx (int): index along plan component to check.\n\n    Returns:\n        datetime64:\n    \"\"\"\n    if self.closed and (idx == 0 or idx == self.length - 1):\n        return self.day[0].duration + self.day[-1].duration\n    return self.day[idx].duration\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.combine_matching_activities","title":"<code>combine_matching_activities(idx_start, idx_end)</code>","text":"<p>Combine two given activities into same activity, remove surplus Legs</p> PARAMETER  DESCRIPTION <code>idx_start</code> <p> TYPE: <code>int</code> </p> <code>idx_end</code> <p> TYPE: <code>int</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def combine_matching_activities(self, idx_start: int, idx_end: int) -&gt; None:\n    \"\"\"Combine two given activities into same activity, remove surplus Legs\n\n    Args:\n      idx_start (int):\n      idx_end (int):\n\n    \"\"\"\n    self.day[idx_start].end_time = self.day[idx_end].end_time  # extend proceeding act\n    self.day.pop(idx_end)  # remove subsequent activity\n    self.day.pop(idx_end - 1)  # remove subsequent leg\n    self.day.pop(idx_start + 1)  # remove proceeding leg\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.combine_wrapped_activities","title":"<code>combine_wrapped_activities(idx_start, idx_end)</code>","text":"<p>Combine two given activities that will wrap around day, remove surplus Legs</p> PARAMETER  DESCRIPTION <code>idx_start</code> <p> TYPE: <code>int</code> </p> <code>idx_end</code> <p> TYPE: <code>int</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def combine_wrapped_activities(self, idx_start: int, idx_end: int) -&gt; None:\n    \"\"\"Combine two given activities that will wrap around day, remove surplus Legs\n\n    Args:\n      idx_start (int):\n      idx_end (int):\n\n    \"\"\"\n    # extend proceeding act to end of day\n    self.day[idx_start].end_time = pam.variables.END_OF_DAY\n    # extend subsequent act to start of day\n    self.day[idx_end].start_time = pam.utils.minutes_to_datetime(0)\n    self.day.pop(idx_start + 1)  # remove proceeding leg\n    self.day.pop(idx_end - 1)  # remove subsequent leg\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.crop","title":"<code>crop()</code>","text":"<p>Crop a plan to end of day (END_OF_DAY). Plan components that start after this time are removed. Activities that end after this time are trimmed. If the last component is a Leg, this leg is removed and the previous activity extended.</p> Source code in <code>pam/activity.py</code> <pre><code>def crop(self):\n    \"\"\"Crop a plan to end of day (END_OF_DAY). Plan components that start after this\n    time are removed. Activities that end after this time are trimmed. If the last component\n    is a Leg, this leg is removed and the previous activity extended.\n\n    \"\"\"\n    # crop plan beyond end of day\n    for idx, component in list(self.reversed()):\n        if component.start_time &gt; pam.variables.END_OF_DAY:\n            self.logger.debug(\"Cropping plan components\")\n            self.day = self.day[:idx]\n        else:\n            break\n\n    # crop plan that is out of sequence\n    for idx in range(1, self.length):\n        if self[idx].start_time &lt; self[idx - 1].end_time:\n            self.logger.debug(\"Cropping plan components\")\n            self.day = self.day[:idx]\n            break\n        if self[idx].start_time &gt; self[idx].end_time:\n            self.logger.debug(\"Cropping plan components\")\n            self.day = self.day[: idx + 1]\n            break\n\n    # deal with last component\n    if isinstance(self.day[-1], Activity):\n        self.day[-1].end_time = pam.variables.END_OF_DAY\n    else:\n        self.logger.debug(\"Cropping plan ending in Leg\")\n        self.day.pop(-1)\n        self.day[-1].end_time = pam.variables.END_OF_DAY\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.expand","title":"<code>expand(pivot_idx)</code>","text":"<p>Fill plan by expanding a pivot activity.</p> PARAMETER  DESCRIPTION <code>pivot_idx</code> <p> TYPE: <code>int</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def expand(self, pivot_idx: int) -&gt; None:\n    \"\"\"Fill plan by expanding a pivot activity.\n\n    Args:\n      pivot_idx (int):\n\n    \"\"\"\n    # todo this isn't great - just pushes other activities to edges of day\n\n    new_time = pam.utils.minutes_to_datetime(0)\n    for seq in range(pivot_idx + 1):  # push forward pivot and all proceeding components\n        new_time = self.day[seq].shift_start_time(new_time)\n\n    new_time = pam.variables.END_OF_DAY\n    for seq in range(self.length - 1, pivot_idx, -1):  # push back all subsequent components\n        new_time = self.day[seq].shift_end_time(new_time)\n\n    self.day[pivot_idx].end_time = new_time  # expand pivot\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.fill_plan","title":"<code>fill_plan(idx_start, idx_end, default='home')</code>","text":"<p>Fill a plan after Activity has been removed.</p> <p>Plan is filled between given remaining activity locations (idx_start and idx_end). Note that the plan will also have legs that need to be removed.</p> PARAMETER  DESCRIPTION <code>idx_start</code> <p>location of previous Activity.</p> <p> TYPE: <code>Union[int, None]</code> </p> <code>idx_end</code> <p>location of subsequent Activity.</p> <p> TYPE: <code>Union[int, None]</code> </p> <code>default</code> <p>Not Used. Defaults to \"home\".</p> <p> TYPE: <code>Any</code> DEFAULT: <code>'home'</code> </p> RETURNS DESCRIPTION <code>True</code> <p> TYPE: <code>True</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def fill_plan(\n    self, idx_start: Union[int, None], idx_end: Union[int, None], default: Any = \"home\"\n) -&gt; True:\n    \"\"\"Fill a plan after Activity has been removed.\n\n    Plan is filled between given remaining\n    activity locations (idx_start and idx_end). Note that the plan will also have legs that\n    need to be removed.\n\n    Args:\n      idx_start (Union[int, None]): location of previous Activity.\n      idx_end (Union[int, None]): location of subsequent Activity.\n      default (Any, optional): Not Used. Defaults to \"home\".\n\n    Returns:\n      True:\n\n    \"\"\"\n    self.logger.debug(f\" fill_plan, {idx_start}-&gt;{idx_end}\")\n\n    if idx_start is None and idx_end is None:  # Assume stay at home\n        self.stay_at_home()\n        return True\n\n    if idx_start is None:  # start of day non wrapping\n        self.day.pop(0)\n        self.expand(idx_end - 1)  # shifted because we popped index 0\n        return True\n\n    if idx_end is None:  # end of day non wrapping\n        self.day.pop(-1)\n        self.expand(idx_start)\n        return True\n\n    if idx_start == idx_end:  # this is a single remaining activity -&gt; stay at home\n        if self.position_of(target=\"home\") is None:\n            raise ValueError(\"Require home activity\")\n        self.stay_at_home()\n        return True\n\n    if self.day[idx_start] == self.day[idx_end]:  # combine activities\n        \"\"\"\n        These activities are the same (based on type and location), so can be combined,\n        but there are 2 sub cases:\n        i) idx_start &lt; idx_end -&gt; wrapped combine\n        ii) else -&gt; regular combine can ignore wrapping\n        \"\"\"\n\n        if idx_end &lt; idx_start:  # this is a wrapped activity --&gt; close it\n            # todo probably don't need to pass the idx - know that it must be first and last\n            self.combine_wrapped_activities(idx_start, idx_end)\n            return True\n\n        # this is a regular non wrapped mid plan activity -&gt; combine acts\n        self.combine_matching_activities(idx_start, idx_end)\n        return True\n\n    \"\"\"\n    Remaining are plans where the activities are different so fill not be combined, instread\n    we will use 'expand' to refill the plan. There are 2 sub cases:\n    i) idx_start &lt; idx_end -&gt; wrapped combine\n    ii) else -&gt; regular combine can ignore wrapping\n    \"\"\"\n\n    if idx_end &lt; idx_start:  # this is a wrapped activity --&gt; close it\n        self.day.pop(0)  # remove start leg\n        self.day.pop(-1)  # remove end leg\n\n        pivot_idx = self.position_of(target=\"home\")\n        if pivot_idx is None:\n            self.logger.warning(\"Unable to find home activity, changing plan to stay at home\")\n            self.stay_at_home()\n            return True\n\n        self.expand(pivot_idx)\n        return True\n\n    # need to change first leg for new destination\n    self.join_activities(idx_start, idx_end)\n    return True\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.finalise_activity_end_times","title":"<code>finalise_activity_end_times()</code>","text":"<p>Add activity end times based on start time of next activity.</p> Source code in <code>pam/activity.py</code> <pre><code>def finalise_activity_end_times(self):\n    \"\"\"Add activity end times based on start time of next activity.\"\"\"\n    if len(self.day) &gt; 1:\n        for seq in range(0, len(self.day) - 1, 2):  # activities excluding last one\n            self.day[seq].end_time = self.day[seq + 1].start_time\n    self.day[-1].end_time = pam.variables.END_OF_DAY\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.fix","title":"<code>fix(crop=True, times=True, locations=True)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def fix(self, crop=True, times=True, locations=True):\n    if crop:\n        self.crop()\n    if times:\n        self.fix_time_consistency()\n    if locations:\n        self.fix_location_consistency()\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.fix_location_consistency","title":"<code>fix_location_consistency()</code>","text":"<p>Force plan locations consistency by adjusting leg locations.</p> Source code in <code>pam/activity.py</code> <pre><code>def fix_location_consistency(self):\n    \"\"\"Force plan locations consistency by adjusting leg locations.\"\"\"\n    for i in range(1, self.length - 1):\n        component = self.day[i]\n\n        if isinstance(component, Leg):\n            component.start_location = copy(self.day[i - 1].location)\n            component.end_location = copy(self.day[i + 1].location)\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.fix_time_consistency","title":"<code>fix_time_consistency()</code>","text":"<p>Force plan component time consistency.</p> Source code in <code>pam/activity.py</code> <pre><code>def fix_time_consistency(self):\n    \"\"\"Force plan component time consistency.\"\"\"\n    for i in range(self.length - 1):\n        self.day[i + 1].start_time = self.day[i].end_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.get","title":"<code>get(idx, default=None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def get(self, idx, default=None):\n    if -self.length &lt;= idx &lt; self.length:\n        return self.day[idx]\n    return default\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.get_home_duration","title":"<code>get_home_duration()</code>","text":"<p>Get the total duration of home activities.</p> Source code in <code>pam/activity.py</code> <pre><code>def get_home_duration(self):\n    \"\"\"Get the total duration of home activities.\"\"\"\n    # total time spent at home\n    home_duration = timedelta(0)\n    for plan in self.day:\n        if plan.act == \"home\":\n            home_duration += plan.duration\n\n    return home_duration\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.get_leg_tour","title":"<code>get_leg_tour(seq)</code>","text":"<p>Get the tour of a leg</p> PARAMETER  DESCRIPTION <code>seq</code> <p>plan sequence. Must be a leg sequence.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list</code> <p>activities in a tour.</p> <p> TYPE: <code>list</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def get_leg_tour(self, seq: int) -&gt; list:\n    \"\"\"Get the tour of a leg\n\n    Args:\n      seq (int): plan sequence. Must be a leg sequence.\n\n    Returns:\n      list: activities in a tour.\n\n    \"\"\"\n    assert isinstance(self.day[seq], Leg)\n\n    act_from = self.day[seq - 1]\n    act_to = self.day[seq + 1]\n\n    for tour in self.activity_tours():\n        for tour_act in tour:\n            if act_from.is_exact(tour_act) or act_to.is_exact(tour_act):\n                return tour\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.infer_activities_from_tour_purpose","title":"<code>infer_activities_from_tour_purpose()</code>","text":"<p>Infer and set activity types based on trip purpose.</p> <p>Algorithm works like breadth first search, initiated from inferred home locations. Search takes place in two stages, first pass forward, the backward. The next activity type is set based on the trip purpose. Pass forward is exhausted first, because it's assumed that this is how the diary is originally filled in.</p> Source code in <code>pam/activity.py</code> <pre><code>def infer_activities_from_tour_purpose(self) -&gt; None:\n    \"\"\"Infer and set activity types based on trip purpose.\n\n    Algorithm works like breadth first search,\n    initiated from inferred home locations. Search takes place in two stages, first pass forward,\n    the backward. The next activity type is set based on the trip purpose. Pass forward is exhausted\n    first, because it's assumed that this is how the diary is originally filled in.\n\n    \"\"\"\n    # find home activities\n    home_idxs = self.infer_activity_idxs(target=self.home)\n    for idx in home_idxs:\n        self.day[idx].act = \"home\"\n\n    area_map = {}\n    remaining = set(range(0, self.length, 2)) - set(home_idxs)\n\n    # forward traverse\n    queue = [\n        idx + 2 for idx in home_idxs if idx + 2 &lt; self.length\n    ]  # add next act idxs to queue\\\n    last_act = None\n\n    while queue:  # traverse from home\n        idx = queue.pop()\n\n        if self.day[idx].act is None:\n            act = self.day[idx - 1].purp.lower()\n            location = str(self.day[idx].location.min)\n\n            if act == last_act and location in area_map:\n                act = area_map[location]\n\n            self.day[idx].act = act\n            remaining -= {idx}\n            last_act = act\n            area_map[location] = act\n\n            if idx + 2 in remaining:\n                queue.append(idx + 2)\n\n    queue = []\n    for location, activity in area_map.items():\n        candidates = self.infer_activity_idxs(target=Location(area=location), default=False)\n        for idx in candidates:\n            if idx in remaining:\n                self.day[idx].act = activity\n                remaining -= {idx}\n                if idx + 2 in remaining:\n                    queue.append(idx + 2)\n\n    while queue:\n        idx = queue.pop()\n\n        if self.day[idx].act is None:\n            act = self.day[idx - 1].purp.lower()\n            location = self.day[idx].location.min\n\n            if act == last_act and location in area_map:\n                act = area_map[location]\n\n            self.day[idx].act = act\n            remaining -= {idx}\n            last_act = act\n            area_map[location] = act\n\n            if idx + 2 &lt; self.length:\n                queue.append(idx + 2)\n\n    # backward traverse\n    queue = list(remaining)  # add next act idxs to queue\n\n    while queue:  # traverse from home\n        idx = queue.pop()\n\n        if self.day[idx].act is None:\n            act = self.day[idx + 1].purp.lower()\n            location = self.day[idx].location.min\n\n            if act == last_act and location in area_map:\n                act = area_map[location]\n\n            self.day[idx].act = act\n            remaining -= {idx}\n            last_act = act\n            area_map[location] = act\n\n            if idx - 2 &gt;= 0:\n                queue.append(idx - 2)\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.infer_activity_idxs","title":"<code>infer_activity_idxs(target, default=True)</code>","text":"<p>Infer idxs of home activity based on location.</p> <p>First pass looks to exclude other acts at home location, second pass adds home idxs. If a leg is found to start and end at the home location then the one with maximum duration is included.</p> PARAMETER  DESCRIPTION <code>target</code> <p> TYPE: <code>Location</code> </p> <code>default</code> <p>Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>set</code> <p> TYPE: <code>set</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def infer_activity_idxs(self, target: Location, default: bool = True) -&gt; set:\n    \"\"\"Infer idxs of home activity based on location.\n\n    First pass looks to exclude other acts at home location, second pass adds home idxs.\n    If a leg is found to start and end at the home location then the one with maximum duration is included.\n\n    Args:\n      target (Location):\n      default (bool, optional): Defaults to True.\n\n    Returns:\n        set:\n    \"\"\"\n    # todo untested for more than three possible home activities in a row.\n    candidates = set()\n    exclude = set()\n\n    for idx, leg in enumerate(self.legs):\n        prev_act_idx = 2 * idx\n        next_act_idx = prev_act_idx + 2\n        if leg.start_location == leg.end_location == target:  # check for larger duration\n            if self.closed_duration(prev_act_idx) &gt; self.closed_duration(next_act_idx):\n                exclude.add(next_act_idx)\n            else:\n                exclude.add(prev_act_idx)\n\n    for idx, act in enumerate(self.activities):\n        if act.location == target and (idx * 2) not in exclude:\n            candidates.add(idx * 2)\n\n    if default and not candidates:  # assume first activity (and last if closed)\n        if self.closed:\n            return set([0, self.length - 1])\n        return set([0])\n\n    return candidates\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.join_activities","title":"<code>join_activities(idx_start, idx_end)</code>","text":"<p>Join together two Activities with new Leg, expand last home activity.</p> PARAMETER  DESCRIPTION <code>idx_start</code> <p> TYPE: <code>int</code> </p> <code>idx_end</code> <p> TYPE: <code>int</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def join_activities(self, idx_start: int, idx_end: int) -&gt; None:\n    \"\"\"Join together two Activities with new Leg, expand last home activity.\n\n    Args:\n      idx_start (int):\n      idx_end (int):\n\n    \"\"\"\n    self.day[idx_start + 1].end_location = self.day[idx_end - 1].end_location\n    self.day[idx_start + 1].purp = self.day[idx_end - 1].purp\n    self.day.pop(idx_end - 1)  # remove second leg\n\n    # todo add logic to change mode and time of leg\n\n    # press plans away from pivoting activity\n    pivot_idx = self.position_of(target=\"home\")\n    if pivot_idx is None:\n        self.logger.warning(\"Unable to find home activity, changing plan to stay at home\")\n        self.stay_at_home()\n        return None\n\n    self.expand(pivot_idx)\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.mode_shift","title":"<code>mode_shift(seq, new_mode='walk', mode_speed={'car': 37, 'bus': 10, 'walk': 4, 'cycle': 14, 'pt': 23, 'rail': 37}, update_duration=False)</code>","text":"<p>Changes mode for a leg, along with any legs in the same tour.</p> <p>Leg durations are adjusted to mode speed, and home activity durations revisited to fit within the 24-hr plan. Default speed values are from National Travel Survey data (NTS0303).</p> PARAMETER  DESCRIPTION <code>seq</code> <p>leg index in self.day</p> <p> TYPE: <code>int</code> </p> <code>new_mode</code> <p>default mode shift. Defaults to \"walk\".</p> <p> TYPE: <code>string</code> DEFAULT: <code>'walk'</code> </p> <code>mode_speed</code> <p>a dictionary of average mode speeds (kph). Defaults to {\"car\": 37, \"bus\": 10, \"walk\": 4, \"cycle\": 14, \"pt\": 23, \"rail\": 37}.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{'car': 37, 'bus': 10, 'walk': 4, 'cycle': 14, 'pt': 23, 'rail': 37}</code> </p> <code>update_duration</code> <p>whether to update leg durations based on mode speed. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def mode_shift(\n    self,\n    seq: int,\n    new_mode=\"walk\",\n    mode_speed={\"car\": 37, \"bus\": 10, \"walk\": 4, \"cycle\": 14, \"pt\": 23, \"rail\": 37},\n    update_duration=False,\n) -&gt; None:\n    \"\"\"Changes mode for a leg, along with any legs in the same tour.\n\n    Leg durations are adjusted to mode speed, and home activity durations revisited to fit within the 24-hr plan.\n    Default speed values are from National Travel Survey data (NTS0303).\n\n    Args:\n      seq (int): leg index in self.day\n      new_mode (string, optional): default mode shift. Defaults to \"walk\".\n      mode_speed (dict, optional): a dictionary of average mode speeds (kph). Defaults to {\"car\": 37, \"bus\": 10, \"walk\": 4, \"cycle\": 14, \"pt\": 23, \"rail\": 37}.\n      update_duration (bool, optional): whether to update leg durations based on mode speed. Defaults to False.\n\n    \"\"\"\n    assert isinstance(self.day[seq], Leg)\n\n    tour = self.get_leg_tour(seq)\n    for seq, plan in enumerate(self.day):\n        if isinstance(plan, Leg):\n            act_from = self.day[seq - 1]\n            act_to = self.day[seq + 1]\n            for other_act in tour:\n                # if any of the trip ends belongs in the tour change the mode\n                if act_from.is_exact(other_act) or act_to.is_exact(other_act):\n                    if update_duration:\n                        shift_duration = (\n                            (mode_speed[plan.mode] / mode_speed[new_mode]) * plan.duration\n                        ) - plan.duration  # calculate any trip duration changes due to mode shift\n                    plan.mode = new_mode  # change mode\n                    if update_duration:\n                        self.change_duration(\n                            seq=seq, shift_duration=shift_duration\n                        )  # change the duration of the trip\n\n    if update_duration:\n        # adjust home activities time in order fit revised legs/activities within a 24hr day\n        home_duration = self.get_home_duration()\n        home_duration_factor = (\n            self.day[-1].end_time - END_OF_DAY\n        ) / home_duration  # factor to adjust home activity time by\n\n        for seq, plan in enumerate(self.day):\n            if plan.act == \"home\":\n                shift_duration = -home_duration_factor * plan.duration\n                shift_duration = timedelta(\n                    seconds=round(shift_duration / timedelta(seconds=1))\n                )  # round to second\n                self.change_duration(seq=seq, shift_duration=shift_duration)\n\n        # make sure the last activity ends in the end of day (ie remove potential rounding errors)\n        if self.day[-1].end_time != END_OF_DAY:\n            self.day[-1].end_time = END_OF_DAY\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.move_activity","title":"<code>move_activity(seq, default='home', new_mode='walk')</code>","text":"<p>Changes Activity location and associated journeys</p> PARAMETER  DESCRIPTION <code>seq</code> <p> TYPE: <code>int</code> </p> <code>default</code> <p>Defaults to \"home\".</p> <p> TYPE: <code>Union[Literal['home'], Location]</code> DEFAULT: <code>'home'</code> </p> <code>new_mode</code> <p>access/egress journey switching to this mode. Ie 'walk'. Defaults to \"walk\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'walk'</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def move_activity(\n    self, seq: int, default: Union[Literal[\"home\"], Location] = \"home\", new_mode: str = \"walk\"\n) -&gt; None:\n    \"\"\"Changes Activity location and associated journeys\n\n    Args:\n      seq (int):\n      default (Union[Literal[\"home\"], Location], optional): Defaults to \"home\".\n      new_mode (str, optional): access/egress journey switching to this mode. Ie 'walk'. Defaults to \"walk\".\n\n    \"\"\"\n    assert isinstance(self.day[seq], Activity)\n\n    # decide on the new location\n    if default == \"home\":\n        new_location = self.home\n    else:\n        assert isinstance(default, Location)\n        new_location = default\n\n    # actually update the location\n    self.day[seq].location = new_location\n    if seq != 0:\n        # if it's not the first activity of plan\n        # update leg that leads to activity at seq\n        self.day[seq - 1].end_location = new_location\n        self.mode_shift(seq - 1, new_mode)\n    if seq != len(self.day) - 1:\n        # if it's not the last activity of plan\n        # update leg that leads to activity at seq\n        self.day[seq + 1].start_location = new_location\n        self.mode_shift(seq + 1, new_mode)\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.plot","title":"<code>plot(**kwargs)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def plot(self, **kwargs):\n    plot.plot_plan(self, **kwargs)\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.position_of","title":"<code>position_of(target='home', search='last')</code>","text":"<p>Return position of target activity type (either first or last depending on search).</p> PARAMETER  DESCRIPTION <code>target</code> <p>Defaults to \"home\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'home'</code> </p> <code>search</code> <p>Defaults to \"last\".</p> <p> TYPE: <code>Literal['first', 'last']</code> DEFAULT: <code>'last'</code> </p> RETURNS DESCRIPTION <code>Union[int, None]</code> <p>Union[int, None]: None if target activity type is not found.</p> Source code in <code>pam/activity.py</code> <pre><code>def position_of(\n    self, target: str = \"home\", search: Literal[\"first\", \"last\"] = \"last\"\n) -&gt; Union[int, None]:\n    \"\"\"Return position of target activity type (either first or last depending on search).\n\n    Args:\n        target (str, optional): Defaults to \"home\".\n        search (Literal['first', 'last'], optional): Defaults to \"last\".\n\n    Returns:\n        Union[int, None]: None if target activity type is not found.\n\n    \"\"\"\n    if search == \"last\":\n        last = None\n        for seq, act in enumerate(self.day):\n            if act.act.lower() == target:\n                last = seq\n        return last\n\n    if search == \"first\":\n        for seq, act in enumerate(self.day):\n            if act.act.lower() == target:\n                return seq\n\n    raise UserWarning(\"Method only supports search types 'first' or 'last'.\")\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.print","title":"<code>print()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def print(self):\n    for seq, component in enumerate(self):\n        print(f\"{seq}:\\t{component}\")\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.remove_activity","title":"<code>remove_activity(seq)</code>","text":"<p>Remove an activity from plan at given seq.</p> <p>Does not remove adjacent legs. Will also check if an activity is wrapped and remove accordingly. Returns</p> PARAMETER  DESCRIPTION <code>seq</code> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>tuple[Union[int, None], Union[int, None]]</code> <p>tuple[Union[int, None], Union[int, None]]: (adjusted) idx of previous (p_idx) and subsequent (s_idx) activities as a tuple. If there is no previous or subsequent activity, ie a removed activity is at the start or end of an open plan, then None can be returned. If all activities are removed then None, None is returned.</p> Source code in <code>pam/activity.py</code> <pre><code>def remove_activity(self, seq: int) -&gt; tuple[Union[int, None], Union[int, None]]:\n    \"\"\"Remove an activity from plan at given seq.\n\n    Does not remove adjacent legs.\n    Will also check if an activity is wrapped and remove accordingly. Returns\n\n    Args:\n      seq (int):\n\n    Returns:\n      tuple[Union[int, None], Union[int, None]]:\n        (adjusted) idx of previous (p_idx) and subsequent (s_idx) activities as a tuple.\n        If there is no previous or subsequent activity, ie a removed activity is at the start or end of an open plan, then None can be returned.\n        If all activities are removed then None, None is returned.\n\n    \"\"\"\n    assert isinstance(self.day[seq], Activity)\n\n    if seq == 0 and seq == self.length - 1:  # remove activity that is entire plan\n        self.logger.debug(\n            f\" remove_activity, idx:{seq} type:{self.day[seq].act}, plan now empty\"\n        )\n        self.day.pop(0)\n        return None, None\n\n    if (seq == 0 or seq == self.length - 1) and self.closed:  # remove activity that wraps\n        self.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}, wraps\")\n        self.day.pop(0)\n        self.day.pop(self.length - 1)\n        if self.length == 1:  # all activities have been removed\n            self.logger.debug(\n                f\" remove_activity, idx:{seq} type:{self.day[seq].act}, now empty\"\n            )\n            return None, None\n        return self.length - 2, 1\n\n    if seq == 0:  # remove first activity\n        self.logger.debug(\n            f\" remove_activity, idx:{seq} type:{self.day[seq].act}, first activity\"\n        )\n        self.day.pop(seq)\n        return None, 1\n\n    if seq == self.length - 1:  # remove last activity\n        self.logger.debug(\n            f\" remove_activity, idx:{seq} type:{self.day[seq].act}, last activity\"\n        )\n        self.day.pop(seq)\n        return self.length - 2, None\n\n    else:  # remove activity somewhere in middle of plan\n        self.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}\")\n        self.day.pop(seq)\n        return seq - 2, seq + 1\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.reversed","title":"<code>reversed()</code>","text":"<p>Reverse iterate through plan, yield idx and component.</p> Source code in <code>pam/activity.py</code> <pre><code>def reversed(self):\n    \"\"\"Reverse iterate through plan, yield idx and component.\"\"\"\n    for i in range(self.length - 1, -1, -1):\n        yield i, self[i]\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.set_leg_purposes","title":"<code>set_leg_purposes()</code>","text":"<p>Set leg purposes to destination activity.</p> <p>Skip 'pt interaction' activities.</p> Source code in <code>pam/activity.py</code> <pre><code>def set_leg_purposes(self) -&gt; None:\n    \"\"\"Set leg purposes to destination activity.\n\n    Skip 'pt interaction' activities.\n\n    \"\"\"\n    for seq, component in enumerate(self):\n        if isinstance(component, Leg):\n            for j in range(seq + 1, len(self.day) - 1, 2):\n                act = self.day[j].act\n                if not act == \"pt interaction\":\n                    self.day[seq].purp = act\n                    break\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.simplify_pt_trips","title":"<code>simplify_pt_trips(ignore=['pt interaction', 'pt_interaction'])</code>","text":"<p>Remove public transit (pt) interaction events and simplify associated legs to single legs with dominant mode. Dominant mode is based on max (total) distance by each mode.</p> <p>For example, given the following trip:</p> <pre><code>home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n</code></pre> <p>Is simplified to:</p> <pre><code>home =bus=&gt; work\n</code></pre> <p>(In this example we are assuming that bus was used to travel further than the two walk legs). The final bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.</p> PARAMETER  DESCRIPTION <code>ignore</code> <p>activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>['pt interaction', 'pt_interaction']</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def simplify_pt_trips(self, ignore=[\"pt interaction\", \"pt_interaction\"]) -&gt; None:\n    \"\"\"Remove public transit (pt) interaction events and simplify associated legs to single legs with\n    dominant mode. Dominant mode is based on max (total) distance by each mode.\n\n    For example, given the following trip:\n\n        home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n\n    Is simplified to:\n\n        home =bus=&gt; work\n\n    (In this example we are assuming that bus was used to travel further than the two walk legs). The final\n    bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.\n\n    Args:\n      ignore (list[str], optional): activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].\n\n    \"\"\"\n    if set(ignore).intersection(self.activity_classes):\n        self.day = list(self.tripify(ignore=ignore))\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.stay_at_home","title":"<code>stay_at_home()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def stay_at_home(self):\n    self.logger.debug(f\" stay_at_home, location:{self.home}\")\n    self.day = [\n        Activity(\n            seq=1,\n            act=\"home\",\n            area=self.home.area,\n            start_time=pam.utils.minutes_to_datetime(0),\n            end_time=pam.variables.END_OF_DAY,\n        )\n    ]\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.trip_legs","title":"<code>trip_legs(ignore=['pt interaction', 'pt_interaction'])</code>","text":"<p>Yield plan trips as lists of legs. Trips are based on sequences of activity types used to separate legs within the same trip. The logic is based on the removal of public transit interaction activities.</p> PARAMETER  DESCRIPTION <code>ignore</code> <p>activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>['pt interaction', 'pt_interaction']</code> </p> YIELDS DESCRIPTION <code>str</code> <p>Iterator[str]</p> Source code in <code>pam/activity.py</code> <pre><code>def trip_legs(self, ignore: list[str] = [\"pt interaction\", \"pt_interaction\"]) -&gt; Iterator[str]:\n    \"\"\"Yield plan trips as lists of legs. Trips are based on sequences of activity types used to separate\n    legs within the same trip. The logic is based on the removal of public transit interaction activities.\n\n    Args:\n      ignore (list[str], optional): activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].\n\n    Yields:\n        Iterator[str]\n\n    \"\"\"\n    if self.day:\n        legs = []\n        for component in self[1:]:\n            if isinstance(component, Leg):\n                legs.append(component)\n            elif component.act not in ignore:\n                yield legs\n                legs = []\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.tripify","title":"<code>tripify(ignore=['pt interaction', 'pt_interaction'])</code>","text":"<p>Iterate through plan components removing public transit (pt) interaction events and simplifying associated legs to single leg with dominant mode. Where dominant mode is based on max (total) distance by each mode for that trip.</p> <p>For example, given the following trip:</p> <pre><code>home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n</code></pre> <p>Is \"tripified\" to:</p> <pre><code>home =bus=&gt; work\n</code></pre> <p>(In this example we are assuming that bus was used to travel further than the two walk legs). The final bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.</p> PARAMETER  DESCRIPTION <code>ignore</code> <p>activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>['pt interaction', 'pt_interaction']</code> </p> RETURNS DESCRIPTION <code>Iterator[PlanComponent]</code> <p>Iterator[PlanComponent]</p> Source code in <code>pam/activity.py</code> <pre><code>def tripify(\n    self, ignore: list[str] = [\"pt interaction\", \"pt_interaction\"]\n) -&gt; Iterator[PlanComponent]:\n    \"\"\"Iterate through plan components removing public transit (pt) interaction events and simplifying\n    associated legs to single leg with dominant mode. Where dominant mode is based on max (total) distance\n    by each mode for that trip.\n\n    For example, given the following trip:\n\n        home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n\n    Is \"tripified\" to:\n\n        home =bus=&gt; work\n\n    (In this example we are assuming that bus was used to travel further than the two walk legs). The final\n    bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.\n\n    Args:\n      ignore (list[str], optional): activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].\n\n    Returns:\n        Iterator[PlanComponent]\n    \"\"\"\n    if self.day:\n        seq = 0\n        modes = {}\n        start_location = self.day[0].location\n        start_time = self.day[0].end_time\n        distance = 0\n        for component in self:\n            if isinstance(component, Leg):\n                modes[component.mode] = modes.get(component.mode, 0) + component.distance\n                distance += component.distance\n                attributes = component.attributes  # trips collect attributes from last leg\n            if isinstance(component, Activity):\n                if component.act not in ignore:\n                    while True:\n                        if modes:\n                            yield Leg(\n                                seq=seq,\n                                mode=max(modes, key=modes.get),\n                                start_area=start_location.area,\n                                end_area=component.location.area,\n                                start_link=start_location.link,\n                                end_link=component.location.link,\n                                start_loc=start_location.loc,\n                                end_loc=component.location.loc,\n                                start_time=start_time,\n                                end_time=component.start_time,\n                                distance=distance,\n                                purp=component.act,\n                                attributes=attributes,\n                            )\n                        yield component\n                        break\n                    modes = {}\n                    start_location = component.location\n                    start_time = component.end_time\n                    distance = 0\n                    seq += 1\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.trips","title":"<code>trips(ignore=['pt interaction', 'pt_interaction'])</code>","text":"<p>Iterate through plan trips. Multi-modal leg trips are simplified to single trip with dominant mode. Where dominant mode is based on max (total) distance by each mode for that trip. The logic is based on the removal of public transit interaction activities.</p> <p>For example, given the following legs:</p> <pre><code>home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n</code></pre> <p>Is simplified to:</p> <pre><code>home =bus=&gt; work\n</code></pre> <p>(In this example we are assuming that bus was used to travel further than the two walk legs). The final bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.</p> PARAMETER  DESCRIPTION <code>ignore</code> <p>activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>['pt interaction', 'pt_interaction']</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Iterator[Trip]</p> Source code in <code>pam/activity.py</code> <pre><code>def trips(self, ignore: list[str] = [\"pt interaction\", \"pt_interaction\"]) -&gt; str:\n    \"\"\"Iterate through plan trips. Multi-modal leg trips are simplified to single trip with dominant mode.\n    Where dominant mode is based on max (total) distance by each mode for that trip. The logic is based on\n    the removal of public transit interaction activities.\n\n    For example, given the following legs:\n\n        home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n\n    Is simplified to:\n\n        home =bus=&gt; work\n\n    (In this example we are assuming that bus was used to travel further than the two walk legs). The final\n    bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.\n\n    Args:\n      ignore (list[str], optional): activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].\n\n    Returns:\n        Iterator[Trip]\n    \"\"\"\n    if self.day:\n        seq = 0\n        modes = {}\n        start_location = self.day[0].location\n        start_time = self.day[0].end_time\n        distance = 0\n        for component in self[1:]:\n            if isinstance(component, Leg):\n                modes[component.mode] = modes.get(component.mode, 0) + component.distance\n                distance += component.distance\n                attributes = component.attributes\n            elif component.act not in ignore:\n                yield Trip(\n                    seq=seq,\n                    mode=max(modes, key=modes.get),\n                    start_area=start_location.area,\n                    end_area=component.location.area,\n                    start_link=start_location.link,\n                    end_link=component.location.link,\n                    start_loc=start_location.loc,\n                    end_loc=component.location.loc,\n                    start_time=start_time,\n                    end_time=component.start_time,\n                    distance=distance,\n                    purp=component.act,\n                    attributes=attributes,\n                )\n                modes = {}\n                start_location = component.location\n                start_time = component.end_time\n                distance = 0\n                seq += 1\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.validate","title":"<code>validate()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate(self):\n    self.validate_sequence()\n    self.validate_times()\n    self.validate_locations()\n    return True\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.validate_locations","title":"<code>validate_locations()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate_locations(self):\n    if not self.valid_locations:\n        raise PAMValidationLocationsError()\n    return True\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.validate_sequence","title":"<code>validate_sequence()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate_sequence(self):\n    if not self.valid_sequence:\n        raise PAMSequenceValidationError()\n    return True\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Plan.validate_times","title":"<code>validate_times()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate_times(self):\n    if not self.valid_time_sequence:\n        raise PAMInvalidTimeSequenceError(\"Plan activity and trips times are not consistent\")\n    return True\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.PlanComponent","title":"<code>PlanComponent</code>","text":""},{"location":"reference/pam/activity/#pam.activity.PlanComponent.duration","title":"<code>duration</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.PlanComponent.hours","title":"<code>hours</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.PlanComponent.shift_duration","title":"<code>shift_duration(new_duration, new_start_time=None)</code>","text":"<p>Given a new duration and optionally start time, set start time &amp; set end time based on duration.</p> PARAMETER  DESCRIPTION <code>new_duration</code> <p> TYPE: <code>timedelta</code> </p> <code>new_start_time</code> <p>Defaults to None.</p> <p> TYPE: <code>datetime64</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new end time.</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_duration(\n    self, new_duration: timedelta, new_start_time: Optional[datetime64] = None\n) -&gt; datetime64:\n    \"\"\"Given a new duration and optionally start time, set start time &amp; set end time based on duration.\n\n    Args:\n      new_duration (timedelta):\n      new_start_time (datetime64, optional): Defaults to None.\n\n    Returns:\n      datetime64: new end time.\n\n    \"\"\"\n    if new_start_time is not None:\n        self.start_time = new_start_time\n    self.end_time = self.start_time + new_duration\n    return self.end_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.PlanComponent.shift_end_time","title":"<code>shift_end_time(new_end_time)</code>","text":"<p>Given a new end time, set end time &amp; start time based on previous duration.</p> PARAMETER  DESCRIPTION <code>new_end_time</code> <p> TYPE: <code>datetime64</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new start time.</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_end_time(self, new_end_time: datetime64) -&gt; datetime64:\n    \"\"\"Given a new end time, set end time &amp; start time based on previous duration.\n\n    Args:\n      new_end_time (datetime64):\n\n    Returns:\n      datetime64: new start time.\n\n    \"\"\"\n    duration = self.duration\n    self.end_time = new_end_time\n    self.start_time = new_end_time - duration\n    return self.start_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.PlanComponent.shift_start_time","title":"<code>shift_start_time(new_start_time)</code>","text":"<p>Given a new start time, set start time &amp; end time based on previous duration.</p> PARAMETER  DESCRIPTION <code>new_start_time</code> <p> TYPE: <code>datetime64</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new end time</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_start_time(self, new_start_time: datetime64) -&gt; datetime64:\n    \"\"\"Given a new start time, set start time &amp; end time based on previous duration.\n\n    Args:\n        new_start_time (datetime64):\n\n    Returns:\n        datetime64: new end time\n\n    \"\"\"\n    duration = self.duration\n    self.start_time = new_start_time\n    self.end_time = new_start_time + duration\n    return self.end_time\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Route","title":"<code>Route(xml_elem=None)</code>","text":"<p>xml element wrapper for leg routes, in the simplest case of a leg with no route, this will behave as an empty dictionary. For routed legs this provides some convenience properties such as is_transit, and transit_route.</p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(self, xml_elem=None) -&gt; None:\n    if xml_elem:\n        self.xml = xml_elem[0]\n    else:\n        self.xml = {}  # this allows an empty route to behave as an empty dict\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Route.distance","title":"<code>distance: float</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Route.exists","title":"<code>exists: bool</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Route.is_routed","title":"<code>is_routed: bool</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Route.is_teleported","title":"<code>is_teleported: bool</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Route.is_transit","title":"<code>is_transit: bool</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Route.network_route","title":"<code>network_route: list</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Route.transit","title":"<code>transit: dict</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Route.type","title":"<code>type</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Route.xml","title":"<code>xml = xml_elem[0]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.Route.get","title":"<code>get(key, default=None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def get(self, key, default=None) -&gt; str:\n    return self.xml.get(key, default)\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.RouteV11","title":"<code>RouteV11(xml_elem)</code>","text":"<p>             Bases: <code>Route</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(self, xml_elem) -&gt; None:\n    super().__init__(xml_elem)\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.RouteV11.distance","title":"<code>distance: float</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.RouteV11.exists","title":"<code>exists: bool</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.RouteV11.is_routed","title":"<code>is_routed: bool</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.RouteV11.is_teleported","title":"<code>is_teleported: bool</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.RouteV11.is_transit","title":"<code>is_transit: bool</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.RouteV11.network_route","title":"<code>network_route: list</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.RouteV11.transit","title":"<code>transit: dict</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.RouteV11.type","title":"<code>type</code>  <code>property</code>","text":""},{"location":"reference/pam/activity/#pam.activity.RouteV11.xml","title":"<code>xml = xml_elem[0]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/activity/#pam.activity.RouteV11.get","title":"<code>get(key, default=None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def get(self, key, default=None) -&gt; str:\n    return self.xml.get(key, default)\n</code></pre>"},{"location":"reference/pam/activity/#pam.activity.Trip","title":"<code>Trip(seq=None, mode=None, start_area=None, end_area=None, start_link=None, end_link=None, start_loc=None, end_loc=None, start_time=None, end_time=None, distance=None, purp=None, freq=None, attributes={}, route=None)</code>","text":"<p>             Bases: <code>Leg</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(\n    self,\n    seq=None,\n    mode=None,\n    start_area=None,\n    end_area=None,\n    start_link=None,\n    end_link=None,\n    start_loc=None,\n    end_loc=None,\n    start_time=None,\n    end_time=None,\n    distance=None,\n    purp=None,\n    freq=None,\n    attributes={},\n    route=None,\n):\n    self.seq = seq\n    self.purp = purp\n    self.mode = mode\n    self.start_location = Location(loc=start_loc, link=start_link, area=start_area)\n    self.end_location = Location(loc=end_loc, link=end_link, area=end_area)\n    self.start_time = start_time\n    self.end_time = end_time\n    self.freq = freq\n    self._distance = distance\n    # relevant for simulated plans\n    self.attributes = attributes\n    if route is not None:\n        self.route = route\n    else:\n        self.route = Route()\n</code></pre>"},{"location":"reference/pam/array/decode/","title":"pam.array.decode","text":""},{"location":"reference/pam/array/decode/#pam.array.decode.add_end_times","title":"<code>add_end_times(plan, end_of_day=END_OF_DAY)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def add_end_times(plan: list, end_of_day=END_OF_DAY):\n    # add end_times\n    for i in range(len(plan) - 1):\n        plan[i].end_time = plan[i + 1].start_time\n    plan[-1].end_time = end_of_day\n</code></pre>"},{"location":"reference/pam/array/decode/#pam.array.decode.fix_missing_components","title":"<code>fix_missing_components(plan, bin_size=3600, default_leg_mode='car', default_activity='other')</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def fix_missing_components(\n    plan: list, bin_size=3600, default_leg_mode=\"car\", default_activity=\"other\"\n):\n    for i in range(len(plan) - 1):\n        if isinstance(plan[i], type(plan[i + 1])):\n            start_time = plan[i].end_time - timedelta(seconds=int(bin_size / 4))\n            end_time = plan[i].end_time + timedelta(seconds=int(bin_size / 4))\n\n            if isinstance(plan[i], Activity):  # add missing Leg\n                plan.insert(\n                    i + 1, Leg(mode=default_leg_mode, start_time=start_time, end_time=end_time)\n                )\n                plan[i].end_time = start_time\n                plan[i + 2].start_time = end_time\n\n            if isinstance(plan[i], Leg):  # add missing Activity\n                plan.insert(\n                    i + 1, Activity(act=default_activity, start_time=start_time, end_time=end_time)\n                )\n                plan[i].end_time = start_time\n                plan[i + 2].start_time = end_time\n</code></pre>"},{"location":"reference/pam/array/decode/#pam.array.decode.fix_missing_end_activity","title":"<code>fix_missing_end_activity(plan, end_of_day=END_OF_DAY, bin_size=3600)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def fix_missing_end_activity(plan: list, end_of_day=END_OF_DAY, bin_size=3600):\n    if not isinstance(plan[-1], Activity):\n        start_time = end_of_day - timedelta(seconds=int(bin_size / 2))  # expected duration\n        plan.append(\n            Activity(act=\"home\", start_time=start_time, end_time=end_of_day)\n        )  # sensible assumption\n        plan[-2].end_time = start_time\n</code></pre>"},{"location":"reference/pam/array/decode/#pam.array.decode.fix_missing_start_activity","title":"<code>fix_missing_start_activity(plan, start_of_day=START_OF_DAY, bin_size=3600)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def fix_missing_start_activity(plan: list, start_of_day=START_OF_DAY, bin_size=3600):\n    if not isinstance(plan[0], Activity):\n        end_time = start_of_day + timedelta(seconds=int(bin_size / 2))  # expected duration\n        plan.insert(\n            0, Activity(act=\"home\", start_time=start_of_day, end_time=end_time)\n        )  # sensible assumption\n        plan[1].start_time = end_time\n</code></pre>"},{"location":"reference/pam/array/decode/#pam.array.decode.iter_array","title":"<code>iter_array(array, mapping, start_of_day=START_OF_DAY, bin_size=3600)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def iter_array(array, mapping, start_of_day=START_OF_DAY, bin_size=3600):\n    prev = None\n    for i, time_bin in enumerate(array):\n        if (prev is None) or (not np.array_equal(time_bin, prev)):  # new component class\n            component_class = mapping.get(np.argmax(time_bin))\n            if component_class is None:\n                raise UserWarning(\n                    f\"Not found index of {np.argmax(time_bin)} in supplied mapping: {mapping}.\"\n                )\n            yield component_class, start_of_day + timedelta(seconds=(i * bin_size))\n        prev = time_bin\n</code></pre>"},{"location":"reference/pam/array/decode/#pam.array.decode.one_hot_to_plan","title":"<code>one_hot_to_plan(array, mapping, bin_size=3600, duration=86400, start_of_day=START_OF_DAY, end_of_day=END_OF_DAY, leg_encoding='travel', default_leg_mode='car', default_activity='other')</code>","text":"<p>Decode a one-hot encoded plan array for a given mapping. Attempts to create a valid plan sequence by assuming obviously missing components. Does not support locations, these must be created manually.</p> PARAMETER  DESCRIPTION <code>array</code> <p>input one-hot encoded plan.</p> <p> TYPE: <code>array</code> </p> <code>mapping</code> <p>encoding index to activity, eg {0: 'home', 1:'travel'}.</p> <p> TYPE: <code>dict</code> </p> <code>bin_size</code> <p>in seconds. Defaults to 3600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3600</code> </p> <code>duration</code> <p>in seconds. Defaults to 86400.</p> <p> TYPE: <code>int</code> DEFAULT: <code>86400</code> </p> <code>start_of_day</code> <p>start datetime of first activity. Defaults to START_OF_DAY.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>START_OF_DAY</code> </p> <code>end_of_day</code> <p>end time of last activity. Defaults to END_OF_DAY.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>END_OF_DAY</code> </p> <code>leg_encoding</code> <p>activity encoding for travel components. Defaults to \"travel\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'travel'</code> </p> <code>default_leg_mode</code> <p>assumed leg mode when unknown. Defaults to \"car\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'car'</code> </p> <code>default_activity</code> <p>assumed activity when unknown. Defaults to \"other\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'other'</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>may raise a UserWarning if bin_size and duration are not consistent with array size.</p> RETURNS DESCRIPTION <code>Plan</code> <p>pam.activity.Plan</p> <p> TYPE: <code>Plan</code> </p> Source code in <code>pam/array/decode.py</code> <pre><code>def one_hot_to_plan(\n    array: np.array,\n    mapping: dict,\n    bin_size: int = 3600,\n    duration: int = 86400,\n    start_of_day: datetime = START_OF_DAY,\n    end_of_day: datetime = END_OF_DAY,\n    leg_encoding: str = \"travel\",\n    default_leg_mode: str = \"car\",\n    default_activity: str = \"other\",\n) -&gt; Plan:\n    \"\"\"Decode a one-hot encoded plan array for a given mapping. Attempts to create a valid plan sequence\n    by assuming obviously missing components. Does not support locations, these must be created\n    manually.\n\n    Args:\n        array (np.array): input one-hot encoded plan.\n        mapping (dict): encoding index to activity, eg {0: 'home', 1:'travel'}.\n        bin_size (int, optional): in seconds. Defaults to 3600.\n        duration (int, optional): in seconds. Defaults to 86400.\n        start_of_day (datetime, optional): start datetime of first activity. Defaults to START_OF_DAY.\n        end_of_day (datetime, optional): end time of last activity. Defaults to END_OF_DAY.\n        leg_encoding (str, optional): activity encoding for travel components. Defaults to \"travel\".\n        default_leg_mode (str, optional): assumed leg mode when unknown. Defaults to \"car\".\n        default_activity (str, optional): assumed activity when unknown. Defaults to \"other\".\n\n    Raises:\n        UserWarning: may raise a UserWarning if bin_size and duration are not consistent with array size.\n\n    Returns:\n        Plan: pam.activity.Plan\n    \"\"\"\n    bins = int(duration / bin_size)\n    if not len(array) == bins:\n        raise UserWarning(\n            \"Specified plan duration and bin lengths do not match given array length.\"\n        )\n\n    proposed_plan = []\n    for act, start_time in iter_array(\n        array=array, mapping=mapping, start_of_day=start_of_day, bin_size=bin_size\n    ):\n        if act == leg_encoding:  # add leg\n            proposed_plan.append(Leg(mode=default_leg_mode, start_time=start_time))\n        else:\n            proposed_plan.append(Activity(act=act, start_time=start_time))\n\n    add_end_times(proposed_plan, end_of_day)\n    fix_missing_start_activity(proposed_plan, start_of_day, bin_size)\n    fix_missing_end_activity(proposed_plan, end_of_day, bin_size)\n    fix_missing_components(proposed_plan, default_leg_mode, default_activity)\n\n    plan = Plan()\n    plan.day = proposed_plan\n    return plan\n</code></pre>"},{"location":"reference/pam/array/distance/","title":"pam.array.distance","text":""},{"location":"reference/pam/array/distance/#pam.array.distance.accuracy","title":"<code>accuracy(actual, predicted)</code>","text":"Source code in <code>pam/array/distance.py</code> <pre><code>def accuracy(actual: np.array, predicted: np.array) -&gt; float:\n    assert actual.shape == predicted.shape\n    correct = 0\n    for ia, ib in zip(actual, predicted):\n        if np.argmax(ia) == np.argmax(ib):\n            correct += 1\n    return correct / len(predicted)\n</code></pre>"},{"location":"reference/pam/array/distance/#pam.array.distance.cross_entropy","title":"<code>cross_entropy(actual, predicted)</code>","text":"Source code in <code>pam/array/distance.py</code> <pre><code>def cross_entropy(actual: np.array, predicted: np.array) -&gt; float:\n    assert actual.shape == predicted.shape\n    epsilon = 1e-12\n    predicted = np.clip(predicted, epsilon, 1.0 - epsilon)\n    return -np.sum(actual * np.log(predicted)) / actual.shape[0]\n</code></pre>"},{"location":"reference/pam/array/encode/","title":"pam.array.encode","text":""},{"location":"reference/pam/array/encode/#pam.array.encode.PlansToCategorical","title":"<code>PlansToCategorical(bin_size=3600, duration=86400)</code>","text":"<p>Tool for converting pam.core.plans to integer arrays.</p> PARAMETER  DESCRIPTION <code>bin_size</code> <p>Defaults to 3600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3600</code> </p> <code>duration</code> <p>Defaults to 86400.</p> <p> TYPE: <code>int</code> DEFAULT: <code>86400</code> </p> Example <p>|&lt;----A----&gt;||&lt;----B----&gt;||||&lt;----A----&gt;| =&gt; [0,0,0,1,1,1,2,0,0,0] Where 0 represents a time bin of activity A, 1 of B and so on. The axis represents time, binnned according to bin_size and total duration, both given in seconds. A mapping between the array values (indexes) and plan activities can be accessed via self.index_to_act and self.act_to_index. Note <ul> <li>Leg components will have the encoding \"travel\" which will be included in the mapping.</li> <li>Location and mode information is lost.</li> <li>Some plan components may be lost if their durations are less than the chosen bin six.</li> <li>Plan components beyond 24 hours are cropped.</li> </ul> Source code in <code>pam/array/encode.py</code> <pre><code>def __init__(self, bin_size: int = 3600, duration: int = 86400) -&gt; None:\n    \"\"\"Tool for converting pam.core.plans to integer arrays.\n\n    Args:\n        bin_size (int, optional): Defaults to 3600.\n        duration (int, optional): Defaults to 86400.\n\n    Example:\n        |&lt;----A----&gt;||&lt;----B----&gt;||&lt;C&gt;||&lt;----A----&gt;| =&gt; [0,0,0,1,1,1,2,0,0,0]\n        Where 0 represents a time bin of activity A, 1 of B and so on.\n        The axis represents time, binnned according to bin_size and total duration, both given in seconds.\n        A mapping between the array values (indexes) and plan activities can be accessed\n        via self.index_to_act and self.act_to_index.\n\n    Note:\n        - Leg components will have the encoding \"travel\" which will be included in the mapping.\n        - Location and mode information is lost.\n        - Some plan components may be lost if their durations are less than the chosen bin six.\n        - Plan components beyond 24 hours are cropped.\n\n    \"\"\"\n    self.bin_size = bin_size\n    self.duration = duration\n    self.bins = int(self.duration / self.bin_size)\n    self.index_to_act = {}\n    self.act_to_index = {}\n</code></pre>"},{"location":"reference/pam/array/encode/#pam.array.encode.PlansToCategorical.act_to_index","title":"<code>act_to_index = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/array/encode/#pam.array.encode.PlansToCategorical.bin_size","title":"<code>bin_size = bin_size</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/array/encode/#pam.array.encode.PlansToCategorical.bins","title":"<code>bins = int(self.duration / self.bin_size)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/array/encode/#pam.array.encode.PlansToCategorical.duration","title":"<code>duration = duration</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/array/encode/#pam.array.encode.PlansToCategorical.index_to_act","title":"<code>index_to_act = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/array/encode/#pam.array.encode.PlansToCategorical.encode","title":"<code>encode(plan)</code>","text":"<p>Transform a pam.activity.Plan into a categorical integer array.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>input Plan object to be encoded as one-hot.</p> <p> TYPE: <code>Plan</code> </p> RETURNS DESCRIPTION <code>array</code> <p>np.array: encoded plan</p> Source code in <code>pam/array/encode.py</code> <pre><code>def encode(self, plan: Plan) -&gt; np.array:\n    \"\"\"Transform a pam.activity.Plan into a categorical integer array.\n\n    Args:\n      plan (Plan): input Plan object to be encoded as one-hot.\n\n    Returns:\n      np.array: encoded plan\n\n    \"\"\"\n    encoded = np.zeros((self.bins))\n    start_bin = 0\n    reference_time = plan.day[0].start_time\n    for component in plan.day:\n        act = component.act\n        if act not in self.act_to_index:\n            index = len(self.act_to_index)\n            self.act_to_index[act] = index\n            self.index_to_act[index] = act\n        index = self.act_to_index[act]\n        end_bin = round(td_to_s(component.end_time - reference_time) / self.bin_size)\n\n        if end_bin &gt;= self.duration:  # deal with last component\n            end_bin = self.duration\n            encoded[start_bin:end_bin] = index\n            break\n\n        encoded[start_bin:end_bin] = index\n        start_bin = end_bin\n\n    return encoded\n</code></pre>"},{"location":"reference/pam/array/encode/#pam.array.encode.PlansToCategorical.get_act","title":"<code>get_act(index)</code>","text":"Source code in <code>pam/array/encode.py</code> <pre><code>def get_act(self, index):\n    return self.index_to_act.get(index)\n</code></pre>"},{"location":"reference/pam/array/encode/#pam.array.encode.plan_to_one_hot","title":"<code>plan_to_one_hot(plan, mapping, bin_size=3600, duration=86400)</code>","text":"<p>Transform a pam.activity.Plan into a one-hot encoded array. Output array is two dimensional. First axis represents time, binnned according to bin_size given in seconds. Seconds axis is a one-hot endcoding of activity type based on the given mapping. Note that Leg components will have the encoding \"travel\" which should be included in the mapping. Location and mode information is lost. Some plan components may be lost if their durations are less than the chosen bin six. Plan components beyond 24 hours are cropped.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>input Plan object to be encoded as one-hot</p> <p> TYPE: <code>Plan</code> </p> <code>mapping</code> <p>dictionary mapping of activity types to one-hot index, eg {\"home\":0, \"travel\":1}</p> <p> TYPE: <code>dict</code> </p> <code>bin_size</code> <p>time bin size (in seconds). Defaults to 3600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3600</code> </p> <code>duration</code> <p>day_duration (in seconds). Defaults to 86400.</p> <p> TYPE: <code>int</code> DEFAULT: <code>86400</code> </p> RETURNS DESCRIPTION <code>array</code> <p>np.array: one-hot encoded plan</p> Source code in <code>pam/array/encode.py</code> <pre><code>def plan_to_one_hot(\n    plan: Plan, mapping: dict, bin_size: int = 3600, duration: int = 86400\n) -&gt; np.array:\n    \"\"\"Transform a pam.activity.Plan into a one-hot encoded array. Output array is two dimensional.\n    First axis represents time, binnned according to bin_size given in seconds.\n    Seconds axis is a one-hot endcoding of activity type based on the given mapping. Note that Leg\n    components will have the encoding \"travel\" which should be included in the mapping. Location and\n    mode information is lost. Some plan components may be lost if their durations are less than\n    the chosen bin six. Plan components beyond 24 hours are cropped.\n\n    Args:\n        plan (Plan): input Plan object to be encoded as one-hot\n        mapping (dict): dictionary mapping of activity types to one-hot index, eg {\"home\":0, \"travel\":1}\n        bin_size (int, optional): time bin size (in seconds). Defaults to 3600.\n        duration (int, optional): day_duration (in seconds). Defaults to 86400.\n\n    Returns:\n        np.array: one-hot encoded plan\n    \"\"\"\n    bins = int(duration / bin_size)\n    encoded = np.zeros((bins, len(mapping)))\n\n    start_bin = 0\n    reference_time = plan.day[0].start_time\n    for component in plan.day:\n        index = mapping.get(component.act, None)\n        end_bin = round(td_to_s(component.end_time - reference_time) / bin_size)\n\n        if end_bin &gt;= duration:  # deal with last component\n            end_bin = duration\n            encoded[start_bin:end_bin, index] = 1.0\n            break\n\n        encoded[start_bin:end_bin, index] = 1.0\n        start_bin = end_bin\n\n    return encoded\n</code></pre>"},{"location":"reference/pam/core/","title":"pam.core","text":""},{"location":"reference/pam/core/#pam.core.Household","title":"<code>Household(hid, attributes={}, freq=None, location=None, area=None, loc=None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def __init__(\n    self,\n    hid,\n    attributes={},\n    freq=None,\n    location: Optional[Location] = None,\n    area=None,\n    loc=None,\n):\n    self.hid = hid\n    self.people = {}\n    self.attributes = attributes\n    self.hh_freq = freq\n    if location:\n        self._location = location\n    else:\n        self._location = Location()\n    if area:  # potential overwrite\n        self._location.area = area\n    if loc:  # potential overwrite\n        self._location.loc = loc\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.activities","title":"<code>activities</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.attributes","title":"<code>attributes = attributes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.av_person_freq","title":"<code>av_person_freq</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.freq","title":"<code>freq</code>  <code>property</code>","text":"<p>Return hh_freq, else if None, return the average frequency of household members.</p> <p>TODO: note this assumes we are basing hh freq on person freq. TODO: replace this with something better.</p>"},{"location":"reference/pam/core/#pam.core.Household.hh_freq","title":"<code>hh_freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.hid","title":"<code>hid = hid</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.legs","title":"<code>legs</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.location","title":"<code>location</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.people","title":"<code>people = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.subpopulation","title":"<code>subpopulation</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Household.add","title":"<code>add(person)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def add(self, person):\n    if isinstance(person, list):\n        for p in person:\n            self.add(p)\n    elif isinstance(person, Person):\n        self.people[person.pid] = person\n    else:\n        raise UserWarning(f\"Expected instance of Person, not: {type(person)}\")\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.build_travel_geodataframe","title":"<code>build_travel_geodataframe(**kwargs)</code>","text":"<p>Builds geopandas.GeoDataFrame for travel Legs found for persons within a Household.</p> KEYWORD ARGUMENTS FOR PLOT.PLANS.BUILD_PERSON_TRAVEL_GEODATAFRAME DESCRIPTION <code>from_epsg</code> <p>coordinate system the plans are currently in</p> <p> TYPE: <code>str</code> </p> <code>to_epsg</code> <p>coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid).</p> Source code in <code>pam/core.py</code> <pre><code>def build_travel_geodataframe(self, **kwargs) -&gt; gpd.GeoDataFrame:\n    \"\"\"Builds geopandas.GeoDataFrame for travel Legs found for persons within a Household.\n\n    Keyword Args: Keyword arguments for plot.plans.build_person_travel_geodataframe\n        from_epsg (str): coordinate system the plans are currently in\n        to_epsg (str): coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.\n\n    Returns:\n        geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid).\n    \"\"\"\n    gdf = None\n    for _, person in self:\n        _gdf = person.build_travel_geodataframe(**kwargs)\n        _gdf[\"hid\"] = self.hid\n        if gdf is None:\n            gdf = _gdf\n        else:\n            gdf = pd.concat([gdf, _gdf])\n    gdf = gdf.sort_values([\"pid\", \"seq\"]).reset_index(drop=True)\n    return gdf\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.fix_plans","title":"<code>fix_plans(crop=True, times=True, locations=True)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def fix_plans(self, crop=True, times=True, locations=True):\n    for _, person in self:\n        if crop:\n            person.plan.crop()\n        if times:\n            person.plan.fix_time_consistency()\n        if locations:\n            person.plan.fix_location_consistency()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.get","title":"<code>get(pid, default=None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def get(self, pid, default=None):\n    return self.people.get(pid, default)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.get_attribute","title":"<code>get_attribute(key)</code>","text":"<p>Get set of attribute values for given key, First searches hh attributes then occupants.</p> Source code in <code>pam/core.py</code> <pre><code>def get_attribute(self, key) -&gt; set:\n    \"\"\"Get set of attribute values for given key, First searches hh attributes then occupants.\"\"\"\n    if key in self.attributes:\n        return {self.attributes[key]}\n    attributes = set()\n    for _, person in self:\n        attributes.add(person.attributes.get(key))\n    return attributes\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.pickle","title":"<code>pickle(path)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def pickle(self, path):\n    with open(path, \"wb\") as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.plot","title":"<code>plot(**kwargs)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def plot(self, **kwargs):\n    plot.plot_household(self, **kwargs)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.plot_travel_plotly","title":"<code>plot_travel_plotly(epsg='epsg:4326', **kwargs)</code>","text":"<p>Uses plotly's Scattermapbox to plot persons' travel.</p> PARAMETER  DESCRIPTION <code>epsg</code> <p>coordinate system the plans spatial information is in, e.g. 'epsg:27700'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'epsg:4326'</code> </p> KEYWORD ARGUMENTS FOR PLOT.PLOT_TRAVEL_PLANS DESCRIPTION <code>gdf</code> <p>generated by build_person_travel_geodataframe.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>groupby</code> <p>optional argument for splitting traces in the plot.</p> <p> TYPE: <code>list</code> </p> <code>colour_by</code> <p>argument for specifying what the colour should correspond to in the plot, travel mode by default.</p> <p> TYPE: <code>str</code> </p> <code>cmap</code> <p>optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent.</p> <p> TYPE: <code>dict</code> </p> <code>mapbox_access_token</code> <p>required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/core.py</code> <pre><code>def plot_travel_plotly(self, epsg: str = \"epsg:4326\", **kwargs) -&gt; None:\n    \"\"\"Uses plotly's Scattermapbox to plot persons' travel.\n\n    Args:\n        epsg (str): coordinate system the plans spatial information is in, e.g. 'epsg:27700'.\n\n    Keyword Args: Keyword arguments for plot.plot_travel_plans\n        gdf (geopandas.GeoDataFrame): generated by build_person_travel_geodataframe.\n        groupby (list): optional argument for splitting traces in the plot.\n        colour_by (str): argument for specifying what the colour should correspond to in the plot, travel mode by default.\n        cmap (dict): optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent.\n        mapbox_access_token (str): required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).\n\n    \"\"\"\n    return plot.plot_travel_plans(\n        gdf=self.build_travel_geodataframe(from_epsg=epsg, to_epsg=\"epsg:4326\"), **kwargs\n    )\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.print","title":"<code>print()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def print(self):\n    print(self)\n    print(self.attributes)\n    for _, person in self:\n        person.print()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.random_person","title":"<code>random_person()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def random_person(self):\n    return self.people[random.choice(list(self.people))]\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.reindex","title":"<code>reindex(prefix)</code>","text":"<p>Safely reindex all person identifiers in household using a prefix.</p> PARAMETER  DESCRIPTION <code>prefix</code> <p>Prefix to add.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/core.py</code> <pre><code>def reindex(self, prefix: str):\n    \"\"\"Safely reindex all person identifiers in household using a prefix.\n\n    Args:\n        prefix (str): Prefix to add.\n    \"\"\"\n    self.hid = prefix + self.hid\n    for pid in list(self.people):\n        person = self.people[pid]\n        new_pid = prefix + pid\n        if new_pid in self.people:\n            raise KeyError(f\"Duplicate person identifier (pid): {new_pid}\")\n        person.reindex(prefix)\n        self.people[new_pid] = person\n        del self.people[pid]\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.set_area","title":"<code>set_area(area)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_area(self, area):\n    self._location.area = area\n    for _, person in self:\n        person.set_area(area)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.set_freq","title":"<code>set_freq(freq)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_freq(self, freq):\n    self.hh_freq = freq\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.set_loc","title":"<code>set_loc(loc)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_loc(self, loc):\n    self._location.loc = loc\n    for _, person in self:\n        person.set_loc(loc)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.set_location","title":"<code>set_location(location)</code>","text":"<p>Set both hh and person home_location, but note that hhs and their persons do not share location object.</p> Source code in <code>pam/core.py</code> <pre><code>def set_location(self, location: Location):\n    \"\"\"Set both hh and person home_location, but note that hhs and their persons do not share location object.\"\"\"\n    self._location = location\n    for _, person in self:\n        person.set_location(location.copy())\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.shared_activities","title":"<code>shared_activities()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def shared_activities(self):\n    shared_activities = []\n    household_activities = []\n    for pid, person in self.people.items():\n        for activity_ in person.activities:\n            if activity_.isin_exact(household_activities):\n                shared_activities.append(activity_)\n            if not activity_.isin_exact(household_activities):\n                household_activities.append(activity_)\n    return shared_activities\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.size","title":"<code>size()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def size(self):\n    return len(self.people)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Household.vehicles","title":"<code>vehicles()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def vehicles(self):\n    for pid, p in self.people.items():\n        for mode, veh in p.vehicles.items():\n            yield pid, mode, veh\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person","title":"<code>Person(pid, freq=None, attributes={}, vehicles=None, home_location=None, home_area=None, home_loc=None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def __init__(\n    self,\n    pid,\n    freq=None,\n    attributes: dict = {},\n    vehicles: Optional[dict[str, Vehicle]] = None,\n    home_location: Optional[Location] = None,\n    home_area=None,\n    home_loc=None,\n):\n    self.pid = pid\n    self.person_freq = freq\n    self.attributes = attributes\n\n    if vehicles is not None:\n        self.vehicles = vehicles\n    else:\n        self.vehicles = {}\n\n    if home_location is not None:\n        self.home_location = home_location\n    else:\n        self.home_location = Location()\n\n    if home_area:\n        self.home_location.area = home_area\n    if home_loc:\n        self.home_location.loc = home_loc\n    # person and their plan share Location\n    self.plan = activity.Plan(home_location=self.home_location)\n    self.plans_non_selected = []\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.activities","title":"<code>activities</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.acts","title":"<code>acts</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.attributes","title":"<code>attributes = attributes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.av_activity_freq","title":"<code>av_activity_freq</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.av_trip_freq","title":"<code>av_trip_freq</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.closed_plan","title":"<code>closed_plan: bool</code>  <code>property</code>","text":"<p>Check if plan starts and stops at the same facility (based on activity and location).</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pam/core/#pam.core.Person.first_activity","title":"<code>first_activity</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.freq","title":"<code>freq</code>  <code>property</code>","text":"<p>Return person_freq, else if None, return the average frequency of legs.</p> <p>TODO consider passing parent hh on creation so that we can retrieve hh freq if required.</p>"},{"location":"reference/pam/core/#pam.core.Person.has_valid_plan","title":"<code>has_valid_plan: bool</code>  <code>property</code>","text":"<p>Check sequence of Activities and Legs.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pam/core/#pam.core.Person.home","title":"<code>home</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.home_based","title":"<code>home_based</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.home_location","title":"<code>home_location = home_location</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.last_activity","title":"<code>last_activity</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.last_component","title":"<code>last_component</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.last_leg","title":"<code>last_leg</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.legs","title":"<code>legs</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.length","title":"<code>length</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.num_activities","title":"<code>num_activities</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.num_legs","title":"<code>num_legs</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.person_freq","title":"<code>person_freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.pid","title":"<code>pid = pid</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.plan","title":"<code>plan = activity.Plan(home_location=self.home_location)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.plans_non_selected","title":"<code>plans_non_selected = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.subpopulation","title":"<code>subpopulation</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.vehicles","title":"<code>vehicles = vehicles</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Person.add","title":"<code>add(p)</code>","text":"<p>Safely add a new component to the plan.</p> PARAMETER  DESCRIPTION <code>p</code> <p>component to add.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>pam/core.py</code> <pre><code>def add(self, p: Any) -&gt; None:\n    \"\"\"Safely add a new component to the plan.\n\n    Args:\n        p (Any): component to add.\n    \"\"\"\n    self.plan.add(p)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.assign_vehicles_from_manager","title":"<code>assign_vehicles_from_manager(manager)</code>","text":"<p>Assign vehicles to person from vehicles manager. This method removes the vehicles attribute from the agent and uses it to populate Person.vehicles variable. This method is used by read.matsim to transfer regular vehicles and electric vehicles from MATSim xml formats to each Person.</p> PARAMETER  DESCRIPTION <code>manager</code> <p>Population vehicles.</p> <p> TYPE: <code>VehicleManager</code> </p> Source code in <code>pam/core.py</code> <pre><code>def assign_vehicles_from_manager(self, manager: VehicleManager):\n    \"\"\"Assign vehicles to person from vehicles manager.\n    This method removes the vehicles attribute from the agent and uses it to populate\n    Person.vehicles variable. This method is used by read.matsim to transfer regular vehicles\n    and electric vehicles from MATSim xml formats to each Person.\n\n    Args:\n        manager (VehicleManager): Population vehicles.\n    \"\"\"\n    self.vehicles = {\n        mode: manager.pop(vid) for mode, vid in self.attributes.pop(\"vehicles\", {}).items()\n    }\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.build_travel_geodataframe","title":"<code>build_travel_geodataframe(**kwargs)</code>","text":"<p>Builds geopandas.GeoDataFrame for Person's Legs.</p> KEYWORD ARGUMENTS FOR PLOT.BUILD_PERSON_TRAVEL_GEODATAFRAME, DESCRIPTION <code>from_epsg</code> <p>coordinate system the plans are currently in</p> <p> TYPE: <code>str</code> </p> <code>to_epsg</code> <p>coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>geopandas.GeoDataFrame: columns for person id (pid).</p> Source code in <code>pam/core.py</code> <pre><code>def build_travel_geodataframe(self, **kwargs) -&gt; gpd.GeoDataFrame:\n    \"\"\"Builds geopandas.GeoDataFrame for Person's Legs.\n\n    Keyword Args: Keyword arguments for plot.build_person_travel_geodataframe,\n        from_epsg (str): coordinate system the plans are currently in\n        to_epsg (str): coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.\n\n    Returns:\n        geopandas.GeoDataFrame: columns for person id (pid).\n    \"\"\"\n    return plot.build_person_travel_geodataframe(self, **kwargs)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.clear_plan","title":"<code>clear_plan()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def clear_plan(self):\n    self.plan.clear()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.evs","title":"<code>evs()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def evs(self):\n    for mode, veh in self.vehicles.items():\n        if isinstance(veh, ElectricVehicle):\n            yield mode, veh\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.fill_plan","title":"<code>fill_plan(p_idx, s_idx, default='home')</code>","text":"<p>Fill a plan after Activity has been removed.</p> PARAMETER  DESCRIPTION <code>p_idx</code> <p>location of previous Activity</p> <p> TYPE: <code>Any</code> </p> <code>s_idx</code> <p>location of subsequent Activity</p> <p> TYPE: <code>Any</code> </p> <code>default</code> <p>Defaults to \"home\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'home'</code> </p> <p>Returns:     bool:</p> Source code in <code>pam/core.py</code> <pre><code>def fill_plan(self, p_idx: Any, s_idx: Any, default: str = \"home\") -&gt; bool:\n    \"\"\"Fill a plan after Activity has been removed.\n\n    Args:\n        p_idx (Any): location of previous Activity\n        s_idx (Any): location of subsequent Activity\n        default (str, optional): Defaults to \"home\"\n    Returns:\n        bool:\n    \"\"\"\n    return self.plan.fill_plan(p_idx, s_idx, default=default)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.finalise","title":"<code>finalise()</code>","text":"<p>Add activity end times based on start time of next activity.</p> Source code in <code>pam/core.py</code> <pre><code>def finalise(self):\n    \"\"\"Add activity end times based on start time of next activity.\"\"\"\n    self.plan.finalise_activity_end_times()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.fix_plan","title":"<code>fix_plan(crop=True, times=True, locations=True)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def fix_plan(self, crop=True, times=True, locations=True):\n    if crop:\n        self.plan.crop()\n    if times:\n        self.plan.fix_time_consistency()\n    if locations:\n        self.plan.fix_location_consistency()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.iter_vehicles","title":"<code>iter_vehicles()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def iter_vehicles(self):\n    for mode, veh in self.vehicles.items():\n        yield mode, veh\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.move_activity","title":"<code>move_activity(seq, default='home', new_mode='walk')</code>","text":"<p>Move an activity from plan at given seq to default location.</p> PARAMETER  DESCRIPTION <code>seq</code> <p> TYPE: <code>Any</code> </p> <code>default</code> <p>'home' or pam.activity.Location. Defaults to \"home\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'home'</code> </p> <code>new_mode</code> <p>access/egress journey switching to this mode. Ie 'walk'. Defaults to \"walk\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'walk'</code> </p> Source code in <code>pam/core.py</code> <pre><code>def move_activity(self, seq: Any, default: str = \"home\", new_mode: str = \"walk\") -&gt; None:\n    \"\"\"Move an activity from plan at given seq to default location.\n\n    Args:\n        seq (Any):\n        default (str, optional):\n            'home' or pam.activity.Location.\n            Defaults to \"home\".\n        new_mode (str, optional):\n            access/egress journey switching to this mode. Ie 'walk'.\n            Defaults to \"walk\".\n    \"\"\"\n    return self.plan.move_activity(seq, default, new_mode)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.pickle","title":"<code>pickle(path)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def pickle(self, path):\n    with open(path, \"wb\") as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.plot","title":"<code>plot(**kwargs)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def plot(self, **kwargs):\n    plot.plot_person(self, **kwargs)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.plot_travel_plotly","title":"<code>plot_travel_plotly(epsg='epsg:4326', **kwargs)</code>","text":"<p>Uses plotly's Scattermapbox to plot persons' travel.</p> PARAMETER  DESCRIPTION <code>epsg</code> <p>coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'epsg:4326'</code> </p> KEYWORD ARGUMENTS FOR PLOT.PLOT_TRAVEL_PLANS DESCRIPTION <code>gdf</code> <p>generated by build_person_travel_geodataframe.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>groupby</code> <p>optional argument for splitting traces in the plot.</p> <p> TYPE: <code>list</code> </p> <code>colour_by</code> <p>argument for specifying what the colour should correspond to in the plot, travel mode by default.</p> <p> TYPE: <code>str</code> </p> <code>cmap</code> <p>optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent.</p> <p> TYPE: <code>dict</code> </p> <code>mapbox_access_token</code> <p>required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>go.Figure: Plotly figure object</p> Source code in <code>pam/core.py</code> <pre><code>def plot_travel_plotly(self, epsg: str = \"epsg:4326\", **kwargs) -&gt; go.Figure:\n    \"\"\"Uses plotly's Scattermapbox to plot persons' travel.\n\n    Args:\n        epsg (str, optional): coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".\n\n    Keyword Args: Keyword arguments for plot.plot_travel_plans\n        gdf (geopandas.GeoDataFrame): generated by build_person_travel_geodataframe.\n        groupby (list): optional argument for splitting traces in the plot.\n        colour_by (str): argument for specifying what the colour should correspond to in the plot, travel mode by default.\n        cmap (dict): optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent.\n        mapbox_access_token (str): required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).\n\n    Returns:\n        go.Figure: Plotly figure object\n    \"\"\"\n    return plot.plot_travel_plans(\n        gdf=self.build_travel_geodataframe(from_epsg=epsg, to_epsg=\"epsg:4326\"), **kwargs\n    )\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.print","title":"<code>print()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def print(self):\n    print(self)\n    print(self.attributes)\n    self.plan.print()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.reindex","title":"<code>reindex(prefix)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def reindex(self, prefix: str):\n    self.pid = prefix + self.pid\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.remove_activity","title":"<code>remove_activity(seq)</code>","text":"<p>Remove an activity from plan at given seq. Check for wrapped removal.</p> PARAMETER  DESCRIPTION <code>seq</code> <p> TYPE: <code>int</code> </p> <p>Returns:     tuple: (adjusted) idx of previous and subsequent activities as a tuple</p> Source code in <code>pam/core.py</code> <pre><code>def remove_activity(self, seq: int) -&gt; tuple:\n    \"\"\"Remove an activity from plan at given seq. Check for wrapped removal.\n\n    Args:\n        seq (int):\n    Returns:\n        tuple: (adjusted) idx of previous and subsequent activities as a tuple\n    \"\"\"\n    return self.plan.remove_activity(seq)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.set_area","title":"<code>set_area(area)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_area(self, area):\n    self.home_location.area = area\n    self.plan.home_location.area = area\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.set_freq","title":"<code>set_freq(freq)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_freq(self, freq):\n    self.person_freq = freq\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.set_loc","title":"<code>set_loc(loc)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_loc(self, loc):\n    self.home_location.loc = loc\n    self.plan.home_location.loc = loc\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.set_location","title":"<code>set_location(location)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_location(self, location: Location):\n    self.home_location = location\n    self.plan.home_location = location\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.stay_at_home","title":"<code>stay_at_home()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def stay_at_home(self):\n    self.plan.stay_at_home()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.validate","title":"<code>validate()</code>","text":"<p>Validate plan.</p> Source code in <code>pam/core.py</code> <pre><code>def validate(self):\n    \"\"\"Validate plan.\"\"\"\n    self.plan.validate()\n    return True\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.validate_locations","title":"<code>validate_locations()</code>","text":"<p>Check sequence of Activity and Leg locations.</p> RETURNS DESCRIPTION <code>True</code> <p> TYPE: <code>True</code> </p> Source code in <code>pam/core.py</code> <pre><code>def validate_locations(self) -&gt; True:\n    \"\"\"Check sequence of Activity and Leg locations.\n\n    Returns:\n        True:\n    \"\"\"\n    if not self.plan.valid_locations:\n        raise PAMValidationLocationsError(f\"Person {self.pid} has invalid plan locations\")\n\n    return True\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.validate_sequence","title":"<code>validate_sequence()</code>","text":"<p>Check sequence of Activities and Legs.</p> RETURNS DESCRIPTION <code>True</code> <p> TYPE: <code>True</code> </p> Source code in <code>pam/core.py</code> <pre><code>def validate_sequence(self) -&gt; True:\n    \"\"\"Check sequence of Activities and Legs.\n\n    Returns:\n        True:\n    \"\"\"\n    if not self.plan.valid_sequence:\n        raise PAMSequenceValidationError(f\"Person {self.pid} has invalid plan sequence\")\n\n    return True\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Person.validate_times","title":"<code>validate_times()</code>","text":"<p>Check sequence of Activity and Leg times.</p> RETURNS DESCRIPTION <code>True</code> <p> TYPE: <code>True</code> </p> Source code in <code>pam/core.py</code> <pre><code>def validate_times(self) -&gt; True:\n    \"\"\"Check sequence of Activity and Leg times.\n\n    Returns:\n        True:\n    \"\"\"\n    if not self.plan.valid_time_sequence:\n        raise PAMInvalidTimeSequenceError(f\"Person {self.pid} has invalid plan times\")\n\n    return True\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population","title":"<code>Population(name=None)</code>","text":"<p>Class to define a population.</p> PARAMETER  DESCRIPTION <code>name</code> <p>Name of population. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/core.py</code> <pre><code>def __init__(self, name: str = None) -&gt; None:\n    \"\"\"Class to define a population.\n\n    Args:\n        name (str, optional): Name of population. Defaults to None.\n    \"\"\"\n    self.name = name\n    self.logger = logging.getLogger(__name__)\n    self.households = {}\n    self._vehicles_manager = VehicleManager()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.attributes","title":"<code>attributes: dict</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.freq","title":"<code>freq</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.has_electric_vehicles","title":"<code>has_electric_vehicles</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.has_vehicles","title":"<code>has_vehicles: bool</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.households","title":"<code>households = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.num_households","title":"<code>num_households</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.population","title":"<code>population</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.size","title":"<code>size</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.stats","title":"<code>stats</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.subpopulations","title":"<code>subpopulations</code>  <code>property</code>","text":""},{"location":"reference/pam/core/#pam.core.Population.vehicle_types","title":"<code>vehicle_types: dict[str, VehicleType]</code>  <code>property</code>","text":"RETURNS DESCRIPTION <code>dict[str, VehicleType]</code> <p>dist[str, VehicleType]: Mapping of vehicle type id to vehicle type data.</p>"},{"location":"reference/pam/core/#pam.core.Population.add","title":"<code>add(target)</code>","text":"<p>Add houeshold/person, or a list of households/persons to the population.</p> PARAMETER  DESCRIPTION <code>target</code> <p>Can be any arbitrary nesting of lists, as long as the deepest nesting includes only Houeshold and Person objects</p> <p> TYPE: <code>list[Union[Household, Person, list]]</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Only Household and Person objects allowed</p> Source code in <code>pam/core.py</code> <pre><code>def add(self, target: list[Union[Household, Person, list]]) -&gt; None:\n    \"\"\"Add houeshold/person, or a list of households/persons to the population.\n\n    Args:\n        target (list[Union[Household, Person, list]]):\n            Can be any arbitrary nesting of lists, as long as the deepest nesting includes only Houeshold and Person objects\n\n    Raises:\n        UserWarning: Only Household and Person objects allowed\n    \"\"\"\n    if isinstance(target, list):\n        for hh in target:\n            self.add(hh)\n    elif isinstance(target, Household):\n        self.households[target.hid] = target\n    elif isinstance(target, Person):\n        self.logger.debug(\n            (\n                \"Directly adding a Person to a Population requires a Household.\",\n                f\"Auto creating a household {target.pid} for person {target.pid}, check this is intended.\",\n            )\n        )\n        self.add(Household(hid=target.pid))\n        self.households[target.pid].add(target)\n    else:\n        raise UserWarning(\n            f\"Expected instance of Household, list or Person, not: {type(target)}\"\n        )\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.add_fields","title":"<code>add_fields(df)</code>  <code>staticmethod</code>","text":"<p>Add extra fields used for benchmarking in place.</p> PARAMETER  DESCRIPTION <code>df</code> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>pam/core.py</code> <pre><code>@staticmethod\ndef add_fields(df: pd.DataFrame) -&gt; None:\n    \"\"\"Add extra fields used for benchmarking in place.\n\n    Args:\n        df (pd.DataFrame):\n    \"\"\"\n    df[\"personhrs\"] = df[\"freq\"] * df[\"duration\"] / 60\n    df[\"departure_hour\"] = df.tst.apply(lambda x: x.hour)\n    df[\"arrival_hour\"] = df.tet.apply(lambda x: x.hour)\n    df[\"euclidean_distance_category\"] = pd.cut(\n        df.euclidean_distance,\n        bins=[0, 1, 5, 10, 25, 50, 100, 200, 999999],\n        labels=[\n            \"0 to 1 km\",\n            \"1 to 5 km\",\n            \"5 to 10 km\",\n            \"10 to 25 km\",\n            \"25 to 50 km\",\n            \"50 to 100 km\",\n            \"100 to 200 km\",\n            \"200+ km\",\n        ],\n    )\n    df[\"duration_category\"] = pd.cut(\n        df.duration,\n        bins=[0, 5, 10, 15, 30, 45, 60, 90, 120, 999999],\n        labels=[\n            \"0 to 5 min\",\n            \"5 to 10 min\",\n            \"10 to 15 min\",\n            \"15 to 30 min\",\n            \"30 to 45 min\",\n            \"45 to 60 min\",\n            \"60 to 90 min\",\n            \"90 to 120 min\",\n            \"120+ min\",\n        ],\n    )\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.add_veh","title":"<code>add_veh(hid, pid, mode, vehicle)</code>","text":"<p>Add vehicle of given mode to person, based on hid and pid. Method checks that id is unique and vehicle type is available, otherwise raises UserWarning.</p> PARAMETER  DESCRIPTION <code>hid</code> <p>Household id</p> <p> TYPE: <code>str</code> </p> <code>pid</code> <p>Person id</p> <p> TYPE: <code>str</code> </p> <code>mode</code> <p>Mode of vehicle</p> <p> TYPE: <code>str</code> </p> <code>vehicle</code> <p>Vehicle to add</p> <p> TYPE: <code>Vehicle</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Duplicate id.</p> <code>UserWarning</code> <p>Unknown vehicle type.</p> Source code in <code>pam/core.py</code> <pre><code>def add_veh(self, hid: str, pid: str, mode: str, vehicle: Vehicle):\n    \"\"\"Add vehicle of given mode to person, based on hid and pid. Method checks that id is unique and vehicle type is available, otherwise raises UserWarning.\n\n    Args:\n        hid (str): Household id\n        pid (str): Person id\n        mode (str): Mode of vehicle\n        vehicle (Vehicle): Vehicle to add\n\n    Raises:\n        UserWarning: Duplicate id.\n        UserWarning: Unknown vehicle type.\n\n    \"\"\"\n    if vehicle.type_id not in self._vehicles_manager._veh_types:\n        raise UserWarning(f\"Unable to add vehicle with unknown type: '{vehicle.type_id}'.\")\n    person_vehicles = self.households[hid][pid].vehicles\n    if not (\n        person_vehicles.get(mode) and person_vehicles[mode].vid == vehicle.vid\n    ):  # assume not replacing existing\n        # so check for duplicates\n        if vehicle.vid in set([v.vid for _, _, _, v in self.vehicles()]):\n            raise UserWarning(\n                f\"Unable to add vehicle with duplicate vehicle id (vid): {vehicle.vid}\"\n            )\n    person_vehicles[mode] = vehicle\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.add_veh_type","title":"<code>add_veh_type(vehicle_type)</code>","text":"<p>Add a vehicle type to the population vehicles manager.</p> PARAMETER  DESCRIPTION <code>vehicle_type</code> <p>Vehicle type to be added.</p> <p> TYPE: <code>VehicleType</code> </p> Source code in <code>pam/core.py</code> <pre><code>def add_veh_type(self, vehicle_type: VehicleType):\n    \"\"\"Add a vehicle type to the population vehicles manager.\n\n    Args:\n        vehicle_type (VehicleType): Vehicle type to be added.\n    \"\"\"\n    self._vehicles_manager.add_type(vehicle_type)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.build_travel_geodataframe","title":"<code>build_travel_geodataframe(**kwargs)</code>","text":"<p>Builds geopandas.GeoDataFrame for travel Legs found for all persons in the Population.</p> KEYWORD ARGUMENTS FOR PLOT.BUILD_PERSON_TRAVEL_GEODATAFRAME. DESCRIPTION <code>from_epsg</code> <p>coordinate system the plans are currently in</p> <p> TYPE: <code>str</code> </p> <code>to_epsg</code> <p>coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid)</p> Source code in <code>pam/core.py</code> <pre><code>def build_travel_geodataframe(self, **kwargs) -&gt; gpd.GeoDataFrame:\n    \"\"\"Builds geopandas.GeoDataFrame for travel Legs found for all persons in the Population.\n\n    Keyword Args: Keyword arguments for plot.build_person_travel_geodataframe.\n        from_epsg (str): coordinate system the plans are currently in\n        to_epsg (str): coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.\n\n    Returns:\n        geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid)\n    \"\"\"\n    gdf = None\n    for hid, household in self.households.items():\n        _gdf = household.build_travel_geodataframe(**kwargs)\n        if gdf is None:\n            gdf = _gdf\n        else:\n            gdf = pd.concat([gdf, _gdf])\n    gdf = gdf.sort_values([\"hid\", \"pid\", \"seq\"]).reset_index(drop=True)\n    return gdf\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.check_vehicles","title":"<code>check_vehicles()</code>","text":"<p>Checks that all person vehicles have types defined by vehicles manager.</p> RAISES DESCRIPTION <code>PAMVehicleIdError</code> <p>Undefined vehicle type in population.</p> RETURNS DESCRIPTION <code>bool</code> <p>Return true if all vehicle types are defined.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/core.py</code> <pre><code>def check_vehicles(self) -&gt; bool:\n    \"\"\"Checks that all person vehicles have types defined by vehicles manager.\n\n    Raises:\n        PAMVehicleIdError: Undefined vehicle type in population.\n\n    Returns:\n        bool: Return true if all vehicle types are defined.\n    \"\"\"\n    veh_types = set(self._vehicles_manager._veh_types.keys())\n    for _, _, _, veh in self.vehicles():\n        if veh.type_id not in veh_types:\n            raise PAMVehicleIdError(\n                f\"Failed to find veh type of id '{veh.type_id}', specified for veh id '{veh.vid}'.\"\n            )\n    return True\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.combine","title":"<code>combine(other, prefix='')</code>","text":"<p>Safe addition with assignment by adding a prefix to create unique pids and hids.</p> Source code in <code>pam/core.py</code> <pre><code>def combine(self, other, prefix=\"\"):\n    \"\"\"Safe addition with assignment by adding a prefix to create unique pids and hids.\"\"\"\n    prefix = str(prefix)\n\n    if isinstance(other, Population):\n        other.reindex(prefix)\n        self += other\n        return None\n    if isinstance(other, Household):\n        other.reindex(prefix)\n        self += other\n        return None\n    if isinstance(other, Person):\n        hh = Household(other.pid)  # we create a new hh for single person\n        hh.add(other)\n        hh.reindex(prefix)\n        self += hh\n        return None\n    raise TypeError(\n        f\"Object for addition must be a Population Household or Person object, not {type(other)}\"\n    )\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.evs","title":"<code>evs()</code>","text":"<p>Return iterator of all electric vehicles in population, prepended with household id, person id and mode.</p> YIELDS DESCRIPTION <code>str, str, str, ElectricVehicle</code> <p>Iterator[str, str, str, ElectricVehicle]: Iterator of (hid, pid, mode, vehicle)</p> Source code in <code>pam/core.py</code> <pre><code>def evs(self) -&gt; Iterator[str, str, str, ElectricVehicle]:\n    \"\"\"Return iterator of all electric vehicles in population, prepended with household id,\n    person id and mode.\n\n    Yields:\n        Iterator[str, str, str, ElectricVehicle]: Iterator of (hid, pid, mode, vehicle)\n    \"\"\"\n    for hid, pid, p in self.people():\n        for mode, veh in p.evs():\n            yield hid, pid, mode, veh\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.fix_plans","title":"<code>fix_plans(crop=True, times=True, locations=True)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def fix_plans(self, crop: bool = True, times=True, locations=True):\n    for _, _, person in self.people():\n        if crop:\n            person.plan.crop()\n        if times:\n            person.plan.fix_time_consistency()\n        if locations:\n            person.plan.fix_location_consistency()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.get","title":"<code>get(hid, default=None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def get(self, hid, default=None):\n    return self.households.get(hid, default)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.legs_df","title":"<code>legs_df()</code>","text":"<p>Extract tabular record of population legs.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: record of legs</p> Source code in <code>pam/core.py</code> <pre><code>def legs_df(self) -&gt; pd.DataFrame:\n    \"\"\"Extract tabular record of population legs.\n\n    Returns:\n        pd.DataFrame: record of legs\n    \"\"\"\n    df = []\n    for hid, pid, person in self.people():\n        for seq, leg in enumerate(person.legs):\n            record = {\n                \"pid\": pid,\n                \"hid\": hid,\n                \"hzone\": person.home,\n                \"ozone\": leg.start_location.area,\n                \"dzone\": leg.end_location.area,\n                \"oloc\": leg.start_location,\n                \"dloc\": leg.end_location,\n                \"seq\": seq,\n                \"purp\": leg.purp,\n                \"mode\": leg.mode,\n                \"tst\": leg.start_time.time(),\n                \"tet\": leg.end_time.time(),\n                # duration in minutes\n                \"duration\": leg.duration / pd.Timedelta(minutes=1),\n                \"euclidean_distance\": leg.euclidean_distance,\n                \"freq\": person.freq,\n            }\n            # add person attributes\n            record = {**record, **dict(person.attributes)}\n            df.append(record)\n    df = pd.DataFrame(df)\n    self.add_fields(df)\n    return df\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.people","title":"<code>people()</code>","text":"<p>Iterator for people in poulation, returns hid, pid and Person.</p> Source code in <code>pam/core.py</code> <pre><code>def people(self):\n    \"\"\"Iterator for people in poulation, returns hid, pid and Person.\"\"\"\n    for hid, household in self.households.items():\n        for pid, person in household.people.items():\n            yield hid, pid, person\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.pickle","title":"<code>pickle(path)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def pickle(self, path: str):\n    with open(path, \"wb\") as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.plans","title":"<code>plans()</code>","text":"<p>Iterator for plans in poulation.</p> Source code in <code>pam/core.py</code> <pre><code>def plans(self) -&gt; Iterator[activity.Plan]:\n    \"\"\"Iterator for plans in poulation.\"\"\"\n    for hid, household in self.households.items():\n        for pid, person in household.people.items():\n            yield person.plan\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.plot_travel_plotly","title":"<code>plot_travel_plotly(epsg='epsg:4326', **kwargs)</code>","text":"<p>Plot travel plans.</p> PARAMETER  DESCRIPTION <code>epsg</code> <p>coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'epsg:4326'</code> </p> KEYWORD ARGUMENTS FOR PLOT.PLOT_TRAVEL_PLANS DESCRIPTION <code>gdf</code> <p>geopandas.GeoDataFrame generated by build_person_travel_geodataframe</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>groupby</code> <p>optional argument for splitting traces in the plot.</p> <p> TYPE: <code>list</code> </p> <code>colour_by</code> <p>argument for specifying what the colour should correspond to in the plot, travel mode by default.</p> <p> TYPE: <code>str</code> </p> <code>cmap</code> <p>optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent.</p> <p> TYPE: <code>dict</code> </p> <code>mapbox_access_token</code> <p>required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>go.Figure: Plotly figure object.</p> Source code in <code>pam/core.py</code> <pre><code>def plot_travel_plotly(self, epsg: str = \"epsg:4326\", **kwargs) -&gt; go.Figure:\n    \"\"\"Plot travel plans.\n\n    Args:\n        epsg (str, optional): coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".\n\n    Keyword Args: Keyword arguments for plot.plot_travel_plans\n        gdf (geopandas.GeoDataFrame): geopandas.GeoDataFrame generated by build_person_travel_geodataframe\n        groupby (list): optional argument for splitting traces in the plot.\n        colour_by (str): argument for specifying what the colour should correspond to in the plot, travel mode by default.\n        cmap (dict): optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent.\n        mapbox_access_token (str): required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).\n\n    Returns:\n        go.Figure: Plotly figure object.\n    \"\"\"\n    return plot.plot_travel_plans(\n        gdf=self.build_travel_geodataframe(from_epsg=epsg, to_epsg=\"epsg:4326\"), **kwargs\n    )\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.print","title":"<code>print()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def print(self):\n    print(self)\n    for _, household in self:\n        household.print()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.random_household","title":"<code>random_household()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def random_household(self):\n    return self.households[random.choice(list(self.households))]\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.random_person","title":"<code>random_person()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def random_person(self):\n    hh = self.random_household()\n    return hh.random_person()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.rebuild_vehicles_manager","title":"<code>rebuild_vehicles_manager()</code>","text":"<p>(Re)build vehicle population from persons. This method adds all Population vehicles from each Person and adds them to the Population.vehicles_manager. This method is used by write.matsim to write regular vehicles and electric vehicles to MATSim xml formats.</p> Source code in <code>pam/core.py</code> <pre><code>def rebuild_vehicles_manager(self):\n    \"\"\"\n    (Re)build vehicle population from persons. This method adds all Population vehicles from each\n    Person and adds them to the Population.vehicles_manager. This method is used by write.matsim\n    to write regular vehicles and electric vehicles to MATSim xml formats.\n    \"\"\"\n    self._vehicles_manager.clear_vehs()\n    self.update_vehicles_manager()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.reindex","title":"<code>reindex(prefix)</code>","text":"<p>Safely reindex all household and person identifiers in population using a prefix.</p> Source code in <code>pam/core.py</code> <pre><code>def reindex(self, prefix: str):\n    \"\"\"Safely reindex all household and person identifiers in population using a prefix.\"\"\"\n    for hid in list(self.households):\n        hh = self.households[hid]\n        new_hid = prefix + str(hid)\n        if new_hid in self.households:\n            raise KeyError(f\"Duplicate household identifier (hid): {new_hid}\")\n\n        hh.reindex(prefix)\n\n        self.households[new_hid] = hh\n        del self.households[hid]\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.remove_vehicle_type","title":"<code>remove_vehicle_type(tid)</code>","text":"<p>Remove vehicle type from vehicles manager.</p> PARAMETER  DESCRIPTION <code>tid</code> <p>Vehicle type id.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/core.py</code> <pre><code>def remove_vehicle_type(self, tid: str):\n    \"\"\"Remove vehicle type from vehicles manager.\n\n    Args:\n        tid (str): Vehicle type id.\n    \"\"\"\n    self._vehicles_manager.remove_type(tid)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.sample_locs","title":"<code>sample_locs(sampler, long_term_activities=None, joint_trips_prefix='escort_', location_override=True)</code>","text":"<p>WIP Sample household plan locs using a sampler.</p> <p>Sampler uses activity types and areas to sample locations. Note that households share locations for activities of the same type within the same area. Trivially this includes household location. But also, for example, shopping activities if they are in the same area.</p> <p>We treat escort activities (ie those prefixed by \"escort_\") as the escorted activity. For example, the sampler treats \"escort_education\" and \"education\" equally. Note that this shared activity sampling of location models shared facilities, but does not explicitly infer or model shared transport. For example there is no consideration of if trips to shared locations take place at the same time or from the same locations.</p> <p>After sampling Location objects are shared between shared activity locations and corresponding trips start and end locations. These objects are mutable, so care must be taken if making changes as these will impact all other persons shared locations in the household. Often this behaviour might be expected. For example if we change the location of the household home activity, all persons and home activities are impacted.</p> PARAMETER  DESCRIPTION <code>long_term_activities</code> <p>a list of activities for which location is only assigned once (per zone). Defaults to None</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>joint_trips_prefix</code> <p>a purpose prefix used to identify escort/joint trips. Defaults to \"escort_\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'escort_'</code> </p> <code>location_override</code> <p>if False, the facility sampler will retain any already-existing locations in the population.. Defaults to True</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>pam/core.py</code> <pre><code>def sample_locs(\n    self,\n    sampler,\n    long_term_activities: list = None,\n    joint_trips_prefix: str = \"escort_\",\n    location_override: bool = True,\n):\n    \"\"\"WIP Sample household plan locs using a sampler.\n\n    Sampler uses activity types and areas to sample locations. Note that households share\n    locations for activities of the same type within the same area. Trivially this includes\n    household location. But also, for example, shopping activities if they are in the same area.\n\n    We treat escort activities (ie those prefixed by \"escort_\") as the escorted activity. For\n    example, the sampler treats \"escort_education\" and \"education\" equally. Note that this shared\n    activity sampling of location models shared facilities, but does not explicitly infer or\n    model shared transport. For example there is no consideration of if trips to shared locations\n    take place at the same time or from the same locations.\n\n    After sampling Location objects are shared between shared activity locations and corresponding\n    trips start and end locations. These objects are mutable, so care must be taken if making changes\n    as these will impact all other persons shared locations in the household. Often this behaviour\n    might be expected. For example if we change the location of the household home activity, all\n    persons and home activities are impacted.\n\n    Args:\n        long_term_activities (list, optional): a list of activities for which location is only assigned once (per zone). Defaults to None\n        joint_trips_prefix (str, optional): a purpose prefix used to identify escort/joint trips. Defaults to \"escort_\"\n        location_override (bool, optional): if False, the facility sampler will retain any already-existing locations in the population.. Defaults to True\n    \"\"\"\n    if long_term_activities is None:\n        long_term_activities = variables.LONG_TERM_ACTIVITIES\n\n    for _, household in self.households.items():\n        home_loc = activity.Location(\n            area=household.location.area, loc=sampler.sample(household.location.area, \"home\")\n        )\n\n        unique_locations = {(household.location.area, \"home\"): home_loc}\n\n        for __, person in household.people.items():\n            for act in person.activities:\n                # remove escort prefix from activity types.\n                if act.act[: len(joint_trips_prefix)] == joint_trips_prefix:\n                    target_act = act.act[(len(joint_trips_prefix)) :]\n                else:\n                    target_act = act.act\n\n                # assign any unique locations\n                if (act.location.area, target_act) in unique_locations:\n                    location = unique_locations[(act.location.area, target_act)]\n                    act.location = location\n                # sample facility\n                elif location_override or act.location.loc is None:\n                    location = activity.Location(\n                        area=act.location.area,\n                        loc=sampler.sample(act.location.area, target_act),\n                    )\n                    if target_act in long_term_activities:\n                        # one location per zone for long-term choices (only)\n                        # short-term activities, such as shopping can visit multiple locations in the same zone\n                        unique_locations[(act.location.area, target_act)] = location\n                    act.location = location\n\n            # complete the alotting activity locations to the trip starts and ends.\n            for idx in range(person.plan.length):\n                component = person.plan[idx]\n                if isinstance(component, activity.Leg):\n                    component.start_location = person.plan[idx - 1].location\n                    component.end_location = person.plan[idx + 1].location\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.sample_locs_complex","title":"<code>sample_locs_complex(sampler, long_term_activities=None, joint_trips_prefix='escort_')</code>","text":"<p>Extends sample_locs method to enable more complex and rules-based sampling.</p> <p>Keeps track of the last location and transport mode, to apply distance- and mode-based sampling rules. It is generally slower than sample_locs, as it loops through both activities and legs.</p> PARAMETER  DESCRIPTION <code>long_term_activities</code> <p>a list of activities for which location is only assigned once (per zone). Defaults to None.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>joint_trips_prefix</code> <p>a purpose prefix used to identify escort/joint trips. Defaults to \"escort_\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'escort_'</code> </p> Source code in <code>pam/core.py</code> <pre><code>def sample_locs_complex(\n    self, sampler, long_term_activities: list = None, joint_trips_prefix: str = \"escort_\"\n):\n    \"\"\"Extends sample_locs method to enable more complex and rules-based sampling.\n\n    Keeps track of the last location and transport mode, to apply distance- and mode-based sampling rules.\n    It is generally slower than sample_locs, as it loops through both activities and legs.\n\n    Args:\n        long_term_activities (list, optional):\n            a list of activities for which location is only assigned once (per zone).\n            Defaults to None.\n        joint_trips_prefix (str, optional):\n            a purpose prefix used to identify escort/joint trips.\n            Defaults to \"escort_\".\n    \"\"\"\n    if long_term_activities is None:\n        long_term_activities = variables.LONG_TERM_ACTIVITIES\n\n    for _, household in self.households.items():\n        home_loc = activity.Location(\n            area=household.location.area,\n            loc=sampler.sample(\n                household.location.area,\n                \"home\",\n                mode=None,\n                previous_duration=None,\n                previous_loc=None,\n            ),\n        )\n        mode = None\n\n        unique_locations = {(household.location.area, \"home\"): home_loc}\n\n        for _, person in household.people.items():\n            mode = None\n            previous_duration = None\n            previous_loc = None\n\n            for idx, component in enumerate(person.plan):\n                # loop through all plan elements\n\n                if isinstance(component, activity.Leg):\n                    mode = component.mode  # keep track of last mode\n                    previous_duration = component.duration\n\n                elif isinstance(component, activity.Activity):\n                    act = component\n\n                    # remove \"escort_\" from activity types.\n                    # TODO: model joint trips\n                    if act.act[: len(joint_trips_prefix)] == joint_trips_prefix:\n                        target_act = act.act[(len(joint_trips_prefix)) :]\n                    else:\n                        target_act = act.act\n\n                    if (act.location.area, target_act) in unique_locations:\n                        location = unique_locations[(act.location.area, target_act)]\n                        act.location = location\n\n                    else:\n                        location = activity.Location(\n                            area=act.location.area,\n                            loc=sampler.sample(\n                                act.location.area,\n                                target_act,\n                                mode=mode,\n                                previous_duration=previous_duration,\n                                previous_loc=previous_loc,\n                            ),\n                        )\n                        if target_act in long_term_activities:\n                            unique_locations[(act.location.area, target_act)] = location\n                        act.location = location\n\n                    previous_loc = location.loc  # keep track of previous location\n\n            # complete the alotting activity locations to the trip starts and ends.\n            for idx in range(person.plan.length):\n                component = person.plan[idx]\n                if isinstance(component, activity.Leg):\n                    component.start_location = person.plan[idx - 1].location\n                    component.end_location = person.plan[idx + 1].location\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.to_csv","title":"<code>to_csv(dir, crs=None, to_crs='EPSG:4326')</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def to_csv(self, dir: str, crs=None, to_crs: str = \"EPSG:4326\"):\n    write.to_csv(self, dir, crs, to_crs)\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.trips_df","title":"<code>trips_df()</code>","text":"<p>Extract tabular record of population legs.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: record of legs</p> Source code in <code>pam/core.py</code> <pre><code>def trips_df(self) -&gt; pd.DataFrame:\n    \"\"\"Extract tabular record of population legs.\n\n    Returns:\n        pd.DataFrame: record of legs\n    \"\"\"\n    df = []\n    for hid, pid, person in self.people():\n        for seq, trip in enumerate(person.plan.trips()):\n            record = {\n                \"pid\": pid,\n                \"hid\": hid,\n                \"hzone\": person.home,\n                \"ozone\": trip.start_location.area,\n                \"dzone\": trip.end_location.area,\n                \"oloc\": trip.start_location,\n                \"dloc\": trip.end_location,\n                \"seq\": seq,\n                \"purp\": trip.purp,\n                \"mode\": trip.mode,\n                \"tst\": trip.start_time.time(),\n                \"tet\": trip.end_time.time(),\n                # duration in minutes\n                \"duration\": trip.duration / pd.Timedelta(minutes=1),\n                \"euclidean_distance\": trip.euclidean_distance,\n                \"freq\": person.freq,\n            }\n            # add person attributes\n            record = {**record, **dict(person.attributes)}\n            df.append(record)\n\n    df = pd.DataFrame(df)\n    self.add_fields(df)\n    return df\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.update_vehicles_manager","title":"<code>update_vehicles_manager()</code>","text":"<p>Update vehicle population from persons.</p> Source code in <code>pam/core.py</code> <pre><code>def update_vehicles_manager(self):\n    \"\"\"\n    Update vehicle population from persons.\n    \"\"\"\n    vehs = {}\n    for _, _, _, veh in self.vehicles():\n        if veh.vid in vehs:\n            raise PAMVehicleIdError(\"Failed to build due to duplicate vehicle id: {veh.vid}\")\n        vehs[veh.vid] = veh\n    self._vehicles_manager._vehicles.update(vehs)\n    if not self._vehicles_manager.is_consistent():\n        raise UserWarning(\"Failed consistency check refer to logs.\")\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.validate","title":"<code>validate()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def validate(self):\n    for hid, pid, person in self.people():\n        person.validate()\n</code></pre>"},{"location":"reference/pam/core/#pam.core.Population.vehicles","title":"<code>vehicles()</code>","text":"<p>Return iterator of all vehicles in population, prepended with household id, person id and mode.</p> YIELDS DESCRIPTION <code>str, str, str, Vehicle</code> <p>Iterator[str, str, str, Vehicle]: Iterator of (hid, pid, mode, vehicle)</p> Source code in <code>pam/core.py</code> <pre><code>def vehicles(self) -&gt; Iterator[str, str, str, Vehicle]:\n    \"\"\"Return iterator of all vehicles in population, prepended with household id, person id\n    and mode.\n\n    Yields:\n        Iterator[str, str, str, Vehicle]: Iterator of (hid, pid, mode, vehicle)\n    \"\"\"\n    for hid, pid, p in self.people():\n        for mode, veh in p.vehicles.items():\n            yield hid, pid, mode, veh\n</code></pre>"},{"location":"reference/pam/location/","title":"pam.location","text":""},{"location":"reference/pam/location/#pam.location.Location","title":"<code>Location(loc=None, link=None, area=None)</code>","text":"Source code in <code>pam/location.py</code> <pre><code>def __init__(self, loc=None, link=None, area=None):\n    self.loc = loc\n    self.link = link\n    self.area = area\n</code></pre>"},{"location":"reference/pam/location/#pam.location.Location.area","title":"<code>area = area</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/location/#pam.location.Location.exists","title":"<code>exists</code>  <code>property</code>","text":""},{"location":"reference/pam/location/#pam.location.Location.link","title":"<code>link = link</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/location/#pam.location.Location.loc","title":"<code>loc = loc</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/location/#pam.location.Location.max","title":"<code>max</code>  <code>property</code>","text":""},{"location":"reference/pam/location/#pam.location.Location.min","title":"<code>min</code>  <code>property</code>","text":""},{"location":"reference/pam/location/#pam.location.Location.x","title":"<code>x</code>  <code>property</code>","text":""},{"location":"reference/pam/location/#pam.location.Location.y","title":"<code>y</code>  <code>property</code>","text":""},{"location":"reference/pam/location/#pam.location.Location.copy","title":"<code>copy()</code>","text":"Source code in <code>pam/location.py</code> <pre><code>def copy(self):\n    return Location(loc=self.loc, link=self.link, area=self.area)\n</code></pre>"},{"location":"reference/pam/operations/combine/","title":"pam.operations.combine","text":""},{"location":"reference/pam/operations/combine/#pam.operations.combine.pop_combine","title":"<code>pop_combine(inpaths, matsim_version, household_key='hid', simplify_pt_trips=False, autocomplete=True, crop=False, leg_attributes=True, leg_route=True, keep_non_selected=True)</code>","text":"<p>Combine two or more populations (e.g. household, freight... etc).</p> Source code in <code>pam/operations/combine.py</code> <pre><code>def pop_combine(\n    inpaths: str,\n    matsim_version: int,\n    household_key: str = \"hid\",\n    simplify_pt_trips: bool = False,\n    autocomplete: bool = True,\n    crop: bool = False,\n    leg_attributes: bool = True,\n    leg_route: bool = True,\n    keep_non_selected=True,\n):\n    \"\"\"Combine two or more populations (e.g. household, freight... etc).\"\"\"\n    print(\"==================================================\")\n    print(\"Combining input populations\")\n\n    combined_population = core.Population()\n\n    for inpath in inpaths:\n        population = read.read_matsim(\n            inpath,\n            weight=1,\n            version=matsim_version,\n            household_key=household_key,\n            simplify_pt_trips=simplify_pt_trips,\n            autocomplete=autocomplete,\n            crop=crop,\n            leg_attributes=leg_attributes,\n            leg_route=leg_route,\n            keep_non_selected=keep_non_selected,\n        )\n        print(f\"population: {population.stats}\")\n\n        combined_population += population\n\n    return combined_population\n</code></pre>"},{"location":"reference/pam/operations/cropping/","title":"pam.operations.cropping","text":"<p>Methods for cropping plans outside core areas.</p>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.create_leg","title":"<code>create_leg(previous_act, next_act, travel_mode='car')</code>","text":"<p>Create a leg between two activities.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def create_leg(previous_act: Activity, next_act: Activity, travel_mode: str = \"car\") -&gt; Leg:\n    \"\"\"Create a leg between two activities.\"\"\"\n    leg = Leg(\n        start_time=previous_act.end_time,\n        end_time=next_act.start_time,\n        mode=travel_mode,\n        purp=next_act.act,\n    )\n    leg.start_location = previous_act.location\n    leg.end_location = next_act.location\n    # link\n    leg.previous = previous_act\n    leg.next = next_act\n    return leg\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.crop_leg","title":"<code>crop_leg(leg, boundary)</code>","text":"<p>Crop a leg to a boundary.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def crop_leg(leg: Leg, boundary: Polygon) -&gt; None:\n    \"\"\"Crop a leg to a boundary.\"\"\"\n    path = get_leg_path(leg)\n    path_cropped = path.intersection(boundary)\n    start_location, end_location = path_cropped.boundary.geoms\n    leg.start_location.loc = start_location\n    leg.previous.location.loc = start_location\n    leg.end_location.loc = end_location\n    leg.next.location.loc = end_location\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.crop_plan","title":"<code>crop_plan(plan, kept_activities)</code>","text":"<p>Crop a plan in a way that exludes any external-external movement (and the corresponding activities). If no plan components are left in scope, the plan will have a single \"external\" activity.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def crop_plan(plan: Plan, kept_activities: List[Activity]) -&gt; None:\n    \"\"\"Crop a plan in a way that exludes any external-external movement (and the corresponding activities).\n    If no plan components are left in scope, the plan will have a single \"external\" activity.\n    \"\"\"\n    if kept_activities:\n        day = list(filter(lambda x: filter_component(x, kept_activities), plan.day))\n    else:\n        day = empty_day()\n    plan.day = day\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.empty_day","title":"<code>empty_day()</code>","text":"Source code in <code>pam/operations/cropping.py</code> <pre><code>def empty_day() -&gt; list:\n    day = [\n        Activity(\n            seq=1,\n            act=\"external\",\n            area=\"external\",\n            start_time=pam.utils.minutes_to_datetime(0),\n            end_time=pam.variables.END_OF_DAY,\n        )\n    ]\n    return day\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.filter_component","title":"<code>filter_component(component, kept_activities)</code>","text":"<p>Check if an activity/leg should be kept.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def filter_component(component, kept_activities: List[Activity]) -&gt; bool:\n    \"\"\"Check if an activity/leg should be kept.\"\"\"\n    if isinstance(component, Activity):\n        return component in kept_activities\n    elif isinstance(component, Leg):\n        return (component.previous in kept_activities) and (component.next in kept_activities)\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.get_kept_activities","title":"<code>get_kept_activities(plan, boundary)</code>","text":"<p>Get a list of the activities to keep after cropping external-external movements.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def get_kept_activities(plan: Plan, boundary: Polygon) -&gt; list:\n    \"\"\"Get a list of the activities to keep after cropping external-external movements.\"\"\"\n    kept_activities = list()\n    for leg in plan.legs:\n        if leg_intersects(leg, boundary):\n            for act in [leg.previous, leg.next]:\n                if act not in kept_activities:\n                    kept_activities.append(act)\n    return kept_activities\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.get_leg_path","title":"<code>get_leg_path(leg)</code>","text":"<p>Get the (euclidean) geometry of a leg.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def get_leg_path(leg: Leg) -&gt; LineString:\n    \"\"\"Get the (euclidean) geometry of a leg.\"\"\"\n    path = LineString([leg.start_location.loc, leg.end_location.loc])\n    return path\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.infill_legs","title":"<code>infill_legs(plan)</code>","text":"<p>Infill missing legs. If there is no leg between two activities, a new one is created linking them.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def infill_legs(plan: Plan) -&gt; None:\n    \"\"\"Infill missing legs.\n    If there is no leg between two activities, a new one is created linking them.\n    \"\"\"\n    i = 0\n    while i &lt; len(plan.day) - 1:\n        component1 = plan.day[i]\n        component2 = plan.day[i + 1]\n        if isinstance(component1, Activity) and isinstance(component2, Activity):\n            leg = create_leg(component1, component2)\n            plan.day.insert(i + 1, leg)\n            i += 1\n        i += 1\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.leg_intersects","title":"<code>leg_intersects(leg, boundary)</code>","text":"<p>Check whether a leg touches an area defined by a boundary.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def leg_intersects(leg: Leg, boundary: Polygon) -&gt; bool:\n    \"\"\"Check whether a leg touches an area defined by a boundary.\"\"\"\n    path = get_leg_path(leg)\n    return path.intersects(boundary)\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.link_plan","title":"<code>link_plan(plan)</code>","text":"<p>Link a plan: each activity/leg gets a pointer to the previous/next plan component.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def link_plan(plan: Plan) -&gt; None:\n    \"\"\"Link a plan: each activity/leg gets a pointer to the previous/next plan component.\"\"\"\n    plan_list = list(plan)\n    act_list = list(plan.activities)\n    leg_list = list(plan.legs)\n\n    for i, p in enumerate(plan_list):\n        p.next = list_get(plan_list, i + 1)\n        p.previous = list_get(plan_list, i - 1)\n\n    for i, p in enumerate(act_list):\n        p.next_act = list_get(act_list, i + 1)\n        p.previous_act = list_get(act_list, i - 1)\n\n    for i, p in enumerate(leg_list):\n        p.start_hour = p.start_time.hour\n        p.next_leg = list_get(leg_list, i + 1)\n        p.previous_leg = list_get(leg_list, i - 1)\n        p.start_location = p.previous.location\n        p.end_location = p.next.location\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.link_population","title":"<code>link_population(population)</code>","text":"<p>Link the plan components of every agent in the population.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def link_population(population: Population) -&gt; None:\n    \"\"\"Link the plan components of every agent in the population.\"\"\"\n    for hid, pid, person in population.people():\n        link_plan(person.plan)\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.list_get","title":"<code>list_get(list_to_access, idx)</code>","text":"Source code in <code>pam/operations/cropping.py</code> <pre><code>def list_get(list_to_access, idx):\n    if idx &lt; len(list_to_access) and idx &gt;= 0:\n        return list_to_access[idx]\n    else:\n        return None\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.rename_external","title":"<code>rename_external(plan, boundary)</code>","text":"<p>Rename all external-area activities as \"external\".</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def rename_external(plan: Plan, boundary: Polygon) -&gt; None:\n    \"\"\"Rename all external-area activities as \"external\".\"\"\"\n    for act in plan.activities:\n        if not boundary.contains(act.location.loc):\n            act.act = \"external\"\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.simplify_external_plans","title":"<code>simplify_external_plans(plan, boundary, snap_to_boundary=False, rename_external_activities=False)</code>","text":"<p>Simplify any activities happening outside the boundary area.</p> Method <ol> <li>Identify which legs touch the boundary area</li> <li>Keep the relevant legs/activities and drop the remaining components</li> <li>Infill: create any new legs between external activities as necessary</li> <li>Ensure plan consistency: start/end times, sequences, etc</li> <li>optional Rename activities to \"external\"</li> <li>optional Crop the leg geometries to start/stop at the core area boundaries</li> </ol> PARAMETER  DESCRIPTION <code>plan</code> <p>a PAM plan</p> <p> TYPE: <code>Plan</code> </p> <code>boundary</code> <p>the geometry of the core modelled area</p> <p> TYPE: <code>Polygon</code> </p> <code>snap_to_boundary</code> <p>whether to crop legs to stop at the core area boundary. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rename_external_activities</code> <p>whether to rename all external-area activities as \"external\" Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def simplify_external_plans(\n    plan: Plan,\n    boundary: Polygon,\n    snap_to_boundary: bool = False,\n    rename_external_activities: bool = False,\n) -&gt; None:\n    \"\"\"Simplify any activities happening outside the boundary area.\n\n    Method:\n     1. Identify which legs touch the boundary area\n     2. Keep the relevant legs/activities and drop the remaining components\n     3. Infill: create any new legs between external activities as necessary\n     4. Ensure plan consistency: start/end times, sequences, etc\n     5. **optional** Rename activities to \"external\"\n     6. **optional** Crop the leg geometries to start/stop at the core area boundaries\n\n    Args:\n      plan (Plan): a PAM plan\n      boundary (Polygon): the geometry of the core modelled area\n      snap_to_boundary (bool, optional): whether to crop legs to stop at the core area boundary. Defaults to False.\n      rename_external_activities (bool, optional): whether to rename all external-area activities as \"external\" Defaults to False.\n\n    \"\"\"\n    link_plan(plan)\n    kept_activities = get_kept_activities(plan, boundary)  # activities to keep\n    crop_plan(plan, kept_activities)  # drop external plan components\n    infill_legs(plan)  # infill with any new legs if required\n    stretch_times(plan)  # fix plan time boundaries\n    link_plan(plan)  # re-link plan components\n    if rename_external_activities:\n        rename_external(plan, boundary)  # rename activities to \"external\"\n    if snap_to_boundary:\n        for leg in plan.legs:\n            crop_leg(leg, boundary)  # crop leg geometry\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.simplify_population","title":"<code>simplify_population(population, boundary, snap_to_boundary=False, rename_external_activities=False)</code>","text":"<p>Simplify external plans across a population.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def simplify_population(\n    population: str,\n    boundary: str,\n    snap_to_boundary: bool = False,\n    rename_external_activities: bool = False,\n) -&gt; None:\n    \"\"\"Simplify external plans across a population.\"\"\"\n    # simplify plans\n    for hid, pid, person in population.people():\n        simplify_external_plans(person.plan, boundary, snap_to_boundary, rename_external_activities)\n\n    # remove empty person-plans and households\n    remove_persons = []\n    for hid, pid, person in population.people():\n        if len(person.plan) == 1 and person.plan.day[0].act == \"external\":\n            remove_persons.append((hid, pid))\n    for hid, pid in remove_persons:\n        del population[hid].people[pid]\n\n    remove_hhs = [\n        hid for hid in population.households if len(population.households[hid].people) == 0\n    ]\n    for hid in remove_hhs:\n        del population.households[hid]\n</code></pre>"},{"location":"reference/pam/operations/cropping/#pam.operations.cropping.stretch_times","title":"<code>stretch_times(plan)</code>","text":"<p>Extend start/end activity times to the start/end of day.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def stretch_times(plan: Plan) -&gt; None:\n    \"\"\"Extend start/end activity times to the start/end of day.\"\"\"\n    plan.day[0].start_time = START_OF_DAY\n    plan.day[-1].end_time = END_OF_DAY\n</code></pre>"},{"location":"reference/pam/optimise/grid/","title":"pam.optimise.grid","text":""},{"location":"reference/pam/optimise/grid/#pam.optimise.grid.Recorder","title":"<code>Recorder(initial_score, initial_plan)</code>","text":"<p>Mechanism for recording grid optimiser progress.</p> PARAMETER  DESCRIPTION <code>initial_score</code> <p>Initial plan score.</p> <p> TYPE: <code>float</code> </p> <code>initial_plan</code> <p>Initial plan.</p> <p> TYPE: <code>Plan</code> </p> Source code in <code>pam/optimise/grid.py</code> <pre><code>def __init__(self, initial_score: float, initial_plan: Plan) -&gt; None:\n    \"\"\"Mechanism for recording grid optimiser progress.\n\n    Args:\n        initial_score (float): Initial plan score.\n        initial_plan (Plan): Initial plan.\n    \"\"\"\n    self.best_plan = initial_plan\n    self.best_score = initial_score\n</code></pre>"},{"location":"reference/pam/optimise/grid/#pam.optimise.grid.Recorder.best_plan","title":"<code>best_plan = initial_plan</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/optimise/grid/#pam.optimise.grid.Recorder.best_score","title":"<code>best_score = initial_score</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/optimise/grid/#pam.optimise.grid.Recorder.update","title":"<code>update(score, plan)</code>","text":"<p>Update with new score and plan.</p> PARAMETER  DESCRIPTION <code>score</code> <p>Latest plan score.</p> <p> TYPE: <code>float</code> </p> <code>plan</code> <p>Latest plan.</p> <p> TYPE: <code>Plan</code> </p> Source code in <code>pam/optimise/grid.py</code> <pre><code>def update(self, score: float, plan: Plan):\n    \"\"\"Update with new score and plan.\n\n    Args:\n        score (float): Latest plan score.\n        plan (Plan): Latest plan.\n    \"\"\"\n    if score &gt;= self.best_score:\n        self.best_score = score\n        self.best_plan = deepcopy(plan)\n</code></pre>"},{"location":"reference/pam/optimise/grid/#pam.optimise.grid.grid_search","title":"<code>grid_search(plan, plans_scorer, config, step=900, copy=True)</code>","text":"<p>Grid search for optimum plan schedule.</p> <p>Checks all permutations of a plan's activity start times and durations, finds plan that has maximum score, based on the given scorer. The precision and size of the grid is based on the given step (seconds). Smaller steps increase the grid size.</p> <p>Trip durations are assumed fixed and activity sequence is not changed.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>Input plan.</p> <p> TYPE: <code>Plan</code> </p> <code>plans_scorer</code> <p>Plans scorer object.</p> <p> TYPE: <code>PlanScorer</code> </p> <code>config</code> <p>PlansScorer config.</p> <p> TYPE: <code>Dict</code> </p> <code>step</code> <p>Grid size in seconds. Defaults to 900.</p> <p> TYPE: <code>int</code> DEFAULT: <code>900</code> </p> <code>copy</code> <p>Create a copy of the input plan. Defaults to True.</p> <p> TYPE: <code>Bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>(Plan, float)</code> <p>Best plan found and score of best plan.</p> Source code in <code>pam/optimise/grid.py</code> <pre><code>def grid_search(\n    plan: Plan, plans_scorer: PlanScorer, config: dict, step: int = 900, copy=True\n) -&gt; (float, Plan):\n    \"\"\"Grid search for optimum plan schedule.\n\n    Checks all permutations of a plan's activity start times and durations, finds plan\n    that has maximum score, based on the given scorer. The precision and size of the grid is based\n    on the given step (seconds). Smaller steps increase the grid size.\n\n    Trip durations are assumed fixed and activity sequence is not changed.\n\n    Args:\n        plan (Plan): Input plan.\n        plans_scorer (PlanScorer): Plans scorer object.\n        config (Dict): PlansScorer config.\n        step (int): Grid size in seconds. Defaults to 900.\n        copy (Bool): Create a copy of the input plan. Defaults to True.\n\n    Returns:\n        (Plan, float): Best plan found and score of best plan.\n    \"\"\"\n    if copy:\n        plan = deepcopy(plan)\n    initial_score = plans_scorer.score_plan(plan, config)\n    recorder = Recorder(initial_score, plan)\n\n    traverse(\n        scorer=plans_scorer,\n        config=config,\n        plan=plan,\n        earliest=0,\n        step=step,\n        leg_index=0,\n        recorder=recorder,\n    )\n    print_report(initial_score, recorder.best_score, step)\n    return recorder.best_plan, recorder.best_score\n</code></pre>"},{"location":"reference/pam/optimise/grid/#pam.optimise.grid.latest_start_time","title":"<code>latest_start_time(plan, leg_index)</code>","text":"Source code in <code>pam/optimise/grid.py</code> <pre><code>def latest_start_time(plan: Plan, leg_index: int):\n    allowance = 24 * 60 * 60\n    for c in plan[(leg_index * 2) + 1 :: 2]:\n        allowance -= c.duration.seconds\n    return allowance\n</code></pre>"},{"location":"reference/pam/optimise/grid/#pam.optimise.grid.print_report","title":"<code>print_report(initial_score, best_score, n)</code>","text":"Source code in <code>pam/optimise/grid.py</code> <pre><code>def print_report(initial_score: float, best_score: float, n: int):\n    if best_score &gt; initial_score:\n        print(f\"Score improved from {initial_score} to {best_score} using step size {n}s.\")\n    else:\n        print(f\"Failed to improve score from initial {initial_score} using step size {n}s.\")\n</code></pre>"},{"location":"reference/pam/optimise/grid/#pam.optimise.grid.traverse","title":"<code>traverse(scorer, config, plan, step, earliest, leg_index, recorder)</code>","text":"<p>Traverse all possible grid permutations by enumerating all trip start times of first trip and recursively all following trips in sequence.</p> Source code in <code>pam/optimise/grid.py</code> <pre><code>def traverse(\n    scorer: PlanScorer,\n    config: dict,\n    plan: Plan,\n    step: int,\n    earliest: int,\n    leg_index: int,\n    recorder: Recorder,\n):\n    \"\"\"Traverse all possible grid permutations by enumerating all trip start times of first trip\n    and recursively all following trips in sequence.\n    \"\"\"\n    ## exit condition\n    if leg_index * 2 + 2 &gt;= len(plan):\n        recorder.update(scorer.score_plan(plan, cnfg=config), plan)\n        return None\n\n    latest_start = latest_start_time(plan, leg_index)\n    for earliest in range(earliest, latest_start + step, step):\n        activity = plan[leg_index * 2]\n        leg = plan[leg_index * 2 + 1]\n        next_activity = plan[leg_index * 2 + 2]\n        activity.end_time = START_OF_DAY + timedelta(seconds=earliest)\n        leg.end_time = leg.shift_start_time(activity.end_time)\n        next_activity.start_time = leg.end_time\n\n        traverse(\n            scorer=scorer,\n            config=config,\n            plan=deepcopy(plan),\n            earliest=earliest + step,  # + plan[leg_index * 2 + 1].duration.seconds,\n            leg_index=leg_index + 1,\n            step=step,\n            recorder=recorder,\n        )\n</code></pre>"},{"location":"reference/pam/optimise/random/","title":"pam.optimise.random","text":""},{"location":"reference/pam/optimise/random/#pam.optimise.random.Stopper","title":"<code>Stopper(horizon=5, sensitivity=0.01)</code>","text":"<p>Early stopping mechanism. Maintains last n scores, where n is equal to \"horizon\". Triggers an early stop if change across horizon is less than given sensitivity.</p> PARAMETER  DESCRIPTION <code>horizon</code> <p>length of stored history. Defaults to 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>sensitivity</code> <p>stopping tolerance. Defaults to 0.01.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.01</code> </p> Source code in <code>pam/optimise/random.py</code> <pre><code>def __init__(self, horizon=5, sensitivity=0.01) -&gt; None:\n    \"\"\"Early stopping mechanism. Maintains last n scores, where n is equal to \"horizon\".\n    Triggers an early stop if change across horizon is less than given sensitivity.\n\n    Args:\n        horizon (int, optional): length of stored history. Defaults to 5.\n        sensitivity (float, optional): stopping tolerance. Defaults to 0.01.\n    \"\"\"\n    self.record = []\n    self.horizon = horizon\n    self.sensitivity = sensitivity\n</code></pre>"},{"location":"reference/pam/optimise/random/#pam.optimise.random.Stopper.horizon","title":"<code>horizon = horizon</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/optimise/random/#pam.optimise.random.Stopper.record","title":"<code>record = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/optimise/random/#pam.optimise.random.Stopper.sensitivity","title":"<code>sensitivity = sensitivity</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/optimise/random/#pam.optimise.random.Stopper.stop","title":"<code>stop(score)</code>","text":"Source code in <code>pam/optimise/random.py</code> <pre><code>def stop(self, score):\n    self.record.append(score)\n    if len(self.record) &gt; self.horizon:\n        self.record.pop(0)\n        if abs(self.record[-1] - self.record[0]) &lt; self.sensitivity:\n            return True\n    return False\n</code></pre>"},{"location":"reference/pam/optimise/random/#pam.optimise.random.print_report","title":"<code>print_report(initial_score, best_score, n)</code>","text":"Source code in <code>pam/optimise/random.py</code> <pre><code>def print_report(initial_score, best_score, n):\n    if best_score &gt; initial_score:\n        print(f\"Score improved from {initial_score} to {best_score} in {n} steps.\")\n    else:\n        print(f\"Failed to improve score from initial {initial_score} in {n} steps.\")\n</code></pre>"},{"location":"reference/pam/optimise/random/#pam.optimise.random.random_mutate_activity_durations","title":"<code>random_mutate_activity_durations(plan, copy=True)</code>","text":"<p>Rearrange input plan into random new plan, maintaining activity sequence and trip durations.</p> Source code in <code>pam/optimise/random.py</code> <pre><code>def random_mutate_activity_durations(plan: Plan, copy=True):\n    \"\"\"Rearrange input plan into random new plan, maintaining activity sequence and trip durations.\"\"\"\n    allowance = 24 * 60 * 60  # seconds\n    for leg in plan.legs:\n        allowance -= leg.duration.total_seconds()\n    n_activities = len(list(plan.activities))\n    activity_durations = [\n        timedelta(seconds=int(random.random() * allowance / n_activities))\n        for n in range(n_activities)\n    ]\n    if copy:\n        plan = deepcopy(plan)\n    time = plan.day[0].shift_duration(new_duration=activity_durations.pop(0))\n    idx = 1\n    for activity_duration, leg_duration in zip(\n        activity_durations, [leg.duration for leg in plan.legs]\n    ):\n        time = plan.day[idx].shift_duration(new_start_time=time, new_duration=leg_duration)\n        time = plan.day[idx + 1].shift_duration(new_start_time=time, new_duration=activity_duration)\n        idx += 2\n    plan.day[-1].end_time = END_OF_DAY\n    return plan\n</code></pre>"},{"location":"reference/pam/optimise/random/#pam.optimise.random.reschedule","title":"<code>reschedule(plan, plans_scorer, config={}, horizon=5, sensitivity=0.01, patience=1000)</code>","text":"<p>Randomly search for an improved plan sequence based on given plans_scorer.</p> <p>This is not seriously suggested as a sensible approach, it is supplied for example only.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>Input plan.</p> <p> TYPE: <code>Plan</code> </p> <code>plans_scorer</code> <p>Plans scorer.</p> <p> TYPE: <code>PlanScorer</code> </p> <code>config</code> <p>plans_scorer configuration. Defaults to {}.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>horizon</code> <p>Early stopper horizon. Defaults to 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>sensitivity</code> <p>Early stopper sensitivity. Defaults to 0.01.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.01</code> </p> <code>patience</code> <p>Defaults to 1000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RETURNS DESCRIPTION <code>(Plan, float)</code> <p>best plan found and best score.</p> Source code in <code>pam/optimise/random.py</code> <pre><code>def reschedule(\n    plan: Plan,\n    plans_scorer: PlanScorer,\n    config: dict = {},\n    horizon: int = 5,\n    sensitivity: float = 0.01,\n    patience: int = 1000,\n) -&gt; (Plan, float):\n    \"\"\"Randomly search for an improved plan sequence based on given plans_scorer.\n\n    This is not seriously suggested as a sensible approach, it is supplied for example only.\n\n    Args:\n        plan (Plan): Input plan.\n        plans_scorer (PlanScorer): Plans scorer.\n        config (dict): plans_scorer configuration. Defaults to {}.\n        horizon (int): Early stopper horizon. Defaults to 5.\n        sensitivity (float): Early stopper sensitivity. Defaults to 0.01.\n        patience (int): Defaults to 1000.\n\n    Returns:\n        (Plan, float): best plan found and best score.\n    \"\"\"\n    best_score = plans_scorer.score_plan(plan, config)\n    initial_score = best_score\n    best_scores = {0: best_score}\n    stopper = Stopper(horizon=horizon, sensitivity=sensitivity)\n    for n in range(patience + 1):\n        proposed_plan = random_mutate_activity_durations(plan, copy=True)\n        score = plans_scorer.score_plan(proposed_plan, config)\n        if score &gt; best_score:\n            best_scores[n] = score\n            best_score = score\n            plan = proposed_plan\n            if stopper.stop(score):\n                print_report(initial_score, best_score, n)\n                return plan, best_scores\n    print_report(initial_score, best_score, n)\n    return plan, best_scores\n</code></pre>"},{"location":"reference/pam/planner/choice_location/","title":"pam.planner.choice_location","text":"<p>Location and mode choice models for activity modelling.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration","title":"<code>ChoiceConfiguration</code>  <code>dataclass</code>","text":"ATTRIBUTE DESCRIPTION <code>u</code> <p>The utility function specification. The string may point to household, person, act, leg, od, or zone data. It can also include values and/or mathematical operations. Parameters may be passed as single values, or as lists (with each element in the list corresponding to one of the modes in the OD object). For example: u='-[0,1] - (2 * od['time']) - (od['time'] * person.attributes['age']&gt;60). Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>scope</code> <p>The scope of the function (for example, work activities). Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>func_probabilities</code> <p>The function for calculating the probability of each alternative. Defaults to None.</p> <p> TYPE: <code>Callable</code> </p> <code>func_sampling</code> <p>The function for sampling across alternatives, ie softmax. Defaults to None.</p> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.func_probabilities","title":"<code>func_probabilities: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.func_sampling","title":"<code>func_sampling: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.scope","title":"<code>scope: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.u","title":"<code>u: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.validate","title":"<code>validate(vars)</code>","text":"PARAMETER  DESCRIPTION <code>vars</code> <p> TYPE: <code>list[str]</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def validate(self, vars: list[str]) -&gt; None:\n    \"\"\"\n\n    Args:\n      vars (list[str]):\n\n    \"\"\"\n    for var in vars:\n        if getattr(self, var) is None:\n            raise ValueError(f\"Setting {var} has not been set yet\")\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceIdx","title":"<code>ChoiceIdx</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Choice set index.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.act","title":"<code>act: Activity</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.hid","title":"<code>hid: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.pid","title":"<code>pid: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.seq","title":"<code>seq: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceLabel","title":"<code>ChoiceLabel</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Destination and mode choice labels of a selected option.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceLabel.destination","title":"<code>destination: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceLabel.mode","title":"<code>mode: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL","title":"<code>ChoiceMNL(population, od, zones)</code>","text":"<p>             Bases: <code>ChoiceModel</code></p> <p>Applies a Multinomial Logit Choice model.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(self, population: Population, od: OD, zones: pd.DataFrame) -&gt; None:\n    super().__init__(population, od, zones)\n    self.configure(\n        func_probabilities=calculate_mnl_probabilities, func_sampling=sample_weighted\n    )\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.configuration","title":"<code>configuration = ChoiceConfiguration()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.od","title":"<code>od = od</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.population","title":"<code>population = population</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.selections","title":"<code>selections: SelectionSet</code>  <code>property</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.zones","title":"<code>zones = self.parse_zone_data(zones)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.apply","title":"<code>apply(apply_location=True, apply_mode=True, once_per_agent=True, apply_mode_to='chain')</code>","text":"<p>Apply the choice model to the PAM population,     updating the activity locations and mode choices in scope.</p> PARAMETER  DESCRIPTION <code>apply_location</code> <p>Whether to update activities' location. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>apply_mode</code> <p>Whether to update travel modes. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>once_per_agent</code> <p>If True, the same selected option is applied to all activities within scope of an agent. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>apply_mode_to</code> <p>Whether to apply the mode to the entire trip chain that contains the activity, or the leg preceding the activity. Defaults to \"chain\".</p> <p> TYPE: <code>Literal['chain', 'previous_leg']</code> DEFAULT: <code>'chain'</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def apply(\n    self,\n    apply_location: bool = True,\n    apply_mode: bool = True,\n    once_per_agent: bool = True,\n    apply_mode_to: Literal[\"chain\", \"previous_leg\"] = \"chain\",\n) -&gt; None:\n    \"\"\"Apply the choice model to the PAM population,\n        updating the activity locations and mode choices in scope.\n\n    Args:\n      apply_location (bool, optional): Whether to update activities' location. Defaults to True.\n      apply_mode (bool, optional): Whether to update travel modes. Defaults to True.\n      once_per_agent (bool, optional): If True, the same selected option is applied to all activities within scope of an agent. Defaults to True.\n      apply_mode_to (Literal[\"chain\", \"previous_leg\"]):\n        Whether to apply the mode to the entire trip chain that contains the activity, or the leg preceding the activity.\n        Defaults to \"chain\".\n\n    \"\"\"\n    self.logger.info(\"Applying choice model...\")\n    self.logger.info(f\"Configuration: \\n{self.configuration}\")\n\n    pid = None\n    destination = None\n    trmode = None\n\n    # update location and mode\n    for idx, selection in zip(self.selections.choice_set.idxs, self.selections.selections):\n        if not (once_per_agent and (pid == idx.pid)):\n            destination = selection.destination\n            trmode = selection.mode\n\n        pid = idx.pid\n        act = idx.act\n\n        if apply_location:\n            act.location.area = destination\n\n        if apply_mode and (act.previous is not None):\n            if apply_mode_to == \"chain\":\n                apply_mode_to_home_chain(act, trmode)\n            elif apply_mode_to == \"previous_leg\":\n                act.previous.mode = trmode\n            else:\n                raise ValueError(f\"Invalid option {apply_mode_to}\")\n\n    self.logger.info(\"Choice model application complete.\")\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.configure","title":"<code>configure(**kwargs)</code>","text":"<p>Specify the model.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Parameters of the ChoiceConfiguration class.</p> <p> TYPE: <code>Optional[Union[str, Callable]]</code> DEFAULT: <code>{}</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def configure(self, **kwargs: Optional[Union[str, Callable]]) -&gt; None:\n    \"\"\"Specify the model.\n\n    Args:\n      **kwargs (Optional[Union[str, Callable]]): Parameters of the ChoiceConfiguration class.\n\n    \"\"\"\n    for k, v in kwargs.items():\n        if isinstance(v, str):\n            v = v.replace(\" \", \"\")\n        setattr(self.configuration, k, v)\n    self.logger.info(\"Updated model configuration\")\n    self.logger.info(self.configuration)\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.get_choice_set","title":"<code>get_choice_set()</code>","text":"<p>Construct an agent's choice set for each activity/leg within scope.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def get_choice_set(self) -&gt; ChoiceSet:\n    \"\"\"Construct an agent's choice set for each activity/leg within scope.\"\"\"\n    self.configuration.validate([\"u\", \"scope\"])\n    od = self.od\n    u = self.configuration.u\n    scope = self.configuration.scope\n    # zones might be defined in `u` and so be required on calling `eval(u)`\n    zones = self.zones  # noqa: F841\n\n    idxs = []\n    u_choices = []\n    choice_labels = list(itertools.product(od.labels.destination_zones, od.labels.mode))\n    choice_labels = [ChoiceLabel(*x) for x in choice_labels]\n\n    # iterate across activities\n    for hid, hh in self.population:\n        for pid, person in hh:\n            for i, act in enumerate(person.activities):\n                if eval(scope):\n                    idx_act = ChoiceIdx(pid=pid, hid=hid, seq=i, act=act)\n                    # calculate utilities for each alternative\n                    u_act = eval(u)\n                    # flatten location-mode combinations\n                    u_act = u_act.flatten()\n\n                    u_choices.append(u_act)\n                    idxs.append(idx_act)\n\n    u_choices = np.array(u_choices)\n\n    # check dimensions\n    assert u_choices.shape[1] == len(choice_labels)\n    assert u_choices.shape[0] == len(idxs)\n\n    return ChoiceSet(idxs=idxs, u_choices=u_choices, choice_labels=choice_labels)\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceMNL.parse_zone_data","title":"<code>parse_zone_data(zones)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/choice_location.py</code> <pre><code>@staticmethod\ndef parse_zone_data(zones: Union[pd.DataFrame, Zones]) -&gt; Zones:\n    if isinstance(zones, Zones):\n        return deepcopy(zones)\n    elif isinstance(zones, pd.DataFrame):\n        return Zones(data=zones.copy())\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel","title":"<code>ChoiceModel(population, od, zones)</code>","text":"<p>Choice model interface.</p> PARAMETER  DESCRIPTION <code>population</code> <p>A PAM population.</p> <p> TYPE: <code>Population</code> </p> <code>od</code> <p>An object holding origin-destination.</p> <p> TYPE: <code>OD</code> </p> <code>zones</code> <p>Zone-level data.</p> <p> TYPE: <code>Union[DataFrame, Zones]</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(self, population: Population, od: OD, zones: Union[pd.DataFrame, Zones]) -&gt; None:\n    \"\"\"Choice model interface.\n\n    Args:\n        population (Population): A PAM population.\n        od (OD): An object holding origin-destination.\n        zones (Union[pd.DataFrame, Zones]): Zone-level data.\n\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.population = population\n    link_population(self.population)\n    self.od = od\n    self.zones = self.parse_zone_data(zones)\n    self.zones.data = self.zones.data.loc[list(od.labels.destination_zones)]\n    self.configuration = ChoiceConfiguration()\n    self._selections = None\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.configuration","title":"<code>configuration = ChoiceConfiguration()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.od","title":"<code>od = od</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.population","title":"<code>population = population</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.selections","title":"<code>selections: SelectionSet</code>  <code>property</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.zones","title":"<code>zones = self.parse_zone_data(zones)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.apply","title":"<code>apply(apply_location=True, apply_mode=True, once_per_agent=True, apply_mode_to='chain')</code>","text":"<p>Apply the choice model to the PAM population,     updating the activity locations and mode choices in scope.</p> PARAMETER  DESCRIPTION <code>apply_location</code> <p>Whether to update activities' location. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>apply_mode</code> <p>Whether to update travel modes. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>once_per_agent</code> <p>If True, the same selected option is applied to all activities within scope of an agent. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>apply_mode_to</code> <p>Whether to apply the mode to the entire trip chain that contains the activity, or the leg preceding the activity. Defaults to \"chain\".</p> <p> TYPE: <code>Literal['chain', 'previous_leg']</code> DEFAULT: <code>'chain'</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def apply(\n    self,\n    apply_location: bool = True,\n    apply_mode: bool = True,\n    once_per_agent: bool = True,\n    apply_mode_to: Literal[\"chain\", \"previous_leg\"] = \"chain\",\n) -&gt; None:\n    \"\"\"Apply the choice model to the PAM population,\n        updating the activity locations and mode choices in scope.\n\n    Args:\n      apply_location (bool, optional): Whether to update activities' location. Defaults to True.\n      apply_mode (bool, optional): Whether to update travel modes. Defaults to True.\n      once_per_agent (bool, optional): If True, the same selected option is applied to all activities within scope of an agent. Defaults to True.\n      apply_mode_to (Literal[\"chain\", \"previous_leg\"]):\n        Whether to apply the mode to the entire trip chain that contains the activity, or the leg preceding the activity.\n        Defaults to \"chain\".\n\n    \"\"\"\n    self.logger.info(\"Applying choice model...\")\n    self.logger.info(f\"Configuration: \\n{self.configuration}\")\n\n    pid = None\n    destination = None\n    trmode = None\n\n    # update location and mode\n    for idx, selection in zip(self.selections.choice_set.idxs, self.selections.selections):\n        if not (once_per_agent and (pid == idx.pid)):\n            destination = selection.destination\n            trmode = selection.mode\n\n        pid = idx.pid\n        act = idx.act\n\n        if apply_location:\n            act.location.area = destination\n\n        if apply_mode and (act.previous is not None):\n            if apply_mode_to == \"chain\":\n                apply_mode_to_home_chain(act, trmode)\n            elif apply_mode_to == \"previous_leg\":\n                act.previous.mode = trmode\n            else:\n                raise ValueError(f\"Invalid option {apply_mode_to}\")\n\n    self.logger.info(\"Choice model application complete.\")\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.configure","title":"<code>configure(**kwargs)</code>","text":"<p>Specify the model.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Parameters of the ChoiceConfiguration class.</p> <p> TYPE: <code>Optional[Union[str, Callable]]</code> DEFAULT: <code>{}</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def configure(self, **kwargs: Optional[Union[str, Callable]]) -&gt; None:\n    \"\"\"Specify the model.\n\n    Args:\n      **kwargs (Optional[Union[str, Callable]]): Parameters of the ChoiceConfiguration class.\n\n    \"\"\"\n    for k, v in kwargs.items():\n        if isinstance(v, str):\n            v = v.replace(\" \", \"\")\n        setattr(self.configuration, k, v)\n    self.logger.info(\"Updated model configuration\")\n    self.logger.info(self.configuration)\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.get_choice_set","title":"<code>get_choice_set()</code>","text":"<p>Construct an agent's choice set for each activity/leg within scope.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def get_choice_set(self) -&gt; ChoiceSet:\n    \"\"\"Construct an agent's choice set for each activity/leg within scope.\"\"\"\n    self.configuration.validate([\"u\", \"scope\"])\n    od = self.od\n    u = self.configuration.u\n    scope = self.configuration.scope\n    # zones might be defined in `u` and so be required on calling `eval(u)`\n    zones = self.zones  # noqa: F841\n\n    idxs = []\n    u_choices = []\n    choice_labels = list(itertools.product(od.labels.destination_zones, od.labels.mode))\n    choice_labels = [ChoiceLabel(*x) for x in choice_labels]\n\n    # iterate across activities\n    for hid, hh in self.population:\n        for pid, person in hh:\n            for i, act in enumerate(person.activities):\n                if eval(scope):\n                    idx_act = ChoiceIdx(pid=pid, hid=hid, seq=i, act=act)\n                    # calculate utilities for each alternative\n                    u_act = eval(u)\n                    # flatten location-mode combinations\n                    u_act = u_act.flatten()\n\n                    u_choices.append(u_act)\n                    idxs.append(idx_act)\n\n    u_choices = np.array(u_choices)\n\n    # check dimensions\n    assert u_choices.shape[1] == len(choice_labels)\n    assert u_choices.shape[0] == len(idxs)\n\n    return ChoiceSet(idxs=idxs, u_choices=u_choices, choice_labels=choice_labels)\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceModel.parse_zone_data","title":"<code>parse_zone_data(zones)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/choice_location.py</code> <pre><code>@staticmethod\ndef parse_zone_data(zones: Union[pd.DataFrame, Zones]) -&gt; Zones:\n    if isinstance(zones, Zones):\n        return deepcopy(zones)\n    elif isinstance(zones, pd.DataFrame):\n        return Zones(data=zones.copy())\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceSet","title":"<code>ChoiceSet</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>MNL Choice set.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceSet.choice_labels","title":"<code>choice_labels: list[ChoiceLabel]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceSet.idxs","title":"<code>idxs: list[ChoiceIdx]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.ChoiceSet.u_choices","title":"<code>u_choices: np.array</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrip","title":"<code>DiscretionaryTrip(trip_chain, od)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Location choice for discretionary trips in a trip chain.</p> Cases <ol> <li>O-&gt;discretionary-&gt;O (DiscretionaryTripRound)</li> <li>O-&gt;discretionary-&gt;D (DiscretionaryTripOD)</li> <li>O-&gt;discretionary-&gt;discretionary-&gt;O</li> <li>O-&gt;discretionary-&gt;discretionary-&gt;D</li> </ol> <p>Chains with multiple discretionary trips are solved recursively,     updating the first location each time, and then keeping it fixed as we solve downstream.</p> PARAMETER  DESCRIPTION <code>trip_chain</code> <p>A trip chain between two long-term activities.</p> <p> TYPE: <code>list[Union[Activity, Leg]]</code> </p> <code>od</code> <p>An object holding origin-destination matrices.</p> <p> TYPE: <code>OD</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(self, trip_chain: list[Union[Activity, Leg]], od: OD) -&gt; None:\n    \"\"\"Location choice for discretionary trips in a trip chain.\n\n    Cases:\n        1. O-&gt;discretionary-&gt;O (DiscretionaryTripRound)\n        2. O-&gt;discretionary-&gt;D (DiscretionaryTripOD)\n        3. O-&gt;discretionary-&gt;discretionary-&gt;O\n        4. O-&gt;discretionary-&gt;discretionary-&gt;D\n\n    Chains with multiple discretionary trips are solved recursively,\n        updating the first location each time, and then keeping it fixed as we solve downstream.\n\n    Args:\n        trip_chain (list[Union[Activity, Leg]]): A trip chain between two long-term activities.\n        od (OD): An object holding origin-destination matrices.\n    \"\"\"\n    self._trip_chain = trip_chain\n    self._od = od\n    self.act_names = get_act_names(trip_chain)\n\n    # anchor points\n    self.anchor_zone_start = trip_chain[0].location.area\n    self.anchor_zone_end = trip_chain[-1].location.area\n    self.trmode = trip_chain[1].mode\n\n    # some checks\n    if len(trip_chain) % 2 == 0:\n        raise ValueError(\n            \"Trip chain must have an odd number of elements as it is a sequence of activities joined by trip legs\"\n        )\n    if not all(isinstance(i, Leg) for i in trip_chain[1::2]):\n        raise TypeError(\"Each odd element in the trip chain should be a leg\")\n    if not all(isinstance(i, Activity) for i in trip_chain[::2]):\n        raise TypeError(\"Each even element in the trip chain should be an activity\")\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrip.act_names","title":"<code>act_names = get_act_names(trip_chain)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrip.anchor_zone_end","title":"<code>anchor_zone_end = trip_chain[-1].location.area</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrip.anchor_zone_start","title":"<code>anchor_zone_start = trip_chain[0].location.area</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrip.od","title":"<code>od: OD</code>  <code>property</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrip.trmode","title":"<code>trmode = trip_chain[1].mode</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrip.choose_destination","title":"<code>choose_destination()</code>  <code>abstractmethod</code>","text":"<p>Selects a destination for the discretionary activity.</p> RETURNS DESCRIPTION <code>str</code> <p>Selected destination zone name.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>@abstractmethod\ndef choose_destination(self) -&gt; str:\n    \"\"\"Selects a destination for the discretionary activity.\n\n    Returns:\n        str: Selected destination zone name.\n    \"\"\"\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrip.update_plan","title":"<code>update_plan()</code>","text":"<p>Update the PAM activity locations of the first activity in the trip chain, and continue downstream until the entire chain is solved.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def update_plan(self):\n    \"\"\"\n    Update the PAM activity locations of the first activity in the trip chain,\n    and continue downstream until the entire chain is solved.\n    \"\"\"\n    if len(self.act_names) &gt; 2:\n        # update locations\n        area = self.choose_destination()\n        self._trip_chain[2].location.area = area\n        self._trip_chain[1].end_location.area = area\n        self._trip_chain[3].start_location.area = area\n\n        # if the remaining chain is now a round-trip:\n        if self.act_names[0] == self.act_names[-1]:\n            # continue downstream recursively\n            # with a round-trip selection\n            DiscretionaryTripRound(trip_chain=self._trip_chain[2:], od=self._od).update_plan()\n        # otherwise, if it is a trip chain with two anchors:\n        else:\n            # continue downstream recursively\n            # the newly-selected location now becomes the first anchor\n            DiscretionaryTripOD(trip_chain=self._trip_chain[2:], od=self._od).update_plan()\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD","title":"<code>DiscretionaryTripOD(trip_chain, od)</code>","text":"<p>             Bases: <code>DiscretionaryTrip</code></p> <p>Location choice for a single discretionary trip, where we have different anchors at the start and end of the chain.</p> <p>The class infers the location of the first trip in the trip chain.</p> Methodology <p>We combine three conditions:</p> <ol> <li>Distribution of leg compared to total trip</li> <li>Diversion factor (compared to direct trips)</li> <li>Zone attraction</li> </ol> <p>Final probabilities are defined as (1) * (2) * (3) (and then normalised to sum up to 1).</p> <p>Location choice for discretionary trips in a trip chain.</p> Cases <ol> <li>O-&gt;discretionary-&gt;O (DiscretionaryTripRound)</li> <li>O-&gt;discretionary-&gt;D (DiscretionaryTripOD)</li> <li>O-&gt;discretionary-&gt;discretionary-&gt;O</li> <li>O-&gt;discretionary-&gt;discretionary-&gt;D</li> </ol> <p>Chains with multiple discretionary trips are solved recursively,     updating the first location each time, and then keeping it fixed as we solve downstream.</p> PARAMETER  DESCRIPTION <code>trip_chain</code> <p>A trip chain between two long-term activities.</p> <p> TYPE: <code>list[Union[Activity, Leg]]</code> </p> <code>od</code> <p>An object holding origin-destination matrices.</p> <p> TYPE: <code>OD</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(self, trip_chain: list[Union[Activity, Leg]], od: OD) -&gt; None:\n    \"\"\"Location choice for discretionary trips in a trip chain.\n\n    Cases:\n        1. O-&gt;discretionary-&gt;O (DiscretionaryTripRound)\n        2. O-&gt;discretionary-&gt;D (DiscretionaryTripOD)\n        3. O-&gt;discretionary-&gt;discretionary-&gt;O\n        4. O-&gt;discretionary-&gt;discretionary-&gt;D\n\n    Chains with multiple discretionary trips are solved recursively,\n        updating the first location each time, and then keeping it fixed as we solve downstream.\n\n    Args:\n        trip_chain (list[Union[Activity, Leg]]): A trip chain between two long-term activities.\n        od (OD): An object holding origin-destination matrices.\n    \"\"\"\n    self._trip_chain = trip_chain\n    self._od = od\n    self.act_names = get_act_names(trip_chain)\n\n    # anchor points\n    self.anchor_zone_start = trip_chain[0].location.area\n    self.anchor_zone_end = trip_chain[-1].location.area\n    self.trmode = trip_chain[1].mode\n\n    # some checks\n    if len(trip_chain) % 2 == 0:\n        raise ValueError(\n            \"Trip chain must have an odd number of elements as it is a sequence of activities joined by trip legs\"\n        )\n    if not all(isinstance(i, Leg) for i in trip_chain[1::2]):\n        raise TypeError(\"Each odd element in the trip chain should be a leg\")\n    if not all(isinstance(i, Activity) for i in trip_chain[::2]):\n        raise TypeError(\"Each even element in the trip chain should be an activity\")\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.act_names","title":"<code>act_names = get_act_names(trip_chain)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.anchor_zone_end","title":"<code>anchor_zone_end = trip_chain[-1].location.area</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.anchor_zone_start","title":"<code>anchor_zone_start = trip_chain[0].location.area</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.attraction_p","title":"<code>attraction_p</code>  <code>property</code>","text":"<p>Attraction probabilities.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.destination_p","title":"<code>destination_p: np.array</code>  <code>property</code>","text":"<p>Get the destination probabilities.</p> <p>Combines the leg ratio, diversion, and attraction factors probabilities by calculating their product.</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: Final destination probabilities.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.diversion_factors","title":"<code>diversion_factors: np.array</code>  <code>property</code>","text":"<p>Calculate the diversion factor for each potential destination (as compared to a direct trip between anchors).</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: An array of the time diversion factors for each candidate intermediate destination.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.diversion_p","title":"<code>diversion_p: np.array</code>  <code>property</code>","text":"<p>Diversion factor probabilities</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: An array of the time diversion factor probabilities for each candidate intermediate destination.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.leg_ratio_p","title":"<code>leg_ratio_p: np.array</code>  <code>property</code>","text":"<p>Get destination probabilities given the leg ratio.</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: An array of the leg time ratio probabilities for each candidate intermediate destination.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.leg_ratios","title":"<code>leg_ratios: np.array</code>  <code>property</code>","text":"<p>Get the impedance ratio between the fist leg candidate locations     and the corresponding total distance (anchor-&gt;discretionary-&gt;anchor).</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: An array of the leg time ratios for each candidate intermediate destination.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.observed_leg_ratio","title":"<code>observed_leg_ratio</code>  <code>property</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.od","title":"<code>od: OD</code>  <code>property</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.trmode","title":"<code>trmode = trip_chain[1].mode</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.choose_destination","title":"<code>choose_destination()</code>","text":"<p>Selects a destination for the discretionary activity.</p> RETURNS DESCRIPTION <code>str</code> <p>Selected destination zone name.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def choose_destination(self) -&gt; str:\n    \"\"\"Selects a destination for the discretionary activity.\n\n    Returns:\n        str: Selected destination zone name.\n    \"\"\"\n    zone = sample_weighted(self.destination_p)\n    area = self._od.labels.destination_zones[zone]\n\n    return area\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.pdf_leg_diversion","title":"<code>pdf_leg_diversion(diversions, max_diversion_factor=2.1)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/choice_location.py</code> <pre><code>@staticmethod\ndef pdf_leg_diversion(diversions: np.array, max_diversion_factor: float = 2.1) -&gt; np.array:\n    return np.interp(diversions, [1, max_diversion_factor], [1, 0])\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.pdf_leg_ratio","title":"<code>pdf_leg_ratio(leg_ratios, observed_ratio)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/choice_location.py</code> <pre><code>@staticmethod\ndef pdf_leg_ratio(leg_ratios: np.array, observed_ratio: float) -&gt; np.array:\n    return np.interp(leg_ratios, [0, observed_ratio, 1], [0, 1, 0])\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripOD.update_plan","title":"<code>update_plan()</code>","text":"<p>Update the PAM activity locations of the first activity in the trip chain, and continue downstream until the entire chain is solved.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def update_plan(self):\n    \"\"\"\n    Update the PAM activity locations of the first activity in the trip chain,\n    and continue downstream until the entire chain is solved.\n    \"\"\"\n    if len(self.act_names) &gt; 2:\n        # update locations\n        area = self.choose_destination()\n        self._trip_chain[2].location.area = area\n        self._trip_chain[1].end_location.area = area\n        self._trip_chain[3].start_location.area = area\n\n        # if the remaining chain is now a round-trip:\n        if self.act_names[0] == self.act_names[-1]:\n            # continue downstream recursively\n            # with a round-trip selection\n            DiscretionaryTripRound(trip_chain=self._trip_chain[2:], od=self._od).update_plan()\n        # otherwise, if it is a trip chain with two anchors:\n        else:\n            # continue downstream recursively\n            # the newly-selected location now becomes the first anchor\n            DiscretionaryTripOD(trip_chain=self._trip_chain[2:], od=self._od).update_plan()\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripRound","title":"<code>DiscretionaryTripRound(trip_chain, od)</code>","text":"<p>             Bases: <code>DiscretionaryTrip</code></p> <p>Location choice for a single discretionary trip, where we have the same anchor at the start and end of the chain.</p> <p>The class infers the location of the first discretionary activity in the trip chain.</p> <p>Location choice for discretionary trips in a trip chain.</p> Cases <ol> <li>O-&gt;discretionary-&gt;O (DiscretionaryTripRound)</li> <li>O-&gt;discretionary-&gt;D (DiscretionaryTripOD)</li> <li>O-&gt;discretionary-&gt;discretionary-&gt;O</li> <li>O-&gt;discretionary-&gt;discretionary-&gt;D</li> </ol> <p>Chains with multiple discretionary trips are solved recursively,     updating the first location each time, and then keeping it fixed as we solve downstream.</p> PARAMETER  DESCRIPTION <code>trip_chain</code> <p>A trip chain between two long-term activities.</p> <p> TYPE: <code>list[Union[Activity, Leg]]</code> </p> <code>od</code> <p>An object holding origin-destination matrices.</p> <p> TYPE: <code>OD</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(self, trip_chain: list[Union[Activity, Leg]], od: OD) -&gt; None:\n    \"\"\"Location choice for discretionary trips in a trip chain.\n\n    Cases:\n        1. O-&gt;discretionary-&gt;O (DiscretionaryTripRound)\n        2. O-&gt;discretionary-&gt;D (DiscretionaryTripOD)\n        3. O-&gt;discretionary-&gt;discretionary-&gt;O\n        4. O-&gt;discretionary-&gt;discretionary-&gt;D\n\n    Chains with multiple discretionary trips are solved recursively,\n        updating the first location each time, and then keeping it fixed as we solve downstream.\n\n    Args:\n        trip_chain (list[Union[Activity, Leg]]): A trip chain between two long-term activities.\n        od (OD): An object holding origin-destination matrices.\n    \"\"\"\n    self._trip_chain = trip_chain\n    self._od = od\n    self.act_names = get_act_names(trip_chain)\n\n    # anchor points\n    self.anchor_zone_start = trip_chain[0].location.area\n    self.anchor_zone_end = trip_chain[-1].location.area\n    self.trmode = trip_chain[1].mode\n\n    # some checks\n    if len(trip_chain) % 2 == 0:\n        raise ValueError(\n            \"Trip chain must have an odd number of elements as it is a sequence of activities joined by trip legs\"\n        )\n    if not all(isinstance(i, Leg) for i in trip_chain[1::2]):\n        raise TypeError(\"Each odd element in the trip chain should be a leg\")\n    if not all(isinstance(i, Activity) for i in trip_chain[::2]):\n        raise TypeError(\"Each even element in the trip chain should be an activity\")\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripRound.act_names","title":"<code>act_names = get_act_names(trip_chain)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripRound.anchor_zone_end","title":"<code>anchor_zone_end = trip_chain[-1].location.area</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripRound.anchor_zone_start","title":"<code>anchor_zone_start = trip_chain[0].location.area</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripRound.od","title":"<code>od: OD</code>  <code>property</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripRound.trmode","title":"<code>trmode = trip_chain[1].mode</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripRound.choose_destination","title":"<code>choose_destination()</code>","text":"<p>Selects a destination for the discretionary activity.</p> RETURNS DESCRIPTION <code>str</code> <p>Selected destination zone name.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def choose_destination(self) -&gt; str:\n    \"\"\"Selects a destination for the discretionary activity.\n\n    Returns:\n        str: Selected destination zone name.\n    \"\"\"\n    assert isinstance(self._trip_chain[1], Leg)\n    destination_p = self._od[\"od_probs\", self.anchor_zone_start, :, self.trmode]\n    destination_p = destination_p / destination_p.sum()\n    zone = sample_weighted(destination_p)\n    area = self._od.labels.destination_zones[zone]\n\n    return area\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTripRound.update_plan","title":"<code>update_plan()</code>","text":"<p>Update the PAM activity locations of the first activity in the trip chain, and continue downstream until the entire chain is solved.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def update_plan(self):\n    \"\"\"\n    Update the PAM activity locations of the first activity in the trip chain,\n    and continue downstream until the entire chain is solved.\n    \"\"\"\n    if len(self.act_names) &gt; 2:\n        # update locations\n        area = self.choose_destination()\n        self._trip_chain[2].location.area = area\n        self._trip_chain[1].end_location.area = area\n        self._trip_chain[3].start_location.area = area\n\n        # if the remaining chain is now a round-trip:\n        if self.act_names[0] == self.act_names[-1]:\n            # continue downstream recursively\n            # with a round-trip selection\n            DiscretionaryTripRound(trip_chain=self._trip_chain[2:], od=self._od).update_plan()\n        # otherwise, if it is a trip chain with two anchors:\n        else:\n            # continue downstream recursively\n            # the newly-selected location now becomes the first anchor\n            DiscretionaryTripOD(trip_chain=self._trip_chain[2:], od=self._od).update_plan()\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrips","title":"<code>DiscretionaryTrips(plan, od)</code>","text":"<p>Solve discretionary trip location choice of a PAM plan.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>PAM plan.</p> <p> TYPE: <code>Plan</code> </p> <code>od</code> <p>An object holding origin-destination matrices.</p> <p> TYPE: <code>OD</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(self, plan: Plan, od: OD) -&gt; None:\n    \"\"\"Solve discretionary trip location choice of a PAM plan.\n\n    Args:\n        plan (Plan): PAM plan.\n        od (OD): An object holding origin-destination matrices.\n    \"\"\"\n    self._plan = plan\n    self._od = od\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.DiscretionaryTrips.update_plan","title":"<code>update_plan()</code>","text":"<p>Update the locations (in-place) of each non-mandatory activity location in the plan.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def update_plan(self):\n    \"\"\"Update the locations (in-place) of each non-mandatory activity location in the plan.\"\"\"\n    trip_chains = get_trip_chains_either_anchor(self._plan)\n    for trip_chain in trip_chains:\n        # if only one achor, convert to round-trip\n        convert_single_anchor_roundtrip(trip_chain)\n        act_names = get_act_names(trip_chain)\n        if len(act_names) &gt; 2:\n            if act_names[0] != act_names[-1]:\n                DiscretionaryTripOD(trip_chain=trip_chain, od=self._od).update_plan()\n            else:\n                DiscretionaryTripRound(trip_chain=trip_chain, od=self._od).update_plan()\n</code></pre>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.SelectionSet","title":"<code>SelectionSet</code>  <code>dataclass</code>","text":"<p>Calculate probabilities and select alternative.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.SelectionSet.choice_set","title":"<code>choice_set: ChoiceSet</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.SelectionSet.func_probabilities","title":"<code>func_probabilities: Callable</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.SelectionSet.func_sampling","title":"<code>func_sampling: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.SelectionSet.probabilities","title":"<code>probabilities: np.array</code>  <code>property</code>","text":"<p>Probabilities for each alternative.</p>"},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.SelectionSet.selections","title":"<code>selections: list[ChoiceLabel]</code>  <code>property</code>","text":""},{"location":"reference/pam/planner/choice_location/#pam.planner.choice_location.SelectionSet.sample","title":"<code>sample()</code>","text":"<p>Sample from a set of alternative options.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def sample(self) -&gt; list:\n    \"\"\"Sample from a set of alternative options.\"\"\"\n    sampled = np.apply_along_axis(func1d=self.func_sampling, axis=1, arr=self.probabilities)\n    sampled_labels = [self.choice_set.choice_labels[x] for x in sampled]\n    self._selections = sampled_labels\n    return sampled_labels\n</code></pre>"},{"location":"reference/pam/planner/clustering/","title":"pam.planner.clustering","text":""},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters","title":"<code>PlanClusters(population, n_cores=1)</code>","text":"<p>Groups activity plans into clusters. Plan similarity is defined using the edit distance     of character-encoded plan sequences.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def __init__(self, population: Population, n_cores: int = 1) -&gt; None:\n    self.population = population\n    self.plans = list(population.plans())\n    self.n_cores = n_cores\n    self._distances = None\n    self.model = None\n\n    # encodings\n    self.activity_classes = sorted(list(population.activity_classes) + [\"travel\"])\n    self.plans_encoder = PlansCharacterEncoder(activity_classes=self.activity_classes)\n</code></pre>"},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.activity_classes","title":"<code>activity_classes = sorted(list(population.activity_classes) + ['travel'])</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.distances","title":"<code>distances: np.array</code>  <code>property</code>","text":"<p>Levenshtein distances between activity plans.</p>"},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.distances_no_diagonal","title":"<code>distances_no_diagonal: np.array</code>  <code>property</code>","text":""},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.model","title":"<code>model = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.n_cores","title":"<code>n_cores = n_cores</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.plans","title":"<code>plans = list(population.plans())</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.plans_encoded","title":"<code>plans_encoded: list[str]</code>  <code>cached</code> <code>property</code>","text":""},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.plans_encoder","title":"<code>plans_encoder = PlansCharacterEncoder(activity_classes=self.activity_classes)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.population","title":"<code>population = population</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.fit","title":"<code>fit(n_clusters, clustering_method='agglomerative', linkage='complete')</code>","text":"<p>Fit an agglomerative clustering model.</p> PARAMETER  DESCRIPTION <code>n_clusters</code> <p>The number of clusters to use.</p> <p> TYPE: <code>int</code> </p> <code>clustering_method</code> <p>The clustering method to use. Defaults to \"agglomerative\".</p> <p> TYPE: <code>Literal['agglomerative', 'spectral']</code> DEFAULT: <code>'agglomerative'</code> </p> <code>linkage</code> <p>Linkage criterion. Defaults to \"complete\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'complete'</code> </p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def fit(\n    self,\n    n_clusters: int,\n    clustering_method: Literal[\"agglomerative\", \"spectral\"] = \"agglomerative\",\n    linkage: Optional[str] = \"complete\",\n) -&gt; None:\n    \"\"\"Fit an agglomerative clustering model.\n\n    Args:\n      n_clusters (int): The number of clusters to use.\n      clustering_method (Literal['agglomerative', 'spectral']): The clustering method to use. Defaults to \"agglomerative\".\n      linkage (str, optional): Linkage criterion. Defaults to \"complete\".\n\n    \"\"\"\n    if clustering_method == \"agglomerative\":\n        model = AgglomerativeClustering(\n            n_clusters=n_clusters, linkage=linkage, metric=\"precomputed\"\n        )\n        model.fit((self.distances))\n    elif clustering_method == \"spectral\":\n        model = SpectralClustering(n_clusters=n_clusters, affinity=\"precomputed\")\n        model.fit((1 - self.distances))\n    else:\n        raise ValueError(\n            \"Please select a valid clustering_method ('agglomerative' or 'spectral')\"\n        )\n\n    self.model = model\n</code></pre>"},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.get_closest_matches","title":"<code>get_closest_matches(plan, n)</code>","text":"<p>Get the n closest matches of a PAM activity schedule.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_closest_matches(self, plan, n) -&gt; list[Plan]:\n    \"\"\"Get the n closest matches of a PAM activity schedule.\"\"\"\n    idx = self.plans.index(plan)\n    idx_closest = np.argsort(self.distances_no_diagonal[idx])[:n]\n    return [self.plans[x] for x in idx_closest]\n</code></pre>"},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.get_cluster_membership","title":"<code>get_cluster_membership()</code>","text":"<p>Get the cluster membership of each person in the population. Returns a dictionary where the index values are (hid, pid) tuples,     and the values are the correponding agents' clusters.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_cluster_membership(self) -&gt; dict:\n    \"\"\"Get the cluster membership of each person in the population.\n    Returns a dictionary where the index values are (hid, pid) tuples,\n        and the values are the correponding agents' clusters.\n    \"\"\"\n    ids = [(hid, pid) for hid, pid, person in self.population.people()]\n    return dict(zip(ids, self.model.labels_))\n</code></pre>"},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.get_cluster_plans","title":"<code>get_cluster_plans(cluster)</code>","text":"<p>Get the plans that belong in a specific cluster.</p> PARAMETER  DESCRIPTION <code>cluster</code> <p>The cluster index.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_cluster_plans(self, cluster: int) -&gt; list:\n    \"\"\"Get the plans that belong in a specific cluster.\n\n    Args:\n        cluster (int): The cluster index.\n    \"\"\"\n    return list(itertools.compress(self.plans, self.model.labels_ == cluster))\n</code></pre>"},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.get_cluster_sizes","title":"<code>get_cluster_sizes()</code>","text":"<p>Get the number of plans in each cluster.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_cluster_sizes(self) -&gt; pd.Series:\n    \"\"\"Get the number of plans in each cluster.\"\"\"\n    return pd.Series(self.model.labels_).value_counts()\n</code></pre>"},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.plot_plan_breakdowns","title":"<code>plot_plan_breakdowns(ax=None, cluster=None, activity_classes=None, **kwargs)</code>","text":"<p>Area plot of the breakdown of activities taking place every minute for a specific cluster.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def plot_plan_breakdowns(\n    self, ax=None, cluster=None, activity_classes: Optional[list[str]] = None, **kwargs\n):\n    \"\"\"Area plot of the breakdown of activities taking place every minute\n    for a specific cluster.\n    \"\"\"\n    if cluster is not None:\n        plans = self.get_cluster_plans(cluster)\n    else:\n        plans = self.plans\n\n    if activity_classes is None:\n        activity_classes = self.activity_classes\n\n    return plot_activity_breakdown_area(\n        plans=plans, activity_classes=self.activity_classes, ax=ax, **kwargs\n    )\n</code></pre>"},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.PlanClusters.plot_plan_breakdowns_tiles","title":"<code>plot_plan_breakdowns_tiles(n=None, **kwargs)</code>","text":"<p>Tiled area plot of the breakdown of activities taking place every minute, for the clusters with the top n number of plans.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def plot_plan_breakdowns_tiles(self, n: Optional[int] = None, **kwargs):\n    \"\"\"Tiled area plot of the breakdown of activities taking place every minute,\n    for the clusters with the top n number of plans.\n    \"\"\"\n    if n is None:\n        n = len(set(self.model.labels_))\n\n    clusters = self.get_cluster_sizes().head(n).index\n    plans = {cluster: self.get_cluster_plans(cluster) for cluster in clusters}\n\n    return plot_activity_breakdown_area_tiles(\n        plans=plans, activity_classes=self.activity_classes, **kwargs\n    )\n</code></pre>"},{"location":"reference/pam/planner/clustering/#pam.planner.clustering.calc_levenshtein_matrix","title":"<code>calc_levenshtein_matrix(x, y, n_cores=1)</code>","text":"<p>Create a levenshtein distance matrix from two lists of strings.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def calc_levenshtein_matrix(x: list[str], y: list[str], n_cores=1) -&gt; np.array:\n    \"\"\"Create a levenshtein distance matrix from two lists of strings.\"\"\"\n    levenshtein_distance = np.vectorize(_levenshtein_distance)\n    if n_cores == 1:\n        distances = levenshtein_distance(np.array(x).reshape(-1, 1), np.array(y))\n    else:\n        xs = np.array_split(x, n_cores)\n        xs = [x.reshape(-1, 1) for x in xs]\n        calc_levenshtein_matrix_partial = partial(levenshtein_distance, b=y)\n        with Pool(n_cores) as p:\n            distances = np.concatenate(p.map(calc_levenshtein_matrix_partial, xs))\n\n    return distances\n</code></pre>"},{"location":"reference/pam/planner/encoder/","title":"pam.planner.encoder","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.Encoder","title":"<code>Encoder(labels, travel_act='travel')</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, labels: List[str], travel_act=\"travel\") -&gt; None:\n    self.labels = set(labels)\n    if travel_act not in self.labels:\n        self.labels.add(travel_act)\n    self.label_code = self.get_mapping(self.labels)\n    self.code_label = {v: k for k, v in self.label_code.items()}\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.Encoder.code_label","title":"<code>code_label = {v: kfor (k, v) in self.label_code.items()}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.Encoder.label_code","title":"<code>label_code = self.get_mapping(self.labels)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.Encoder.labels","title":"<code>labels = set(labels)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.Encoder.decode","title":"<code>decode(code)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, code: Union[int, str]) -&gt; str:\n    return self.code_label[code]\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.Encoder.encode","title":"<code>encode(label)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, label: str) -&gt; Union[int, str]:\n    return self.label_code[label]\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.Encoder.get_mapping","title":"<code>get_mapping(labels)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_mapping(labels: List[str]):\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder","title":"<code>PlanCharacterEncoder(activity_encoder=None, labels=None)</code>","text":"<p>             Bases: <code>PlanEncoder</code></p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(\n    self,\n    activity_encoder: Optional[StringCharacterEncoder] = None,\n    labels: Optional[List[str]] = None,\n) -&gt; None:\n    if activity_encoder is not None:\n        self.activity_encoder = activity_encoder\n    elif labels is not None:\n        self.activity_encoder = self.activity_encoder_class(labels)\n    else:\n        raise ValueError(\"Please provide appropriate activity labels or encodings\")\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.activity_encoder","title":"<code>activity_encoder = activity_encoder</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.activity_encoder_class","title":"<code>activity_encoder_class = StringCharacterEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.add_plan_component","title":"<code>add_plan_component(plan, seq, act, start_time, duration)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef add_plan_component(plan: Plan, seq, act, start_time, duration) -&gt; None:\n    if act == \"travel\":\n        plan.add(activity.Leg(seq=seq, start_time=start_time, end_time=start_time + duration))\n    else:\n        plan.add(\n            activity.Activity(\n                seq=seq, act=act, start_time=start_time, end_time=start_time + duration\n            )\n        )\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.decode","title":"<code>decode(encoded_plan)</code>","text":"<p>Decode a sequence to a new PAM plan.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, encoded_plan: np.array) -&gt; Plan:\n    \"\"\"Decode a sequence to a new PAM plan.\"\"\"\n    start_time = START_OF_DAY\n    plan = activity.Plan()\n    # for every activity/leg:\n    for seq, (k, g) in enumerate(groupby(self.get_seq(encoded_plan))):\n        duration = td(minutes=len(list(g)))\n        act = self.activity_encoder.decode(k)\n        # add to the plan and advance start time\n        self.add_plan_component(\n            plan=plan, seq=seq, act=act, start_time=start_time, duration=duration\n        )\n        start_time += duration\n\n    return plan\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.encode","title":"<code>encode(plan)</code>","text":"<p>Convert a pam plan to a character sequence.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plan: Plan) -&gt; np.array:\n    \"\"\"Convert a pam plan to a character sequence.\"\"\"\n    encoded = \"\"\n    for act in plan.day:\n        duration = int(act.duration / td(minutes=1))\n        encoded = encoded + (self.activity_encoder.encode(act.act) * duration)\n\n    return encoded\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.get_seq","title":"<code>get_seq(x)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_seq(x):\n    return x\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanEncoder","title":"<code>PlanEncoder(activity_encoder=None, labels=None)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(\n    self,\n    activity_encoder: Optional[StringCharacterEncoder] = None,\n    labels: Optional[List[str]] = None,\n) -&gt; None:\n    if activity_encoder is not None:\n        self.activity_encoder = activity_encoder\n    elif labels is not None:\n        self.activity_encoder = self.activity_encoder_class(labels)\n    else:\n        raise ValueError(\"Please provide appropriate activity labels or encodings\")\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanEncoder.activity_encoder","title":"<code>activity_encoder = activity_encoder</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanEncoder.activity_encoder_class","title":"<code>activity_encoder_class = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanEncoder.add_plan_component","title":"<code>add_plan_component(plan, seq, act, start_time, duration)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef add_plan_component(plan: Plan, seq, act, start_time, duration) -&gt; None:\n    if act == \"travel\":\n        plan.add(activity.Leg(seq=seq, start_time=start_time, end_time=start_time + duration))\n    else:\n        plan.add(\n            activity.Activity(\n                seq=seq, act=act, start_time=start_time, end_time=start_time + duration\n            )\n        )\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanEncoder.decode","title":"<code>decode(encoded_plan)</code>","text":"<p>Decode a sequence to a new PAM plan.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, encoded_plan: np.array) -&gt; Plan:\n    \"\"\"Decode a sequence to a new PAM plan.\"\"\"\n    start_time = START_OF_DAY\n    plan = activity.Plan()\n    # for every activity/leg:\n    for seq, (k, g) in enumerate(groupby(self.get_seq(encoded_plan))):\n        duration = td(minutes=len(list(g)))\n        act = self.activity_encoder.decode(k)\n        # add to the plan and advance start time\n        self.add_plan_component(\n            plan=plan, seq=seq, act=act, start_time=start_time, duration=duration\n        )\n        start_time += duration\n\n    return plan\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanEncoder.encode","title":"<code>encode()</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self):\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanEncoder.get_seq","title":"<code>get_seq(x)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_seq(x):\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder","title":"<code>PlanOneHotEncoder(activity_encoder=None, labels=None)</code>","text":"<p>             Bases: <code>PlanEncoder</code></p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(\n    self,\n    activity_encoder: Optional[StringCharacterEncoder] = None,\n    labels: Optional[List[str]] = None,\n) -&gt; None:\n    if activity_encoder is not None:\n        self.activity_encoder = activity_encoder\n    elif labels is not None:\n        self.activity_encoder = self.activity_encoder_class(labels)\n    else:\n        raise ValueError(\"Please provide appropriate activity labels or encodings\")\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.activity_encoder","title":"<code>activity_encoder = activity_encoder</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.activity_encoder_class","title":"<code>activity_encoder_class = StringIntEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.add_plan_component","title":"<code>add_plan_component(plan, seq, act, start_time, duration)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef add_plan_component(plan: Plan, seq, act, start_time, duration) -&gt; None:\n    if act == \"travel\":\n        plan.add(activity.Leg(seq=seq, start_time=start_time, end_time=start_time + duration))\n    else:\n        plan.add(\n            activity.Activity(\n                seq=seq, act=act, start_time=start_time, end_time=start_time + duration\n            )\n        )\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.decode","title":"<code>decode(encoded_plan)</code>","text":"<p>Decode a sequence to a new PAM plan.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, encoded_plan: np.array) -&gt; Plan:\n    \"\"\"Decode a sequence to a new PAM plan.\"\"\"\n    start_time = START_OF_DAY\n    plan = activity.Plan()\n    # for every activity/leg:\n    for seq, (k, g) in enumerate(groupby(self.get_seq(encoded_plan))):\n        duration = td(minutes=len(list(g)))\n        act = self.activity_encoder.decode(k)\n        # add to the plan and advance start time\n        self.add_plan_component(\n            plan=plan, seq=seq, act=act, start_time=start_time, duration=duration\n        )\n        start_time += duration\n\n    return plan\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.encode","title":"<code>encode(plan)</code>","text":"<p>Encode a PAM plan into a 2D numpy boolean array, where the row indicates the activity and the column indicates the minute of the day.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plan: Plan) -&gt; np.array:\n    \"\"\"Encode a PAM plan into a 2D numpy boolean array,\n    where the row indicates the activity\n    and the column indicates the minute of the day.\n    \"\"\"\n    duration = int((plan.day[-1].end_time - START_OF_DAY) / td(minutes=1))\n    encoded = np.zeros(shape=(len(self.activity_encoder.labels), duration), dtype=bool)\n    for act in plan.day:\n        start_minute = int((act.start_time - START_OF_DAY) / td(minutes=1))\n        end_minute = int((act.end_time - START_OF_DAY) / td(minutes=1))\n        idx = self.activity_encoder.encode(act.act)\n        encoded[idx, start_minute:end_minute] = True\n\n    return encoded\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.get_seq","title":"<code>get_seq(x)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_seq(x):\n    return x.argmax(axis=0)\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansCharacterEncoder","title":"<code>PlansCharacterEncoder(activity_classes)</code>","text":"<p>             Bases: <code>PlansEncoder</code></p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, activity_classes: set) -&gt; None:\n    self.plan_encoder = self.plans_encoder_class(labels=activity_classes)\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansCharacterEncoder.dtype","title":"<code>dtype = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansCharacterEncoder.plan_encoder","title":"<code>plan_encoder = self.plans_encoder_class(labels=activity_classes)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansCharacterEncoder.plans_encoder_class","title":"<code>plans_encoder_class = PlanCharacterEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansCharacterEncoder.encode","title":"<code>encode(plans)</code>","text":"<p>Encode all plans to a stacked numpy array.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plans: List[Plan]) -&gt; np.ndarray:\n    \"\"\"Encode all plans to a stacked numpy array.\"\"\"\n    plans_encoded = np.stack([self.plan_encoder.encode(x) for x in plans])\n    return plans_encoded\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansEncoder","title":"<code>PlansEncoder(activity_classes)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, activity_classes: set) -&gt; None:\n    self.plan_encoder = self.plans_encoder_class(labels=activity_classes)\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansEncoder.dtype","title":"<code>dtype = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansEncoder.plan_encoder","title":"<code>plan_encoder = self.plans_encoder_class(labels=activity_classes)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansEncoder.plans_encoder_class","title":"<code>plans_encoder_class = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansEncoder.encode","title":"<code>encode(plans)</code>","text":"<p>Encode all plans to a stacked numpy array.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plans: List[Plan]) -&gt; np.ndarray:\n    \"\"\"Encode all plans to a stacked numpy array.\"\"\"\n    plans_encoded = np.stack([self.plan_encoder.encode(x) for x in plans])\n    return plans_encoded\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansOneHotEncoder","title":"<code>PlansOneHotEncoder(activity_classes)</code>","text":"<p>             Bases: <code>PlansEncoder</code></p> <p>Encode plans to a 3D numpy array, where the first axis indicates the person, the second indicates the activity, and the third indicates the minute of the day.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, activity_classes: set) -&gt; None:\n    self.plan_encoder = self.plans_encoder_class(labels=activity_classes)\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansOneHotEncoder.dtype","title":"<code>dtype = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansOneHotEncoder.plan_encoder","title":"<code>plan_encoder = self.plans_encoder_class(labels=activity_classes)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansOneHotEncoder.plans_encoder_class","title":"<code>plans_encoder_class = PlanOneHotEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.PlansOneHotEncoder.encode","title":"<code>encode(plans)</code>","text":"<p>Encode all plans to a stacked numpy array.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plans: List[Plan]) -&gt; np.ndarray:\n    \"\"\"Encode all plans to a stacked numpy array.\"\"\"\n    plans_encoded = np.stack([self.plan_encoder.encode(x) for x in plans])\n    return plans_encoded\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringCharacterEncoder","title":"<code>StringCharacterEncoder(labels, travel_act='travel')</code>","text":"<p>             Bases: <code>Encoder</code></p> <p>Encodes strings as single characters.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, labels: List[str], travel_act=\"travel\") -&gt; None:\n    self.labels = set(labels)\n    if travel_act not in self.labels:\n        self.labels.add(travel_act)\n    self.label_code = self.get_mapping(self.labels)\n    self.code_label = {v: k for k, v in self.label_code.items()}\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringCharacterEncoder.code_label","title":"<code>code_label = {v: kfor (k, v) in self.label_code.items()}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringCharacterEncoder.label_code","title":"<code>label_code = self.get_mapping(self.labels)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringCharacterEncoder.labels","title":"<code>labels = set(labels)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringCharacterEncoder.decode","title":"<code>decode(code)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, code: Union[int, str]) -&gt; str:\n    return self.code_label[code]\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringCharacterEncoder.encode","title":"<code>encode(label)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, label: str) -&gt; Union[int, str]:\n    return self.label_code[label]\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringCharacterEncoder.get_mapping","title":"<code>get_mapping(labels)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_mapping(labels: List[str]) -&gt; dict:\n    encoded = {}\n    for i, act in enumerate(labels):\n        encoded[act] = chr(i + 65)\n    return encoded\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringIntEncoder","title":"<code>StringIntEncoder(labels, travel_act='travel')</code>","text":"<p>             Bases: <code>Encoder</code></p> <p>Encodes strings as integers.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, labels: List[str], travel_act=\"travel\") -&gt; None:\n    self.labels = set(labels)\n    if travel_act not in self.labels:\n        self.labels.add(travel_act)\n    self.label_code = self.get_mapping(self.labels)\n    self.code_label = {v: k for k, v in self.label_code.items()}\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringIntEncoder.code_label","title":"<code>code_label = {v: kfor (k, v) in self.label_code.items()}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringIntEncoder.label_code","title":"<code>label_code = self.get_mapping(self.labels)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringIntEncoder.labels","title":"<code>labels = set(labels)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringIntEncoder.decode","title":"<code>decode(code)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, code: Union[int, str]) -&gt; str:\n    return self.code_label[code]\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringIntEncoder.encode","title":"<code>encode(label)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, label: str) -&gt; Union[int, str]:\n    return self.label_code[label]\n</code></pre>"},{"location":"reference/pam/planner/encoder/#pam.planner.encoder.StringIntEncoder.get_mapping","title":"<code>get_mapping(labels)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_mapping(labels: List[str]) -&gt; dict:\n    encoded = {label: i for i, label in enumerate(labels)}\n    return encoded\n</code></pre>"},{"location":"reference/pam/planner/ipf/","title":"pam.planner.ipf","text":""},{"location":"reference/pam/planner/ipf/#pam.planner.ipf.generate_joint_distributions","title":"<code>generate_joint_distributions(zone_data, tolerance=0.001, max_iterations=10 ** 3)</code>","text":"<p>Generate joint demographic distributions that match zone marginals.</p> PARAMETER  DESCRIPTION <code>zone_data</code> <p>Zone data, with the zone label as the dataframe index. The dataframe columns should follow this convention: <code>variable|class</code>, for example: <code>age|minor, age|adult, income|low, income|high, ....</code></p> <p> TYPE: <code>DataFrame</code> </p> <code>tolerance</code> <p>Max accepted percentage difference to the targets. Defaults to 0.001.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>0.001</code> </p> <code>max_iterations</code> <p>Max number of iterations. Defaults to 10**3.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>10 ** 3</code> </p> RETURNS DESCRIPTION <code>tuple[dict, dict[str, ndarray]]</code> <p>tuple[dict, dict[np.ndarray]]: Encodings and a matrix of the joint distributions.</p> Source code in <code>pam/planner/ipf.py</code> <pre><code>def generate_joint_distributions(\n    zone_data: pd.DataFrame,\n    tolerance: Optional[float] = 0.001,\n    max_iterations: Optional[int] = 10**3,\n) -&gt; tuple[dict, dict[str, np.ndarray]]:\n    \"\"\"Generate joint demographic distributions that match zone marginals.\n\n    Args:\n        zone_data (pd.DataFrame): Zone data, with the zone label as the dataframe index.\n            The dataframe columns should follow this convention: `variable|class`,\n            for example: `age|minor, age|adult, income|low, income|high, ....`\n        tolerance (Optional[float], optional): Max accepted percentage difference to the targets. Defaults to 0.001.\n        max_iterations (Optional[int], optional): Max number of iterations. Defaults to 10**3.\n\n    Returns:\n        tuple[dict, dict[np.ndarray]]: Encodings and a matrix of the joint distributions.\n    \"\"\"\n    encodings, marginals = prepare_zone_marginals(zone_data)\n    dist = {}\n    for zone, zone_marginals in marginals.items():\n        # start with a small value in each cell\n        X = np.zeros(tuple(map(len, zone_marginals))) + 0.001\n        # apply iterative proportinal fitting\n        fitted = ipf(X, zone_marginals, tolerance=tolerance, max_iterations=max_iterations)\n        fitted = fitted.round(0).astype(int)\n        dist[zone] = fitted\n\n    return encodings, dist\n</code></pre>"},{"location":"reference/pam/planner/ipf/#pam.planner.ipf.generate_population","title":"<code>generate_population(population, zone_data, tolerance=0.001, max_iterations=10 ** 3)</code>","text":"<p>Resample a population and assign its person to zones,     so that the distributions in the <code>zone_data</code> dataset are met.</p> PARAMETER  DESCRIPTION <code>population</code> <p>A PAM population. Its person attributes should include the controls in the zone data</p> <p> TYPE: <code>Population</code> </p> <code>zone_data</code> <p>Zone data, with the zone label as the dataframe index. The dataframe columns should follow this convention: <code>variable|class</code>, for example: <code>age|minor, age|adult, income|low, income|high, ....</code></p> <p> TYPE: <code>DataFrame</code> </p> <code>tolerance</code> <p>Max accepted percentage difference to the targets. Defaults to 0.001.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>0.001</code> </p> <code>max_iterations</code> <p>Max number of iterations. Defaults to 10**3.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>10 ** 3</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>A new population that matches marginals in each zone. The household location of each agent is defined under person.attributes['hzone']</p> <p> TYPE: <code>Population</code> </p> Source code in <code>pam/planner/ipf.py</code> <pre><code>def generate_population(\n    population: Population,\n    zone_data: pd.DataFrame,\n    tolerance: Optional[float] = 0.001,\n    max_iterations: Optional[int] = 10**3,\n) -&gt; Population:\n    \"\"\"Resample a population and assign its person to zones,\n        so that the distributions in the `zone_data` dataset are met.\n\n    Args:\n        population (Population): A PAM population.\n            Its person attributes should include the controls in the zone data\n        zone_data (pd.DataFrame): Zone data, with the zone label as the dataframe index.\n            The dataframe columns should follow this convention: `variable|class`,\n            for example: `age|minor, age|adult, income|low, income|high, ....`\n        tolerance (Optional[float], optional): Max accepted percentage difference to the targets. Defaults to 0.001.\n        max_iterations (Optional[int], optional): Max number of iterations. Defaults to 10**3.\n\n    Returns:\n        Population: A new population that matches marginals in each zone.\n            The household location of each agent is defined under person.attributes['hzone']\n    \"\"\"\n    encodings, dist = generate_joint_distributions(\n        zone_data, tolerance=tolerance, max_iterations=max_iterations\n    )\n    sample_pool = get_sample_pool(population, encodings)\n    pop_fitted = sample_population(encodings, dist, sample_pool)\n\n    return pop_fitted\n</code></pre>"},{"location":"reference/pam/planner/ipf/#pam.planner.ipf.get_max_error","title":"<code>get_max_error(X, marginals)</code>","text":"<p>Get the maximum absolute percentage between a matrix and a set of marginals.</p> PARAMETER  DESCRIPTION <code>X</code> <p>Input matrix</p> <p> TYPE: <code>array</code> </p> <code>marginals</code> <p>a list of marginals</p> <p> TYPE: <code>list[array]</code> </p> RETURNS DESCRIPTION <code>float</code> <p>the maximum error value</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/planner/ipf.py</code> <pre><code>def get_max_error(X: np.ndarray, marginals: list[np.array]) -&gt; float:\n    \"\"\"Get the maximum absolute percentage between a matrix and a set of marginals.\n\n    Args:\n        X (np.array): Input matrix\n        marginals (list[np.array]): a list of marginals\n\n    Returns:\n        float: the maximum error value\n    \"\"\"\n    max_error = 0\n    for dim in range(X.ndim):\n        scaling_factor = get_scaling_factor(X, dim, marginals[dim])\n        max_error = max(max_error, abs(scaling_factor - 1).max())\n\n    return max_error\n</code></pre>"},{"location":"reference/pam/planner/ipf/#pam.planner.ipf.get_sample_pool","title":"<code>get_sample_pool(population, encodings)</code>","text":"<p>Prepares the sample pool for each demographic category.</p> PARAMETER  DESCRIPTION <code>population</code> <p>The input PAM population object.</p> <p> TYPE: <code>Population</code> </p> <code>encodings</code> <p>Variable encodings generated with <code>prepare_zone_marginals</code>.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict[tuple, list[Person]]</code> <p>dict[tuple, list[Person]]: The sample pool. Its index comprises the distribution matrix coordinates (index) for each demographic category. Its values consist of the PAM persons belonging in each category.</p> Source code in <code>pam/planner/ipf.py</code> <pre><code>def get_sample_pool(population: Population, encodings: dict) -&gt; dict[tuple, list[Person]]:\n    \"\"\"Prepares the sample pool for each demographic category.\n\n    Args:\n        population (Population): The input PAM population object.\n        encodings (dict): Variable encodings generated with `prepare_zone_marginals`.\n\n    Returns:\n        dict[tuple, list[Person]]: The sample pool.\n            Its index comprises the distribution matrix coordinates (index) for each demographic category.\n            Its values consist of the PAM persons belonging in each category.\n    \"\"\"\n    person_pool = defaultdict(list)\n    for hid, pid, person in population.people():\n        code = tuple([v.index(person.attributes[k]) for k, v in encodings.items()])\n        person_pool[code].append(person)\n\n    return person_pool\n</code></pre>"},{"location":"reference/pam/planner/ipf/#pam.planner.ipf.get_scaling_factor","title":"<code>get_scaling_factor(X, sel_dim, marginals)</code>","text":"<p>Get the scaling factors required to match a set of marginals for a selected matrix dimension.     The returned matrix will have the same dimensions as the input matrix</p> PARAMETER  DESCRIPTION <code>X</code> <p>The matrix to be scaled.</p> <p> TYPE: <code>ndarray</code> </p> <code>sel_dim</code> <p>The matrix dimension that corresponds to the marginals.</p> <p> TYPE: <code>int</code> </p> <code>marginals</code> <p>The target values for the selected dimension.</p> <p> TYPE: <code>array</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: A matrix that can be multiplied by the input matrix in order to get a new matrix that matches the maginals for the selected dimension.</p> Source code in <code>pam/planner/ipf.py</code> <pre><code>def get_scaling_factor(X: np.ndarray, sel_dim: int, marginals: np.array) -&gt; np.ndarray:\n    \"\"\"Get the scaling factors required to match a set of marginals for a selected matrix dimension.\n        The returned matrix will have the same dimensions as the input matrix\n\n    Args:\n        X (np.ndarray): The matrix to be scaled.\n        sel_dim (int): The matrix dimension that corresponds to the marginals.\n        marginals (np.array): The target values for the selected dimension.\n\n    Returns:\n        np.ndarray: A matrix that can be multiplied by the input matrix\n            in order to get a new matrix that matches the maginals for the selected dimension.\n    \"\"\"\n    other_dims = tuple(i for i in range(X.ndim) if i != sel_dim)\n    totals = X.sum(axis=other_dims)\n    if ((totals == 0) &amp; (totals != marginals)).sum():\n        warnings.warn(\"Zero-cell issue found! Please check the seed matrix totals.\", UserWarning)\n    scaling_factor = safe_divide(marginals, totals)\n    scaling_factor = np.expand_dims(scaling_factor, other_dims)\n\n    return scaling_factor\n</code></pre>"},{"location":"reference/pam/planner/ipf/#pam.planner.ipf.ipf","title":"<code>ipf(X, marginals, tolerance=0.001, max_iterations=10 ** 3)</code>","text":"<p>Apply Iterative Proportional Fitting on a multi-dimensional matrix.</p> PARAMETER  DESCRIPTION <code>X</code> <p>Initial matrix.</p> <p> TYPE: <code>array</code> </p> <code>marginals</code> <p>Total to match, one for each matrix dimension.</p> <p> TYPE: <code>list[array]</code> </p> <code>tolerance</code> <p>Max accepted percentage difference to the targets. Defaults to 0.001.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>0.001</code> </p> <code>max_iterations</code> <p>Max number of iterations. Defaults to 10**3.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>10 ** 3</code> </p> RETURNS DESCRIPTION <code>array</code> <p>np.array: A fitted matrix that matches the marginals for each dimension.</p> Source code in <code>pam/planner/ipf.py</code> <pre><code>def ipf(\n    X: np.array,\n    marginals: list[np.array],\n    tolerance: Optional[float] = 0.001,\n    max_iterations: Optional[int] = 10**3,\n) -&gt; np.array:\n    \"\"\"Apply Iterative Proportional Fitting on a multi-dimensional matrix.\n\n    Args:\n        X (np.array): Initial matrix.\n        marginals (list[np.array]): Total to match, one for each matrix dimension.\n        tolerance (Optional[float], optional): Max accepted percentage difference to the targets. Defaults to 0.001.\n        max_iterations (Optional[int], optional): Max number of iterations. Defaults to 10**3.\n\n    Returns:\n        np.array: A fitted matrix that matches the marginals for each dimension.\n    \"\"\"\n    X_fitted = X.copy()\n    iters = 0\n    max_error = get_max_error(X, marginals)\n    while (max_error &gt; tolerance) and (iters &lt; max_iterations):\n        for sel_dim in range(X_fitted.ndim):\n            scaling_factor = get_scaling_factor(X_fitted, sel_dim, marginals[sel_dim])\n            X_fitted *= scaling_factor\n        iters += 1\n\n    return X_fitted\n</code></pre>"},{"location":"reference/pam/planner/ipf/#pam.planner.ipf.prepare_zone_marginals","title":"<code>prepare_zone_marginals(zone_data)</code>","text":"<p>Prepare zone marginals in the required format.</p> PARAMETER  DESCRIPTION <code>zone_data</code> <p>Zone data, with the zone label as the dataframe index. The dataframe columns should follow this convention: <code>variable|class</code>, for example: <code>age|minor, age|adult, income|low, income|high, ....</code>/ Alternatively, the user can provide a multi-index column format, where the first level represents the variable, and the second the class.</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>tuple[dict, dict[str, list[array]]]</code> <p>tuple[dict, dict[list[np.array]]]: Zone encodings and marginals.</p> Source code in <code>pam/planner/ipf.py</code> <pre><code>def prepare_zone_marginals(zone_data: pd.DataFrame) -&gt; tuple[dict, dict[str, list[np.array]]]:\n    \"\"\"Prepare zone marginals in the required format.\n\n    Args:\n        zone_data (pd.DataFrame): Zone data, with the zone label as the dataframe index.\n            The dataframe columns should follow this convention: `variable|class`,\n            for example: `age|minor, age|adult, income|low, income|high, ....`/\n            Alternatively, the user can provide a multi-index column format,\n            where the first level represents the variable, and the second the class.\n\n    Returns:\n        tuple[dict, dict[list[np.array]]]: Zone encodings and marginals.\n    \"\"\"\n    df_marginals = zone_data.copy()\n    if df_marginals.columns.nlevels != 2:\n        df_marginals.columns = pd.MultiIndex.from_tuples(\n            [tuple(x.split(\"|\")) for x in df_marginals.columns]\n        )\n\n    encodings = defaultdict(list)\n    for x, y in df_marginals.columns:\n        encodings[x].append(y)\n\n    marginals = {}\n    for i, irow in df_marginals.iterrows():\n        marginals[i] = irow.groupby(level=0).apply(np.array).loc[list(encodings.keys())].tolist()\n\n    return encodings, marginals\n</code></pre>"},{"location":"reference/pam/planner/ipf/#pam.planner.ipf.sample_population","title":"<code>sample_population(encodings, dist, sample_pool)</code>","text":"<p>Sample a population.</p> PARAMETER  DESCRIPTION <code>encodings</code> <p>Variable encodings generated with <code>prepare_zone_marginals</code>.</p> <p> TYPE: <code>str</code> </p> <code>dist</code> <p>Joint distribution matrix.</p> <p> TYPE: <code>dict[str, ndarray]</code> </p> <code>sample_pool</code> <p>The person sample pool generated wtih <code>get_sample_pool</code>.</p> <p> TYPE: <code>dict[tuple, list[Person]]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Zero-cell issue (trying to sample from a category with no seed samples)</p> RETURNS DESCRIPTION <code>Population</code> <p>A resampled PAM population.</p> <p> TYPE: <code>Population</code> </p> Source code in <code>pam/planner/ipf.py</code> <pre><code>def sample_population(\n    encodings: dict, dist: dict[str, np.ndarray], sample_pool: dict[tuple, list[Person]]\n) -&gt; Population:\n    \"\"\"Sample a population.\n\n    Args:\n        encodings (str): Variable encodings generated with `prepare_zone_marginals`.\n        dist (dict[str, np.ndarray]): Joint distribution matrix.\n        sample_pool (dict[tuple, list[Person]]): The person sample pool generated wtih `get_sample_pool`.\n\n    Raises:\n        ValueError: Zero-cell issue (trying to sample from a category with no seed samples)\n\n    Returns:\n        Population: A resampled PAM population.\n    \"\"\"\n    pop_fitted = Population()\n    n = 0\n    for zone, zone_dist in dist.items():\n        for code, sample_size in np.ndenumerate(zone_dist):\n            if sample_size:\n                if code not in sample_pool:\n                    # zero cell issue: raise an error\n                    k = list(encodings.keys())\n                    missing_cat = [([k[i], encodings[k[i]][j]]) for i, j in enumerate(code)]\n                    raise ValueError(f\"Missing category in seed population: {missing_cat}\")\n                else:\n                    # sample persons from the appropriate demographic group\n                    persons = random.choices(sample_pool[code], k=sample_size)\n                    # add to the population\n                    for person in persons:\n                        person_new = deepcopy(person)\n                        person_new.pid = f\"{person_new.pid}-{n}\"\n                        person_new.attributes[\"hzone\"] = zone\n                        pop_fitted.add(person_new)\n                        n += 1\n\n    return pop_fitted\n</code></pre>"},{"location":"reference/pam/planner/od/","title":"pam.planner.od","text":"<p>Manages origin-destination data required by the planner module.</p>"},{"location":"reference/pam/planner/od/#pam.planner.od.Labels","title":"<code>Labels</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Data labels for the origin-destination dataset.</p>"},{"location":"reference/pam/planner/od/#pam.planner.od.Labels.destination_zones","title":"<code>destination_zones: list</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.Labels.mode","title":"<code>mode: list</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.Labels.origin_zones","title":"<code>origin_zones: list</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.Labels.vars","title":"<code>vars: list</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.OD","title":"<code>OD(data, labels)</code>","text":"<p>Holds origin-destination matrices for a number of modes and variables.</p> PARAMETER  DESCRIPTION <code>data</code> <p>A multi-dimensional numpy array of the origin-destination data. - First dimension: variable (ie travel time, distance, etc) - Second dimension: origin zone - Third dimension: destination zone - Fourth dimension: mode (ie car, bus, etc)</p> <p> TYPE: <code>ndarray</code> </p> <code>labels</code> <p> TYPE: <code>Union[Labels, list, dict]</code> </p> Source code in <code>pam/planner/od.py</code> <pre><code>def __init__(self, data: np.ndarray, labels: Union[Labels, list, dict]) -&gt; None:\n    \"\"\"\n    Args:\n        data (np.ndarray):\n            A multi-dimensional numpy array of the origin-destination data.\n            - First dimension: variable (ie travel time, distance, etc)\n            - Second dimension: origin zone\n            - Third dimension: destination zone\n            - Fourth dimension: mode (ie car, bus, etc)\n        labels (Union[Labels, list, dict]):\n    \"\"\"\n    self.data = data\n    self.labels = self.parse_labels(labels)\n    self.data_checks()\n</code></pre>"},{"location":"reference/pam/planner/od/#pam.planner.od.OD.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.OD.labels","title":"<code>labels = self.parse_labels(labels)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.OD.data_checks","title":"<code>data_checks()</code>","text":"<p>Check the integrity of input data and labels.</p> Source code in <code>pam/planner/od.py</code> <pre><code>def data_checks(self):\n    \"\"\"Check the integrity of input data and labels.\"\"\"\n    assert (\n        self.data.ndim == 4\n    ), \"The number of matrix dimensions should be 4 (mode, variable, origin, destination)\"\n    for i, (key, labels) in enumerate(zip(self.labels._fields, self.labels)):\n        assert len(labels) == self.data.shape[i], (\n            f\"The number of {key} labels should match the number of elements\"\n            f\"in dimension {i} of the OD dataset\"\n        )\n</code></pre>"},{"location":"reference/pam/planner/od/#pam.planner.od.OD.parse_labels","title":"<code>parse_labels(labels)</code>  <code>staticmethod</code>","text":"<p>Parse labels as a named tuple.</p> Source code in <code>pam/planner/od.py</code> <pre><code>@staticmethod\ndef parse_labels(labels: Union[Labels, list, dict]) -&gt; Labels:\n    \"\"\"Parse labels as a named tuple.\"\"\"\n    if not isinstance(labels, Labels):\n        if isinstance(labels, list):\n            return Labels(*labels)\n        elif isinstance(labels, dict):\n            return Labels(**labels)\n        else:\n            raise ValueError(\"Please provide a valid label type\")\n    return labels\n</code></pre>"},{"location":"reference/pam/planner/od/#pam.planner.od.ODFactory","title":"<code>ODFactory</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.ODFactory.check","title":"<code>check(matrices, labels)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/od.py</code> <pre><code>@staticmethod\ndef check(matrices: list[ODMatrix], labels: Labels) -&gt; None:\n    # all matrices follow the same zoning system and are equal size\n    for mat in matrices:\n        assert mat.origin_zones == labels.origin_zones, \"Please check zone labels\"\n        assert mat.destination_zones == labels.destination_zones, \"Please check zone labels\"\n        assert mat.matrix.shape == matrices[0].matrix.shape, \"Please check matrix dimensions\"\n\n    # all possible combinations are provided\n    combinations_matrices = [(var, trmode) for (var, trmode, *others) in matrices]\n    combinations_labels = list(itertools.product(labels.vars, labels.mode))\n    for combination in combinations_labels:\n        assert (\n            combination in combinations_matrices\n        ), f\"Combination {combination} missing from the input matrices\"\n\n    # no duplicate combinations\n    assert len(combinations_matrices) == len(\n        set(combinations_matrices)\n    ), \"No duplicate keys are allowed\"\n</code></pre>"},{"location":"reference/pam/planner/od/#pam.planner.od.ODFactory.from_matrices","title":"<code>from_matrices(matrices)</code>  <code>classmethod</code>","text":"<p>Creates an OD instance from a list of ODMatrices.</p> Source code in <code>pam/planner/od.py</code> <pre><code>@classmethod\ndef from_matrices(cls, matrices: list[ODMatrix]) -&gt; OD:\n    \"\"\"Creates an OD instance from a list of ODMatrices.\"\"\"\n    # collect dimensions\n    labels = cls.prepare_labels(matrices)\n\n    cls.check(matrices, labels)\n\n    # create ndarray\n    od = np.zeros(shape=[len(x) for x in labels])\n    for mat in matrices:\n        od[labels.vars.index(mat.var), :, :, labels.mode.index(mat.mode)] = mat.matrix\n\n    return OD(data=od, labels=labels)\n</code></pre>"},{"location":"reference/pam/planner/od/#pam.planner.od.ODFactory.prepare_labels","title":"<code>prepare_labels(matrices)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/od.py</code> <pre><code>@staticmethod\ndef prepare_labels(matrices: list[ODMatrix]) -&gt; Labels:\n    labels = Labels(\n        vars=list(dict.fromkeys(mat.var for mat in matrices)),\n        origin_zones=matrices[0].origin_zones,\n        destination_zones=matrices[0].destination_zones,\n        mode=list(dict.fromkeys(mat.mode for mat in matrices)),\n    )\n    return labels\n</code></pre>"},{"location":"reference/pam/planner/od/#pam.planner.od.ODMatrix","title":"<code>ODMatrix</code>","text":"<p>             Bases: <code>NamedTuple</code></p>"},{"location":"reference/pam/planner/od/#pam.planner.od.ODMatrix.destination_zones","title":"<code>destination_zones: tuple</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.ODMatrix.matrix","title":"<code>matrix: np.array</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.ODMatrix.mode","title":"<code>mode: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.ODMatrix.origin_zones","title":"<code>origin_zones: tuple</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/od/#pam.planner.od.ODMatrix.var","title":"<code>var: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/planner/utils_planner/","title":"pam.planner.utils_planner","text":""},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.apply_mode_to_home_chain","title":"<code>apply_mode_to_home_chain(act, trmode)</code>","text":"<p>Apply a transport mode across a home-based trip chain, which comprises the specified activity.</p> PARAMETER  DESCRIPTION <code>act</code> <p>The activity that is part of the trip chain.</p> <p> TYPE: <code>Activity</code> </p> <code>trmode</code> <p>The mode to apply to each leg of the chain.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def apply_mode_to_home_chain(act: Activity, trmode: str) -&gt; None:\n    \"\"\"Apply a transport mode across a home-based trip chain,\n    which comprises the specified activity.\n\n    Args:\n        act (Activity): The activity that is part of the trip chain.\n        trmode (str): The mode to apply to each leg of the chain.\n    \"\"\"\n    if \"next\" not in act.__dict__:\n        raise KeyError(\n            \"Plan is not linked. Please use `pam.operations.cropping.link_plan` to link activities and legs.\"\n        )\n\n    # apply forwards\n    elem = act.next\n    while (elem is not None) and (elem.act != \"home\"):\n        if isinstance(elem, Leg):\n            elem.mode = trmode\n        elem = elem.next\n\n    # apply backwards\n    elem = act.previous\n    while (elem is not None) and (elem.act != \"home\"):\n        if isinstance(elem, Leg):\n            elem.mode = trmode\n        elem = elem.previous\n</code></pre>"},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.calculate_mnl_probabilities","title":"<code>calculate_mnl_probabilities(x)</code>","text":"<p>Calculates MNL probabilities from a set of alternatives.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def calculate_mnl_probabilities(x: Union[np.array, list]) -&gt; np.array:\n    \"\"\"Calculates MNL probabilities from a set of alternatives.\"\"\"\n    return np.exp(x) / np.exp(x).sum()\n</code></pre>"},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.convert_single_anchor_roundtrip","title":"<code>convert_single_anchor_roundtrip(chain)</code>","text":"<p>If a trip chain only has one anchor, make it a round-trip. - If only the start activity is an anchor, it appends a return trip to the start location. - If only the end activity is an anchor, it inserts a first leg from the end activity location. - If neither end is an anchor, it treats the first location as an anchor. The addition of the \"return\" elements is done in-place.</p> PARAMETER  DESCRIPTION <code>chain</code> <p>a chain of activity and legs between two long-term activities</p> <p> TYPE: <code>list[Union[Activity, Leg]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def convert_single_anchor_roundtrip(chain: list[Union[Activity, Leg]]) -&gt; None:\n    \"\"\"If a trip chain only has one anchor, make it a round-trip.\n    - If only the start activity is an anchor, it appends a return trip to the start location.\n    - If only the end activity is an anchor, it inserts a first leg from the end activity location.\n    - If neither end is an anchor, it treats the first location as an anchor.\n    The addition of the \"return\" elements is done in-place.\n\n    Args:\n        chain: a chain of activity and legs between two long-term activities\n\n    Returns:\n        None\n    \"\"\"\n    if chain[0].act not in LONG_TERM_ACTIVITIES and chain[-1].act in LONG_TERM_ACTIVITIES:\n        leg = deepcopy(chain[-2])\n        act = deepcopy(chain[-1])\n        leg.start_location = act.location\n        chain.insert(0, leg)\n        chain.insert(0, act)\n    elif chain[-1].act not in LONG_TERM_ACTIVITIES and chain[0].act in LONG_TERM_ACTIVITIES:\n        leg = deepcopy(chain[1])\n        act = deepcopy(chain[0])\n        chain.append(leg)\n        chain.append(act)\n    # if all activities are non-disrectionary, create a tour from/to the first location\n    elif chain[-1].act not in LONG_TERM_ACTIVITIES and chain[0].act not in LONG_TERM_ACTIVITIES:\n        act = deepcopy(chain[0])\n        leg = deepcopy(chain[1])\n        act.act = \"home\"\n        leg.start_location = act.location\n        chain.insert(0, leg)\n        chain.insert(0, act)\n        chain.append(leg)\n        chain.append(act)\n</code></pre>"},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.get_act_names","title":"<code>get_act_names(seqs)</code>","text":"<p>Get the activity names of a plan.</p> PARAMETER  DESCRIPTION <code>seqs</code> <p>a list of plan components (activities and legs)</p> <p> TYPE: <code>list[Union[Activity, Leg]]</code> </p> RETURNS DESCRIPTION <code>list</code> <p>a list of the activity names</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def get_act_names(seqs: list[Union[Activity, Leg]]) -&gt; list[str]:\n    \"\"\"\n    Get the activity names of a plan.\n\n    Args:\n        seqs: a list of plan components (activities and legs)\n\n    Returns:\n        list: a list of the activity names\n    \"\"\"\n    return [x.act for x in seqs if isinstance(x, Activity)]\n</code></pre>"},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.get_first_leg_time_ratio","title":"<code>get_first_leg_time_ratio(chain)</code>","text":"<p>Get the ratio of the first leg duration to the total trip chain duration.</p> PARAMETER  DESCRIPTION <code>chain</code> <p>a chain of activity and legs between two long-term activities</p> <p> TYPE: <code>list[Union[Activity, Leg]]</code> </p> RETURNS DESCRIPTION <code>float</code> <p>the first leg duration ratio</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def get_first_leg_time_ratio(chain: list[Union[Activity, Leg]]) -&gt; float:\n    \"\"\"Get the ratio of the first leg duration to the total trip chain duration.\n\n    Args:\n        chain: a chain of activity and legs between two long-term activities\n\n    Returns:\n        float: the first leg duration ratio\n\n    \"\"\"\n    durations = [x.duration / datetime.timedelta(seconds=1) for x in chain if isinstance(x, Leg)]\n    ratio = durations[0] / sum(durations)\n\n    return ratio\n</code></pre>"},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.get_trip_chains","title":"<code>get_trip_chains(plan, act='home')</code>","text":"<p>Get trip chains starting and/or ending at a long-term activity.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def get_trip_chains(plan: Plan, act: str = \"home\") -&gt; list[list[Union[Activity, Leg]]]:\n    \"\"\"Get trip chains starting and/or ending at a long-term activity.\"\"\"\n    chains = []\n    chain = []\n    for elem in plan.day:\n        if isinstance(elem, Activity) and elem.act == act:\n            if len(chain) &gt; 0:\n                chains.append(chain + [elem])\n                chain = []\n        chain.append(elem)\n\n    if len(chain) &gt; 1:\n        chains += [chain]  # add any remaining trips until the end of the day\n\n    return chains\n</code></pre>"},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.get_trip_chains_either_anchor","title":"<code>get_trip_chains_either_anchor(plan, acts=LONG_TERM_ACTIVITIES)</code>","text":"<p>Get trip chains starting and/OR ending at a long-term activity. Similar to get_trip_chains, but can slice plans on multiple activity types.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def get_trip_chains_either_anchor(\n    plan: Plan, acts: list[str] = LONG_TERM_ACTIVITIES\n) -&gt; list[list[Union[Activity, Leg]]]:\n    \"\"\"Get trip chains starting and/OR ending at a long-term activity.\n    Similar to get_trip_chains, but can slice plans on multiple activity types.\n    \"\"\"\n    chains = []\n    chain = []\n    for elem in plan.day:\n        if isinstance(elem, Activity) and elem.act in acts:\n            if len(chain) &gt; 0:\n                chains.append(chain + [elem])\n                chain = []\n        chain.append(elem)\n\n    if len(chain) &gt; 1:\n        chains += [chain]  # add any remaining trips until the end of the day\n\n    return chains\n</code></pre>"},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.get_validate","title":"<code>get_validate(obj, name)</code>","text":"<p>Get an object's attribute, or raise an error if its value is None.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def get_validate(obj, name: str):\n    \"\"\"Get an object's attribute, or raise an error if its value is None.\"\"\"\n    attr = getattr(obj, name)\n    if attr is None:\n        raise ValueError(f\"Attribute {name} has not been set yet\")\n    return attr\n</code></pre>"},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.safe_divide","title":"<code>safe_divide(x, y)</code>","text":"<p>Safely divide two arrays. When dividing by zero, the result is set to zero.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Numerator array.</p> <p> TYPE: <code>array</code> </p> <code>y</code> <p>Denominator array.</p> <p> TYPE: <code>array</code> </p> RETURNS DESCRIPTION <code>array</code> <p>np.array: Divided array.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def safe_divide(x: np.array, y: np.array) -&gt; np.array:\n    \"\"\"Safely divide two arrays. When dividing by zero, the result is set to zero.\n\n\n    Args:\n        x (np.array): Numerator array.\n        y (np.array): Denominator array.\n\n    Returns:\n        np.array: Divided array.\n    \"\"\"\n    return np.divide(x, y, out=np.zeros(x.shape, dtype=np.float64), where=y != 0)\n</code></pre>"},{"location":"reference/pam/planner/utils_planner/#pam.planner.utils_planner.sample_weighted","title":"<code>sample_weighted(weights)</code>","text":"<p>Weighted sampling. Returns the index of the selection.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def sample_weighted(weights: np.array) -&gt; int:\n    \"\"\"Weighted sampling.\n    Returns the index of the selection.\n    \"\"\"\n    return random.choices(range(len(weights)), weights=weights, k=1)[0]\n</code></pre>"},{"location":"reference/pam/planner/zones/","title":"pam.planner.zones","text":"<p>Manages zone-level data required by the planner module.</p>"},{"location":"reference/pam/planner/zones/#pam.planner.zones.Zones","title":"<code>Zones(data)</code>","text":"PARAMETER  DESCRIPTION <code>data</code> <p>A dataframe with variables as columns and the zone as index</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>pam/planner/zones.py</code> <pre><code>def __init__(self, data: pd.DataFrame) -&gt; None:\n    \"\"\"\n\n    Args:\n        data (pd.DataFrame): A dataframe with variables as columns and the zone as index\n\n    \"\"\"\n    self.data = data\n</code></pre>"},{"location":"reference/pam/planner/zones/#pam.planner.zones.Zones.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/plot/plans/","title":"pam.plot.plans","text":""},{"location":"reference/pam/plot/plans/#pam.plot.plans.build_cmap","title":"<code>build_cmap(df)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def build_cmap(df: pd.DataFrame) -&gt; dict:\n    colors = plt.cm.Set3.colors[::-1]\n    activities_unique = df[\"act\"].unique()\n    # repeat colours if unique items &gt; 1\n    len_factor = (len(activities_unique) // len(colors)) + 1\n    d_color = dict(zip(activities_unique, colors * len_factor))\n    d_color[\"Travel\"] = (0.3, 0.3, 0.3)\n    return d_color\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.build_person_df","title":"<code>build_person_df(person)</code>","text":"<p>Loop through a persons plan, creating a pandas dataframe defining activities for plotting.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def build_person_df(person):\n    \"\"\"Loop through a persons plan, creating a pandas dataframe defining activities for plotting.\"\"\"\n    data = {\"act\": [], \"modes\": [], \"start_time\": [], \"end_time\": [], \"dur\": []}\n    for component in person.plan.day:\n        data[\"act\"].append(component.act.lower().title())\n        if isinstance(component, activity.Leg):\n            data[\"modes\"].append(component.mode.lower().title())\n        else:\n            data[\"modes\"].append(None)\n        data[\"start_time\"].append(component.start_time.hour + component.start_time.minute / 60)\n        data[\"end_time\"].append(component.end_time.hour + component.end_time.minute / 60)\n        data[\"dur\"].append(component.duration.total_seconds() / 3600)\n    df = pd.DataFrame(data)\n    df[\"pid\"] = person.pid\n\n    return df\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.build_person_travel_geodataframe","title":"<code>build_person_travel_geodataframe(person, from_epsg=None, to_epsg=None)</code>","text":"<p>Loop through a persons legs, creating a geopandas GeoDataFrame defining travel for plotting.</p> PARAMETER  DESCRIPTION <code>person</code> <p> TYPE: <code>Person</code> </p> <code>from_epsg</code> <p>coordinate system the plans are currently in. You need to specify <code>from_epsg</code> as well to use this. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>to_epsg</code> <p>coordinate system you want the geo dataframe to be projected to. You need to specify <code>from_epsg</code> as well to use this. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>geographically pinpointed travel legs for given <code>person</code>.</p> <p> TYPE: <code>GeoDataFrame</code> </p> Source code in <code>pam/plot/plans.py</code> <pre><code>def build_person_travel_geodataframe(\n    person: Person, from_epsg: Optional[str] = None, to_epsg: Optional[str] = None\n) -&gt; GeoDataFrame:\n    \"\"\"Loop through a persons legs, creating a geopandas GeoDataFrame defining travel for plotting.\n\n    Args:\n      person (pam.core.Person):\n      from_epsg (str, optional):\n        coordinate system the plans are currently in.\n        You need to specify `from_epsg` as well to use this. Defaults to None.\n      to_epsg (str, optional):\n        coordinate system you want the geo dataframe to be projected to.\n        You need to specify `from_epsg` as well to use this. Defaults to None.\n\n    Returns:\n        GeoDataFrame: geographically pinpointed travel legs for given `person`.\n\n    \"\"\"\n    df = pd.DataFrame()\n    for leg in person.legs:\n        if (leg.start_location.loc is None) or (leg.end_location.loc is None):\n            raise AttributeError(\n                \"\"\"\nTo create a geopandas.DataFrame you need specific locations. Make sure Legs have\nloc attribute defined with a shapely.Point or s2sphere.CellId.\n\"\"\"\n            )\n        geometry = utils.get_linestring(leg.start_location.loc, leg.end_location.loc)\n        _leg_dict = {\n            \"mode\": leg.mode,\n            \"purp\": leg.purp,\n            \"seq\": leg.seq,\n            \"freq\": leg.freq,\n            \"start_time\": leg.start_time,\n            \"end_time\": leg.end_time,\n            \"start_location\": geometry.coords[0],\n            \"end_location\": geometry.coords[-1],\n            \"geometry\": geometry,\n            \"distance\": leg.distance,\n            \"service_id\": leg.route.transit.get(\"transitLineId\"),\n            \"route_id\": leg.route.transit.get(\"transitRouteId\"),\n            \"o_stop\": leg.route.transit.get(\"accessFacilityId\"),\n            \"d_stop\": leg.route.transit.get(\"egressFacilityId\"),\n            \"network_route\": leg.route.network_route,\n        }\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\", category=ShapelyDeprecationWarning)\n            df = pd.concat([df, pd.Series(_leg_dict)], ignore_index=True, axis=1)\n\n    df = df.T.infer_objects()\n    df[\"pid\"] = person.pid\n    df = GeoDataFrame(df, geometry=\"geometry\")\n    if from_epsg:\n        df.crs = from_epsg\n        if to_epsg:\n            df = df.to_crs(to_epsg)\n\n    return df\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.build_plan_df","title":"<code>build_plan_df(plan, pid='sample')</code>","text":"<p>Loop through a plan, creating a pandas dataframe defining activities for plotting.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def build_plan_df(plan, pid=\"sample\"):\n    \"\"\"Loop through a plan, creating a pandas dataframe defining activities for plotting.\"\"\"\n    data = {\"act\": [], \"modes\": [], \"start_time\": [], \"end_time\": [], \"dur\": []}\n    for component in plan.day:\n        data[\"act\"].append(component.act.lower().title())\n        if isinstance(component, activity.Leg) and component.mode is not None:\n            data[\"modes\"].append(component.mode.lower().title())\n        else:\n            data[\"modes\"].append(None)\n        data[\"start_time\"].append(component.start_time.hour + component.start_time.minute / 60)\n        data[\"end_time\"].append(component.end_time.hour + component.end_time.minute / 60)\n        data[\"dur\"].append(component.duration.total_seconds() / 3600)\n    df = pd.DataFrame(data)\n    df[\"pid\"] = pid\n\n    return df\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.build_rgb_travel_cmap","title":"<code>build_rgb_travel_cmap(df, colour_by)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def build_rgb_travel_cmap(df, colour_by):\n    colors = [\n        (int(tup[0] * 255), int(tup[1] * 255), int(tup[2] * 255))\n        for tup in plt.cm.Set3.colors[::-1]\n    ]\n    colour_by_unique = df[colour_by].unique()\n    # repeat colours if unique items &gt; 12\n    len_factor = (len(colour_by_unique) // len(colors)) + 1\n    d_color = dict(zip(colour_by_unique, colors * len_factor))\n    return d_color\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.plot_activities","title":"<code>plot_activities(df, cmap=None, width=DEFAULT_ACTIVITIES_PLOT_WIDTH, legend=True, label_fontsize=None, path=None)</code>","text":"<p>Plot activity plans from pandas dataframe.</p> PARAMETER  DESCRIPTION <code>df</code> <p>Input activity plan data</p> <p> TYPE: <code>DataFrame</code> </p> <code>cmap</code> <p>Map from activity to colour. If not given, random colours will be applied from <code>Set3</code>. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>width</code> <p>Figure width. Defaults to DEFAULT_ACTIVITIES_PLOT_WIDTH.</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_ACTIVITIES_PLOT_WIDTH</code> </p> <code>legend</code> <p>If True, a legend will be added to the bottom of the figure. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>label_fontsize</code> <p>Set fontsize of activity / trip labels using a mapping or a single value to apply to all labels. This can be a partial mapping, with those not defined defaulting to a fontsize of DEFAULT_ACTIVITIES_FONTSIZE. Defaults to None.</p> <p> TYPE: <code>Union[dict, int]</code> DEFAULT: <code>None</code> </p> <code>path</code> <p>If given, path to which the figure should be saved. Defaults to None.</p> <p> TYPE: <code>Optional[str | Path]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_activities(\n    df: pd.DataFrame,\n    cmap: Optional[dict] = None,\n    width: int = DEFAULT_ACTIVITIES_PLOT_WIDTH,\n    legend: bool = True,\n    label_fontsize: Optional[Union[dict, int]] = None,\n    path: Optional[Union[str, Path]] = None,\n) -&gt; None:\n    \"\"\"Plot activity plans from pandas dataframe.\n\n    Args:\n        df (pd.DataFrame): Input activity plan data\n        cmap (Optional[dict], optional): Map from activity to colour. If not given, random colours will be applied from `Set3`. Defaults to None.\n        width (int, optional): Figure width. Defaults to DEFAULT_ACTIVITIES_PLOT_WIDTH.\n        legend (bool, optional): If True, a legend will be added to the bottom of the figure. Defaults to True.\n        label_fontsize (Union[dict, int], optional): Set fontsize of activity / trip labels using a mapping or a single value to apply to all labels. This can be a partial mapping, with those _not_ defined defaulting to a fontsize of DEFAULT_ACTIVITIES_FONTSIZE. Defaults to None.\n        path (Optional[str  |  Path], optional): If given, path to which the figure should be saved. Defaults to None.\n    \"\"\"\n    if cmap is None:\n        cmap = build_cmap(df)\n    fontscale = width / DEFAULT_ACTIVITIES_PLOT_WIDTH\n    scaled_fontsize = DEFAULT_ACTIVITIES_FONTSIZE * fontscale\n\n    df[\"color\"] = df[\"act\"].map(cmap)\n    pids = df[\"pid\"].unique()\n\n    fig, axs = plt.subplots(\n        len(pids),\n        1,\n        figsize=(width, 0.5 + 1.25 * len(pids)),\n        sharex=True,  # fudge to keep proportions about right\n    )\n\n    for idx, pid in enumerate(pids):\n        person_data = df.loc[df.pid == pid]\n        label_x, label_y, labels = [], [], []\n\n        if len(pids) == 1:\n            ax = axs\n        else:\n            ax = axs[idx]\n\n        for i in range(len(person_data)):\n            y = 1\n            data = person_data.iloc[i]\n            ax.barh(\n                y,\n                width=\"dur\",\n                data=data,\n                left=\"start_time\",\n                label=\"act\",\n                color=\"color\",\n                edgecolor=\"black\",\n                linewidth=2,\n            )\n\n            # Populate Labelling Params\n            label_x.append(data[\"start_time\"] + data[\"dur\"] / 2)\n            label_y.append(y)\n            labels.append(data.act)\n\n        # Labels\n        rects = ax.patches\n\n        for x, y, rect, label in zip(label_x, label_y, rects, labels):\n            r, g, b, _ = rect.get_facecolor()\n            # see https://en.wikipedia.org/wiki/Relative_luminance\n            luminance = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 255\n            if luminance &lt; 140:\n                color = \"white\"\n            else:\n                color = \"black\"\n            if isinstance(label_fontsize, dict):\n                _fontsize = label_fontsize.get(label, scaled_fontsize)\n            elif label_fontsize is not None:\n                _fontsize = label_fontsize\n            else:\n                _fontsize = scaled_fontsize\n\n            scaled_rect_width = rect.get_width() * width / DEFAULT_ACTIVITIES_PLOT_WIDTH\n\n            if scaled_rect_width &gt;= 2:\n                ax.text(\n                    x,\n                    y,\n                    label,\n                    ha=\"center\",\n                    va=\"center\",\n                    fontdict={\"color\": color, \"size\": _fontsize, \"weight\": \"regular\"},\n                )\n            elif scaled_rect_width &gt;= 0.5:\n                ax.text(\n                    x,\n                    y,\n                    label,\n                    ha=\"center\",\n                    va=\"center\",\n                    fontdict={\n                        \"color\": color,\n                        \"size\": _fontsize,\n                        \"weight\": \"regular\",\n                        \"rotation\": 90,\n                    },\n                )\n\n        ax.set_title(f\"Person ID: {pid}\", fontsize=scaled_fontsize)\n        ax.get_yaxis().set_visible(False)\n        ax.set_xticks(range(25))\n        ax.set_xlim(right=24)\n        ax.tick_params(axis=\"x\", which=\"major\", labelsize=scaled_fontsize)\n        for side in [\"top\", \"right\", \"bottom\", \"left\"]:\n            ax.spines[side].set_visible(False)\n\n    if legend:\n        legend_elements = []\n        for act, color in cmap.items():\n            legend_elements.append(Patch(facecolor=color, edgecolor=\"black\", label=act))\n        fig.legend(\n            handles=legend_elements,\n            ncol=len(legend_elements),\n            prop={\"size\": 1.2 * scaled_fontsize},\n            frameon=False,\n            bbox_to_anchor=(0.5, 0),\n            loc=\"upper center\",\n            borderaxespad=0.0,\n            borderpad=0.5,\n        )\n    fig.tight_layout()\n\n    if path is not None:\n        fig.savefig(path, bbox_inches=\"tight\")\n\n    return fig, axs\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.plot_activity_breakdown_area","title":"<code>plot_activity_breakdown_area(plans, activity_classes=None, plans_encoder=None, normalize=False, legend=True, ax=None, colormap='tab20')</code>","text":"<p>Area plot of the breakdown of activities taking place every minute.</p> PARAMETER  DESCRIPTION <code>plans</code> <p>A list of PAM plans.</p> <p> TYPE: <code>list[Plan]</code> </p> <code>activity_classes</code> <p>A list of the activity labels to encode a plan from. Defaults to None.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>plans_encoder</code> <p>A pre-encoded plan; alternative to passing <code>activity_classes</code>. Defaults to None.</p> <p> TYPE: <code>Optional[type[PlanEncoder]]</code> DEFAULT: <code>None</code> </p> <code>normalize</code> <p>Whether to convert the y-axis to percentages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>legend</code> <p>Whether to include the legend of activities in the plot. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>ax</code> <p>A matplotlib axis; if not given, a new one will be generated. Defaults to None.</p> <p> TYPE: <code>Optional[Axes]</code> DEFAULT: <code>None</code> </p> <code>colormap</code> <p>The colormap to use in the plot. Defaults to \"tab20\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'tab20'</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>One of <code>activity_classes</code> or <code>plans_encoder</code> must be defined.</p> RETURNS DESCRIPTION <code>Axes</code> <p>plt.Axes: plot object.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_activity_breakdown_area(\n    plans: list[Plan],\n    activity_classes: Optional[list[str]] = None,\n    plans_encoder: Optional[type[encoder.PlanEncoder]] = None,\n    normalize: bool = False,\n    legend: bool = True,\n    ax: Optional[plt.Axes] = None,\n    colormap: str = \"tab20\",\n) -&gt; plt.Axes:\n    \"\"\"\n    Area plot of the breakdown of activities taking place every minute.\n\n    Args:\n        plans (list[Plan]): A list of PAM plans.\n        activity_classes (Optional[list[str]], optional): A list of the activity labels to encode a plan from. Defaults to None.\n        plans_encoder (Optional[type[encoder.PlanEncoder]], optional): A pre-encoded plan; alternative to passing `activity_classes`. Defaults to None.\n        normalize (bool, optional): Whether to convert the y-axis to percentages. Defaults to False.\n        legend (bool, optional): Whether to include the legend of activities in the plot. Defaults to True.\n        ax (Optional[plt.Axes], optional): A matplotlib axis; if not given, a new one will be generated. Defaults to None.\n        colormap (str, optional): The colormap to use in the plot. Defaults to \"tab20\".\n\n    Raises:\n        ValueError: One of `activity_classes` or `plans_encoder` must be defined.\n\n    Returns:\n        plt.Axes: plot object.\n    \"\"\"\n    if activity_classes is not None:\n        plans_encoder = encoder.PlansOneHotEncoder(activity_classes=activity_classes)\n    elif plans_encoder is None:\n        raise ValueError(\"Please provide a list of activity classes or a plans encoder.\")\n\n    labels = plans_encoder.plan_encoder.activity_encoder.labels\n    freqs = plans_encoder.encode(plans).sum(axis=0)\n\n    if normalize:\n        freqs = freqs.astype(float) / freqs.sum(0)\n\n    if ax is None:\n        fig, ax = plt.subplots(1, 1)\n\n    n_labels = len(labels)\n    cmap = matplotlib.colormaps[colormap]\n    colors = [cmap(x) for x in range(n_labels)]\n\n    ax.stackplot(range(freqs.shape[1]), *freqs, colors=colors)\n\n    if legend:\n        ax.legend(labels, loc=\"lower left\", bbox_to_anchor=(1.0, 0), frameon=False)\n\n    if normalize:\n        ax.yaxis.set_major_formatter(mtick.FuncFormatter(lambda x, _: \"{:.0%}\".format(x)))\n\n    ax.set_xlim(0, freqs.shape[1])\n    ax.set_ylim(0, freqs.sum(0).max())\n\n    return ax\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.plot_activity_breakdown_area_tiles","title":"<code>plot_activity_breakdown_area_tiles(plans, activity_classes, figsize=(10, 8), **kwargs)</code>","text":"<p>Tiled area plot of the breakdown of activities taking place every minute.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_activity_breakdown_area_tiles(\n    plans: dict[list[Plan]], activity_classes: list[str], figsize=(10, 8), **kwargs\n):\n    \"\"\"Tiled area plot of the breakdown of activities taking place every minute.\"\"\"\n    plans_encoder = encoder.PlansOneHotEncoder(activity_classes=activity_classes)\n    labels = plans_encoder.plan_encoder.activity_encoder.labels\n    nrows = int(np.ceil(len(plans) / 2))\n    irow = 0\n    icol = 0\n    fig, axs = plt.subplots(nrows, 2, figsize=figsize, sharex=True, sharey=True)\n    fig.tight_layout(pad=2)\n    for k, v in plans.items():\n        n = len(v)\n        if nrows &gt; 1:\n            ax = axs[irow, icol]\n        else:\n            ax = axs[icol]\n        print(ax)\n        plot_activity_breakdown_area(\n            plans=v, ax=ax, legend=False, normalize=True, plans_encoder=plans_encoder, **kwargs\n        )\n        ax.set_title(f\"Cluster {k} - {n} plans\")\n        irow += icol\n        icol = (icol + 1) % 2\n\n    ax.legend(labels, loc=\"lower left\", bbox_to_anchor=(1.0, 0), frameon=False)\n\n    return axs\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.plot_household","title":"<code>plot_household(household, **kwargs)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_household(household, **kwargs):\n    df = pd.concat([build_person_df(person) for person in household.people.values()])\n    plot_activities(df, **kwargs)\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.plot_person","title":"<code>plot_person(person, **kwargs)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_person(person, **kwargs):\n    df = build_person_df(person)\n    plot_activities(df, **kwargs)\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.plot_persons","title":"<code>plot_persons(persons, **kwargs)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_persons(persons, **kwargs):\n    df = pd.concat([build_person_df(person) for person in persons])\n    plot_activities(df, **kwargs)\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.plot_plan","title":"<code>plot_plan(plan, **kwargs)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_plan(plan, **kwargs):\n    df = build_plan_df(plan)\n    plot_activities(df, **kwargs)\n</code></pre>"},{"location":"reference/pam/plot/plans/#pam.plot.plans.plot_travel_plans","title":"<code>plot_travel_plans(gdf, groupby=None, colour_by='mode', cmap=None, mapbox_access_token='')</code>","text":"<p>Uses plotly's Scattermapbox to plot travel GeoDataFrame.</p> PARAMETER  DESCRIPTION <code>gdf</code> <p>Ouptut of <code>build_person_travel_geodataframe</code>.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>groupby</code> <p>List of column names to group together into different plotly <code>traces</code>. Defaults to None.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>colour_by</code> <p>The <code>gdf</code> column that should be used to define colours in the plot. Defaults to \"mode\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'mode'</code> </p> <code>cmap</code> <p>Useful to pass if generating a number of plots and want to keep colour scheme. Defaults to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>mapbox_access_token</code> <p>required to generate the plot. See https://docs.mapbox.com/help/how-mapbox-works/access-tokens/ Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <p>Returns:     go.Figure: plotly figure object</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_travel_plans(\n    gdf: GeoDataFrame,\n    groupby: Optional[list] = None,\n    colour_by: str = \"mode\",\n    cmap: Optional[dict] = None,\n    mapbox_access_token: str = \"\",\n) -&gt; go.Figure:\n    \"\"\"Uses plotly's Scattermapbox to plot travel GeoDataFrame.\n\n    Args:\n      gdf (GeoDataFrame): Ouptut of `build_person_travel_geodataframe`.\n      groupby (list, optional): List of column names to group together into different plotly `traces`. Defaults to None.\n      colour_by (str, optional): The `gdf` column that should be used to define colours in the plot. Defaults to \"mode\".\n      cmap (dict, optional): Useful to pass if generating a number of plots and want to keep colour scheme. Defaults to None.\n      mapbox_access_token (str, optional):\n        required to generate the plot. See https://docs.mapbox.com/help/how-mapbox-works/access-tokens/\n        Defaults to \"\".\n    Returns:\n        go.Figure: plotly figure object\n\n    \"\"\"\n    if not mapbox_access_token:\n        raise Warning(\"You need to pass `mapbox_access_token` for the plot to appear.\")\n    _gdf = gdf.copy()\n    _gdf[\"start_time\"] = _gdf[\"start_time\"].dt.strftime(\"%H:%M:%S\")\n    _gdf[\"end_time\"] = _gdf[\"end_time\"].dt.strftime(\"%H:%M:%S\")\n    _gdf[\"seq\"] = _gdf[\"seq\"].astype(int)\n\n    if cmap is None:\n        cmap = build_rgb_travel_cmap(gdf, colour_by)\n\n    data = []\n    all_coords = []\n\n    if groupby is None:\n        groupby = []\n        to_group = colour_by\n    else:\n        to_group = [colour_by] + groupby\n    for name, group in _gdf.groupby(to_group):\n        if len(groupby) &gt; 0:\n            colour_by_item = name[0]\n        else:\n            colour_by_item = name\n        colour = \"rgb({},{},{})\".format(\n            cmap[colour_by_item][0], cmap[colour_by_item][1], cmap[colour_by_item][2]\n        )\n\n        lat = []\n        lon = []\n        hovertext = []\n        for idx in group.index:\n            coords = group.loc[idx, \"geometry\"].coords\n            all_coords.extend(coords)\n            lat = lat + [point[1] for point in coords] + [float(\"nan\")]\n            lon = lon + [point[0] for point in coords] + [float(\"nan\")]\n            _hovertext = [\"\"] * (len(coords) + 1)\n            _hovertext[0] = \"pid: {}&lt;br&gt;start time: {}&lt;br&gt;trip seq: {}&lt;br&gt;mode: {}\".format(\n                group.loc[idx, \"pid\"],\n                group.loc[idx, \"start_time\"],\n                group.loc[idx, \"seq\"],\n                group.loc[idx, \"mode\"],\n            )\n            _hovertext[-2] = \"pid: {}&lt;br&gt;end time: {}&lt;br&gt;trip seq: {}&lt;br&gt;mode: {}\".format(\n                group.loc[idx, \"pid\"],\n                group.loc[idx, \"end_time\"],\n                group.loc[idx, \"seq\"],\n                group.loc[idx, \"mode\"],\n            )\n            hovertext = hovertext + _hovertext\n\n        data.append(\n            go.Scattermapbox(\n                lat=lat,\n                lon=lon,\n                hovertext=hovertext,\n                hoverinfo=\"text\",\n                mode=\"lines+markers\",\n                marker=dict(size=10, color=colour, opacity=0.75),\n                line=dict(color=colour),\n                name=\"{}\".format(name),\n            )\n        )\n\n    if all_coords:\n        c_lat = sum([point[1] for point in all_coords]) / len(all_coords)\n        c_lon = sum([point[0] for point in all_coords]) / len(all_coords)\n    else:\n        c_lat = 0\n        c_lon = 0\n\n    layout = go.Layout(\n        title=\"\",\n        autosize=True,\n        hovermode=\"closest\",\n        mapbox=go.layout.Mapbox(\n            accesstoken=mapbox_access_token,\n            bearing=0,\n            center=go.layout.mapbox.Center(lat=c_lat, lon=c_lon),\n            pitch=0,\n            zoom=10,\n            style=\"dark\",\n        ),\n    )\n    fig = go.Figure(data=data, layout=layout)\n    return fig\n</code></pre>"},{"location":"reference/pam/plot/stats/","title":"pam.plot.stats","text":""},{"location":"reference/pam/plot/stats/#pam.plot.stats.calculate_activity_duration_by_act","title":"<code>calculate_activity_duration_by_act(population, exclude=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_activity_duration_by_act(population, exclude=None):\n    all_activities = []\n    for hid, pid, person in population.people():\n        for seq, activity in enumerate(person.activities):\n            all_activities.append(\n                {\n                    \"act\": activity.act,\n                    \"duration_hours\": activity.duration.days * 24\n                    + activity.duration.seconds / 3600,\n                }\n            )\n    all_activities_df = pd.DataFrame(all_activities)\n    outputs_df = all_activities_df.groupby(\"act\", as_index=False).agg({\"duration_hours\": \"sum\"})\n    outputs_df.insert(0, \"scenario\", population.name, True)\n    if exclude is not None:\n        outputs_df = outputs_df[outputs_df.act != exclude]\n    return outputs_df\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.calculate_leg_duration_by_mode","title":"<code>calculate_leg_duration_by_mode(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_leg_duration_by_mode(population):\n    all_legs = []\n    for hid, pid, person in population.people():\n        for seq, leg in enumerate(person.legs):\n            all_legs.append(\n                {\n                    \"leg mode\": leg.mode,\n                    \"duration_hours\": leg.duration.days * 24 + leg.duration.seconds / 3600,\n                }\n            )\n    all_legs_df = pd.DataFrame(all_legs)\n    outputs_df = all_legs_df.groupby(\"leg mode\", as_index=False).agg({\"duration_hours\": \"sum\"})\n    outputs_df.insert(0, \"scenario\", population.name, True)\n    return outputs_df\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.calculate_total_activity_duration","title":"<code>calculate_total_activity_duration(population, exclude=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_total_activity_duration(population, exclude=None):\n    total_activity_duration = timedelta(minutes=0)\n    for hid, pid, person in population.people():\n        for seq, activity in enumerate(person.activities):\n            if activity.act != exclude:\n                total_activity_duration = total_activity_duration + activity.duration\n    total_activity_duration_hours = (\n        total_activity_duration.days * 24 + total_activity_duration.seconds / 3600\n    )\n    return total_activity_duration_hours\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.calculate_total_leg_duration","title":"<code>calculate_total_leg_duration(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_total_leg_duration(population):\n    total_leg_duration = timedelta(minutes=0)\n    for hid, pid, person in population.people():\n        for seq, leg in enumerate(person.legs):\n            total_leg_duration = total_leg_duration + leg.duration\n    total_leg_duration_hours = total_leg_duration.days * 24 + total_leg_duration.seconds / 3600\n    return total_leg_duration_hours\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.extract_activity_log","title":"<code>extract_activity_log(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def extract_activity_log(population):\n    log = []\n    for hid, pid, person in population.people():\n        for activity in person.activities:\n            log.append(\n                {\n                    \"act\": activity.act,\n                    \"start\": dt_to_s(activity.start_time),\n                    \"end\": dt_to_s(activity.end_time),\n                    \"duration\": td_to_s(activity.duration),\n                }\n            )\n\n    return pd.DataFrame(log)\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.extract_leg_log","title":"<code>extract_leg_log(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def extract_leg_log(population):\n    log = []\n    for hid, pid, person in population.people():\n        for leg in person.legs:\n            log.append(\n                {\n                    \"mode\": leg.mode,\n                    \"start\": dt_to_s(leg.start_time),\n                    \"end\": dt_to_s(leg.end_time),\n                    \"duration\": td_to_s(leg.duration),\n                }\n            )\n\n    return pd.DataFrame(log)\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.plot_activity_duration","title":"<code>plot_activity_duration(list_of_populations, exclude=None, axis=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_activity_duration(list_of_populations, exclude=None, axis=None):\n    x = []\n    y = []\n    for idx, population in enumerate(list_of_populations):\n        x.append(population.name)\n        y.append(calculate_total_activity_duration(population, exclude))\n\n    outputs_df = pd.DataFrame({\"scenario\": x, \"activity duration (hours)\": y})\n    x_label_rotation = 90\n    if exclude is not None:\n        title = \"activities (excl \" + exclude + \")\"\n    else:\n        title = \"activities\"\n\n    if axis is None:\n        plt.bar(x, y)\n        plt.xticks(rotation=x_label_rotation)\n        plt.ylabel(\"duration (hours)\")\n        plt.title(title)\n        plt.show\n\n    else:\n        axis.bar(x, y)\n        axis.plot()\n        axis.set_title(title)\n        axis.xaxis.set_label(\"\")\n        axis.xaxis.set_ticks(x)\n        axis.xaxis.set_ticklabels(x, rotation=x_label_rotation)\n    return outputs_df\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.plot_activity_duration_by_act","title":"<code>plot_activity_duration_by_act(list_of_populations, exclude=None, axis=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_activity_duration_by_act(list_of_populations, exclude=None, axis=None):\n    population_act_df = pd.DataFrame()\n    for idx, population in enumerate(list_of_populations):\n        population_act_df = pd.concat(\n            [population_act_df, calculate_activity_duration_by_act(population, exclude)],\n            ignore_index=True,\n        )\n    pivot_for_chart = population_act_df.pivot(\n        index=\"scenario\", columns=\"act\", values=\"duration_hours\"\n    )\n\n    if exclude is not None:\n        title = \"activities by type (excl \" + exclude + \")\"\n    else:\n        title = \"activities by type\"\n\n    if axis is None:\n        pivot_for_chart.plot.bar(stacked=True)\n        plt.ylabel(\"duration (hours)\")\n        plt.title(title)\n        plt.show\n    else:\n        pivot_for_chart.plot.bar(stacked=True, ax=axis)\n        axis.set_xlabel(\"\")\n        axis.set_title(title)\n    return pivot_for_chart\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.plot_activity_times","title":"<code>plot_activity_times(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_activity_times(population):\n    acts = extract_activity_log(population)\n    fig = plot_time_bins(acts, sub_col=\"act\")\n    return fig\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.plot_leg_duration","title":"<code>plot_leg_duration(list_of_populations, axis=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_leg_duration(list_of_populations, axis=None):\n    x = []\n    y = []\n    for idx, population in enumerate(list_of_populations):\n        x.append(population.name)\n        y.append(calculate_total_leg_duration(population))\n\n    outputs_df = pd.DataFrame({\"scenario\": x, \"leg duration (hours)\": y})\n    title = \"legs\"\n    x_label_rotation = 90\n    if axis is None:\n        plt.bar(x, y)\n        plt.xticks(rotation=x_label_rotation)\n        plt.ylabel(\"duration (hours)\")\n        plt.title(title)\n    else:\n        axis.bar(x, y)\n        axis.plot()\n        axis.set_title(title)\n        axis.xaxis.set_label(\"\")\n        axis.xaxis.set_ticks(x)\n        axis.xaxis.set_ticklabels(x, rotation=x_label_rotation)\n    return outputs_df\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.plot_leg_duration_by_mode","title":"<code>plot_leg_duration_by_mode(list_of_populations, axis=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_leg_duration_by_mode(list_of_populations, axis=None):\n    population_mode_df = pd.DataFrame()\n    for idx, population in enumerate(list_of_populations):\n        population_mode_df = pd.concat(\n            [population_mode_df, calculate_leg_duration_by_mode(population)], ignore_index=True\n        )\n    pivot_for_chart = population_mode_df.pivot(\n        index=\"scenario\", columns=\"leg mode\", values=\"duration_hours\"\n    )\n    title = \"legs by mode\"\n\n    if axis is None:\n        pivot_for_chart.plot.bar(stacked=True)\n        plt.title(title)\n        plt.ylabel(\"duration (hours)\")\n    else:\n        pivot_for_chart.plot.bar(stacked=True, ax=axis)\n        axis.set_xlabel(\"\")\n        axis.set_title(title)\n    return pivot_for_chart\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.plot_leg_times","title":"<code>plot_leg_times(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_leg_times(population):\n    legs = extract_leg_log(population)\n    fig = plot_time_bins(legs, sub_col=\"mode\")\n    return fig\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.plot_population_comparisons","title":"<code>plot_population_comparisons(list_of_populations, activity_to_exclude=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_population_comparisons(list_of_populations, activity_to_exclude=None):\n    fig1, ax = plt.subplots(nrows=1, ncols=2, tight_layout=True, sharey=True)\n    plot_leg_duration(list_of_populations, ax[0])\n    leg_modes = plot_leg_duration_by_mode(list_of_populations, ax[1])\n    ax[0].set_ylabel(\"duration (hours)\")\n\n    fig2, ax2 = plt.subplots(nrows=1, ncols=2, tight_layout=True, sharey=True)\n    plot_activity_duration(list_of_populations, activity_to_exclude, ax2[0])\n    activity_types = plot_activity_duration_by_act(list_of_populations, activity_to_exclude, ax2[1])\n    ax2[0].set_ylabel(\"duration (hours)\")\n\n    leg_modes[\"TOTAL\"] = leg_modes.sum(axis=1)\n    activity_types[\"TOTAL\"] = activity_types.sum(axis=1)\n    print(leg_modes, \"\\n\", activity_types)\n\n    return fig1, fig2, leg_modes, activity_types\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.plot_time_bins","title":"<code>plot_time_bins(data, sub_col, width=12, height_factor=1.2)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_time_bins(data, sub_col, width=12, height_factor=1.2):\n    subs = set(data[sub_col])\n    fig, axs = plt.subplots(len(subs), figsize=(width, 1.2 * len(subs)), sharex=False)\n    if not isinstance(axs, np.ndarray):\n        axs = [axs]\n\n    for ax, sub in zip(axs, subs):\n        binned = time_binner(data.loc[data[sub_col] == sub])\n        ax.pcolormesh(binned.T, cmap=\"cool\", edgecolors=\"white\", linewidth=1)\n        ax.xaxis.set_ticks([i for i in range(0, 97, 8)])\n        ax.xaxis.set_ticklabels([f\"{h:02}:00\" for h in range(0, 25, 2)])\n        ax.yaxis.set_ticks([0.5, 1.5, 2.5])\n        ax.yaxis.set_ticklabels([\"Duration\", \"End time\", \"Start time\"])\n        ax.grid(which=\"minor\", color=\"w\", linestyle=\"-\", linewidth=2)\n        for pos in [\"right\", \"top\", \"bottom\", \"left\"]:\n            ax.spines[pos].set_visible(False)\n        ax.set_title(sub.title(), fontsize=\"medium\", rotation=0)\n    fig.tight_layout()\n    return fig\n</code></pre>"},{"location":"reference/pam/plot/stats/#pam.plot.stats.time_binner","title":"<code>time_binner(data)</code>","text":"<p>Bin start and end times and durations, return freq table for 24 hour period, 15min intervals.</p> Source code in <code>pam/plot/stats.py</code> <pre><code>def time_binner(data):\n    \"\"\"Bin start and end times and durations, return freq table for 24 hour period, 15min intervals.\"\"\"\n    bins = list(range(0, 24 * 60 * 60 + 1, 15 * 60))\n    bins[-1] = 100 * 60 * 60\n    labels = pd.timedelta_range(start=\"00:00:00\", periods=96, freq=\"15min\")\n    binned = pd.DataFrame(index=pd.timedelta_range(start=\"00:00:00\", periods=96, freq=\"15min\"))\n    binned[\"duration\"] = pd.cut(data.duration, bins, labels=labels, right=False).value_counts()\n    binned[\"end\"] = pd.cut(data.end, bins, labels=labels, right=False).value_counts()\n    binned[\"start\"] = pd.cut(data.start, bins, labels=labels, right=False).value_counts()\n    binned = binned / binned.max()\n    return binned\n</code></pre>"},{"location":"reference/pam/policy/filters/","title":"pam.policy.filters","text":""},{"location":"reference/pam/policy/filters/#pam.policy.filters.Filter","title":"<code>Filter()</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for attribute-based filters.</p> Source code in <code>pam/policy/filters.py</code> <pre><code>def __init__(self):\n    pass\n</code></pre>"},{"location":"reference/pam/policy/filters/#pam.policy.filters.Filter.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/filters/#pam.policy.filters.Filter.satisfies_conditions","title":"<code>satisfies_conditions(x)</code>  <code>abstractmethod</code>","text":"<p>Check if object satisfies conditions to be filtered</p> Source code in <code>pam/policy/filters.py</code> <pre><code>@abstractmethod\ndef satisfies_conditions(self, x):\n    \"Check if object satisfies conditions to be filtered\"\n</code></pre>"},{"location":"reference/pam/policy/filters/#pam.policy.filters.PersonAttributeFilter","title":"<code>PersonAttributeFilter(conditions, how='all')</code>","text":"<p>             Bases: <code>Filter</code></p> <p>Helps filtering Person on specified attributes.</p> PARAMETER  DESCRIPTION <code>conditions</code> <p>Dictionary of key = person.attribute, value = function that returns a boolean given the value at person.attribute[key]</p> <p> TYPE: <code>dict[str, Callable[[str], bool]]</code> </p> <code>how</code> <p>The level of rigour used to match conditions. <code>all</code> means all conditions for a person need to be met. <code>any</code> means at least one condition needs to be met</p> <p> TYPE: <code>Literal['all', 'any']</code> DEFAULT: <code>'all'</code> </p> Source code in <code>pam/policy/filters.py</code> <pre><code>def __init__(\n    self, conditions: dict[str, Callable[[str], bool]], how: Literal[\"all\", \"any\"] = \"all\"\n) -&gt; None:\n    \"\"\"Helps filtering Person on specified attributes.\n\n    Args:\n        conditions (dict[str, Callable[[str], bool]]):\n            Dictionary of key = person.attribute, value = function that returns a boolean given the value at person.attribute[key]\n        how (Literal[\"all\", \"any\"]):\n            The level of rigour used to match conditions.\n            `all` means all conditions for a person need to be met. `any` means at least one condition needs to be met\n\n    \"\"\"\n    super().__init__()\n    self.conditions = conditions\n    self.how = how\n</code></pre>"},{"location":"reference/pam/policy/filters/#pam.policy.filters.PersonAttributeFilter.conditions","title":"<code>conditions = conditions</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/filters/#pam.policy.filters.PersonAttributeFilter.how","title":"<code>how = how</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/filters/#pam.policy.filters.PersonAttributeFilter.household_satisfies_conditions","title":"<code>household_satisfies_conditions(household)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def household_satisfies_conditions(self, household):\n    if not self.conditions:\n        return True\n    for pid, person in household.people.items():\n        if self.person_satisfies_conditions(person):\n            return True\n    return False\n</code></pre>"},{"location":"reference/pam/policy/filters/#pam.policy.filters.PersonAttributeFilter.person_satisfies_conditions","title":"<code>person_satisfies_conditions(person)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def person_satisfies_conditions(self, person):\n    if not self.conditions:\n        return True\n    elif self.how == \"all\":\n        satisfies_attribute_conditions = True\n        for attribute_key, attribute_condition in self.conditions.items():\n            satisfies_attribute_conditions &amp;= attribute_condition(\n                person.attributes[attribute_key]\n            )\n        return satisfies_attribute_conditions\n    elif self.how == \"any\":\n        satisfies_attribute_conditions = False\n        for attribute_key, attribute_condition in self.conditions.items():\n            satisfies_attribute_conditions |= attribute_condition(\n                person.attributes[attribute_key]\n            )\n        return satisfies_attribute_conditions\n    else:\n        raise NotImplementedError(\n            \"{} not implemented, use only `all` or `any`\".format(self.how)\n        )\n</code></pre>"},{"location":"reference/pam/policy/filters/#pam.policy.filters.PersonAttributeFilter.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/filters/#pam.policy.filters.PersonAttributeFilter.satisfies_conditions","title":"<code>satisfies_conditions(x)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def satisfies_conditions(self, x):\n    if isinstance(x, pam.core.Household):\n        # household satisfies conditions if one person satisfies conditions according to self.how\n        return self.household_satisfies_conditions(x)\n    elif isinstance(x, pam.core.Person):\n        return self.person_satisfies_conditions(x)\n    elif isinstance(x, pam.activity.Activity):\n        raise NotImplementedError\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pam/policy/modifiers/","title":"pam.policy.modifiers","text":""},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.AddActivity","title":"<code>AddActivity(activities)</code>","text":"<p>             Bases: <code>Modifier</code></p> <p>Adds specified activities.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be added.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: list[str]):\n    \"\"\"Adds specified activities.\n\n    Args:\n        activities (list[str]): List of activities to be added.\n\n    \"\"\"\n    super().__init__()\n    self.activities = activities\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.AddActivity.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.AddActivity.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(\n    self,\n    household: pam.core.Household,\n    person: Optional[pam.core.Person] = None,\n    activities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\n    raise NotImplementedError(\"Watch this space\")\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.AddActivity.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.Modifier","title":"<code>Modifier()</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for modifiers - these are classes which change activities in a person's plan.</p> <p>In general a modifer should be able to be applied on three levels Household - apply change to all activities in all person's plans in household Person - apply change to all activities in a person's plan Activity - apply change to individual activity in a person's plan</p> <p>Not all modifiers will satisfy this of course, e.g. ReduceSharedActivity only works on a household level as the activites for removal need to be shared within a household.</p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self):\n    super().__init__()\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.Modifier.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>  <code>abstractmethod</code>","text":"<p>Uses self.probability to decide if household/person/activity should be selected.</p> PARAMETER  DESCRIPTION <code>household</code> <p> TYPE: <code>Household</code> </p> <code>person</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[Person]</code> DEFAULT: <code>None</code> </p> <code>activities</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[list[Activity]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>@abstractmethod\ndef apply_to(\n    self,\n    household: pam.core.Household,\n    person: Optional[pam.core.Person] = None,\n    activities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\n    \"\"\"Uses self.probability to decide if household/person/activity should be selected.\n\n    Args:\n        household (Household):\n        person (Optional[Person], optional): Defaults to None.\n        activities (Optional[list[Activity]], optional): Defaults to None.\n    \"\"\"\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.Modifier.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation","title":"<code>MoveActivityTourToHomeLocation(activities, location='home', new_mode='walk')</code>","text":"<p>             Bases: <code>Modifier</code></p> <p>Moves a tour of activities to home location.</p> <p>A tour is defined as a list of activities sandwiched between two home activities.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be considered in a tour. Any combination of activities in activities sandwiched by home activities will be selected Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.</p> <p> TYPE: <code>list[str]</code> </p> <code>location</code> <p>Location to which the tour should be moved. Defaults to \"home\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'home'</code> </p> <code>new_mode</code> <p>Mode used in the legs to/from the activity when we relocate the activity. Defaults to \"walk\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'walk'</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: list[str], location: str = \"home\", new_mode: str = \"walk\"):\n    \"\"\"Moves a tour of activities to home location.\n\n    A tour is defined as a list of activities sandwiched between two home activities.\n\n    Args:\n        activities:\n            List of activities to be considered in a tour.\n            Any combination of activities in activities sandwiched by home activities will be selected\n            Does not require an exact match.\n            E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.\n        location (str): Location to which the tour should be moved. Defaults to \"home\".\n        new_mode (str): Mode used in the legs to/from the activity when we relocate the activity. Defaults to \"walk\".\n\n    \"\"\"\n    super().__init__()\n    self.activities = activities\n    self.default = location\n    self.new_mode = new_mode\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.default","title":"<code>default = location</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.new_mode","title":"<code>new_mode = new_mode</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(\n    self,\n    household: pam.core.Household,\n    person: Optional[pam.core.Person] = None,\n    activities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\n    new_mode = self.new_mode\n    if activities and person:\n        self.move_individual_activities(person, activities, new_mode)\n    elif person:\n        self.move_person_activities(person, new_mode)\n    elif household and isinstance(household, pam.core.Household):\n        self.move_household_activities(household, new_mode)\n    else:\n        raise NotImplementedError(\n            \"Types passed incorrectly: {}, {}, {}. You need {} at the very least.\"\n            \"\".format(type(household), type(person), type(activities), type(pam.core.Household))\n        )\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.is_part_of_tour","title":"<code>is_part_of_tour(act, tours)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def is_part_of_tour(self, act, tours: list):\n    for tour in tours:\n        # more rigorous check if activity in activities; Activity.__eq__ is not sufficient here\n        if act.isin_exact(tour):\n            return True\n    return False\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.matching_activity_tours","title":"<code>matching_activity_tours(plan, p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def matching_activity_tours(self, plan, p):\n    tours = plan.activity_tours()\n    matching_tours = []\n    for tour in tours:\n        if self.tour_matches_activities(tour, p):\n            matching_tours.append(tour)\n    return matching_tours\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_activities","title":"<code>move_activities(person, p, new_mode='walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_activities(self, person, p, new_mode=\"walk\"):\n    tours = self.matching_activity_tours(person.plan, p)\n    if tours:\n        for seq in range(len(person.plan)):\n            if isinstance(person.plan[seq], pam.activity.Activity):\n                act = person.plan[seq]\n                if self.is_part_of_tour(act, tours):\n                    person.move_activity(seq, default=self.default, new_mode=new_mode)\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_household_activities","title":"<code>move_household_activities(household, new_mode='walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_household_activities(self, household, new_mode=\"walk\"):\n    for pid, person in household.people.items():\n        self.move_person_activities(person, new_mode=new_mode)\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_individual_activities","title":"<code>move_individual_activities(person, activities, new_mode='walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_individual_activities(self, person, activities, new_mode=\"walk\"):\n    def is_a_selected_activity(act):\n        # more rigorous check if activity in activities; Activity.__eq__ is not sufficient here\n        return act.isin_exact(activities)\n\n    self.move_activities(person, p=is_a_selected_activity, new_mode=new_mode)\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_person_activities","title":"<code>move_person_activities(person, new_mode='walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_person_activities(self, person, new_mode=\"walk\"):\n    def return_true(act):\n        return True\n\n    self.move_activities(person, p=return_true, new_mode=new_mode)\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.tour_matches_activities","title":"<code>tour_matches_activities(tour, p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def tour_matches_activities(self, tour, p):\n    if set([act.act for act in tour]) - set(self.activities) == set():\n        for act in tour:\n            if p(act):\n                return True\n    return False\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity","title":"<code>ReduceSharedActivity(activities)</code>","text":"<p>             Bases: <code>Modifier</code></p> <p>Policy that needs to be applied on a household level. For activities shared within a household (Activity.act (type of activity), start/end times and locations match). Randomly assigns a person whose activities will be retained and deletes the shared activities from other persons in household.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities that should be considered for sharing. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: list[str]) -&gt; None:\n    \"\"\"Policy that needs to be applied on a household level. For activities\n    shared within a household (Activity.act (type of activity), start/end\n    times and locations match). Randomly assigns a person whose activities\n    will be retained and deletes the shared activities from other persons\n    in household.\n\n    Args:\n        activities (list[str]):\n            List of activities that should be considered for sharing.\n            Does not require an exact match.\n            E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.\n\n    \"\"\"\n    super().__init__()\n    self.activities = activities\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(\n    self,\n    household: pam.core.Household,\n    person: Optional[pam.core.Person] = None,\n    activities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\n    if household and isinstance(household, pam.core.Household):\n        self.remove_household_activities(household)\n    else:\n        raise NotImplementedError(\n            \"Types passed incorrectly: {}, {}, {}. This modifier exists only for Households\"\n            \"you need to pass {}.\"\n            \"\".format(type(household), type(person), type(activities), type(pam.core.Household))\n        )\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.is_activity_for_removal","title":"<code>is_activity_for_removal(p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def is_activity_for_removal(self, p):\n    return p.act.lower() in self.activities\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.people_who_share_activities_for_removal","title":"<code>people_who_share_activities_for_removal(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def people_who_share_activities_for_removal(self, household):\n    shared_activities_for_removal = self.shared_activities_for_removal(household)\n    people_with_shared_acts_for_removal = []\n    for pid, person in household.people.items():\n        for activity in person.activities:\n            if activity.isin_exact(shared_activities_for_removal):\n                people_with_shared_acts_for_removal.append(person)\n    return people_with_shared_acts_for_removal\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.remove_activities","title":"<code>remove_activities(person, shared_activities_for_removal)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_activities(self, person, shared_activities_for_removal):\n    seq = 0\n    while seq &lt; len(person.plan):\n        act = person.plan[seq]\n        # TODO there is a bug here `act in shared_activities_for_removal` should really be\n        # act.in_list_exact(shared_activities_for_removal), but if tthere is more than one\n        # activity in shared_activities_for_removal and  the  activities adjoin the\n        # activities morph and change time, making them not satisfy self.is_exact(other) anymore\n        # in this implementation however, you risk deleting isolated activities that have the\n        # same name and location but aren't shared\n        if isinstance(act, pam.activity.Activity) and act in shared_activities_for_removal:\n            previous_idx, subsequent_idx = person.remove_activity(seq)\n            person.fill_plan(previous_idx, subsequent_idx, default=\"home\")\n        else:\n            seq += 1\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.remove_household_activities","title":"<code>remove_household_activities(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_household_activities(self, household):\n    acts_for_removal = self.shared_activities_for_removal(household)\n    if acts_for_removal:\n        # pick the person that retains activities\n        ppl_sharing_activities = self.people_who_share_activities_for_removal(household)\n        if ppl_sharing_activities:\n            person_retaining_activities = random.choice(\n                self.people_who_share_activities_for_removal(household)\n            )\n            for pid, person in household.people.items():\n                if person != person_retaining_activities:\n                    self.remove_activities(person, acts_for_removal)\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.shared_activities_for_removal","title":"<code>shared_activities_for_removal(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def shared_activities_for_removal(self, household):\n    shared_activities = household.shared_activities()\n    return [act for act in shared_activities if self.is_activity_for_removal(act)]\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.RemoveActivity","title":"<code>RemoveActivity(activities)</code>","text":"<p>             Bases: <code>Modifier</code></p> <p>Removes specified activities.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be removed.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: list[str]):\n    \"\"\"Removes specified activities.\n\n    Args:\n        activities (list[str]): List of activities to be removed.\n\n    \"\"\"\n    super().__init__()\n    self.activities = activities\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.RemoveActivity.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.RemoveActivity.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(\n    self,\n    household: pam.core.Household,\n    person: Optional[pam.core.Person] = None,\n    activities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\n    if activities and person:\n        self.remove_individual_activities(person, activities)\n    elif person:\n        self.remove_person_activities(person)\n    elif household and isinstance(household, pam.core.Household):\n        self.remove_household_activities(household)\n    else:\n        raise TypeError(\n            \"Types passed incorrectly: {}, {}, {}. You need {} at the very least.\"\n            \"\".format(type(household), type(person), type(activities), type(pam.core.Household))\n        )\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.RemoveActivity.is_activity_for_removal","title":"<code>is_activity_for_removal(p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def is_activity_for_removal(self, p):\n    return p.act.lower() in self.activities\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.RemoveActivity.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_activities","title":"<code>remove_activities(person, p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_activities(self, person, p):\n    seq = 0\n    while seq &lt; len(person.plan):\n        act = person.plan[seq]\n        if self.is_activity_for_removal(act) and p(act):\n            previous_idx, subsequent_idx = person.remove_activity(seq)\n            person.fill_plan(previous_idx, subsequent_idx, default=\"home\")\n        else:\n            seq += 1\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_household_activities","title":"<code>remove_household_activities(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_household_activities(self, household):\n    for pid, person in household.people.items():\n        self.remove_person_activities(person)\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_individual_activities","title":"<code>remove_individual_activities(person, activities)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_individual_activities(self, person, activities):\n    def is_a_selected_activity(act):\n        # more rigorous check if activity in activities; Activity.__eq__ is not sufficient here\n        return act.isin_exact(activities)\n\n    self.remove_activities(person, p=is_a_selected_activity)\n</code></pre>"},{"location":"reference/pam/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_person_activities","title":"<code>remove_person_activities(person)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_person_activities(self, person):\n    def return_true(act):\n        return True\n\n    self.remove_activities(person, p=return_true)\n</code></pre>"},{"location":"reference/pam/policy/policies/","title":"pam.policy.policies","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.ActivityPolicy","title":"<code>ActivityPolicy(modifier, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PolicyLevel</code></p> <p>Policy that is to be applied on an individual activity level.</p> PARAMETER  DESCRIPTION <code>modifier</code> <p>the class which governs the change to be performed to the activities in a person's plan.</p> <p> TYPE: <code>Modifier</code> </p> <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select activity for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self,\n    modifier: modifiers.Modifier,\n    probability: Union[float, int, probability_samplers.SamplingProbability],\n    attribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n    \"\"\"Policy that is to be applied on an individual activity level.\n\n    Args:\n        modifier (modifiers.Modifier): the class which governs the change to be performed to the activities in a person's plan.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select activity for policy application based on object attributes. Defaults to None.\n    \"\"\"\n    super().__init__(modifier, attribute_filter)\n    self.probability = probability_samplers.verify_probability(\n        probability,\n        (probability_samplers.HouseholdProbability, probability_samplers.PersonProbability),\n    )\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.ActivityPolicy.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.ActivityPolicy.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.ActivityPolicy.probability","title":"<code>probability = probability_samplers.verify_probability(probability, (probability_samplers.HouseholdProbability, probability_samplers.PersonProbability))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.ActivityPolicy.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    for pid, person in household.people.items():\n        if self.attribute_filter.satisfies_conditions(person):\n            activities_to_purge = []\n            for activity in person.activities:\n                if isinstance(self.probability, list):\n                    p = 1\n                    for prob in self.probability:\n                        p *= prob.p(activity)\n                    if random.random() &lt; p:\n                        activities_to_purge.append(activity)\n                elif self.probability.sample(activity):\n                    activities_to_purge.append(activity)\n            if activities_to_purge:\n                self.modifier.apply_to(household, person, activities_to_purge)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.ActivityPolicy.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdPolicy","title":"<code>HouseholdPolicy(modifier, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PolicyLevel</code></p> <p>Policy that is to be applied on a household level.</p> PARAMETER  DESCRIPTION <code>modifier</code> <p>The class which governs the change to be performed to the activities in a person's plan.</p> <p> TYPE: <code>Modifier</code> </p> <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. The household policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self,\n    modifier: modifiers.Modifier,\n    probability: Union[float, int, probability_samplers.SamplingProbability],\n    attribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n    \"\"\"Policy that is to be applied on a household level.\n\n    Args:\n        modifier (modifiers.Modifier): The class which governs the change to be performed to the activities in a person's plan.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            The household policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select household for policy application based on object attributes. Defaults to None.\n    \"\"\"\n\n    super().__init__(modifier, attribute_filter)\n    self.probability = probability_samplers.verify_probability(probability)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdPolicy.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdPolicy.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdPolicy.probability","title":"<code>probability = probability_samplers.verify_probability(probability)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdPolicy.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    if self.attribute_filter.satisfies_conditions(household):\n        if isinstance(self.probability, list):\n            p = 1\n            for prob in self.probability:\n                p *= prob.p(household)\n            if random.random() &lt; p:\n                self.modifier.apply_to(household)\n        elif self.probability.sample(household):\n            self.modifier.apply_to(household)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdPolicy.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdQuarantined","title":"<code>HouseholdQuarantined(probability)</code>","text":"<p>             Bases: <code>Policy</code></p> <p>Household level Policy which removes all non-home activities for all persons in a household.</p> PARAMETER  DESCRIPTION <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. This policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self, probability: Union[float, int, probability_samplers.SamplingProbability]\n) -&gt; None:\n    \"\"\"Household level Policy which removes all non-home activities for all persons in a household.\n\n    Args:\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            This policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.\n    \"\"\"\n    super().__init__()\n    self.probability = probability_samplers.verify_probability(probability)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdQuarantined.probability","title":"<code>probability = probability_samplers.verify_probability(probability)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdQuarantined.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    p = self.probability.p(household)\n    if random.random() &lt; p:\n        for pid, person in household.people.items():\n            person.stay_at_home()\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.HouseholdQuarantined.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.MovePersonActivitiesToHome","title":"<code>MovePersonActivitiesToHome(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PersonPolicy</code></p> <p>Pre-packaged person-level policy which moves a tour of activities to home location.</p> <p>A tour is defined as a list of activities sandwiched between two home activities.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be considered in a tour. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The activity policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes.. Defaults to None.</p> <p> TYPE: <code>Optional[Filter]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self,\n    activities: list,\n    probability: Union[float, int, probability_samplers.SamplingProbability],\n    attribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n    \"\"\"Pre-packaged person-level policy which moves a tour of activities to home location.\n\n    A tour is defined as a list of activities sandwiched between two home activities.\n\n    Args:\n        activities (list):\n            List of activities to be considered in a tour.\n            Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The activity policy accepts all but 'HouseholdProbability' level of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n        attribute_filter (Optional[filters.Filter], optional):\n            If given, helps filter/select household for policy application based on object attributes.. Defaults to None.\n    \"\"\"\n    super().__init__(\n        modifiers.MoveActivityTourToHomeLocation(activities), probability, attribute_filter\n    )\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.MovePersonActivitiesToHome.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.MovePersonActivitiesToHome.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.MovePersonActivitiesToHome.probability","title":"<code>probability = probability_samplers.verify_probability(probability, probability_samplers.HouseholdProbability)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.MovePersonActivitiesToHome.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    for pid, person in household.people.items():\n        if self.attribute_filter.satisfies_conditions(person):\n            if isinstance(self.probability, list):\n                p = 1\n                for prob in self.probability:\n                    p *= prob.p(person)\n                if random.random() &lt; p:\n                    self.modifier.apply_to(household, person)\n            elif self.probability.sample(person):\n                self.modifier.apply_to(household, person)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.MovePersonActivitiesToHome.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonPolicy","title":"<code>PersonPolicy(modifier, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PolicyLevel</code></p> <p>Policy that is to be applied on a person level.</p> PARAMETER  DESCRIPTION <code>modifier</code> <p>the class which governs the change to be performed to the activities in a person's plan.</p> <p> TYPE: <code>Modifier</code> </p> <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select person for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self,\n    modifier: modifiers.Modifier,\n    probability: Union[float, int, probability_samplers.SamplingProbability],\n    attribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n    \"\"\"Policy that is to be applied on a person level.\n\n    Args:\n        modifier (modifiers.Modifier): the class which governs the change to be performed to the activities in a person's plan.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select person for policy application based on object attributes. Defaults to None.\n    \"\"\"\n    super().__init__(modifier, attribute_filter)\n    self.probability = probability_samplers.verify_probability(\n        probability, (probability_samplers.HouseholdProbability)\n    )\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonPolicy.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonPolicy.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonPolicy.probability","title":"<code>probability = probability_samplers.verify_probability(probability, probability_samplers.HouseholdProbability)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonPolicy.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    for pid, person in household.people.items():\n        if self.attribute_filter.satisfies_conditions(person):\n            if isinstance(self.probability, list):\n                p = 1\n                for prob in self.probability:\n                    p *= prob.p(person)\n                if random.random() &lt; p:\n                    self.modifier.apply_to(household, person)\n            elif self.probability.sample(person):\n                self.modifier.apply_to(household, person)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonPolicy.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonStayAtHome","title":"<code>PersonStayAtHome(probability)</code>","text":"<p>             Bases: <code>Policy</code></p> <p>Person level Policy which removes all non-home activities for a person.</p> PARAMETER  DESCRIPTION <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self, probability: Union[float, int, probability_samplers.SamplingProbability]\n) -&gt; None:\n    \"\"\"Person level Policy which removes all non-home activities for a person.\n\n    Args:\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n    \"\"\"\n    super().__init__()\n    self.probability = probability_samplers.verify_probability(\n        probability, (probability_samplers.HouseholdProbability)\n    )\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonStayAtHome.probability","title":"<code>probability = probability_samplers.verify_probability(probability, probability_samplers.HouseholdProbability)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonStayAtHome.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    for pid, person in household.people.items():\n        if random.random() &lt; self.probability.p(person):\n            person.stay_at_home()\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.PersonStayAtHome.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.Policy","title":"<code>Policy()</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for policies.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self):\n    pass\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.Policy.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>  <code>abstractmethod</code>","text":"<p>Uses self.probability to decide if household/person/activity should be selected.</p> PARAMETER  DESCRIPTION <code>household</code> <p> TYPE: <code>Household</code> </p> <code>person</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[Person]</code> DEFAULT: <code>None</code> </p> <code>activities</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[list[Activity]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>@abstractmethod\ndef apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    \"\"\"Uses self.probability to decide if household/person/activity should be selected.\n\n    Args:\n        household (Household):\n        person (Optional[Person], optional): Defaults to None.\n        activities (Optional[list[Activity]], optional): Defaults to None.\n    \"\"\"\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.Policy.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.PolicyLevel","title":"<code>PolicyLevel(modifier, attribute_filter=None)</code>","text":"<p>             Bases: <code>Policy</code></p> <p>Base class to formalise the hierarchy of levels at which a policy should applied at.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self, modifier: modifiers.Modifier, attribute_filter: Optional[filters.Filter] = None\n):\n    super().__init__()\n    assert isinstance(\n        modifier, modifiers.Modifier\n    ), \"modifier needs to be subclass of {}\".format(type(modifiers.Modifier))\n    self.modifier = modifier\n    if attribute_filter is None:\n        self.attribute_filter = filters.PersonAttributeFilter({})\n    else:\n        self.attribute_filter = attribute_filter\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.PolicyLevel.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.PolicyLevel.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.PolicyLevel.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    super().apply_to(household, person, activities)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.PolicyLevel.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.ReduceSharedHouseholdActivities","title":"<code>ReduceSharedHouseholdActivities(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>HouseholdPolicy</code></p> <p>Pre-packaged household-level policy which reduces the number of activities shared within a household.</p> <p>Activity.act (type of activity), start/end times and locations match. Randomly assigns a person whose activities will be retained and deletes the shared activities from other persons in household.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities that should be considered for sharing. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The activity policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Optional[Filter]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self,\n    activities: list,\n    probability: Union[float, int, probability_samplers.SamplingProbability],\n    attribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n    \"\"\"Pre-packaged household-level policy which reduces the number of activities shared within a household.\n\n    Activity.act (type of activity), start/end times and locations match.\n    Randomly assigns a person whose activities will be retained and deletes the shared activities from other persons in household.\n\n    Args:\n        activities (list):\n            List of activities that should be considered for sharing.\n            Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The activity policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n        attribute_filter (Optional[filters.Filter], optional):\n            If given, helps filter/select household for policy application based on object attributes. Defaults to None.\n    \"\"\"\n    super().__init__(modifiers.ReduceSharedActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.ReduceSharedHouseholdActivities.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.ReduceSharedHouseholdActivities.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.ReduceSharedHouseholdActivities.probability","title":"<code>probability = probability_samplers.verify_probability(probability)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.ReduceSharedHouseholdActivities.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    if self.attribute_filter.satisfies_conditions(household):\n        if isinstance(self.probability, list):\n            p = 1\n            for prob in self.probability:\n                p *= prob.p(household)\n            if random.random() &lt; p:\n                self.modifier.apply_to(household)\n        elif self.probability.sample(household):\n            self.modifier.apply_to(household)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.ReduceSharedHouseholdActivities.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveHouseholdActivities","title":"<code>RemoveHouseholdActivities(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>HouseholdPolicy</code></p> <p>Pre-packaged household-level policy which removes specified activities from all person's plans within selected households.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be removed.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The household policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self,\n    activities: list,\n    probability: Union[float, int, probability_samplers.SamplingProbability],\n    attribute_filter: Optional[filters.Filter] = None,\n):\n    \"\"\"Pre-packaged household-level policy which removes specified activities from all person's plans within selected households.\n\n    Args:\n        activities (list): List of activities to be removed.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The household policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select household for policy application based on object attributes. Defaults to None.\n    \"\"\"\n    super().__init__(modifiers.RemoveActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveHouseholdActivities.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveHouseholdActivities.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveHouseholdActivities.probability","title":"<code>probability = probability_samplers.verify_probability(probability)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveHouseholdActivities.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    if self.attribute_filter.satisfies_conditions(household):\n        if isinstance(self.probability, list):\n            p = 1\n            for prob in self.probability:\n                p *= prob.p(household)\n            if random.random() &lt; p:\n                self.modifier.apply_to(household)\n        elif self.probability.sample(household):\n            self.modifier.apply_to(household)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveHouseholdActivities.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveIndividualActivities","title":"<code>RemoveIndividualActivities(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>ActivityPolicy</code></p> <p>Pre-packaged activity-level policy which removes specified activities from all person's plans within selected households.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be removed.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Optional[Filter]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self,\n    activities: list,\n    probability: Union[float, int, probability_samplers.SamplingProbability],\n    attribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n    \"\"\"Pre-packaged activity-level policy which removes specified activities from all person's plans within selected households.\n\n    Args:\n        activities (list):  List of activities to be removed.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.\n        attribute_filter (Optional[filters.Filter], optional):\n            If given, helps filter/select household for policy application based on object attributes. Defaults to None.\n    \"\"\"\n    super().__init__(modifiers.RemoveActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveIndividualActivities.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveIndividualActivities.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveIndividualActivities.probability","title":"<code>probability = probability_samplers.verify_probability(probability, (probability_samplers.HouseholdProbability, probability_samplers.PersonProbability))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveIndividualActivities.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    for pid, person in household.people.items():\n        if self.attribute_filter.satisfies_conditions(person):\n            activities_to_purge = []\n            for activity in person.activities:\n                if isinstance(self.probability, list):\n                    p = 1\n                    for prob in self.probability:\n                        p *= prob.p(activity)\n                    if random.random() &lt; p:\n                        activities_to_purge.append(activity)\n                elif self.probability.sample(activity):\n                    activities_to_purge.append(activity)\n            if activities_to_purge:\n                self.modifier.apply_to(household, person, activities_to_purge)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemoveIndividualActivities.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemovePersonActivities","title":"<code>RemovePersonActivities(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PersonPolicy</code></p> <p>Pre-packaged person-level policy which removes specified activities from all person's plans within selected households.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be removed.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The person policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select person for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\n    self,\n    activities: list,\n    probability: Union[float, int, probability_samplers.SamplingProbability],\n    attribute_filter: Optional[filters.Filter] = None,\n):\n    \"\"\"Pre-packaged person-level policy which removes specified activities from all person's plans within selected households.\n\n    Args:\n        activities (list):  List of activities to be removed.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The person policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select person for policy application based on object attributes. Defaults to None.\n    \"\"\"\n    super().__init__(modifiers.RemoveActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemovePersonActivities.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemovePersonActivities.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemovePersonActivities.probability","title":"<code>probability = probability_samplers.verify_probability(probability, probability_samplers.HouseholdProbability)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemovePersonActivities.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\n    self,\n    household: Household,\n    person: Optional[Person] = None,\n    activities: Optional[list[Activity]] = None,\n) -&gt; None:\n    for pid, person in household.people.items():\n        if self.attribute_filter.satisfies_conditions(person):\n            if isinstance(self.probability, list):\n                p = 1\n                for prob in self.probability:\n                    p *= prob.p(person)\n                if random.random() &lt; p:\n                    self.modifier.apply_to(household, person)\n            elif self.probability.sample(person):\n                self.modifier.apply_to(household, person)\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.RemovePersonActivities.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/policies/#pam.policy.policies.apply_policies","title":"<code>apply_policies(population, policies, in_place=False)</code>","text":"<p>Method which applies policies to population.</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> <code>policies</code> <p>Policies to be applied to the population.</p> <p> TYPE: <code>Union[list[Policy], Policy]</code> </p> <code>in_place</code> <p>Whether to apply policies to current Population (True) object or return a copy (False). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[Population]</code> <p>pam.core.Population, optional: if <code>in_place</code> is False.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_policies(\n    population: Population, policies: Union[list[Policy], Policy], in_place: bool = False\n) -&gt; Optional[Population]:\n    \"\"\"Method which applies policies to population.\n\n    Args:\n      population (pam.core.Population):\n      policies (Union[list[Policy], Policy]): Policies to be applied to the population.\n      in_place (bool): Whether to apply policies to current Population (True) object or return a copy (False). Defaults to False.\n\n    Returns:\n      pam.core.Population, optional: if `in_place` is False.\n\n    \"\"\"\n    if not in_place:\n        pop = deepcopy(population)\n    else:\n        pop = population\n\n    if isinstance(policies, Policy):\n        policies = [policies]\n    for i in range(len(policies)):\n        policy = policies[i]\n        assert isinstance(\n            policy, Policy\n        ), \"Policies need to be of type {}, not {}. Failed for policy {} at list index {}\".format(\n            type(Policy), type(policy), policy, i\n        )\n    for hid, household in pop.households.items():\n        for policy in policies:\n            policy.apply_to(household)\n    if not in_place:\n        return pop\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/","title":"pam.policy.probability_samplers","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability","title":"<code>ActivityProbability(activities, probability, kwargs=None)</code>","text":"<p>             Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which evaluates value of probability at household, person and activity level based on probability for an activity.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>A float/int: 0&lt;probability&lt;=1 or a function which given input of pam.core.Activity returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the activity being sampled.</p> <p> TYPE: <code>Union[float, int, Callable[[Activity]]]</code> </p> <code>kwargs</code> <p>Keyword arguments to add when calling <code>probability</code>, if it is a Callable. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(\n    self,\n    activities: list,\n    probability: Union[float, int, Callable[[pam.activity.Activity], float]],\n    kwargs: Optional[dict] = None,\n) -&gt; None:\n    \"\"\"A probabilistic sampler which evaluates value of probability at household, person and activity level based on probability for an activity.\n\n    Args:\n        activities (list): List of activities.\n        probability (Union[float, int, Callable[[pam.activity.Activity]]]):\n            A float/int: 0&lt;probability&lt;=1 or a function which given input of pam.core.Activity returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the activity being sampled.\n        kwargs (Optional[dict], optional): Keyword arguments to add when calling `probability`, if it is a Callable. Defaults to None.\n    \"\"\"\n    super().__init__(probability)\n    self.activities = activities\n    assert isinstance(self.probability, float) or callable(self.probability)\n    if kwargs is None:\n        self.kwargs = {}\n    else:\n        self.kwargs = kwargs\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.kwargs","title":"<code>kwargs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.probability","title":"<code>probability = probability</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.compute_probability_for_activity","title":"<code>compute_probability_for_activity(activity)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def compute_probability_for_activity(self, activity):\n    if isinstance(self.probability, float):\n        return self.probability\n    elif callable(self.probability):\n        return self.probability(activity, **self.kwargs)\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.is_relevant_activity","title":"<code>is_relevant_activity(act)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def is_relevant_activity(self, act):\n    return act.act.lower() in self.activities\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\n    if isinstance(x, pam.core.Household):\n        p = 1\n        for pid, person in x.people.items():\n            for act in person.activities:\n                if self.is_relevant_activity(act):\n                    p *= 1 - self.compute_probability_for_activity(act)\n        return 1 - p\n    elif isinstance(x, pam.core.Person):\n        p = 1\n        for act in x.activities:\n            if self.is_relevant_activity(act):\n                p *= 1 - self.compute_probability_for_activity(act)\n        return 1 - p\n    elif isinstance(x, pam.activity.Activity):\n        if self.is_relevant_activity(x):\n            return self.compute_probability_for_activity(x)\n        return 0\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.sample","title":"<code>sample(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def sample(self, x):\n    return random.random() &lt; self.p(x)\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability","title":"<code>HouseholdProbability(probability, kwargs=None)</code>","text":"<p>             Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which evaluates value of probability at household level based on probability for a household.</p> PARAMETER  DESCRIPTION <code>probability</code> <p>0&lt;probability&lt;=1, or a function which given input of pam.core.Household returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the household being sampled.</p> <p> TYPE: <code>Union[float, int, Callable[[Household], float]]</code> </p> <code>kwargs</code> <p>Keyword arguments to add when calling <code>probability</code>, if it is a Callable. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(\n    self,\n    probability: Union[float, int, Callable[[pam.core.Household], float]],\n    kwargs: Optional[dict] = None,\n) -&gt; None:\n    \"\"\"A probabilistic sampler which evaluates value of probability at household level based on probability for a household.\n\n    Args:\n        probability (Union[float, int, Callable[[pam.core.Household], float]]):\n            0&lt;probability&lt;=1, or a function which given input of pam.core.Household returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the household being sampled.\n        kwargs (Optional[dict], optional): Keyword arguments to add when calling `probability`, if it is a Callable. Defaults to None.\n    \"\"\"\n    super().__init__(probability)\n    assert isinstance(self.probability, float) or callable(self.probability)\n    if kwargs is None:\n        self.kwargs = {}\n    else:\n        self.kwargs = kwargs\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.kwargs","title":"<code>kwargs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.probability","title":"<code>probability = probability</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.compute_probability_for_household","title":"<code>compute_probability_for_household(household)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def compute_probability_for_household(self, household):\n    if isinstance(self.probability, float):\n        return self.probability\n    elif callable(self.probability):\n        return self.probability(household, **self.kwargs)\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\n    if isinstance(x, pam.core.Household):\n        return self.compute_probability_for_household(x)\n    elif isinstance(x, pam.core.Person):\n        raise NotImplementedError\n    elif isinstance(x, pam.activity.Activity):\n        raise NotImplementedError\n    else:\n        raise TypeError\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.sample","title":"<code>sample(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def sample(self, x):\n    return random.random() &lt; self.p(x)\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability","title":"<code>PersonProbability(probability, kwargs=None)</code>","text":"<p>             Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which evaluates value of probability at household and person level based on probability for a person.</p> PARAMETER  DESCRIPTION <code>probability</code> <p>0&lt;probability&lt;=1 or a function which given input of pam.core.Person returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the person being sampled.</p> <p> TYPE: <code>Union[float, int, Callable[[Person], float]]</code> </p> <code>kwargs</code> <p>Keyword arguments to add when calling <code>probability</code>, if it is a Callable. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(\n    self,\n    probability: Union[float, int, Callable[[pam.core.Person], float]],\n    kwargs: Optional[dict] = None,\n) -&gt; None:\n    \"\"\"A probabilistic sampler which evaluates value of probability at household and person level based on probability for a person.\n\n    Args:\n        probability (Union[float, int, Callable[[pam.core.Person], float]]):\n            0&lt;probability&lt;=1 or a function which given input of pam.core.Person returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the person being sampled.\n        kwargs (Optional[dict], optional): Keyword arguments to add when calling `probability`, if it is a Callable. Defaults to None.\n    \"\"\"\n    super().__init__(probability)\n    assert isinstance(self.probability, float) or callable(self.probability)\n    if kwargs is None:\n        self.kwargs = {}\n    else:\n        self.kwargs = kwargs\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.kwargs","title":"<code>kwargs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.probability","title":"<code>probability = probability</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.compute_probability_for_person","title":"<code>compute_probability_for_person(person)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def compute_probability_for_person(self, person):\n    if isinstance(self.probability, float):\n        return self.probability\n    elif callable(self.probability):\n        return self.probability(person, **self.kwargs)\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\n    if isinstance(x, pam.core.Household):\n        p = 1\n        for pid, person in x.people.items():\n            p *= 1 - self.compute_probability_for_person(person)\n        return 1 - p\n    elif isinstance(x, pam.core.Person):\n        return self.compute_probability_for_person(x)\n    elif isinstance(x, pam.activity.Activity):\n        raise NotImplementedError\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.sample","title":"<code>sample(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def sample(self, x):\n    return random.random() &lt; self.p(x)\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability","title":"<code>SamplingProbability(probability)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for probabilistic samplers.</p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(self, probability: Union[float, int]):\n    if isinstance(probability, int):\n        probability = float(probability)\n    if isinstance(probability, float):\n        assert 0 &lt; probability &lt;= 1\n    self.probability = probability\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.probability","title":"<code>probability = probability</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.p","title":"<code>p(x)</code>  <code>abstractmethod</code>","text":"<p>Compute probability</p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>@abstractmethod\ndef p(self, x):\n    \"Compute probability\"\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.sample","title":"<code>sample(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def sample(self, x):\n    return random.random() &lt; self.p(x)\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability","title":"<code>SimpleProbability(probability)</code>","text":"<p>             Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which returns value of probability at the same level as the input (household/person/activity).</p> PARAMETER  DESCRIPTION <code>probability</code> <p>0&lt;probability&lt;=1.</p> <p> TYPE: <code>Union[float, int]</code> </p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(self, probability: Union[float, int]) -&gt; None:\n    \"\"\"A probabilistic sampler which returns value of probability at the same level as the input (household/person/activity).\n\n    Args:\n        probability (Union[float, int]): 0&lt;probability&lt;=1.\n    \"\"\"\n    super().__init__(probability)\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability.probability","title":"<code>probability = probability</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\n    return self.probability\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability.sample","title":"<code>sample(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def sample(self, x):\n    return random.random() &lt; self.p(x)\n</code></pre>"},{"location":"reference/pam/policy/probability_samplers/#pam.policy.probability_samplers.verify_probability","title":"<code>verify_probability(probability, unacceptable_types=None)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def verify_probability(probability, unacceptable_types=None):\n    if unacceptable_types is None:\n        unacceptable_types = ()\n    if isinstance(probability, int):\n        probability = float(probability)\n    assert not isinstance(\n        probability, unacceptable_types\n    ), \"{} is of type {} which is not accepted. Check your policy's application level.\".format(\n        probability, type(probability)\n    )\n    if isinstance(probability, float):\n        assert 0 &lt; probability &lt;= 1\n        probability = SimpleProbability(probability)\n    elif isinstance(probability, list):\n        for i in range(len(probability)):\n            assert not isinstance(\n                probability[i], unacceptable_types\n            ), \"{} is of type {} which is not accepted. Check your policy's application level\".format(\n                probability[i], type(probability[i])\n            )\n            if isinstance(probability[i], float):\n                probability[i] = SimpleProbability(probability[i])\n    else:\n        assert isinstance(\n            probability, SamplingProbability\n        ), \"Probability passed to a policy needs to be float, integer or {}, not {}\".format(\n            type(SamplingProbability), type(probability)\n        )\n    return probability\n</code></pre>"},{"location":"reference/pam/read/diary/","title":"pam.read.diary","text":""},{"location":"reference/pam/read/diary/#pam.read.diary.add_hhs_from_hhs_attributes","title":"<code>add_hhs_from_hhs_attributes(population, hhs_attributes=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_hhs_from_hhs_attributes(\n    population: core.Population, hhs_attributes: Optional[pd.DataFrame] = None\n):\n    logger = logging.getLogger(__name__)\n\n    if hhs_attributes is None:\n        return None\n\n    logger.info(\"Adding hhs from hhs_attributes\")\n    for hid, hh in hhs_attributes.groupby(\"hid\"):\n        if hid not in population.households:\n            hh_attributes = hhs_attributes.loc[hid].to_dict()\n            household = core.Household(\n                hid,\n                attributes=hh_attributes,\n                freq=hh_attributes.pop(\"freq\", None),\n                area=hh_attributes.pop(\"hzone\", None),\n            )\n            population.add(household)\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.add_hhs_from_persons_attributes","title":"<code>add_hhs_from_persons_attributes(population, persons_attributes=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_hhs_from_persons_attributes(\n    population: core.Population, persons_attributes: Optional[pd.DataFrame] = None\n):\n    logger = logging.getLogger(__name__)\n\n    if persons_attributes is None or \"hid\" not in persons_attributes.columns:\n        return None\n\n    if \"hzone\" in persons_attributes.columns:\n        hzone_lookup = persons_attributes.groupby(\"hid\").head(1).set_index(\"hid\").hzone.to_dict()\n    else:\n        hzone_lookup = {}\n\n    logger.info(\"Adding hhs from persons_attributes\")\n    for hid, hh_data in persons_attributes.groupby(\"hid\"):\n        if hid not in population.households:\n            hzone = hzone_lookup.get(hid)\n            household = core.Household(hid, area=hzone)\n            population.add(household)\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.add_hhs_from_trips","title":"<code>add_hhs_from_trips(population, trips=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_hhs_from_trips(population: core.Population, trips: Optional[pd.DataFrame] = None):\n    logger = logging.getLogger(__name__)\n\n    if trips is None or \"hid\" not in trips.columns:\n        return None\n\n    logger.info(\"Adding hhs from trips\")\n    for hid, hh_data in trips.groupby(\"hid\"):\n        if hid not in population.households:\n            hzone = hh_data.iloc[0].to_dict().get(\"hzone\")\n            household = core.Household(hid, area=hzone)\n            population.add(household)\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.add_persons_from_persons_attributes","title":"<code>add_persons_from_persons_attributes(population, persons_attributes=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_persons_from_persons_attributes(\n    population: core.Population, persons_attributes: Optional[pd.DataFrame] = None\n):\n    logger = logging.getLogger(__name__)\n\n    if persons_attributes is None or \"hid\" not in persons_attributes.columns:\n        return None\n\n    persons_attributes_dict = (\n        persons_attributes.reset_index().set_index([\"hid\", \"pid\"]).to_dict(\"index\")\n    )\n\n    logger.info(\"Adding persons from persons_attributes\")\n    for hid, hh_data in persons_attributes.groupby(\"hid\"):\n        household = population.get(hid)\n        if household is None:\n            logger.warning(f\"Failed to find household {hid} in population - unable to add person.\")\n            continue\n        for pid in hh_data.index:\n            if pid in household.people:\n                continue\n\n            person_attributes = persons_attributes_dict[hid, pid]\n\n            person = core.Person(\n                pid,\n                attributes=person_attributes,\n                home_area=person_attributes.get(\"hzone\", None),\n                freq=person_attributes.pop(\"freq\", None),\n            )\n            household.add(person)\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.add_persons_from_trips","title":"<code>add_persons_from_trips(population, trips=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_persons_from_trips(population: core.Population, trips: Optional[pd.DataFrame] = None):\n    logger = logging.getLogger(__name__)\n\n    if trips is None or \"hid\" not in trips.columns:\n        return None\n\n    logger.info(\"Adding persons from trips\")\n    for (hid, pid), hh_person_data in trips.groupby([\"hid\", \"pid\"]):\n        household = population.households.get(hid)\n        if household is None:\n            logger.warning(f\"Failed to find household {hid} in population - unable to add person.\")\n            continue\n        if pid in household.people:\n            continue\n        person = core.Person(pid, home_area=hh_person_data.iloc[0].to_dict().get(\"hzone\"))\n        household.add(person)\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.build_population","title":"<code>build_population(trips=None, persons_attributes=None, hhs_attributes=None)</code>","text":"<p>Build a population of households and persons (without plans).</p> <p>Built from available trips, persons_attributes and households_attributes data. Details of required table formats are in the README.</p> PARAMETER  DESCRIPTION <code>trips</code> <p>trips table. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>persons_attributes</code> <p>persons attributes table. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>households attributes table. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>pam.Population: population object</p> Source code in <code>pam/read/diary.py</code> <pre><code>def build_population(\n    trips: Optional[pd.DataFrame] = None,\n    persons_attributes: Optional[pd.DataFrame] = None,\n    hhs_attributes: Optional[pd.DataFrame] = None,\n) -&gt; core.Population:\n    \"\"\"Build a population of households and persons (without plans).\n\n    Built from available trips, persons_attributes and households_attributes data.\n    Details of required table formats are in the README.\n\n    Args:\n      trips (Optional[pd.DataFrame]): trips table. Defaults to None.\n      persons_attributes (Optional[pd.DataFrame]): persons attributes table. Defaults to None.\n      hhs_attributes (Optional[pd.DataFrame]): households attributes table. Defaults to None.\n\n    Returns:\n      pam.Population: population object\n\n    \"\"\"\n    population = core.Population()\n    add_hhs_from_hhs_attributes(population=population, hhs_attributes=hhs_attributes)\n    add_hhs_from_persons_attributes(population=population, persons_attributes=persons_attributes)\n    add_hhs_from_trips(population=population, trips=trips)\n    add_persons_from_persons_attributes(\n        population=population, persons_attributes=persons_attributes\n    )\n    add_persons_from_trips(population=population, trips=trips)\n\n    return population\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.from_to_travel_diary_read","title":"<code>from_to_travel_diary_read(trips, persons_attributes=None, hhs_attributes=None, include_loc=False, sort_by_seq=False)</code>","text":"<p>Turn Diary Plan tabular data inputs into core population format.</p> <p>Tabular data derived from travel survey and attributes.</p> <p>This is a variation of the standard load_travel_diary() method because it does not require activity inference or home location. We expect broadly the same data schema except rather than purp (purpose) we use trips oact (origin activity) and dact (destination activity).</p> PARAMETER  DESCRIPTION <code>trips</code> <p> TYPE: <code>DataFrame</code> </p> <code>persons_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>include_loc</code> <p>optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns) (Default value = False). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_by_seq</code> <p>optionally force trip sorting as True or False. Defaults to False.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/diary.py</code> <pre><code>def from_to_travel_diary_read(\n    trips: pd.DataFrame,\n    persons_attributes: Optional[pd.DataFrame] = None,\n    hhs_attributes: Optional[pd.DataFrame] = None,\n    include_loc: bool = False,\n    sort_by_seq: Optional[bool] = False,\n) -&gt; core.Population:\n    \"\"\"Turn Diary Plan tabular data inputs into core population format.\n\n    Tabular data derived from travel survey and attributes.\n\n    This is a variation of the standard load_travel_diary() method because it does not require activity inference or home location.\n    We expect broadly the same data schema except rather than purp (purpose) we use trips oact (origin activity) and dact (destination activity).\n\n    Args:\n        trips (pd.DataFrame):\n        persons_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        hhs_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        include_loc (bool, optional): optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns) (Default value = False). Defaults to False.\n        sort_by_seq (Optional[bool], optional): optionally force trip sorting as True or False. Defaults to False.\n\n    Returns:\n        core.Population:\n    \"\"\"\n    logger = logging.getLogger(__name__)\n\n    population = build_population(\n        trips=trips, persons_attributes=persons_attributes, hhs_attributes=hhs_attributes\n    )\n\n    if sort_by_seq is None and \"seq\" in trips.columns:\n        sort_by_seq = True\n    if \"seq\" not in trips.columns:\n        seq = trips.groupby([\"hid\", \"pid\"]).cumcount()\n        trips = trips.assign(seq=seq.values)\n\n    trips = trips.set_index([\"hid\", \"pid\", \"seq\"])\n\n    if sort_by_seq:\n        trips = trips.sort_index()\n\n    for hid, household in population:\n        for pid, person in household:\n            try:\n                person_trips = trips.loc[hid, pid]\n            except KeyError:\n                person.stay_at_home()\n                continue\n\n            first_act = person_trips.iloc[0].oact.lower()\n            if not first_act == \"home\":\n                logger.warning(\n                    f\" Person pid:{pid} hid:{hid} plan does not start with 'home' activity: {first_act}\"\n                )\n\n            loc = None\n            if include_loc:\n                loc = person_trips.start_loc.iloc[0]\n\n            person.add(\n                activity.Activity(\n                    seq=0,\n                    act=first_act,\n                    area=person_trips.iloc[0].ozone,\n                    loc=loc,\n                    start_time=utils.parse_time(0),\n                )\n            )\n\n            for seq, trip in person_trips.iterrows():\n                start_loc = None\n                end_loc = None\n                if include_loc:\n                    start_loc = trip.start_loc\n                    end_loc = trip.end_loc\n                purpose = trip.dact.lower()\n\n                person.add(\n                    activity.Leg(\n                        seq=seq,\n                        purp=purpose,\n                        mode=trip[\"mode\"].lower(),\n                        start_area=trip.ozone,\n                        end_area=trip.dzone,\n                        start_loc=start_loc,\n                        end_loc=end_loc,\n                        start_time=utils.parse_time(trip.tst),\n                        end_time=utils.parse_time(trip.tet),\n                        distance=trip.get(\"distance\"),\n                    )\n                )\n\n                person.add(\n                    activity.Activity(\n                        seq=seq + 1,\n                        act=purpose,\n                        area=trip.dzone,\n                        loc=end_loc,\n                        start_time=utils.parse_time(trip.tet),\n                    )\n                )\n\n            person.plan.finalise_activity_end_times()\n            household.add(person)\n\n        population.add(household)\n\n    return population\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.load_travel_diary","title":"<code>load_travel_diary(trips, persons_attributes=None, hhs_attributes=None, sample_perc=None, tour_based=True, from_to=False, include_loc=False, sort_by_seq=None, trip_freq_as_person_freq=False, trip_freq_as_hh_freq=False)</code>","text":"<p>Turn standard tabular data inputs (travel survey and attributes) into core population format.</p> PARAMETER  DESCRIPTION <code>trips</code> <p> TYPE: <code>Union[DataFrame, str]</code> </p> <code>persons_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Union[DataFrame, str, None]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Union[DataFrame, str, None]</code> DEFAULT: <code>None</code> </p> <code>sample_perc</code> <p>If different to None, it samples the travel population by the corresponding percentage. Defaults to None.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>tour_based</code> <p>Set to False to force a simpler trip-based purpose parser. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>from_to</code> <p>Set to True to force the from-to purpose parser (requires 'oact' and 'dact' trips columns). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_loc</code> <p>If True, include location data as shapely Point geometries ('start_loc' and 'end_loc' trips columns). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_by_seq</code> <p>If not None, force trip sorting as True or False. Defaults to None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> <code>trip_freq_as_person_freq</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>trip_freq_as_hh_freq</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/diary.py</code> <pre><code>def load_travel_diary(\n    trips: Union[pd.DataFrame, str],\n    persons_attributes: Union[pd.DataFrame, str, None] = None,\n    hhs_attributes: Union[pd.DataFrame, str, None] = None,\n    sample_perc: Optional[float] = None,\n    tour_based: bool = True,\n    from_to: bool = False,\n    include_loc: bool = False,\n    sort_by_seq: Optional[bool] = None,\n    trip_freq_as_person_freq: bool = False,\n    trip_freq_as_hh_freq: bool = False,\n) -&gt; core.Population:\n    \"\"\"Turn standard tabular data inputs (travel survey and attributes) into core population format.\n\n    Args:\n      trips (Union[pd.DataFrame, str]):\n      persons_attributes (Union[pd.DataFrame, str, None], optional): Defaults to None.\n      hhs_attributes (Union[pd.DataFrame, str, None], optional): Defaults to None.\n      sample_perc (float, optional): If different to None, it samples the travel population by the corresponding percentage. Defaults to None.\n      tour_based (bool, optional): Set to False to force a simpler trip-based purpose parser. Defaults to True.\n      from_to (bool, optional): Set to True to force the from-to purpose parser (requires 'oact' and 'dact' trips columns). Defaults to False.\n      include_loc (bool, optional): If True, include location data as shapely Point geometries ('start_loc' and 'end_loc' trips columns). Defaults to False.\n      sort_by_seq (bool, optional): If not None, force trip sorting as True or False. Defaults to None.\n      trip_freq_as_person_freq (bool, optional): Defaults to False.\n      trip_freq_as_hh_freq (bool, optional): Defaults to False.\n\n    Returns:\n      core.Population:\n    \"\"\"\n\n    # TODO check for required col headers and give useful error?\n\n    logger = logging.getLogger(__name__)\n\n    if isinstance(trips, str):\n        logger.warning(f\"Attempting to load trips dataframe from path: {trips}\")\n        trips = pd.read_csv(trips)\n\n    if isinstance(persons_attributes, str):\n        logger.warning(f\"Attempting to load trips dataframe from path: {persons_attributes}\")\n        persons_attributes = pd.read_csv(persons_attributes)\n\n    if isinstance(hhs_attributes, str):\n        logger.warning(f\"Attempting to load trips dataframe from path: {hhs_attributes}\")\n        hhs_attributes = pd.read_csv(hhs_attributes)\n\n    if not isinstance(trips, pd.DataFrame):\n        raise UserWarning(\"Unrecognised input for trips input.\")\n\n    if persons_attributes is not None and not isinstance(persons_attributes, pd.DataFrame):\n        raise UserWarning(\"Unrecognised input for person_attributes\")\n\n    if hhs_attributes is not None and not isinstance(hhs_attributes, pd.DataFrame):\n        raise UserWarning(\"Unrecognised input for hh_attributes\")\n\n    # reset indexes if named\n    for table in [trips, persons_attributes, hhs_attributes]:\n        if table is not None and table.index.name is not None:\n            table.reset_index(inplace=True)\n\n    if (\"oact\" in trips.columns and \"dact\" in trips.columns) or from_to:\n        logger.warning(\"Using from-to activity parser using 'oact' and 'dact' columns\")\n        from_to = True\n\n        # check that trips diary has required fields\n        missing = {\"pid\", \"ozone\", \"dzone\", \"oact\", \"dact\", \"mode\", \"tst\", \"tet\"} - set(\n            trips.columns\n        )\n\n        if missing:\n            raise UserWarning(f\"Input trips_diary missing required column names: {missing}.\")\n\n    else:\n        if tour_based:\n            logger.warning(\"Using tour based purpose parser (recommended)\")\n        else:\n            logger.warning(\n                \"\"\"\nUsing simple trip based purpose parser, this assumes first activity is 'home'.\nIf you do not wish to assume this, try setting 'tour_based' = True (default).\n\"\"\"\n            )\n\n        # check that trips diary has required fields\n        missing = {\"pid\", \"ozone\", \"dzone\", \"purp\", \"mode\", \"tst\", \"tet\"} - set(trips.columns)\n        if missing:\n            raise UserWarning(f\"Input trips_diary missing required column names: {missing}.\")\n\n    if sort_by_seq and \"seq\" not in trips.columns:\n        raise UserWarning(\n            \"\"\"\n    You must include a trips 'seq' column if you wish to sort trips:\n    Either include a 'seq' column or use the existing ordering by\n    setting 'sort_by_seq' = False/None (default).\n    \"\"\"\n        )\n\n    if include_loc and not all(x in trips.columns for x in [\"start_loc\", \"end_loc\"]):\n        raise UserWarning(\n            \"\"\"\n    You must include a trips 'start_loc' and 'end_loc' column if you wish to use precise locations:\n    Either include a 'start_loc' and 'end_loc' column or set 'include_loc' = False (default).\n    Note that these columns must be shapely Point geometries.\n    \"\"\"\n        )\n\n    if trip_freq_as_person_freq:  # use trip freq as person freq\n        if \"freq\" not in trips.columns:\n            raise UserWarning(\n                \"\"\"\n                You have opted to use 'trip_freq_as_person_freq' but cannot build this mapping:\n                Please check 'freq' is included in the trips_diary input.\n                \"\"\"\n            )\n\n        logger.info(\"Loading person freq ('freq') from trips_diary freq input.\")\n        pid_freq_map = dict(zip(trips.pid, trips.freq))  # this will take last freq from trips\n\n        if persons_attributes is None:\n            logger.info(\"Building new person attributes dataframe to hold person frequency.\")\n            persons_attributes = pd.DataFrame(\n                {\"pid\": list(pid_freq_map.keys()), \"freq\": list(pid_freq_map.values())}\n            )\n        else:\n            logger.info(\"Adding freq to person attributes using trip frequency.\")\n            persons_attributes[\"freq\"] = persons_attributes.pid.map(pid_freq_map)\n\n        trips.drop(\"freq\", axis=1, inplace=True)\n\n    if trip_freq_as_hh_freq:\n        if \"freq\" not in trips.columns:\n            raise UserWarning(\n                \"\"\"\n                You have opted to use 'trip_freq_as_hh_freq' but cannot build this mapping:\n                Please check 'freq' is included in the trips_diary input.\n                \"\"\"\n            )\n        if \"hid\" not in trips.columns:\n            raise UserWarning(\n                \"\"\"\n                You have opted to use 'trip_freq_as_hh_freq' but cannot build this mapping:\n                Please check 'hid' is included in the trips_diary input.\n                \"\"\"\n            )\n\n        logger.info(\"Loading houshold freq ('freq') from trips_diary freq input.\")\n        hid_freq_map = dict(zip(trips.hid, trips.freq))  # this will take last freq from trips\n\n        if hhs_attributes is None:\n            logger.info(\"Building new household attributes dataframe to hold houshold frequency.\")\n            hhs_attributes = pd.DataFrame(\n                {\"hid\": list(hid_freq_map.keys()), \"freq\": list(hid_freq_map.values())}\n            )\n        else:\n            logger.info(\"Adding freq to household attributes using trip frequency.\")\n            hhs_attributes[\"freq\"] = hhs_attributes.hid.map(hid_freq_map)\n\n        trips.drop(\"freq\", axis=1, inplace=True)\n\n    # add hid to trips if not already added\n    if (\n        \"hid\" not in trips.columns\n        and (persons_attributes is None or \"hid\" not in persons_attributes.columns)\n        and (hhs_attributes is None or \"pid\" not in hhs_attributes.columns)\n    ):\n        logger.warning(\n            \"\"\"\n            No household entities found, households will be composed of individual persons using 'pid':\n            If you wish to correct this, please add 'hid' to either the trips or persons_attributes inputs.\n            \"\"\"\n        )\n        trips[\"hid\"] = trips.pid\n\n    # check that person_attributes has required fields if used\n    if persons_attributes is not None:\n        if \"pid\" not in persons_attributes.columns and not persons_attributes.index.name == \"pid\":\n            raise UserWarning(\n                \"Input person_attributes dataframe missing required unique identifier column: 'pid'.\"\n            )\n\n        if \"hid\" not in persons_attributes and \"hid\" in trips:\n            logger.warning(\"Adding pid-&gt;hh mapping to persons_attributes from trips.\")\n            mapping = dict(zip(trips.pid, trips.hid))\n            persons_attributes[\"hid\"] = persons_attributes.pid.map(mapping)\n\n        if \"hzone\" not in persons_attributes.columns and \"hid\" in persons_attributes.columns:\n            if hhs_attributes is not None and \"hzone\" in hhs_attributes:\n                logger.warning(\"Adding home locations to persons attributes using hhs_attributes.\")\n                mapping = dict(zip(hhs_attributes.hid, hhs_attributes.hzone))\n                persons_attributes[\"hzone\"] = persons_attributes.hid.map(mapping)\n            elif \"hzone\" in trips and \"hid\" in trips:\n                logger.warning(\n                    \"Adding home locations to persons attributes using trips attributes.\"\n                )\n                mapping = dict(zip(trips.hid, trips.hzone))\n                persons_attributes[\"hzone\"] = persons_attributes.hid.map(mapping)\n\n    # check if hh_attributes are being used\n    if hhs_attributes is not None:\n        if \"hid\" not in hhs_attributes.columns and not hhs_attributes.index.name == \"hid\":\n            raise UserWarning(\n                \"Input hh_attributes dataframe missing required unique identifier column: 'hid'.\"\n            )\n\n        if \"hid\" in trips.columns:\n            logger.info(\"Using person to household mapping from trips_diary data\")\n            if persons_attributes is not None and \"hid\" not in persons_attributes.columns:\n                logger.info(\n                    \"Loading person to household mapping for person_attributes from trips data\"\n                )\n                person_hh_mapping = dict(zip(trips.pid, trips.hid))\n                persons_attributes[\"hid\"] = persons_attributes.pid.map(person_hh_mapping)\n\n        elif persons_attributes is not None and \"hid\" in persons_attributes.columns:\n            logger.info(\"Loading person to household mapping from person_attributes data\")\n            person_hh_mapping = dict(zip(persons_attributes.pid, persons_attributes.hid))\n            trips[\"hid\"] = trips.pid.map(person_hh_mapping)\n\n        else:\n            raise UserWarning(\n                \"\"\"\n            Household attributes found but failed to build person to household mapping from provided inputs:\n            Please provide a household ID field ('hid') in either the trips_diary or person_attributes inputs.\n            \"\"\"\n            )\n\n        if \"hzone\" not in hhs_attributes.columns:\n            if (\n                persons_attributes is not None\n                and \"hzone\" in persons_attributes\n                and \"hid\" in persons_attributes.columns\n            ):\n                logger.warning(\"Adding home locations to hhs attributes using persons_attributes.\")\n                mapping = dict(zip(persons_attributes.hid, persons_attributes.hzone))\n                hhs_attributes[\"hzone\"] = hhs_attributes.hid.map(mapping)\n            elif \"hzone\" in trips and \"hid\" in trips:\n                logger.warning(\"Adding home locations to hhs attributes using trips attributes.\")\n                mapping = dict(zip(trips.hid, trips.hzone))\n                hhs_attributes[\"hzone\"] = hhs_attributes.hid.map(mapping)\n\n    # add hzone to trips_diary\n    if \"hzone\" not in trips.columns:\n        if hhs_attributes is not None and \"hzone\" in hhs_attributes.columns:\n            logger.info(\"Loading household area ('hzone') from hh_attributes input.\")\n            hh_mapping = dict(zip(hhs_attributes.hid, hhs_attributes.hzone))\n            trips[\"hzone\"] = trips.hid.map(hh_mapping)\n        elif (\n            persons_attributes is not None\n            and \"hzone\" in persons_attributes.columns\n            and \"hid\" in persons_attributes.columns\n        ):\n            logger.info(\"Loading household area ('hzone') from person_attributes input.\")\n            hh_mapping = dict(zip(persons_attributes.hid, persons_attributes.hzone))\n            trips[\"hzone\"] = trips.hid.map(hh_mapping)\n        else:\n            logger.warning(\n                \"\"\"\n        Unable to load household area ('hzone') - not found in trips_diary or unable to build from attributes.\n        Pam will try to infer home location from activities, but this behaviour is not recommended.\n        \"\"\"\n            )\n\n    # Add an empty frequency fields if required\n    if \"freq\" not in trips.columns:\n        logger.warning(\"Using freq of 'None' for all trips.\")\n        trips[\"freq\"] = None\n\n    if persons_attributes is not None and \"freq\" not in persons_attributes.columns:\n        logger.warning(\"Using freq of 'None' for all persons.\")\n        persons_attributes[\"freq\"] = None\n\n    if hhs_attributes is not None and \"freq\" not in hhs_attributes.columns:\n        logger.warning(\"Using freq of 'None' for all households.\")\n        hhs_attributes[\"freq\"] = None\n\n    if sample_perc is not None:\n        if \"freq\" not in trips.columns:\n            raise UserWarning(\n                f\"\"\"\n                You have opted to use a sample ({sample_perc}, but this option requires that trips frequencies are set:):\n                Please add a 'freq' column to the trips dataframe or remove sampling (set 'sample_perc' = None).\n                \"\"\"\n            )\n        trips = sample_population(\n            trips=trips, sample_perc=sample_perc, weight_col=\"freq\"\n        )  # sample the travel population\n\n    logger.debug(\"Resetting trips index if required\")\n    if trips.index.name is not None:\n        persons_attributes.reset_index(inplace=True)\n\n    if persons_attributes is not None:\n        logger.debug(\"Setting persons_attributes index to pid\")\n        if persons_attributes.index.name is None:\n            persons_attributes.set_index(\"pid\", inplace=True)\n        elif not persons_attributes.index.name == \"pid\":\n            persons_attributes = persons_attributes.reset_index().set_index(\"pid\")\n\n    if hhs_attributes is not None:\n        logger.debug(\"Setting households_attributes index to hid\")\n        if hhs_attributes.index.name is None:\n            hhs_attributes.set_index(\"hid\", inplace=True)\n        elif not hhs_attributes.index.name == \"hid\":\n            hhs_attributes = hhs_attributes.reset_index().set_index(\"hid\")\n\n    if from_to:\n        logger.debug(\"Initiating from-to parser.\")\n        return from_to_travel_diary_read(\n            trips=trips,\n            persons_attributes=persons_attributes,\n            hhs_attributes=hhs_attributes,\n            include_loc=include_loc,\n            sort_by_seq=sort_by_seq,\n        )\n\n    if tour_based:\n        logger.debug(\"Initiating tour-based parser.\")\n        return tour_based_travel_diary_read(\n            trips=trips,\n            persons_attributes=persons_attributes,\n            hhs_attributes=hhs_attributes,\n            include_loc=include_loc,\n            sort_by_seq=sort_by_seq,\n        )\n\n    logger.debug(\"Initiating trip-based parser.\")\n    return trip_based_travel_diary_read(\n        trips=trips,\n        persons_attributes=persons_attributes,\n        hhs_attributes=hhs_attributes,\n        include_loc=include_loc,\n        sort_by_seq=sort_by_seq,\n    )\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.sample_population","title":"<code>sample_population(trips_df, sample_perc, attributes_df=None, weight_col='freq')</code>","text":"<p>Return the trips of a random sample of the travel population.</p> <p>We merge the trips and attribute datasets to enable probability weights based on population demographics.</p> PARAMETER  DESCRIPTION <code>trips_df</code> <p>Trips dataset</p> <p> TYPE: <code>DataFrame</code> </p> <code>sample_perc</code> <p>Sampling percentage</p> <p> TYPE: <code>float</code> </p> <code>attributes_df</code> <p>Population attributes dataset. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>weight_col</code> <p>The field to use for probability weighting. Defaults to \"freq\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'freq'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame:  a sampled version of the <code>trips_df</code> dataframe</p> Source code in <code>pam/read/diary.py</code> <pre><code>def sample_population(\n    trips_df: pd.DataFrame,\n    sample_perc: float,\n    attributes_df: Optional[pd.DataFrame] = None,\n    weight_col: str = \"freq\",\n) -&gt; pd.DataFrame:\n    \"\"\"Return the trips of a random sample of the travel population.\n\n    We merge the trips and attribute datasets to enable probability weights based on population demographics.\n\n    Args:\n        trips_df (pd.DataFrame): Trips dataset\n        sample_perc (float): Sampling percentage\n        attributes_df (Optional[pd.DataFrame], optional): Population attributes dataset. Defaults to None.\n        weight_col (str, optional): The field to use for probability weighting. Defaults to \"freq\".\n\n    Returns:\n        pd.DataFrame:  a sampled version of the `trips_df` dataframe\n    \"\"\"\n    if attributes_df is not None:\n        sample_pids = (\n            trips_df.groupby(\"pid\")[[\"freq\"]]\n            .sum()\n            .join(attributes_df, how=\"left\")\n            .sample(frac=sample_perc, weights=weight_col)\n            .index\n        )\n    else:\n        sample_pids = (\n            trips_df.groupby(\"pid\")[[\"freq\"]]\n            .sum()\n            .sample(frac=sample_perc, weights=weight_col)\n            .index\n        )\n\n    return trips_df[trips_df.pid.isin(sample_pids)]\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.tour_based_travel_diary_read","title":"<code>tour_based_travel_diary_read(trips, persons_attributes=None, hhs_attributes=None, include_loc=False, sort_by_seq=None)</code>","text":"<p>Complex travel diray reader.</p> <p>Will try to infer home activity and tour based purposes.</p> PARAMETER  DESCRIPTION <code>trips</code> <p> TYPE: <code>DataFrame</code> </p> <code>persons_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>include_loc</code> <p>optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_by_seq</code> <p>optionally force trip sorting as True or False. Defaults to None.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/diary.py</code> <pre><code>def tour_based_travel_diary_read(\n    trips: pd.DataFrame,\n    persons_attributes: Optional[pd.DataFrame] = None,\n    hhs_attributes: Optional[pd.DataFrame] = None,\n    include_loc: bool = False,\n    sort_by_seq: Optional[bool] = None,\n) -&gt; core.Population:\n    \"\"\"Complex travel diray reader.\n\n    Will try to infer home activity and tour based purposes.\n\n    Args:\n        trips (pd.DataFrame):\n        persons_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        hhs_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        include_loc (bool, optional): optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns). Defaults to False.\n        sort_by_seq (Optional[bool], optional): optionally force trip sorting as True or False. Defaults to None.\n\n    Returns:\n        core.Population:\n    \"\"\"\n    population = build_population(\n        trips=trips, persons_attributes=persons_attributes, hhs_attributes=hhs_attributes\n    )\n\n    if sort_by_seq is None and \"seq\" in trips.columns:\n        sort_by_seq = True\n    if \"seq\" not in trips.columns:\n        seq = trips.groupby([\"hid\", \"pid\"]).cumcount()\n        trips = trips.assign(seq=seq.values)\n\n    trips = trips.set_index([\"hid\", \"pid\", \"seq\"])\n\n    if sort_by_seq:\n        trips = trips.sort_index()\n\n    for hid, household in population:\n        for pid, person in household:\n            try:\n                person_trips = trips.loc[hid, pid]\n            except KeyError:\n                person.stay_at_home()\n                continue\n\n            loc = None\n            if include_loc:\n                loc = person_trips.start_loc.iloc[0]\n\n            person = population[hid][pid]\n\n            person.add(\n                activity.Activity(\n                    seq=0,\n                    act=None,\n                    area=person_trips.ozone.iloc[0],\n                    loc=loc,\n                    start_time=utils.parse_time(0),\n                )\n            )\n\n            for seq, trip in person_trips.iterrows():\n                start_loc = None\n                end_loc = None\n\n                if include_loc:\n                    start_loc = trip.start_loc\n                    end_loc = trip.end_loc\n\n                person.add(\n                    activity.Leg(\n                        seq=seq,\n                        purp=trip.purp.lower(),\n                        mode=trip[\"mode\"].lower(),\n                        start_area=trip.ozone,\n                        end_area=trip.dzone,\n                        start_loc=start_loc,\n                        end_loc=end_loc,\n                        start_time=utils.parse_time(trip.tst),\n                        end_time=utils.parse_time(trip.tet),\n                        distance=trip.get(\"distance\"),\n                        freq=trip.freq,\n                    )\n                )\n\n                person.add(\n                    activity.Activity(\n                        seq=seq + 1,\n                        act=None,\n                        area=trip.dzone,\n                        loc=end_loc,\n                        start_time=utils.parse_time(trip.tet),\n                    )\n                )\n\n            person.plan.finalise_activity_end_times()\n            person.plan.infer_activities_from_tour_purpose()\n            person.plan.set_leg_purposes()\n\n    return population\n</code></pre>"},{"location":"reference/pam/read/diary/#pam.read.diary.trip_based_travel_diary_read","title":"<code>trip_based_travel_diary_read(trips, persons_attributes=None, hhs_attributes=None, include_loc=False, sort_by_seq=None)</code>","text":"<p>Turn Activity Plan tabular data inputs into core population format.</p> <p>Tabular data inputs are derived from travel survey and attributes.</p> <p>This is a variation of the standard load_travel_diary() method because it does not require activity inference. However all plans are expected to be tour based, so assumed to start and end at home. We expect broadly the same data schema except rather than trip 'purpose' we use trips 'activity'.</p> PARAMETER  DESCRIPTION <code>trips</code> <p> TYPE: <code>DataFrame</code> </p> <code>persons_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>include_loc</code> <p>optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_by_seq</code> <p>optionally force trip sorting as True or False. Defaults to None.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/diary.py</code> <pre><code>def trip_based_travel_diary_read(\n    trips: pd.DataFrame,\n    persons_attributes: Optional[pd.DataFrame] = None,\n    hhs_attributes: Optional[pd.DataFrame] = None,\n    include_loc: bool = False,\n    sort_by_seq: Optional[bool] = None,\n) -&gt; core.Population:\n    \"\"\"Turn Activity Plan tabular data inputs into core population format.\n\n    Tabular data inputs are derived from travel survey and attributes.\n\n    This is a variation of the standard load_travel_diary() method because it does not require activity inference.\n    However all plans are expected to be tour based, so assumed to start and end at home.\n    We expect broadly the same data schema except rather than trip 'purpose' we use trips 'activity'.\n\n    Args:\n        trips (pd.DataFrame):\n        persons_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        hhs_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        include_loc (bool, optional): optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns). Defaults to False.\n        sort_by_seq (Optional[bool], optional): optionally force trip sorting as True or False. Defaults to None.\n\n    Returns:\n        core.Population:\n    \"\"\"\n\n    population = build_population(\n        trips=trips, persons_attributes=persons_attributes, hhs_attributes=hhs_attributes\n    )\n\n    if sort_by_seq is None and \"seq\" in trips.columns:\n        sort_by_seq = True\n    if \"seq\" not in trips.columns:\n        seq = trips.groupby([\"hid\", \"pid\"]).cumcount()\n        trips = trips.assign(seq=seq.values)\n\n    trips = trips.set_index([\"hid\", \"pid\", \"seq\"])\n\n    if sort_by_seq:\n        trips = trips.sort_index()\n\n    for hid, household in population:\n        for pid, person in household:\n            try:\n                person_trips = trips.loc[hid, pid]\n            except KeyError:\n                person.stay_at_home()\n                continue\n\n            household.location.area or person_trips.hzone.iloc[0]\n            origin_area = person_trips.ozone.iloc[0]\n\n            loc = None\n            if include_loc:\n                loc = person_trips.start_loc.iloc[0]\n\n            person.add(\n                activity.Activity(\n                    seq=0, act=\"home\", area=origin_area, loc=loc, start_time=utils.parse_time(0)\n                )\n            )\n\n            for seq, trip in person_trips.iterrows():\n                start_loc = None\n                end_loc = None\n                if include_loc:\n                    start_loc = trip.start_loc\n                    end_loc = trip.end_loc\n                purpose = trip.purp.lower()\n\n                person.add(\n                    activity.Leg(\n                        seq=seq,\n                        purp=purpose,\n                        mode=trip[\"mode\"].lower(),\n                        start_area=trip.ozone,\n                        end_area=trip.dzone,\n                        start_loc=start_loc,\n                        end_loc=end_loc,\n                        start_time=utils.parse_time(trip.tst),\n                        end_time=utils.parse_time(trip.tet),\n                        distance=trip.get(\"distance\"),\n                    )\n                )\n\n                person.add(\n                    activity.Activity(\n                        seq=seq + 1,\n                        act=purpose,\n                        area=trip.dzone,\n                        loc=end_loc,\n                        start_time=utils.parse_time(trip.tet),\n                    )\n                )\n\n            person.plan.finalise_activity_end_times()\n            household.add(person)\n\n        population.add(household)\n\n    return population\n</code></pre>"},{"location":"reference/pam/read/matsim/","title":"pam.read.matsim","text":""},{"location":"reference/pam/read/matsim/#pam.read.matsim.get_attributes_from_legs","title":"<code>get_attributes_from_legs(elem)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def get_attributes_from_legs(elem):\n    attributes = {}\n    for attr in elem.xpath(\"./attributes/attribute\"):\n        attributes[attr.get(\"name\")] = attr.text\n    return attributes\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.get_attributes_from_person","title":"<code>get_attributes_from_person(elem)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def get_attributes_from_person(elem):\n    ident = elem.xpath(\"@id\")[0]\n    attributes = {}\n    for attr in elem.xpath(\"./attributes/attribute\"):\n        attribute_type = attr.get(\"class\")\n        attribute_name = attr.get(\"name\")\n        if attribute_type == \"java.lang.String\":\n            attributes[attribute_name] = attr.text\n        elif attribute_type == \"java.lang.Boolean\":\n            attributes[attribute_name] = attr.text.lower() == \"true\"\n        elif attribute_type == \"java.lang.Integer\":\n            attributes[attribute_name] = int(attr.text)\n        elif attribute_type == \"java.lang.Double\":\n            attributes[attribute_name] = float(attr.text)\n        elif attribute_type == \"org.matsim.vehicles.PersonVehicles\":\n            attributes[attribute_name] = parse_veh_attribute(attr.text)\n        # last try:\n        else:\n            attributes[attribute_name] = attr.text\n    return ident, attributes\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.load_attributes_map","title":"<code>load_attributes_map(attributes_path)</code>","text":"<p>Given path to MATSim attributes input, return dictionary of attributes (as dict).</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def load_attributes_map(attributes_path):\n    \"\"\"Given path to MATSim attributes input, return dictionary of attributes (as dict).\"\"\"\n    attributes_map = {}\n    people = utils.get_elems(attributes_path, \"object\")\n    for person in people:\n        att_map = {}\n        for attribute in person:\n            att_map[attribute.get(\"name\")] = attribute.text\n        attributes_map[person.get(\"id\")] = att_map\n\n    return attributes_map\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.load_attributes_map_from_v12","title":"<code>load_attributes_map_from_v12(plans_path)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def load_attributes_map_from_v12(plans_path):\n    return dict(\n        [get_attributes_from_person(elem) for elem in utils.get_elems(plans_path, \"person\")]\n    )\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.parse_matsim_plan","title":"<code>parse_matsim_plan(plan_xml, person_id, version, simplify_pt_trips, crop, autocomplete, leg_attributes=True, leg_route=True)</code>","text":"<p>Parse a MATSim plan.</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def parse_matsim_plan(\n    plan_xml,\n    person_id: str,\n    version: int,\n    simplify_pt_trips: bool,\n    crop: bool,\n    autocomplete: bool,\n    leg_attributes: bool = True,\n    leg_route: bool = True,\n) -&gt; activity.Plan:\n    \"\"\"Parse a MATSim plan.\"\"\"\n    logger = logging.getLogger(__name__)\n    act_seq = 0\n    leg_seq = 0\n    arrival_dt = START_OF_DAY\n    departure_dt = None\n    plan = activity.Plan()\n\n    for stage in plan_xml:\n        \"\"\"\n        Loop through stages incrementing time and extracting attributes.\n        \"\"\"\n        if stage.tag in [\"act\", \"activity\"]:\n            act_seq += 1\n            act_type = stage.get(\"type\")\n\n            loc = None\n            x, y = stage.get(\"x\"), stage.get(\"y\")\n            if x and y:\n                loc = Point(int(float(x)), int(float(y)))\n\n            if act_type == \"pt interaction\":\n                departure = stage.get(\"end_time\")\n                if departure is not None:\n                    departure_dt = utils.safe_strptime(departure)\n                else:\n                    departure_dt = arrival_dt + timedelta(seconds=0.0)\n\n            else:\n                departure_dt = utils.safe_strptime(stage.get(\"end_time\", \"24:00:00\"))\n\n            if departure_dt &lt; arrival_dt:\n                logger.debug(f\"Negative duration activity found at pid={person_id}\")\n\n            plan.add(\n                activity.Activity(\n                    seq=act_seq,\n                    act=act_type,\n                    loc=loc,\n                    link=stage.get(\"link\"),\n                    start_time=arrival_dt,\n                    end_time=departure_dt,\n                )\n            )\n\n        if stage.tag == \"leg\":\n            mode, route, attributes = unpack_leg(stage, version)\n            if not leg_attributes:\n                attributes = {}\n\n            leg_seq += 1\n            trav_time = stage.get(\"trav_time\")\n            if trav_time is not None:\n                leg_duration = utils.safe_strpdelta(trav_time)\n                arrival_dt = departure_dt + leg_duration\n            else:\n                arrival_dt = departure_dt  # todo this assumes 0 duration unless known\n\n            if not leg_route:\n                # Optionally ignores route info such as links, distance and so on.\n                plan.add(\n                    activity.Leg(\n                        seq=leg_seq,\n                        mode=mode,\n                        start_time=departure_dt,\n                        end_time=arrival_dt,\n                        attributes=attributes,\n                    )\n                )\n\n            else:\n                plan.add(\n                    activity.Leg(\n                        seq=leg_seq,\n                        mode=mode,\n                        start_link=route.get(\"start_link\"),\n                        end_link=route.get(\"end_link\"),\n                        start_time=departure_dt,\n                        end_time=arrival_dt,\n                        distance=route.distance,\n                        attributes=attributes,\n                        route=route,\n                    )\n                )\n\n    if simplify_pt_trips:\n        plan.simplify_pt_trips()\n\n    plan.set_leg_purposes()\n\n    score = plan_xml.get(\"score\", None)\n    if score:\n        score = float(score)\n    plan.score = score  # experienced plan scores\n\n    if crop:\n        plan.crop()\n    if autocomplete:\n        plan.autocomplete_matsim()\n\n    return plan\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.parse_veh_attribute","title":"<code>parse_veh_attribute(text)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def parse_veh_attribute(text) -&gt; dict:\n    return json.loads(text)\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.read_matsim","title":"<code>read_matsim(plans_path, attributes_path=None, all_vehicles_path=None, electric_vehicles_path=None, weight=100, version=12, household_key=None, simplify_pt_trips=False, autocomplete=True, crop=False, keep_non_selected=False, leg_attributes=True, leg_route=True)</code>","text":"<p>Load a MATSim format population into core population format. It is possible to maintain the unity of housholds using a household uid in the attributes input, i.e.: <code>xml     &lt;attribute class=\"java.lang.String\" name=\"hid\"&gt;hh_0001&lt;/attribute&gt;</code>.</p> PARAMETER  DESCRIPTION <code>plans_path</code> <p>path to matsim format xml</p> <p> TYPE: <code>str</code> </p> <code>attributes_path</code> <p>path to matsim format xml. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>all_vehicles_path</code> <p>path to matsim all_vehicles xml file. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>electric_vehicles_path</code> <p>path to matsim electric_vehicles xml. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>weight</code> <p>int. Defaults to 100.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>version</code> <p>Defaults to 12.</p> <p> TYPE: <code>Literal[11, 12]</code> DEFAULT: <code>12</code> </p> <code>household_key</code> <p>Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>simplify_pt_trips</code> <p>bool, simplify legs in multi-leg trips. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>autocomplete</code> <p>bool, fills missing leg and activity attributes. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>crop</code> <p>bool, crop plans that go beyond 24 hours. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>keep_non_selected</code> <p>Whether to parse non-selected plans (storing them in person.plans_non_selected). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>leg_attributes</code> <p>Parse leg attributes such as routing mode. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>leg_route</code> <p>Parse leg route. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def read_matsim(\n    plans_path: str,\n    attributes_path: Optional[str] = None,\n    all_vehicles_path: Optional[str] = None,\n    electric_vehicles_path: Optional[str] = None,\n    weight: int = 100,\n    version: Literal[11, 12] = 12,\n    household_key: Optional[str] = None,\n    simplify_pt_trips: bool = False,\n    autocomplete: bool = True,\n    crop: bool = False,\n    keep_non_selected: bool = False,\n    leg_attributes: bool = True,\n    leg_route: bool = True,\n) -&gt; core.Population:\n    \"\"\"Load a MATSim format population into core population format.\n    It is possible to maintain the unity of housholds using a household uid in\n    the attributes input, i.e.:\n    ``` xml\n        &lt;attribute class=\"java.lang.String\" name=\"hid\"&gt;hh_0001&lt;/attribute&gt;\n    ```.\n\n    Args:\n        plans_path (str): path to matsim format xml\n        attributes_path (str, optional): path to matsim format xml. Defaults to None.\n        all_vehicles_path (str, optional): path to matsim all_vehicles xml file. Defaults to None.\n        electric_vehicles_path (str, optional): path to matsim electric_vehicles xml. Defaults to None.\n        weight (int, optional): int. Defaults to 100.\n        version (Literal[11, 12], optional): Defaults to 12.\n        household_key (str, optional): Defaults to None.\n        simplify_pt_trips (bool, optional): bool, simplify legs in multi-leg trips. Defaults to False.\n        autocomplete (bool, optional): bool, fills missing leg and activity attributes. Defaults to True.\n        crop (bool, optional): bool, crop plans that go beyond 24 hours. Defaults to False.\n        keep_non_selected (bool, optional): Whether to parse non-selected plans (storing them in person.plans_non_selected). Defaults to False.\n        leg_attributes (bool, optional): Parse leg attributes such as routing mode. Defaults to True.\n        leg_route (bool, optional): Parse leg route. Defaults to True.\n\n    Returns:\n        core.Population:\n    \"\"\"\n    logger = logging.getLogger(__name__)\n\n    population = core.Population()\n\n    if attributes_path is not None and version == 12:\n        raise UserWarning(\n            \"\"\"\nYou have provided an attributes_path and enabled matsim version 12, but\nv12 does not require an attributes input:\nEither remove the attributes_path arg, or enable version 11.\n\"\"\"\n        )\n\n    if version not in [11, 12]:\n        raise UserWarning(\"Version must be set to 11 or 12.\")\n\n    if version == 11 and not attributes_path:\n        logger.warning(\n            \"\"\"\nYou have specified version 11 and not supplied an attributes path, population will not\nhave attributes or be able to use a household attribute id. Check this is intended.\n\"\"\"\n        )\n\n    if all_vehicles_path:\n        logger.debug(f\"Loading vehicles from {all_vehicles_path}\")\n        if electric_vehicles_path:\n            logger.debug(f\"Loading EVs from {electric_vehicles_path}\")\n        population._vehicles_manager.from_xml(all_vehicles_path, electric_vehicles_path)\n\n    attributes = {}\n    if attributes_path:\n        logger.debug(f\"Loading attributes from {attributes_path}\")\n        if (version == 12) and (attributes_path is not None):\n            logger.warning(\n                \"It is not required to load attributes from a separate path after version 11.\"\n            )\n        attributes = load_attributes_map(attributes_path)\n\n    for person in stream_matsim_persons(\n        plans_path,\n        attributes=attributes,\n        vehicles_manager=population._vehicles_manager,\n        weight=weight,\n        version=version,\n        simplify_pt_trips=simplify_pt_trips,\n        autocomplete=autocomplete,\n        crop=crop,\n        keep_non_selected=keep_non_selected,\n        leg_attributes=leg_attributes,\n        leg_route=leg_route,\n    ):\n        # Check if using households, then update population accordingly.\n        if household_key and person.attributes.get(household_key):  # using households\n            if population.get(person.attributes.get(household_key)):  # existing household\n                household = population.get(person.attributes.get(household_key))\n                household.add(person)\n            else:  # new household\n                household = core.Household(person.attributes.get(household_key), freq=weight)\n                household.add(person)\n                population.add(household)\n        else:  # not using households, create dummy household\n            household = core.Household(person.pid, freq=weight)\n            household.add(person)\n            population.add(household)\n\n    return population\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.selected_plans","title":"<code>selected_plans(plans_path)</code>","text":"<p>Given path to MATSim plans input, yield person id and plan for all selected plans.</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def selected_plans(plans_path):\n    \"\"\"Given path to MATSim plans input, yield person id and plan for all selected plans.\"\"\"\n    for person in utils.get_elems(plans_path, \"person\"):\n        for plan in person:\n            if plan.get(\"selected\") == \"yes\":\n                yield person.get(\"id\"), plan\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.stream_matsim_persons","title":"<code>stream_matsim_persons(plans_path, attributes={}, vehicles_manager=None, weight=100, version=12, simplify_pt_trips=False, autocomplete=True, crop=False, keep_non_selected=False, leg_attributes=True, leg_route=True)</code>","text":"<p>Stream a MATSim format population into core.Person objects. Expects agent attributes (and vehicles) to be supplied as optional dictionaries. This allows this function to support \"version 11\" plans.</p> <p>TODO: a v12 only method could also stream attributes and would use less memory</p> PARAMETER  DESCRIPTION <code>plans_path</code> <p>path to matsim format xml</p> <p> TYPE: <code>str</code> </p> <code>attributes</code> <p>map of person attributes, only required for v11. Defaults to {}.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>vehicles_manager</code> <p>Population vehicles manager. Defaults to None.</p> <p> TYPE: <code>VehicleManager</code> DEFAULT: <code>None</code> </p> <code>weight</code> <p>path to matsim electric_vehicles xml. Defaults to 100.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>version</code> <p>Defaults to 12.</p> <p> TYPE: <code>Literal[11, 12]</code> DEFAULT: <code>12</code> </p> <code>simplify_pt_trips</code> <p>simplify legs in multi-leg trips. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>autocomplete</code> <p>fills missing leg and activity attributes. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>crop</code> <p>crop plans that go beyond 24 hours. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>keep_non_selected</code> <p>Whether to parse non-selected plans (storing them in <code>person.plans_non_selected</code>). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>leg_attributes</code> <p>Parse leg attributes such as routing mode. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>leg_route</code> <p>Parse leg route. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p><code>version</code> must be set to 11 or 12.</p> YIELDS DESCRIPTION <code>Person</code> <p>Iterator[core.Person]:</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def stream_matsim_persons(\n    plans_path: str,\n    attributes: dict = {},\n    vehicles_manager: Optional[VehicleManager] = None,\n    weight: int = 100,\n    version: Literal[11, 12] = 12,\n    simplify_pt_trips: bool = False,\n    autocomplete: bool = True,\n    crop: bool = False,\n    keep_non_selected: bool = False,\n    leg_attributes: bool = True,\n    leg_route: bool = True,\n) -&gt; Iterator[core.Person]:\n    \"\"\"Stream a MATSim format population into core.Person objects.\n    Expects agent attributes (and vehicles) to be supplied as optional dictionaries.\n    This allows this function to support \"version 11\" plans.\n\n    TODO: a v12 only method could also stream attributes and would use less memory\n\n    Args:\n        plans_path (str):\n            path to matsim format xml\n        attributes (dict, optional):\n            map of person attributes, only required for v11. Defaults to {}.\n        vehicles_manager (VehicleManager, optional):\n            Population vehicles manager. Defaults to None.\n        weight (int, optional):\n            path to matsim electric_vehicles xml. Defaults to 100.\n        version (Literal[11, 12], optional):\n            Defaults to 12.\n        simplify_pt_trips (bool, optional):\n            simplify legs in multi-leg trips. Defaults to False.\n        autocomplete (bool, optional):\n            fills missing leg and activity attributes. Defaults to True.\n        crop (bool, optional):\n            crop plans that go beyond 24 hours. Defaults to False.\n        keep_non_selected (bool, optional):\n            Whether to parse non-selected plans (storing them in `person.plans_non_selected`). Defaults to False.\n        leg_attributes (bool, optional):\n            Parse leg attributes such as routing mode. Defaults to True.\n        leg_route (bool, optional):\n            Parse leg route. Defaults to True.\n\n    Raises:\n        UserWarning: `version` must be set to 11 or 12.\n\n    Yields:\n        Iterator[core.Person]:\n    \"\"\"\n    if version not in [11, 12]:\n        raise UserWarning(\"Version must be set to 11 or 12.\")\n\n    if vehicles_manager is None:\n        vehicles_manager = VehicleManager()\n\n    for person_xml in utils.get_elems(plans_path, \"person\"):\n        if version == 11:\n            person_id = person_xml.xpath(\"@id\")[0]\n            agent_attributes = attributes.get(person_id, {})\n        else:\n            person_id, agent_attributes = get_attributes_from_person(person_xml)\n\n        # remove vehicle attribute from agent and create person vehicles dictionary\n        person_vehs = {}\n        if vehicles_manager.len():\n            agent_vehs = agent_attributes.pop(\"vehicles\", {})\n            person_vehs = {mode: vehicles_manager.pop(vid) for mode, vid in agent_vehs.items()}\n\n        person = core.Person(\n            person_id, attributes=agent_attributes, freq=weight, vehicles=person_vehs\n        )\n\n        for plan_xml in person_xml:\n            if plan_xml.get(\"selected\") == \"yes\":\n                person.plan = parse_matsim_plan(\n                    plan_xml=plan_xml,\n                    person_id=person_id,\n                    version=version,\n                    simplify_pt_trips=simplify_pt_trips,\n                    crop=crop,\n                    autocomplete=autocomplete,\n                    leg_attributes=leg_attributes,\n                    leg_route=leg_route,\n                )\n            elif keep_non_selected and plan_xml.get(\"selected\") == \"no\":\n                person.plans_non_selected.append(\n                    parse_matsim_plan(\n                        plan_xml=plan_xml,\n                        person_id=person_id,\n                        version=version,\n                        simplify_pt_trips=simplify_pt_trips,\n                        crop=crop,\n                        autocomplete=autocomplete,\n                        leg_attributes=leg_attributes,\n                        leg_route=leg_route,\n                    )\n                )\n        yield person\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.unpack_leg","title":"<code>unpack_leg(leg, version)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def unpack_leg(leg, version):\n    if version == 12:\n        return unpack_leg_v12(leg)\n    return unpack_route_v11(leg)\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.unpack_leg_v12","title":"<code>unpack_leg_v12(leg)</code>","text":"<p>Extract mode, route and attributes as available.</p> PARAMETER  DESCRIPTION <code>leg</code> <p> TYPE: <code>xml_leg_element</code> </p> RETURNS DESCRIPTION <code>tuple[str, Route, dict]</code> <p>tuple[str, Route, dict]: mode, route, attributes</p> Example <p>There are four known cases:</p> <p>=== Unrouted ===</p> <p>For example a leg missing both attributes and route elements, this is the case for non experienced or non routed plans: <pre><code>    &lt;leg mode=\"car\" dep_time=\"07:00:00\" trav_time=\"00:07:34\"&gt;\n    &lt;/leg&gt;\n</code></pre></p> <p>=== Transit ===</p> <p>This is a transit routed leg with the route encoded as json string and routingMode attribute: <pre><code>    &lt;leg mode=\"pt\" trav_time=\"00:43:42\"&gt;\n        &lt;attributes&gt;\n            &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;bus&lt;/attribute&gt;\n        &lt;/attributes&gt;\n        &lt;route type=\"default_pt\" start_link=\"1-2\" end_link=\"3-4\" trav_time=\"00:43:42\" distance=\"10100.0\"&gt;\n        {\"transitRouteId\":\"work_bound\",\"boardingTime\":\"07:30:00\",\"transitLineId\":\"city_line\",\"accessFacilityId\":\"home_stop_out\",\"egressFacilityId\":\"work_stop_in\"}\n        &lt;/route&gt;\n    &lt;/leg&gt;\n</code></pre></p> <p>Route must be transit i.e. there will not be a network route. Route attributes include:     - type = \"default_pt\"     - start_link     - end_link     - trav_time     - distance</p> <p>=== Network Routed ===</p> <p>This is a network routed mode, eg car: <pre><code>    &lt;leg mode=\"car\" dep_time=\"07:58:00\" trav_time=\"00:04:52\"&gt;\n        &lt;attributes&gt;\n            &lt;attribute name=\"enterVehicleTime\" class=\"java.lang.Double\"&gt;28680.0&lt;/attribute&gt;\n            &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;car&lt;/attribute&gt;\n        &lt;/attributes&gt;\n        &lt;route type=\"links\" start_link=\"4155\" end_link=\"5221366698030330427_5221366698041252619\" trav_time=\"00:04:52\" distance=\"4898.473995989452\" vehicleRefId=\"null\"&gt;\n        4155 5221366345330551489_5221366345327939575 2623 4337 5221366343808222067_5221366343837130911 2984 1636 3671 6110 etc...\n        &lt;/route&gt;\n    &lt;/leg&gt;\n</code></pre></p> <p>Route attributes include:     - type = \"links\"     - start_link     - end_link     - trav_time     - distance     - vehicleRefId The network route is given as a space seperated sequence of link ids.</p> <p>=== Teleported ===</p> <p>This is a teleported route, eg walk/cycle: <pre><code>    &lt;leg mode=\"walk\" dep_time=\"09:23:00\" trav_time=\"01:54:10\"&gt;\n        &lt;attributes&gt;\n            &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;walk&lt;/attribute&gt;\n        &lt;/attributes&gt;\n        &lt;route type=\"generic\" start_link=\"5221366698030330427_5221366698041252619\" end_link=\"114\" trav_time=\"01:54:10\" distance=\"5710.003987453454\"&gt;&lt;/route&gt;\n    &lt;/leg&gt;\n</code></pre></p> <p>Route attributes include:     - type = \"generic\"     - start_link     - end_link     - trav_time     - distance The network route is empty.</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def unpack_leg_v12(leg) -&gt; tuple[str, Route, dict]:\n    \"\"\"Extract mode, route and attributes as available.\n\n    Args:\n        leg (xml_leg_element):\n\n    Returns:\n        tuple[str, Route, dict]: mode, route, attributes\n\n    Example:\n        There are four known cases:\n\n        === Unrouted ===\n\n        For example a leg missing both attributes and route elements, this is the case for non experienced or non routed plans:\n        ```xml\n            &lt;leg mode=\"car\" dep_time=\"07:00:00\" trav_time=\"00:07:34\"&gt;\n            &lt;/leg&gt;\n        ```\n\n        === Transit ===\n\n        This is a transit routed leg with the route encoded as json string and routingMode attribute:\n        ```xml\n            &lt;leg mode=\"pt\" trav_time=\"00:43:42\"&gt;\n                &lt;attributes&gt;\n                    &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;bus&lt;/attribute&gt;\n                &lt;/attributes&gt;\n                &lt;route type=\"default_pt\" start_link=\"1-2\" end_link=\"3-4\" trav_time=\"00:43:42\" distance=\"10100.0\"&gt;\n                {\"transitRouteId\":\"work_bound\",\"boardingTime\":\"07:30:00\",\"transitLineId\":\"city_line\",\"accessFacilityId\":\"home_stop_out\",\"egressFacilityId\":\"work_stop_in\"}\n                &lt;/route&gt;\n            &lt;/leg&gt;\n        ```\n\n        Route must be transit i.e. there will not be a network route.\n        Route attributes include:\n            - type = \"default_pt\"\n            - start_link\n            - end_link\n            - trav_time\n            - distance\n\n        === Network Routed ===\n\n        This is a network routed mode, eg car:\n        ``` xml\n            &lt;leg mode=\"car\" dep_time=\"07:58:00\" trav_time=\"00:04:52\"&gt;\n                &lt;attributes&gt;\n                    &lt;attribute name=\"enterVehicleTime\" class=\"java.lang.Double\"&gt;28680.0&lt;/attribute&gt;\n                    &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;car&lt;/attribute&gt;\n                &lt;/attributes&gt;\n                &lt;route type=\"links\" start_link=\"4155\" end_link=\"5221366698030330427_5221366698041252619\" trav_time=\"00:04:52\" distance=\"4898.473995989452\" vehicleRefId=\"null\"&gt;\n                4155 5221366345330551489_5221366345327939575 2623 4337 5221366343808222067_5221366343837130911 2984 1636 3671 6110 etc...\n                &lt;/route&gt;\n            &lt;/leg&gt;\n        ```\n\n        Route attributes include:\n            - type = \"links\"\n            - start_link\n            - end_link\n            - trav_time\n            - distance\n            - vehicleRefId\n        The network route is given as a space seperated sequence of link ids.\n\n        === Teleported ===\n\n        This is a teleported route, eg walk/cycle:\n        ``` xml\n            &lt;leg mode=\"walk\" dep_time=\"09:23:00\" trav_time=\"01:54:10\"&gt;\n                &lt;attributes&gt;\n                    &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;walk&lt;/attribute&gt;\n                &lt;/attributes&gt;\n                &lt;route type=\"generic\" start_link=\"5221366698030330427_5221366698041252619\" end_link=\"114\" trav_time=\"01:54:10\" distance=\"5710.003987453454\"&gt;&lt;/route&gt;\n            &lt;/leg&gt;\n        ```\n\n        Route attributes include:\n            - type = \"generic\"\n            - start_link\n            - end_link\n            - trav_time\n            - distance\n        The network route is empty.\n    \"\"\"\n    mode = leg.get(\"mode\")\n    route = Route(leg.xpath(\"route\"))\n    attributes = get_attributes_from_legs(leg)\n    return mode, route, attributes\n</code></pre>"},{"location":"reference/pam/read/matsim/#pam.read.matsim.unpack_route_v11","title":"<code>unpack_route_v11(leg)</code>","text":"<p>Extract mode, network route and transit route as available.</p> PARAMETER  DESCRIPTION <code>leg</code> <p> TYPE: <code>xml_leg_element</code> </p> RETURNS DESCRIPTION <code>tuple[str, RouteV11, dict]</code> <p>tuple[str, RouteV11, dict]: mode, route, attributes</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def unpack_route_v11(leg) -&gt; tuple[str, RouteV11, dict]:\n    \"\"\"Extract mode, network route and transit route as available.\n\n    Args:\n        leg (xml_leg_element):\n\n    Returns:\n        tuple[str, RouteV11, dict]: mode, route, attributes\n    \"\"\"\n    mode = leg.get(\"mode\")\n    route = RouteV11(leg.xpath(\"route\"))\n    return mode, route, {}\n</code></pre>"},{"location":"reference/pam/report/benchmarks/","title":"pam.report.benchmarks","text":""},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.BenchmarkDict","title":"<code>BenchmarkDict</code>","text":"<p>             Bases: <code>TypedDict</code></p>"},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.BenchmarkDict.aggfunc","title":"<code>aggfunc: list[Callable]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.BenchmarkDict.colnames","title":"<code>colnames: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.BenchmarkDict.data_fields","title":"<code>data_fields: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.BenchmarkDict.dimensions","title":"<code>dimensions: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.benchmarks","title":"<code>benchmarks(population)</code>","text":"<p>Yield benchmarks.</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> YIELDS DESCRIPTION <code>str</code> <p>Iterator[tuple[str, pd.DataFrame]]: (filename, benchmark).</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def benchmarks(population: Population) -&gt; Iterator[tuple[str, pd.DataFrame]]:\n    \"\"\"Yield benchmarks.\n\n    Args:\n        population (Population):\n\n    Yields:\n        Iterator[tuple[str, pd.DataFrame]]: (filename, benchmark).\n    \"\"\"\n\n    bms: list[tuple[str, BenchmarkDict]] = [\n        (\n            \"mode_counts.csv\",\n            {\n                \"dimensions\": [\"mode\"],\n                \"data_fields\": [\"freq\"],\n                \"colnames\": [\"mode\", \"trips\"],\n                \"aggfunc\": [sum],\n            },\n        ),\n        (\n            \"distances.csv\",\n            {\n                \"dimensions\": [\"euclidean_distance_category\"],\n                \"data_fields\": [\"freq\"],\n                \"colnames\": [\"distance\", \"trips\"],\n                \"aggfunc\": [sum],\n            },\n        ),\n        (\n            \"mode_distances.csv\",\n            {\n                \"dimensions\": [\"mode\", \"euclidean_distance_category\"],\n                \"data_fields\": [\"freq\"],\n                \"colnames\": [\"mode\", \"distance\", \"trips\"],\n                \"aggfunc\": [sum],\n            },\n        ),\n        (\n            \"durations.csv\",\n            {\n                \"dimensions\": [\"duration_category\"],\n                \"data_fields\": [\"freq\"],\n                \"colnames\": [\"duration\", \"trips\"],\n                \"aggfunc\": [sum],\n            },\n        ),\n        (\n            \"mode_durations.csv\",\n            {\n                \"dimensions\": [\"mode\", \"duration_category\"],\n                \"data_fields\": [\"freq\"],\n                \"colnames\": [\"mode\", \"duration\", \"trips\"],\n                \"aggfunc\": [sum],\n            },\n        ),\n        (\n            \"departure_times.csv\",\n            {\n                \"dimensions\": [\"departure_hour\"],\n                \"data_fields\": [\"freq\"],\n                \"colnames\": [\"departure_hour\", \"trips\"],\n                \"aggfunc\": [sum],\n            },\n        ),\n        (\n            \"mode_purposes.csv\",\n            {\n                \"dimensions\": [\"mode\", \"purp\"],\n                \"data_fields\": [\"freq\"],\n                \"colnames\": [\"mode\", \"purpose\", \"trips\"],\n                \"aggfunc\": [sum],\n            },\n        ),\n    ]\n    trips = population.trips_df()\n    for path, kwargs in bms:\n        yield path, create_benchmark(trips.copy(), **kwargs)\n</code></pre>"},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.create_benchmark","title":"<code>create_benchmark(data, dimensions=None, data_fields=None, aggfunc=[len], normalise_by=None, colnames=None)</code>","text":"<p>Extract user-specified benchmarks from the population</p> PARAMETER  DESCRIPTION <code>data</code> <p>dataframe of trip or leg logs with required fields.</p> <p> TYPE: <code>DataFrame</code> </p> <code>dimensions</code> <p>Dimensions to group by. If None, return the disaggregate dataset. Defaults to None.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>data_fields</code> <p>The data to summarise. If None, simply count the instances of each group. Defaults to None.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>aggfunc</code> <p>A set of functions to apply to each data field in <code>data_fields</code>, after grouping by the specified dimensions. For example: [len, sum], [sum, np.mean], [np.sum]. Defaults to [len].</p> <p> TYPE: <code>list[Callable]</code> DEFAULT: <code>[len]</code> </p> <code>normalise_by</code> <p>If given, convert calculated values to percentages across the dimension(s) specified here. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>colnames</code> <p>If given, rename the columns of the returned dataset. Defaults to None.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame:</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def create_benchmark(\n    data: pd.DataFrame,\n    dimensions: Optional[list[str]] = None,\n    data_fields: Optional[list[str]] = None,\n    aggfunc: list[Callable] = [len],\n    normalise_by: Optional[str] = None,\n    colnames: Optional[list[str]] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Extract user-specified benchmarks from the population\n\n    Args:\n        data (pd.DataFrame): dataframe of trip or leg logs with required fields.\n        dimensions (Optional[list[str]], optional): Dimensions to group by. If None, return the disaggregate dataset. Defaults to None.\n        data_fields (Optional[list[str]], optional): The data to summarise. If None, simply count the instances of each group. Defaults to None.\n        aggfunc (list[Callable], optional):\n            A set of functions to apply to each data field in `data_fields`, after grouping by the specified dimensions.\n            For example: [len, sum], [sum, np.mean], [np.sum].\n            Defaults to [len].\n        normalise_by (Optional[str], optional): If given, convert calculated values to percentages across the dimension(s) specified here. Defaults to None.\n        colnames (Optional[list[str]], optional): If given, rename the columns of the returned dataset. Defaults to None.\n\n    Returns:\n        pd.DataFrame:\n    \"\"\"\n    df = data.copy()\n\n    # aggregate across specified dimensions\n    if dimensions is not None:\n        if data_fields is not None:\n            df = df.groupby(dimensions, observed=False)[data_fields].agg(aggfunc).fillna(0)\n        else:\n            df = df.value_counts(dimensions)\n\n    # show as percentages\n    if normalise_by is not None:\n        if normalise_by == \"total\":\n            df = df / df.sum(axis=0)\n        else:\n            df = df.groupby(level=normalise_by).transform(lambda x: x / x.sum())\n    df = df.sort_index().reset_index()\n\n    # flatten column MultiIndex\n    if isinstance(df.columns, pd.MultiIndex):\n        df.columns = df.columns.map(\"_\".join).str.strip(\"_\")\n\n    # rename columns\n    if colnames is not None:\n        df.columns = colnames\n\n    return df\n</code></pre>"},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.departure_time_counts","title":"<code>departure_time_counts(population)</code>","text":"<p>number of trips by hour of departure.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def departure_time_counts(population):\n    \"number of trips by hour of departure.\"\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions=[\"departure_hour\"],\n        data_fields=[\"freq\"],\n        colnames=[\"departure_hour\", \"trips\"],\n        aggfunc=[sum],\n    )\n</code></pre>"},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.distance_counts","title":"<code>distance_counts(population)</code>","text":"<p>number of trips by (euclidean) distance category.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def distance_counts(population):\n    \"number of trips by (euclidean) distance category.\"\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions=[\"euclidean_distance_category\"],\n        data_fields=[\"freq\"],\n        colnames=[\"distance\", \"trips\"],\n        aggfunc=[sum],\n    )\n</code></pre>"},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.duration_counts","title":"<code>duration_counts(population)</code>","text":"<p>number of trips by duration.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def duration_counts(population):\n    \"number of trips by duration.\"\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions=[\"duration_category\"],\n        data_fields=[\"freq\"],\n        colnames=[\"duration\", \"trips\"],\n        aggfunc=[sum],\n    )\n</code></pre>"},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.mode_counts","title":"<code>mode_counts(population)</code>","text":"<p>number of trips by (euclidean) distance category.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_counts(population):\n    \"number of trips by (euclidean) distance category.\"\n    data = population.trips_df()\n    return create_benchmark(\n        data, dimensions=[\"mode\"], data_fields=[\"freq\"], colnames=[\"mode\", \"trips\"], aggfunc=[sum]\n    )\n</code></pre>"},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.mode_distance_counts","title":"<code>mode_distance_counts(population)</code>","text":"<p>number of trips by (euclidean) distance category and mode.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_distance_counts(population):\n    \"number of trips by (euclidean) distance category and mode.\"\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions=[\"mode\", \"euclidean_distance_category\"],\n        data_fields=[\"freq\"],\n        colnames=[\"mode\", \"distance\", \"trips\"],\n        aggfunc=[sum],\n    )\n</code></pre>"},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.mode_duration_counts","title":"<code>mode_duration_counts(population)</code>","text":"<p>number of trips by duration and mode.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_duration_counts(population):\n    \"number of trips by duration and mode.\"\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions=[\"mode\", \"duration_category\"],\n        data_fields=[\"freq\"],\n        colnames=[\"mode\", \"duration\", \"trips\"],\n        aggfunc=[sum],\n    )\n</code></pre>"},{"location":"reference/pam/report/benchmarks/#pam.report.benchmarks.mode_purpose_counts","title":"<code>mode_purpose_counts(population)</code>","text":"<p>purpose split for each mode.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_purpose_counts(population):\n    \"purpose split for each mode.\"\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions=[\"mode\", \"purp\"],\n        data_fields=[\"freq\"],\n        colnames=[\"mode\", \"purpose\", \"trips\"],\n        aggfunc=[sum],\n    )\n</code></pre>"},{"location":"reference/pam/report/stringify/","title":"pam.report.stringify","text":""},{"location":"reference/pam/report/stringify/#pam.report.stringify.ActColour","title":"<code>ActColour(colour=True)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def __init__(self, colour=True) -&gt; None:\n    if colour:\n        self._queue = inf_yield(self._col_queue)\n    else:\n        self._queue = inf_yield(self._bw_queue)\n</code></pre>"},{"location":"reference/pam/report/stringify/#pam.report.stringify.ActColour.mapping","title":"<code>mapping = {'travel': 232}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/stringify/#pam.report.stringify.ActColour.paint","title":"<code>paint(act, text)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def paint(self, act, text):\n    if act not in self.mapping:\n        self.mapping[act] = next(self._queue)\n    return f\"\\033[38;5;{self.mapping[act]}m{text}\\033[0m\"\n</code></pre>"},{"location":"reference/pam/report/stringify/#pam.report.stringify.inf_yield","title":"<code>inf_yield(queue)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def inf_yield(queue: list):\n    while True:\n        for i in queue:\n            yield i\n</code></pre>"},{"location":"reference/pam/report/stringify/#pam.report.stringify.stringify_plan","title":"<code>stringify_plan(plan_array, mapping, colourer)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def stringify_plan(plan_array, mapping, colourer):\n    return \"\".join([colourer.paint(mapping[i], \"\u2587\") for i in plan_array])\n</code></pre>"},{"location":"reference/pam/report/stringify/#pam.report.stringify.stringify_plans","title":"<code>stringify_plans(plans_path, simplify_pt_trips=False, crop=False, colour=True, width=101)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def stringify_plans(\n    plans_path, simplify_pt_trips: bool = False, crop: bool = False, colour=True, width=101\n):\n    print(f\"Loading plan sequences from {plans_path}.\")\n    encoder = PlansToCategorical(bin_size=int(86400 / width), duration=86400)\n    colourer = ActColour(colour=colour)\n    for person in stream_matsim_persons(plans_path, simplify_pt_trips=simplify_pt_trips, crop=crop):\n        apply_jitter_to_plan(\n            plan=person.plan, jitter=timedelta(minutes=30), min_duration=timedelta(minutes=5)\n        )\n        encoded = encoder.encode(person.plan)\n        string = stringify_plan(plan_array=encoded, mapping=encoder.index_to_act, colourer=colourer)\n        print(person.pid, string)\n\n    print()\n    print(\"Key:\")\n    for act in encoder.act_to_index:\n        print(f\"{colourer.paint(act, '\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587')}: {act}\")\n</code></pre>"},{"location":"reference/pam/report/summary/","title":"pam.report.summary","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT","title":"<code>TEXT</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.BOLD","title":"<code>BOLD = '\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.END","title":"<code>END = '\\x1b[0m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.FAIL","title":"<code>FAIL = '\\x1b[91m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.HEADER","title":"<code>HEADER = '\\x1b[95m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.OKBLUE","title":"<code>OKBLUE = '\\x1b[94m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.OKCYAN","title":"<code>OKCYAN = '\\x1b[96m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.OKGREEN","title":"<code>OKGREEN = '\\x1b[92m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.TITLE","title":"<code>TITLE = '\\n\\x1b[95m\\x1b[4m\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.UNDERLINE","title":"<code>UNDERLINE = '\\x1b[4m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.TEXT.WARNING","title":"<code>WARNING = '\\x1b[93m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/report/summary/#pam.report.summary.activities_summary","title":"<code>activities_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def activities_summary(population: Population, key=\"subpopulation\") -&gt; PrettyTable:\n    table = PrettyTable()\n    summary = {}\n    summary[\"total\"] = count_activites(population)\n    slices = []\n\n    if key is not None:\n        slices = population.attributes.get(key, [])\n        for value in slices:\n            summary[value] = count_activites(population, key, value)\n\n    table.field_names = [\"activities\", \"total\"] + list(slices)\n\n    for stat, total_value in summary[\"total\"].items():\n        row = [stat, total_value]\n        for k in slices:\n            row.append(summary[k].get(stat))\n        table.add_row(row)\n\n    table.align[\"activities\"] = \"r\"\n    return table\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.calc_stats","title":"<code>calc_stats(population, key=None, value=None)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def calc_stats(population: Population, key=None, value=None) -&gt; dict:\n    summary = {\"hhs\": 0, \"persons\": 0}\n    hh_occupants = []\n    for _, hh in population:\n        if key is not None and value not in hh.get_attribute(key):\n            continue\n        summary[\"hhs\"] += hh.freq\n        occupants = 0\n        for _, person in hh:\n            if key is not None and not person.attributes.get(key) == value:\n                continue\n            occupants += 1\n            summary[\"persons\"] += person.freq\n        hh_occupants.append(occupants)\n    if hh_occupants:\n        summary[\"av_occupancy\"] = sum(hh_occupants) / len(hh_occupants)\n    return summary\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.count_activites","title":"<code>count_activites(population, key=None, value=None)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def count_activites(population: Population, key=None, value=None) -&gt; dict:\n    classes = population.activity_classes\n    summary = {a: 0 for a in classes}\n    for _, _, person in population.people():\n        if key is not None and not person.attributes.get(key) == value:\n            continue\n        freq = person.freq\n        for act in person.activities:\n            summary[act.act] += freq\n    return summary\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.count_modes","title":"<code>count_modes(population, key=None, value=None)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def count_modes(population: Population, key=None, value=None) -&gt; dict:\n    modes = population.mode_classes\n    summary = {m: 0 for m in modes}\n    for _, _, person in population.people():\n        if key is not None and not person.attributes.get(key) == value:\n            continue\n        freq = person.freq\n        for leg in person.legs:\n            summary[leg.mode] += freq\n    return summary\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.get_attributes","title":"<code>get_attributes(population, show=10, key=None, value=None)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def get_attributes(population, show: int = 10, key=None, value=None) -&gt; dict:\n    attributes = defaultdict(set)\n    for _, _, person in population.people():\n        if key is not None and not person.attributes.get(key) == value:\n            continue\n        for k, v in person.attributes.items():\n            if k == key:\n                continue\n            attributes[k].add(str(v))\n    for k, v in attributes.items():\n        if len(v) &gt; show:\n            attributes[k] = \"---\"\n    return dict(attributes)\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.header","title":"<code>header(head)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def header(head: str):\n    print(f\"{TEXT.HEADER.value}{head}{TEXT.END.value}\")\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.header_and_text","title":"<code>header_and_text(head, text)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def header_and_text(head: str, text: str):\n    print(f\"{TEXT.HEADER.value}{head}{TEXT.END.value} {text}\")\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.modes_summary","title":"<code>modes_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def modes_summary(population: Population, key=\"subpopulation\") -&gt; PrettyTable:\n    table = PrettyTable()\n    summary = {}\n    summary[\"total\"] = count_modes(population)\n    slices = []\n\n    if key is not None:\n        slices = population.attributes.get(key, [])\n        for value in slices:\n            summary[value] = count_modes(population, key, value)\n\n    table.field_names = [\"modes\", \"total\"] + list(slices)\n\n    for stat, total_value in summary[\"total\"].items():\n        row = [stat, total_value]\n        for k in slices:\n            row.append(summary[k].get(stat))\n        table.add_row(row)\n\n    table.align[\"modes\"] = \"r\"\n\n    return table\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.pretty_print_summary","title":"<code>pretty_print_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def pretty_print_summary(population: Population, key=\"subpopulation\"):\n    # stats\n    header(\"Population Stats:\")\n    print(stats_summary(population, key))\n    print()\n\n    # attributes\n    header(\"Population Attributes:\")\n    for k, vs in get_attributes(population).items():\n        subheader_and_text(f\"{k}:\", vs)\n    print()\n\n    if key is not None:\n        for v in population.attributes.get(key, []):\n            header(f\"Attribute: \\033[4m{v}\\033[0m:\")\n            for k, vs in get_attributes(population, key=key, value=v).items():\n                subheader_and_text(f\"{k}:\", vs)\n            print()\n\n    # activites\n    header(\"Activities:\")\n    print(activities_summary(population, key))\n    print()\n\n    # modes\n    header(\"Modes:\")\n    print(modes_summary(population, key))\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.print_summary","title":"<code>print_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def print_summary(population: Population, key=\"subpopulation\"):\n    # stats\n    print(\"Population Stats:\")\n    print(stats_summary(population, key))\n    print()\n\n    # attributes\n    print(\"Population Attributes:\")\n    for k, vs in get_attributes(population).items():\n        print(f\"{k}:\", vs)\n    print()\n\n    if key is not None:\n        for v in population.attributes.get(key, []):\n            print(f\"Attribute: {v}\")\n            for k, vs in get_attributes(population, key=key, value=v).items():\n                print(f\"{k}:\", vs)\n            print()\n\n    # activites\n    print(\"Activities:\")\n    print(activities_summary(population, key))\n    print()\n\n    # modes\n    print(\"Modes:\")\n    print(modes_summary(population, key))\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.stats_summary","title":"<code>stats_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def stats_summary(population: Population, key=\"subpopulation\") -&gt; PrettyTable:\n    table = PrettyTable()\n    summary = {}\n    summary[\"total\"] = calc_stats(population)\n    slices = []\n\n    if key is not None:\n        slices = population.attributes.get(key, [])\n        for value in slices:\n            summary[value] = calc_stats(population, key, value)\n\n    table.field_names = [\"stat\", \"total\"] + list(slices)\n\n    for stat, total_value in summary[\"total\"].items():\n        row = [stat, total_value]\n        for k in slices:\n            row.append(summary[k].get(stat))\n        table.add_row(row)\n\n    table.align[\"stat\"] = \"r\"\n    return table\n</code></pre>"},{"location":"reference/pam/report/summary/#pam.report.summary.subheader_and_text","title":"<code>subheader_and_text(head, text)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def subheader_and_text(head: str, text: str):\n    print(f\"{TEXT.OKBLUE.value}{head}{TEXT.END.value} {text}\")\n</code></pre>"},{"location":"reference/pam/samplers/attributes/","title":"pam.samplers.attributes","text":""},{"location":"reference/pam/samplers/attributes/#pam.samplers.attributes.bin_integer_transformer","title":"<code>bin_integer_transformer(features, target, bins, default=None)</code>","text":"<p>Bin a target integer feature based on bins.</p> <p>Where bins are a dict, with keys as a tuple of bin extends (inclusive) and values as the new mapping. Missing ranges will return None. Where features are a dictionary structure of features, eg: {'age':1, ...}.</p> Source code in <code>pam/samplers/attributes.py</code> <pre><code>def bin_integer_transformer(features, target, bins, default=None):\n    \"\"\"Bin a target integer feature based on bins.\n\n    Where bins are a dict, with keys as a tuple of bin extends (inclusive) and values as the new mapping.\n    Missing ranges will return None.\n    Where features are a dictionary structure of features, eg: {'age':1, ...}.\n    \"\"\"\n    value = features.get(target)\n    if value is None:\n        raise KeyError(f\"Can not find target key: {target} in sampling features: {features}\")\n    for (lower, upper), new_value in bins.items():\n        if lower &lt; int(value) &lt;= upper:\n            return new_value\n    return default\n</code></pre>"},{"location":"reference/pam/samplers/attributes/#pam.samplers.attributes.discrete_joint_distribution_sampler","title":"<code>discrete_joint_distribution_sampler(features, mapping, distribution, careful=False, seed=None)</code>","text":"<p>Randomly sample from a joint distribution based some discrete features.</p> PARAMETER  DESCRIPTION <code>features</code> <p>a dictionary structure of features, eg: {'gender':'female'}</p> <p> TYPE: <code>dict</code> </p> <code>mapping</code> <p>the feature name for each level of the distribution, e.g.: ['age', 'gender']</p> <p> TYPE: <code>Any</code> </p> <code>distribution</code> <p>A nested dict of probabilities based on possible features. E.g.: {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': .5}}</p> <p> TYPE: <code>dict[dict]</code> </p> <code>careful</code> <p>If True, missing mapped feature in <code>distribution</code> will raise an exception. If False, missing values will return False. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>all <code>mapping</code> keys must be in <code>features</code>.</p> <code>KeyError</code> <p>If <code>careful</code>, mapped feature must be a key in <code>distribution</code>.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/samplers/attributes.py</code> <pre><code>def discrete_joint_distribution_sampler(\n    features: dict,\n    mapping: Any,\n    distribution: dict[dict],\n    careful: bool = False,\n    seed: Optional[int] = None,\n) -&gt; bool:\n    \"\"\"Randomly sample from a joint distribution based some discrete features.\n\n    Args:\n        features (dict): a dictionary structure of features, eg: {'gender':'female'}\n        mapping (Any): the feature name for each level of the distribution, e.g.: ['age', 'gender']\n        distribution (dict[dict]):\n            A nested dict of probabilities based on possible features.\n            E.g.: {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': .5}}\n        careful (bool, optional):\n            If True, missing mapped feature in `distribution` will raise an exception. If False, missing values will return False.\n            Defaults to False.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n\n    Raises:\n        KeyError: all `mapping` keys must be in `features`.\n        KeyError: If `careful`, mapped feature must be a key in `distribution`.\n\n    Returns:\n        bool:\n    \"\"\"\n\n    # Fix random seed\n    random.seed(seed)\n    p = distribution\n    for key in mapping:\n        value = features.get(key)\n        if value is None:\n            raise KeyError(f\"Can not find mapping: {key} in sampling features: {features}\")\n\n        p = p.get(value)\n        if p is None:\n            if careful:\n                raise KeyError(f\"Can not find feature for {key}: {value} in distribution: {p}\")\n            else:\n                return False\n    return random.random() &lt;= p\n</code></pre>"},{"location":"reference/pam/samplers/basic/","title":"pam.samplers.basic","text":""},{"location":"reference/pam/samplers/basic/#pam.samplers.basic.freq_sample","title":"<code>freq_sample(freq, sample, seed=None)</code>","text":"<p>Down or up sample a frequency based on a sample size.</p> <p>Sub unit frequencies are rounded probabalistically.</p> PARAMETER  DESCRIPTION <code>freq</code> <p>pre sampled frequency.</p> <p> TYPE: <code>float</code> </p> <code>sample</code> <p>sample size.</p> <p> TYPE: <code>float</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>new frequency</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/samplers/basic.py</code> <pre><code>def freq_sample(freq: float, sample: float, seed: Optional[int] = None) -&gt; int:\n    \"\"\"Down or up sample a frequency based on a sample size.\n\n    Sub unit frequencies are rounded probabalistically.\n\n    Args:\n        freq (float): pre sampled frequency.\n        sample (float): sample size.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n\n    Returns:\n        int: new frequency\n    \"\"\"\n    # Fix random seed\n    random.seed(seed)\n\n    new_freq = freq * sample\n    remainder = new_freq - int(new_freq)\n    remainder = int(random.random() &lt; remainder)\n    return int(new_freq) + remainder\n</code></pre>"},{"location":"reference/pam/samplers/facility/","title":"pam.samplers.facility","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler","title":"<code>FacilitySampler(facilities, zones, activities=None, build_xml=True, fail=True, random_default=True, weight_on=None, max_walk=None, transit_modes=None, expected_euclidean_speeds=None, activity_areas_path=None, seed=None)</code>","text":"<p>Sampler object for facilities.</p> Note <p>If a zone id is missing then the sampler will not be able to default to random sample, so will either return None or fail as per the fail flag.</p> PARAMETER  DESCRIPTION <code>facilities</code> <p>facilities Geodataframe</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>zones</code> <p>zones Geodataframe</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>activities</code> <p>optionally set list of subset of activities to be considered. Defaults to None.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>build_xml</code> <p>flag to build a facility xml output (for MATSim). Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>fail</code> <p>flag hard fail if sample not found. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>random_default</code> <p>flag for defaulting to random sample when activity missing. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>weight_on</code> <p>the column name of the facilities geodataframe which contains facility weights (for sampling). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>max_walk</code> <p>maximum walking distnace from a transit stop. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>transit_modes</code> <p>a list of PT modes. If not specified, the default list in variables.TRANSIT_MODES is used. Defaults to None.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>expected_euclidean_speeds</code> <p>a dictionary specifying the euclidean speed of the various modes (m/s). If not specified, the default list in variables.EXPECTED_EUCLIDEAN_SPEEDS is used. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>activity_areas_path</code> <p>path to the activity areas shapefile (previously exported throught the FacilitySampler.export_activity_areas method). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def __init__(\n    self,\n    facilities: gp.GeoDataFrame,\n    zones: gp.GeoDataFrame,\n    activities: Optional[list] = None,\n    build_xml: bool = True,\n    fail: bool = True,\n    random_default: bool = True,\n    weight_on: Optional[str] = None,\n    max_walk: Optional[float] = None,\n    transit_modes: Optional[list] = None,\n    expected_euclidean_speeds: Optional[dict] = None,\n    activity_areas_path: Optional[str] = None,\n    seed: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Sampler object for facilities.\n\n    Note:\n      If a zone id is missing then the sampler will not be able to default to random sample, so will either return None or fail as per the fail flag.\n\n    Args:\n        facilities (gp.GeoDataFrame): facilities Geodataframe\n        zones (gp.GeoDataFrame): zones Geodataframe\n        activities (Optional[list], optional): optionally set list of subset of activities to be considered. Defaults to None.\n        build_xml (bool, optional): flag to build a facility xml output (for MATSim). Defaults to True.\n        fail (bool, optional): flag hard fail if sample not found. Defaults to True.\n        random_default (bool, optional): flag for defaulting to random sample when activity missing. Defaults to True.\n        weight_on (Optional[str], optional): the column name of the facilities geodataframe which contains facility weights (for sampling). Defaults to None.\n        max_walk (Optional[float], optional): maximum walking distnace from a transit stop. Defaults to None.\n        transit_modes (Optional[list], optional):  a list of PT modes. If not specified, the default list in variables.TRANSIT_MODES is used. Defaults to None.\n        expected_euclidean_speeds (Optional[dict], optional): a dictionary specifying the euclidean speed of the various modes (m/s). If not specified, the default list in variables.EXPECTED_EUCLIDEAN_SPEEDS is used. Defaults to None.\n        activity_areas_path (Optional[str], optional): path to the activity areas shapefile (previously exported throught the FacilitySampler.export_activity_areas method). Defaults to None.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n\n    # Fix random seed\n    self.seed = seed\n\n    if activities is None:\n        self.activities = list(set(facilities.activity))\n    else:\n        self.activities = activities\n\n    ## overrides for transit mode and speed specifications\n    self.TRANSIT_MODES = transit_modes if transit_modes is not None else variables.TRANSIT_MODES\n    self.EXPECTED_EUCLIDEAN_SPEEDS = (\n        expected_euclidean_speeds\n        if expected_euclidean_speeds is not None\n        else variables.EXPECTED_EUCLIDEAN_SPEEDS\n    )\n\n    # spatial join\n    if activity_areas_path is None:\n        self.activity_areas = self.spatial_join(facilities, zones)\n        self.activity_areas_dict = self.activity_areas_indexing(self.activity_areas)\n    else:\n        self.load_activity_areas(activity_areas_path)\n\n    # build samplers\n    self.samplers = self.build_facilities_sampler(\n        self.activity_areas_dict, weight_on=weight_on, max_walk=max_walk\n    )\n    self.build_xml = build_xml\n    self.fail = fail\n    self.random_default = random_default\n\n    if random_default:\n        self.random_sampler = RandomPointSampler(geoms=zones, fail=fail, seed=seed)\n\n    self.facilities = {}\n    self.index_counter = 0\n    self.error_counter = 0\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.EXPECTED_EUCLIDEAN_SPEEDS","title":"<code>EXPECTED_EUCLIDEAN_SPEEDS = expected_euclidean_speeds if expected_euclidean_speeds is not None else variables.EXPECTED_EUCLIDEAN_SPEEDS</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.TRANSIT_MODES","title":"<code>TRANSIT_MODES = transit_modes if transit_modes is not None else variables.TRANSIT_MODES</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.activities","title":"<code>activities = list(set(facilities.activity))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.activity_areas","title":"<code>activity_areas = self.spatial_join(facilities, zones)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.activity_areas_dict","title":"<code>activity_areas_dict = self.activity_areas_indexing(self.activity_areas)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.build_xml","title":"<code>build_xml = build_xml</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.error_counter","title":"<code>error_counter = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.facilities","title":"<code>facilities = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.fail","title":"<code>fail = fail</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.index_counter","title":"<code>index_counter = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.random_default","title":"<code>random_default = random_default</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.random_sampler","title":"<code>random_sampler = RandomPointSampler(geoms=zones, fail=fail, seed=seed)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.samplers","title":"<code>samplers = self.build_facilities_sampler(self.activity_areas_dict, weight_on=weight_on, max_walk=max_walk)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.seed","title":"<code>seed = seed</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.activity_areas_indexing","title":"<code>activity_areas_indexing(activity_areas)</code>","text":"<p>Convert joined zone-activities gdf to a nested dictionary for faster indexing.</p> <p>The first index level refers to zones, while the second to activity purposes.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def activity_areas_indexing(self, activity_areas):\n    \"\"\"Convert joined zone-activities gdf to a nested dictionary for faster indexing.\n\n    The first index level refers to zones, while the second to activity purposes.\n    \"\"\"\n    activity_areas_dict = {x: {} for x in activity_areas[\"index_right\"].unique()}\n    for (zone, act), facility_data in activity_areas.groupby([\"index_right\", \"activity\"]):\n        activity_areas_dict[zone][act] = facility_data\n\n    return activity_areas_dict\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.build_facilities_sampler","title":"<code>build_facilities_sampler(activity_areas, weight_on=None, max_walk=None)</code>","text":"<p>Build facility location sampler from osmfs input.</p> <p>The sampler returns a tuple of (uid, Point). TODO: I do not like having a sjoin and assuming index names here TODO: look to move to more carefully defined input data format for facilities.</p> PARAMETER  DESCRIPTION <code>activity_areas</code> <p> TYPE: <code>dict</code> </p> <code>weight_on</code> <p>a column (name) of the facilities geodataframe to be used as a sampling weight. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>max_walk</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p> TYPE: <code>dict</code> </p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def build_facilities_sampler(\n    self,\n    activity_areas: dict,\n    weight_on: Optional[str] = None,\n    max_walk: Optional[float] = None,\n) -&gt; dict:\n    \"\"\"Build facility location sampler from osmfs input.\n\n    The sampler returns a tuple of (uid, Point).\n    TODO: I do not like having a sjoin and assuming index names here\n    TODO: look to move to more carefully defined input data format for facilities.\n\n    Args:\n        activity_areas (dict):\n        weight_on (Optional[str], optional): a column (name) of the facilities geodataframe to be used as a sampling weight. Defaults to None.\n        max_walk (Optional[float], optional): Defaults to None.\n\n    Returns:\n        dict:\n    \"\"\"\n    sampler_dict = {}\n\n    self.logger.warning(\"Building sampler, this may take a while.\")\n    for zone in set(activity_areas.keys()):\n        sampler_dict[zone] = {}\n        zone_facs = activity_areas.get(zone, {})\n\n        for act in self.activities:\n            self.logger.debug(f\"Building sampler for zone:{zone} act:{act}.\")\n            facs = zone_facs.get(act, None)\n            if facs is not None:\n                points = list(facs.geometry.items())\n                if weight_on is not None:\n                    # weighted sampler\n                    weights = facs[weight_on]\n                    transit_distance = facs[\"transit\"] if max_walk is not None else None\n                    sampler_dict[zone][act] = inf_yielder(\n                        points,\n                        weights,\n                        transit_distance,\n                        max_walk,\n                        self.TRANSIT_MODES,\n                        self.EXPECTED_EUCLIDEAN_SPEEDS,\n                        seed=self.seed,\n                    )\n                else:\n                    # simple sampler\n                    sampler_dict[zone][act] = inf_yielder(points, seed=self.seed)\n            else:\n                sampler_dict[zone][act] = None\n    return sampler_dict\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.clear","title":"<code>clear()</code>","text":"Source code in <code>pam/samplers/facility.py</code> <pre><code>def clear(self):\n    self.facilities = {}\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.export_activity_areas","title":"<code>export_activity_areas(filepath)</code>","text":"<p>Export the spatially joined facilities-zones geodataframe.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def export_activity_areas(self, filepath):\n    \"Export the spatially joined facilities-zones geodataframe.\"\n    with open(filepath, \"wb\") as f:\n        pickle.dump(self.activity_areas_dict, f)\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.load_activity_areas","title":"<code>load_activity_areas(filepath)</code>","text":"<p>Load the spatially joined facilities-zones geodataframe.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def load_activity_areas(self, filepath):\n    \"Load the spatially joined facilities-zones geodataframe.\"\n    with open(filepath, \"rb\") as f:\n        self.activity_areas_dict = pickle.load(f)\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.sample","title":"<code>sample(location_idx, activity, mode=None, previous_duration=None, previous_loc=None)</code>","text":"<p>Sample a Point from the given location and for the given activity.</p> PARAMETER  DESCRIPTION <code>location_idx</code> <p>the zone to sample from</p> <p> TYPE: <code>str</code> </p> <code>activity</code> <p>activity purpose</p> <p> TYPE: <code>str</code> </p> <code>mode</code> <p>transport mode used to access facility. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>previous_duration</code> <p>the time duration of the arriving leg. Defaults to None.</p> <p> TYPE: <code>Optional[Timedelta]</code> DEFAULT: <code>None</code> </p> <code>previous_loc</code> <p>the location of the last visited activity. Defaults to None.</p> <p> TYPE: <code>Optional[Point]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Point</code> <p>shapely.geometry.Point: Sampled point</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def sample(\n    self,\n    location_idx: str,\n    activity: str,\n    mode: Optional[str] = None,\n    previous_duration: Optional[pd.Timedelta] = None,\n    previous_loc: Optional[shapely.geometry.Point] = None,\n) -&gt; shapely.geometry.Point:\n    \"\"\"Sample a Point from the given location and for the given activity.\n\n    Args:\n        location_idx (str): the zone to sample from\n        activity (str): activity purpose\n        mode (Optional[str], optional): transport mode used to access facility. Defaults to None.\n        previous_duration (Optional[pd.Timedelta], optional): the time duration of the arriving leg. Defaults to None.\n        previous_loc (Optional[shapely.geometry.Point], optional): the location of the last visited activity. Defaults to None.\n\n    Returns:\n        shapely.geometry.Point: Sampled point\n    \"\"\"\n    idx, loc = self.sample_facility(\n        location_idx,\n        activity,\n        mode=mode,\n        previous_duration=previous_duration,\n        previous_loc=previous_loc,\n    )\n\n    if idx is not None and self.build_xml:\n        self.facilities[idx] = {\"loc\": loc, \"act\": activity}\n\n    return loc\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.sample_facility","title":"<code>sample_facility(location_idx, activity, patience=1000, mode=None, previous_duration=None, previous_loc=None)</code>","text":"<p>Sample a facility id and location. If a location idx is missing, can return a random location.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def sample_facility(\n    self,\n    location_idx: str,\n    activity: str,\n    patience=1000,\n    mode: Optional[str] = None,\n    previous_duration: Optional[pd.Timedelta] = None,\n    previous_loc: Optional[shapely.geometry.Point] = None,\n):\n    \"\"\"Sample a facility id and location. If a location idx is missing, can return a random location.\"\"\"\n    if location_idx not in self.samplers:\n        if self.random_default:\n            self.logger.warning(f\"Using random sample for zone:{location_idx}:{activity}\")\n            idx = f\"_{self.index_counter}\"\n            self.index_counter += 1\n            return idx, self.random_sampler.sample(location_idx, activity)\n        if self.fail:\n            raise IndexError(f\"Cannot find idx: {location_idx} in facilities sampler\")\n        self.logger.warning(f\"Missing location idx:{location_idx}\")\n        return None, None\n\n    sampler = self.samplers[location_idx][activity]\n\n    if sampler is None:\n        self.error_counter += 1\n        if self.error_counter &gt;= patience:\n            raise UserWarning(f\"Failures to sample, exceeded patience of {patience}.\")\n        if self.random_default:\n            self.logger.warning(f\"Using random sample for zone:{location_idx}:{activity}\")\n            idx = f\"_{self.index_counter}\"\n            self.index_counter += 1\n            return idx, self.random_sampler.sample(location_idx, activity)\n        elif self.fail:\n            raise UserWarning(\n                f\"Cannot find activity: {activity} in location: {location_idx}, consider allowing random default.\"\n            )\n        else:\n            return None, None\n    else:\n        self.error_counter = 0\n        if isinstance(sampler, Generator):\n            return next(sampler)\n        else:\n            return next(sampler(mode, previous_duration, previous_loc))\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.spatial_join","title":"<code>spatial_join(facilities, zones)</code>","text":"<p>Spatially join facility and zone data.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def spatial_join(self, facilities, zones):\n    \"Spatially join facility and zone data.\"\n    self.logger.warning(\"Joining facilities data to zones, this may take a while.\")\n    activity_areas = gp.sjoin(facilities, zones, how=\"inner\", predicate=\"intersects\")\n    return activity_areas\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.FacilitySampler.write_facilities_xml","title":"<code>write_facilities_xml(path, comment=None, coordinate_reference_system=None)</code>","text":"Source code in <code>pam/samplers/facility.py</code> <pre><code>def write_facilities_xml(self, path, comment=None, coordinate_reference_system=None):\n    create_local_dir(os.path.dirname(path))\n\n    compression = DEFAULT_GZIP_COMPRESSION if is_gzip(path) else 0\n    with et.xmlfile(path, encoding=\"utf-8\", compression=compression) as xf:\n        xf.write_declaration()\n        xf.write_doctype(\n            '&lt;!DOCTYPE facilities SYSTEM \"http://matsim.org/files/dtd/facilities_v1.dtd\"&gt;'\n        )\n\n        with xf.element(\"facilities\"):\n            if comment:\n                xf.write(et.Comment(comment), pretty_print=True)\n\n            if coordinate_reference_system is not None:\n                xf.write(create_crs_attribute(coordinate_reference_system), pretty_print=True)\n\n            for i, data in self.facilities.items():\n                facility_xml = et.Element(\n                    \"facility\", {\"id\": str(i), \"x\": str(data[\"loc\"].x), \"y\": str(data[\"loc\"].y)}\n                )\n                et.SubElement(facility_xml, \"activity\", {\"type\": data[\"act\"]})\n                xf.write(facility_xml, pretty_print=True)\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.euclidean_distance","title":"<code>euclidean_distance(p1, p2)</code>","text":"<p>Calculate euclidean distance between two Activity.location.loc objects.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def euclidean_distance(p1, p2):\n    \"\"\"Calculate euclidean distance between two Activity.location.loc objects.\"\"\"\n    return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** 0.5\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.inf_yielder","title":"<code>inf_yielder(candidates, weights=None, transit_distance=None, max_walk=None, transit_modes=None, expected_euclidean_speeds=None, seed=None)</code>","text":"<p>Redirect to the appropriate sampler.</p> PARAMETER  DESCRIPTION <code>candidates</code> <p>Tuples contain candidate facilities index values and their geolocation.</p> <p> TYPE: <code>list[tuple[Any, Point]]</code> </p> <code>weights</code> <p>sampling weights (ie facility floorspace). Defaults to None.</p> <p> TYPE: <code>Optional[Series]</code> DEFAULT: <code>None</code> </p> <code>transit_distance</code> <p>distance of each candidate facility from the closest PT stop. Defaults to None.</p> <p> TYPE: <code>Optional[Series]</code> DEFAULT: <code>None</code> </p> <code>max_walk</code> <p>maximum walking distance from a PT stop. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>transit_modes</code> <p>Possible transit modes. Defaults to None.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>expected_euclidean_speeds</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[Any, Point]</code> <p>tuple[Any, shapely.geometry.Point]: Sampled candidate.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def inf_yielder(\n    candidates: list[tuple[Any, shapely.geometry.Point]],\n    weights: Optional[pd.Series] = None,\n    transit_distance: Optional[pd.Series] = None,\n    max_walk: Optional[float] = None,\n    transit_modes: Optional[list[str]] = None,\n    expected_euclidean_speeds: Optional[dict] = None,\n    seed: Optional[int] = None,\n) -&gt; tuple[Any, shapely.geometry.Point]:\n    \"\"\"Redirect to the appropriate sampler.\n\n    Args:\n        candidates (list[tuple[Any, shapely.geometry.Point]]): Tuples contain candidate facilities index values and their geolocation.\n        weights (Optional[pd.Series], optional): sampling weights (ie facility floorspace). Defaults to None.\n        transit_distance (Optional[pd.Series], optional):  distance of each candidate facility from the closest PT stop. Defaults to None.\n        max_walk (Optional[float], optional): maximum walking distance from a PT stop. Defaults to None.\n        transit_modes (Optional[list[str]], optional): Possible transit modes. Defaults to None.\n        expected_euclidean_speeds (Optional[dict], optional): Defaults to None.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n\n    Returns:\n        tuple[Any, shapely.geometry.Point]: Sampled candidate.\n    \"\"\"\n\n    if isinstance(weights, pd.Series):\n        return lambda mode=None, previous_duration=None, previous_loc=None: inf_yielder_weighted(\n            candidates=candidates,\n            weights=weights,\n            transit_distance=transit_distance,\n            max_walk=max_walk,\n            transit_modes=transit_modes,\n            expected_euclidean_speeds=expected_euclidean_speeds,\n            mode=mode,\n            previous_duration=previous_duration,\n            previous_loc=previous_loc,\n            seed=seed,\n        )\n    else:\n        return inf_yielder_simple(candidates, seed=seed)\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.inf_yielder_simple","title":"<code>inf_yielder_simple(candidates, seed=None)</code>","text":"<p>Endlessly yield shuffled candidate items.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def inf_yielder_simple(\n    candidates: list[tuple[Any, shapely.geometry.Point]], seed: Optional[int] = None\n) -&gt; Iterator[tuple[Any, shapely.geometry.Point]]:\n    \"\"\"Endlessly yield shuffled candidate items.\"\"\"\n    # Fix random seed\n    random.seed(seed)\n    while True:\n        random.shuffle(candidates)\n        for c in candidates:\n            yield c\n</code></pre>"},{"location":"reference/pam/samplers/facility/#pam.samplers.facility.inf_yielder_weighted","title":"<code>inf_yielder_weighted(candidates, weights, transit_distance, max_walk, transit_modes, expected_euclidean_speeds, mode, previous_duration, previous_loc, seed=None)</code>","text":"<p>A more complex sampler, which allows for weighted and rule-based sampling (with replacement).</p> PARAMETER  DESCRIPTION <code>candidates</code> <p>Tuples contain candidate facilities index values and their geolocation.</p> <p> TYPE: <code>list[tuple[Any, Point]]</code> </p> <code>weights</code> <p>sampling weights (ie facility floorspace).</p> <p> TYPE: <code>Optional[Series]</code> </p> <code>transit_distance</code> <p>distance of each candidate facility from the closest public transport (PT) stop.</p> <p> TYPE: <code>Optional[Series]</code> </p> <code>max_walk</code> <p>maximum walking distance from a PT stop.</p> <p> TYPE: <code>Optional[float]</code> </p> <code>transit_modes</code> <p>Possible transit modes.</p> <p> TYPE: <code>Optional[list[str]]</code> </p> <code>expected_euclidean_speeds</code> <p> TYPE: <code>Optional[dict]</code> </p> <code>mode</code> <p>transport mode used to access facility.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>previous_duration</code> <p>the time duration of the arriving leg.</p> <p> TYPE: <code>Optional[Timedelta]</code> </p> <code>previous_loc</code> <p>the location of the last visited activity.</p> <p> TYPE: <code>Optional[Point]</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>Any</code> <p>Iterator[tuple[Any, shapely.geometry.Point]]:</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def inf_yielder_weighted(\n    candidates: list[tuple[Any, shapely.geometry.Point]],\n    weights: Optional[pd.Series],\n    transit_distance: Optional[pd.Series],\n    max_walk: Optional[float],\n    transit_modes: Optional[list[str]],\n    expected_euclidean_speeds: Optional[dict],\n    mode: Optional[str],\n    previous_duration: Optional[pd.Timedelta],\n    previous_loc: Optional[shapely.geometry.Point],\n    seed: Optional[int] = None,\n) -&gt; Iterator[tuple[Any, shapely.geometry.Point]]:\n    \"\"\"A more complex sampler, which allows for weighted and rule-based sampling (with replacement).\n\n    Args:\n        candidates (list[tuple[Any, shapely.geometry.Point]]): Tuples contain candidate facilities index values and their geolocation.\n        weights (Optional[pd.Series]): sampling weights (ie facility floorspace).\n        transit_distance (Optional[pd.Series]): distance of each candidate facility from the closest public transport (PT) stop.\n        max_walk (Optional[float]): maximum walking distance from a PT stop.\n        transit_modes (Optional[list[str]]): Possible transit modes.\n        expected_euclidean_speeds (Optional[dict]):\n        mode (Optional[str]):  transport mode used to access facility.\n        previous_duration (Optional[pd.Timedelta]): the time duration of the arriving leg.\n        previous_loc (Optional[shapely.geometry.Point]):  the location of the last visited activity.\n        seed (Optional[int], optional):  If given, seed number for reproducible results. Defaults to None.\n\n\n    Yields:\n        Iterator[tuple[Any, shapely.geometry.Point]]:\n    \"\"\"\n    # Fix random seed\n    np.random.seed(seed)\n    if isinstance(weights, pd.Series):\n        # if a series of facility weights is provided, perform weighted sampling with replacement\n        while True:\n            ## if a transit mode is used and the distance from a stop is longer than the maximum walking distance,\n            ## then replace the weight with a very small value\n            if isinstance(transit_distance, pd.Series) and mode in transit_modes:\n                weights = np.where(\n                    transit_distance &gt; max_walk,\n                    weights\n                    * variables.SMALL_VALUE,  # if no alternative is found within the acceptable range, the initial weights will be used\n                    weights,\n                )\n            else:\n                weights = weights.values\n\n            # if the last location has been passed to the sampler, normalise by (expected) distance\n            if previous_loc is not None:\n                # calculate euclidean distance between the last visited location and every candidate location\n                distances = np.array(\n                    [euclidean_distance(previous_loc, candidate[1]) for candidate in candidates]\n                )\n\n                # calculate deviation from \"expected\" distance\n                speed = (\n                    expected_euclidean_speeds[mode]\n                    if mode in expected_euclidean_speeds.keys()\n                    else expected_euclidean_speeds[\"average\"]\n                )\n                expected_distance = (\n                    previous_duration / pd.Timedelta(seconds=1)\n                ) * speed  # (in meters)\n                distance_weights = np.abs(distances - expected_distance)\n                distance_weights = np.where(\n                    distance_weights == 0, variables.SMALL_VALUE, distance_weights\n                )  # avoid having zero weights\n\n                ## normalise weights by distance\n                weights = weights / (distance_weights**2)  # distance decay factor of 2\n\n            weights = weights / weights.sum()  # probability weights should add up to 1\n            yield candidates[np.random.choice(len(candidates), p=weights)]\n</code></pre>"},{"location":"reference/pam/samplers/population/","title":"pam.samplers.population","text":""},{"location":"reference/pam/samplers/population/#pam.samplers.population.sample","title":"<code>sample(population, sample, seed=None, verbose=False)</code>","text":"<p>Sample a new population from the existing using a sample size.</p> <p>Frequency of returned population is set to 1/sample, eg 0.1 -&gt; 10, such that each household and person represents 10 people from input population. Note that in the current implementation frequencies are automatically discovered from the population object households, person and leg weights, in that order. When gathering frequencies, for example for a household from multiple person in that houshold, the household frequency is taken as the average person frequency. Similarly for persons and their legs.</p> PARAMETER  DESCRIPTION <code>population</code> <p>input population object to sample from using population frequency.</p> <p> TYPE: <code>Population</code> </p> <code>sample</code> <p>sample size of new population, eg 0.1 for a 10% sample.</p> <p> TYPE: <code>float</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>verbose</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>A new Population object with households sampled based on input frequency.</p> <p> TYPE: <code>Population</code> </p> Source code in <code>pam/samplers/population.py</code> <pre><code>def sample(\n    population: Population, sample: float, seed: Optional[int] = None, verbose: bool = False\n) -&gt; Population:\n    \"\"\"Sample a new population from the existing using a sample size.\n\n    Frequency of returned population is set to 1/sample, eg 0.1 -&gt; 10, such that each household and person represents 10 people from input population.\n    Note that in the current implementation frequencies are automatically discovered from the population object households, person and leg weights, in that order.\n    When gathering frequencies, for example for a household from multiple person in that houshold, the household frequency is taken as the average person frequency.\n    Similarly for persons and their legs.\n\n    Args:\n        population (Population): input population object to sample from using population frequency.\n        sample (float):  sample size of new population, eg 0.1 for a 10% sample.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n        verbose (bool, optional): Defaults to False.\n\n    Returns:\n        Population:\n            A new Population object with households sampled based on input frequency.\n    \"\"\"\n    sampled_population = Population()\n    sample_freq = int(1 / sample)\n    size = population.size * sample\n    sampled = 0\n\n    for _, hh in population:\n        sampled_count = freq_sample(freq=hh.freq, sample=sample, seed=seed)\n\n        for n in range(sampled_count):  # add sampled hhs (note we provide new unique hid)\n            sampled_hh = deepcopy(hh)\n            sampled_hh.hid = f\"{hh.hid}-{n}\"\n            sampled_hh.people = {}\n            sampled_hh.hh_freq = sample_freq\n\n            # add sampled people (note we provide a new unique pid)\n            for pid, person in hh.people.items():\n                sampled_person = deepcopy(person)\n                sampled_person.pid = f\"{pid}-{n}\"\n                sampled_person.person_freq = sample_freq\n                sampled_hh.add(sampled_person)\n\n            sampled_population.add(sampled_hh)\n\n        if verbose:\n            sampled += sampled_count\n            progress = sampled / size\n            if progress % 0.01 == 0:\n                print(f\"Sampled approx. {progress*100}%\")\n\n    if verbose:\n        print(f\"Population sampler completed: {sampled} households from target of {size} sampled\")\n\n    return sampled_population\n</code></pre>"},{"location":"reference/pam/samplers/spatial/","title":"pam.samplers.spatial","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler","title":"<code>GeometryRandomSampler(geo_df_file, geometry_name_column, default_region, seed=None)</code>","text":"PARAMETER  DESCRIPTION <code>geo_df_file</code> <p> TYPE: <code>str</code> </p> <code>geometry_name_column</code> <p> TYPE: <code>str</code> </p> <code>default_region</code> <p> TYPE: <code>str</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def __init__(\n    self,\n    geo_df_file: str,\n    geometry_name_column: str,\n    default_region: str,\n    seed: Optional[int] = None,\n) -&gt; None:\n    \"\"\"\n\n    Args:\n        geo_df_file (str):\n        geometry_name_column (str):\n        default_region (str):\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n    \"\"\"\n    self.geo_df = gp.read_file(geo_df_file)\n    self.geometry_name_column = geometry_name_column\n    self.default_region = default_region\n\n    self.geo_df_loc_lookup = {\n        value: key for (key, value) in self.geo_df[geometry_name_column].to_dict().items()\n    }\n\n    # Throws exception if default_region is invalid\n    default_id = self.geo_df_loc_lookup[default_region]\n    self.default_geom = self.geo_df.geometry.loc[default_id]\n\n    # Store random seed\n    self.seed = seed\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.default_geom","title":"<code>default_geom = self.geo_df.geometry.loc[default_id]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.default_region","title":"<code>default_region = default_region</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.geo_df","title":"<code>geo_df = gp.read_file(geo_df_file)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.geo_df_loc_lookup","title":"<code>geo_df_loc_lookup = {value: keyfor (key, value) in self.geo_df[geometry_name_column].to_dict().items()}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.geometry_name_column","title":"<code>geometry_name_column = geometry_name_column</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.seed","title":"<code>seed = seed</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.sample_point","title":"<code>sample_point(geo_region, patience=1000)</code>","text":"<p>Randomly sample point within geodata loaded on class initialisation.</p> <p>Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry.</p> PARAMETER  DESCRIPTION <code>geo_region</code> <p> TYPE: <code>str</code> </p> <code>patience</code> <p>Defaults to 1000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RAISES DESCRIPTION <code>RuntimeWarning</code> <p>If the method cannot return a valid point within 50 attempts then a RunTimeWarning is raised.</p> RETURNS DESCRIPTION <code>Point</code> <p>Sampled geometry.</p> <p> TYPE: <code>Point</code> </p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point(self, geo_region: str, patience: int = 1000) -&gt; Point:\n    \"\"\"Randomly sample point within geodata loaded on class initialisation.\n\n    Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry.\n\n    Args:\n        geo_region (str):\n        patience (int, optional): Defaults to 1000.\n\n    Raises:\n        RuntimeWarning: If the method cannot return a valid point within 50 attempts then a RunTimeWarning is raised.\n\n    Returns:\n        Point: Sampled geometry.\n    \"\"\"\n    try:\n        geo_id = self.geo_df_loc_lookup[geo_region]\n        geom = self.geo_df.geometry.loc[geo_id]\n    except KeyError:\n        print(\"Unknown region: {}, sampling from {}\".format(geo_region, self.default_region))\n        geom = self.default_geom\n\n    # Fix random seed\n    random.seed(self.seed)\n\n    min_x, min_y, max_x, max_y = geom.bounds\n    for attempt in range(patience):\n        random_point = Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))\n        if geom.is_valid:\n            if random_point.within(geom):\n                return random_point\n        else:\n            if random_point.within(geom.buffer(0)):\n                return random_point\n\n    raise RuntimeWarning(\n        f\"unable to sample point from geometry:{geo_region} with {patience} attempts\"\n    )\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler","title":"<code>RandomPointSampler(geoms, patience=100, fail=True, seed=None)</code>","text":"<p>Returns randomly placed point within given geometries, as defined by geoms.</p> <p>Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry. If the method cannot return a valid point within 'patience' attempts then either a RunTimeWarning is raised or returns None.</p> PARAMETER  DESCRIPTION <code>geoms</code> <p> TYPE: <code>Union[GeoSeries, GeoDataFrame]</code> </p> <code>patience</code> <p>number of tries to sample point. Defaults to 100.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>fail</code> <p>If True, raise error rather than return None. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p><code>geoms</code> must be one of [gp.GeoSeries, gp.GeoDataFrame].</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def __init__(\n    self,\n    geoms: Union[gp.GeoSeries, gp.GeoDataFrame],\n    patience: int = 100,\n    fail: bool = True,\n    seed: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Returns randomly placed point within given geometries, as defined by geoms.\n\n    Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry.\n    If the method cannot return a valid point within 'patience' attempts then either a RunTimeWarning is raised or returns None.\n\n    Args:\n        geoms (Union[gp.GeoSeries, gp.GeoDataFrame]):\n        patience (int, optional): number of tries to sample point. Defaults to 100.\n        fail (bool, optional): If True, raise error rather than return None. Defaults to True.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n\n    Raises:\n        UserWarning: `geoms` must be one of [gp.GeoSeries, gp.GeoDataFrame].\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n\n    self.index = list(geoms.index)\n\n    if isinstance(geoms, gp.GeoSeries):\n        self.geoms = geoms\n\n    elif isinstance(geoms, gp.GeoDataFrame):\n        self.geoms = geoms.geometry\n\n    else:\n        raise UserWarning(\n            f\"Unknown datatype: {type(geoms)}, please use GeoSeries or GeoDataFrame\"\n        )\n\n    self.patience = patience\n    self.fail = fail\n    # Store random seed\n    self.seed = seed\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.fail","title":"<code>fail = fail</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.geoms","title":"<code>geoms = geoms</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.index","title":"<code>index = list(geoms.index)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.patience","title":"<code>patience = patience</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.seed","title":"<code>seed = seed</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample","title":"<code>sample(idx, activity)</code>","text":"PARAMETER  DESCRIPTION <code>idx</code> <p>index of initialised geometry dataset.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>activity</code> <p>Unused. Kept for consistency across samplers.</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p><code>idx</code> must be in input geometry if <code>self.fail</code> is True.</p> RETURNS DESCRIPTION <code>Optional[Point]</code> <p>Optional[Point]: None if <code>idx</code> not in input geometry and <code>self.fail</code> is False.</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample(self, idx: Union[int, str], activity: Any) -&gt; Optional[Point]:\n    \"\"\"\n    Args:\n        idx (Union[int, str]): index of initialised geometry dataset.\n        activity (Any): Unused. Kept for consistency across samplers.\n\n    Raises:\n        IndexError: `idx` must be in input geometry if `self.fail` is True.\n\n    Returns:\n        Optional[Point]: None if `idx` not in input geometry and `self.fail` is False.\n    \"\"\"\n    if idx not in self.index:\n        if self.fail:\n            raise IndexError(f\"Cannot find idx: {idx} in geoms index\")\n        self.logger.warning(f\"Cannot find idx:{idx}, returning None\")\n        return None\n\n    geom = self.geoms[idx]\n\n    if not geom.is_valid:\n        geom.buffer(0)\n\n    if geom.geom_type == \"Polygon\":\n        return self.validate_return(self.sample_point_from_polygon(geom), idx)\n\n    if geom.geom_type == \"MultiPolygon\":\n        return self.validate_return(self.sample_point_from_multipolygon(geom), idx)\n\n    if geom.geom_type == \"LineString\" or geom.geom_type == \"LinearRing\":\n        return self.validate_return(self.sample_point_from_linestring(geom), idx)\n\n    if geom.geom_type == \"MultiLineString\":\n        return self.validate_return(self.sample_point_from_multilinestring(geom), idx)\n\n    if geom.geom_type == \"Point\":\n        return self.validate_return(self.sample_point_from_point(geom), idx)\n\n    if geom.geom_type == \"MultiPoint\":\n        return self.validate_return(self.sample_point_from_multipoint(geom), idx)\n\n    self.logger.warning(f\"Unknown geom type {geom.geom_type}, attempting to sample.\")\n\n    return self.validate_return(self.sample_point_from_polygon(geom), idx)\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_linestring","title":"<code>sample_point_from_linestring(geom)</code>","text":"<p>Also works for linearRing.</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_linestring(self, geom):\n    \"\"\"Also works for linearRing.\"\"\"\n    # Fix random seed\n    random.seed(self.seed)\n    return geom.interpolate(random.random(), True)\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_multilinestring","title":"<code>sample_point_from_multilinestring(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_multilinestring(self, geom):\n    # Fix random seed\n    random.seed(self.seed)\n    line = random.choice(list(geom.geoms))\n    return self.sample_point_from_linestring(line)\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_multipoint","title":"<code>sample_point_from_multipoint(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_multipoint(self, geom):\n    # Fix random seed\n    random.seed(self.seed)\n    return random.choice(list(geom.geoms))\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_multipolygon","title":"<code>sample_point_from_multipolygon(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_multipolygon(self, geom):\n    # Fix random seed\n    random.seed(self.seed)\n    poly = random.choices(geom.geoms, weights=[poly.area for poly in geom.geoms])[0]\n    return self.sample_point_from_polygon(poly)\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_point","title":"<code>sample_point_from_point(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_point(self, geom):\n    return geom\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_polygon","title":"<code>sample_point_from_polygon(geom)</code>","text":"<p>Return random coordinates within polygon, note that will return float coordinates.</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_polygon(self, geom):\n    \"\"\"Return random coordinates within polygon, note that will return float coordinates.\"\"\"\n    # Fix random seed\n    random.seed(self.seed)\n    min_x, min_y, max_x, max_y = geom.bounds\n    for _ in range(self.patience):\n        random_point = Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))\n        if random_point.within(geom):\n            return random_point\n\n    return Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))\n</code></pre>"},{"location":"reference/pam/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.validate_return","title":"<code>validate_return(point, idx)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def validate_return(self, point, idx):\n    if point is None and self.fail:\n        raise TimeoutError(f\"Failed to sample point for geom idx: {idx}\")\n    return point\n</code></pre>"},{"location":"reference/pam/samplers/time/","title":"pam.samplers.time","text":""},{"location":"reference/pam/samplers/time/#pam.samplers.time.apply_jitter_to_plan","title":"<code>apply_jitter_to_plan(plan, jitter, min_duration)</code>","text":"<p>Apply time jitter to activity durations in a plan, leg durations are kept the same. Activity durations are jittered in sequence order. At each step the activity is jittered according to the maximum jitter and minimum duration of all activities in the plan.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>plan to be jittered</p> <p> TYPE: <code>Plan</code> </p> <code>jitter</code> <p>maximum jitter</p> <p> TYPE: <code>timedelta</code> </p> <code>min_duration</code> <p>minimum activity duration.</p> <p> TYPE: <code>timedelta</code> </p> Source code in <code>pam/samplers/time.py</code> <pre><code>def apply_jitter_to_plan(plan: Plan, jitter: timedelta, min_duration: timedelta):\n    \"\"\"Apply time jitter to activity durations in a plan, leg durations are kept the same.\n    Activity durations are jittered in sequence order. At each step the activity\n    is jittered according to the maximum jitter and minimum duration of all activities\n    in the plan.\n\n    Args:\n        plan (Plan): plan to be jittered\n        jitter (timedelta): maximum jitter\n        min_duration (timedelta): minimum activity duration.\n    \"\"\"\n    if plan.length == 1:  # do nothing\n        return None\n    for i in range(0, plan.length - 1, 2):\n        jitter_activity(plan, i, jitter=jitter, min_duration=min_duration)\n</code></pre>"},{"location":"reference/pam/samplers/time/#pam.samplers.time.jitter_activity","title":"<code>jitter_activity(plan, i, jitter, min_duration)</code>","text":"<p>Jitter duration of given activity at index i.</p> <p>Remaining activities and legs after activity are also shifted. Leg durations are not changed. Subsequent activity durations are equally change to maintain 24hr plan.</p> PARAMETER  DESCRIPTION <code>plan</code> <p> TYPE: <code>Plan</code> </p> <code>i</code> <p> TYPE: <code>int</code> </p> <code>jitter</code> <p> TYPE: <code>timedelta</code> </p> <code>min_duration</code> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>index <code>i</code> of <code>plan</code> must be of type <code>Activity</code>.</p> Source code in <code>pam/samplers/time.py</code> <pre><code>def jitter_activity(plan: Plan, i: int, jitter: timedelta, min_duration: timedelta):\n    \"\"\"Jitter duration of given activity at index i.\n\n    Remaining activities and legs after activity are also shifted.\n    Leg durations are not changed.\n    Subsequent activity durations are equally change to maintain 24hr plan.\n\n    Args:\n        plan (Plan):\n        i (int):\n        jitter (timedelta):\n        min_duration (timedelta):\n\n    Raises:\n        UserWarning: index `i` of `plan` must be of type `Activity`.\n    \"\"\"\n    act = plan[i]\n    if not isinstance(act, Activity):\n        raise UserWarning(f\"Expected type of Activity for act, not {type(act)}\")\n\n    prev_duration = act.duration\n    tail = (len(plan) - i) / 2\n\n    min_end = max(act.start_time + min_duration, act.end_time - jitter)\n\n    allowance = plan[-1].end_time - act.end_time\n    for j in range(i + 1, len(plan), 2):  # legs\n        allowance = -plan[j].duration\n    for j in range(i + 2, len(plan) + 1, 2):  # acts\n        allowance = -min_duration\n\n    max_end = min(plan[-1].end_time - allowance, act.end_time + jitter)\n    jitter_range = max((max_end - min_end).seconds, 1)\n\n    jitter = timedelta(seconds=randrange(jitter_range))\n    new_duration = min_end - act.start_time + jitter\n    change = (new_duration - prev_duration) / tail\n\n    time = act.shift_duration(new_duration)\n    time = plan[i + 1].shift_start_time(time)  # shift first tail leg\n\n    for j in range(i + 2, len(plan) - 1, 2):  # tail acts\n        time = plan[j].shift_start_time(time)\n        time = plan[j].shift_duration(plan[j].duration - change)\n        time = plan[j + 1].shift_start_time(time)  # leg\n\n    # final act\n    time = plan[-1].shift_start_time(time)\n    plan[-1].end_time = END_OF_DAY\n</code></pre>"},{"location":"reference/pam/samplers/tour/","title":"pam.samplers.tour","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.FrequencySampler","title":"<code>FrequencySampler(dist, freq=None, threshold_matrix=None, threshold_value=None)</code>","text":"<p>Object for initiating and sampling from frequency weighted distributing. This object includes three samplers: a single sample, multiple samples, or sample based on a threshold value (requires a threshold matrix).</p> PARAMETER  DESCRIPTION <code>dist</code> <p>Input distribution. If a DataFrame is given, the index will be used.</p> <p> TYPE: <code>Union[Iterable, DataFrame]</code> </p> <code>freq</code> <p>If given, weighting for input items, either as an iterable or a reference to a column of <code>dist</code> (which then must be a DataFrame). Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Iterable]]</code> DEFAULT: <code>None</code> </p> <code>threshold_matrix</code> <p>A dataframe that will be reduced based on a specified threshold_value. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>threshold_value</code> <p>A value to filter the threshold_matrix. This is the maximum allowed value. Defaults to None.</p> <p> TYPE: <code>Optional[Union[int, float]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(\n    self,\n    dist: Union[Iterable, pd.DataFrame],\n    freq: Optional[Union[str, Iterable]] = None,\n    threshold_matrix: Optional[pd.DataFrame] = None,\n    threshold_value: Optional[Union[int, float]] = None,\n) -&gt; None:\n    \"\"\"\n\n    Args:\n        dist (Union[Iterable, pd.DataFrame]):\n            Input distribution. If a DataFrame is given, the index will be used.\n        freq (Optional[Union[str, Iterable]], optional):\n            If given, weighting for input items, either as an iterable or a reference to a column of `dist` (which then must be a DataFrame).\n            Defaults to None.\n        threshold_matrix (Optional[pd.DataFrame], optional):\n            A dataframe that will be reduced based on a specified threshold_value. Defaults to None.\n        threshold_value (Optional[Union[int, float]], optional):\n            A value to filter the threshold_matrix. This is the maximum allowed value. Defaults to None.\n    \"\"\"\n    self.distribution = dist\n    self.frequency = freq\n    self.threshold_matrix = threshold_matrix\n    self.threshold_value = threshold_value\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.FrequencySampler.distribution","title":"<code>distribution = dist</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.FrequencySampler.frequency","title":"<code>frequency = freq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.FrequencySampler.threshold_matrix","title":"<code>threshold_matrix = threshold_matrix</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.FrequencySampler.threshold_value","title":"<code>threshold_value = threshold_value</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.FrequencySampler.sample","title":"<code>sample()</code>","text":"RETURNS DESCRIPTION <code>Any</code> <p>Single object sampled from distribution</p> <p> TYPE: <code>Any</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def sample(self) -&gt; Any:\n    \"\"\"\n\n    Returns:\n        Any: Single object sampled from distribution\n\n    \"\"\"\n    return random.choices(self.distribution, weights=self.frequency, k=1)[0]\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.FrequencySampler.samples","title":"<code>samples(n=1)</code>","text":"PARAMETER  DESCRIPTION <code>n</code> <p>number of samples to be returned. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list</code> <p>objects sampled from distribution</p> <p> TYPE: <code>list</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def samples(self, n: int = 1) -&gt; list:\n    \"\"\"\n\n    Args:\n      n (int, optional): number of samples to be returned. Defaults to 1.\n\n    Returns:\n      list: objects sampled from distribution\n\n    \"\"\"\n    return random.choices(self.distribution, weights=self.frequency, k=n)\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.FrequencySampler.threshold_sample","title":"<code>threshold_sample()</code>","text":"<p>Returns a sampler of a distribution that has been reduced based on a threshold value.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def threshold_sample(self):\n    \"\"\"Returns a sampler of a distribution that has been reduced based on a threshold value.\"\"\"\n    d_list = self.threshold_matrix\n    d_list = d_list[d_list &lt;= self.threshold_value].index\n    d_threshold = self.distribution[self.distribution.index.isin(d_list)]\n\n    if len(d_threshold) == 0:\n        warnings.warn(\"No destinations within this threshold value, change threshold\")\n        return None\n    else:\n        return random.choices(\n            list(d_threshold.index), weights=list(d_threshold[self.frequency]), k=1\n        )[0]\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.PivotDistributionSampler","title":"<code>PivotDistributionSampler(bins, pivots, total=None)</code>","text":"<p>Defines a distribution, a sampler, and plots based on input values. The resulting distribution can be sampled for inputs required to build an agent plan (i.e, time of day, repetition of activities).</p> <p>Builds a dict distribution based on bins (i.e, hours) and pivots (i.e, hourly demand).</p> <p>Where the input pivot does not specify a value, values are estimated within the bin range by interpolation.</p> PARAMETER  DESCRIPTION <code>bins</code> <p>a range or dictionary of values</p> <p> TYPE: <code>Iterable</code> </p> <code>pivots</code> <p>a dictionary of values associated with the bins.</p> <p> TYPE: <code>dict</code> </p> <code>total</code> <p>Defaults to None.</p> <p> TYPE: <code>optional</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(self, bins: Iterable, pivots: dict, total=None):\n    \"\"\"Builds a dict distribution based on bins (i.e, hours) and pivots (i.e, hourly demand).\n\n    Where the input pivot does not specify a value, values are estimated within the bin range by interpolation.\n\n    Args:\n        bins (Iterable): a range or dictionary of values\n        pivots (dict): a dictionary of values associated with the bins.\n        total (optional): Defaults to None.\n    \"\"\"\n    self.demand = {}\n\n    if bins[0] not in pivots:\n        pivots[bins[0]] = 0\n    if bins[-1] + 1 not in pivots:\n        pivots[bins[-1] + 1] = 0\n\n    pivot_keys = sorted(pivots.keys())\n\n    for k in range(len(pivot_keys) - 1):\n        ka = pivot_keys[k]\n        kb = pivot_keys[k + 1]\n        pivot_a = pivots[ka]\n        pivot_b = pivots[kb]\n        for i in bins:\n            if ka &lt;= i &lt; kb:\n                self.demand[i] = self._interpolate(i, ka, pivot_a, kb, pivot_b)\n            else:\n                continue\n\n    if total is not None:\n        dist_sum = sum(self.demand.values())\n        for i in bins:\n            self.demand[i] = (self.demand[i] / dist_sum) * total\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.PivotDistributionSampler.demand","title":"<code>demand = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.PivotDistributionSampler.plot","title":"<code>plot(plot_title, x_label, y_label)</code>","text":"<p>Plots distribution to validate the distribution aligns with expected hourly demand.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot(self, plot_title, x_label, y_label):\n    \"\"\"Plots distribution to validate the distribution aligns with expected hourly demand.\"\"\"\n    fig, ax = plt.subplots(figsize=(10, 4))\n    ax.bar(list(self.demand.keys()), list(self.demand.values()))\n    ax.plot(list(self.demand.keys()), list(self.demand.values()), c=\"orange\")\n    ax.set_title(plot_title)\n    ax.set_xlabel(x_label)\n    ax.set_ylabel(y_label)\n\n    return fig\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.PivotDistributionSampler.sample","title":"<code>sample()</code>","text":"Source code in <code>pam/samplers/tour.py</code> <pre><code>def sample(self):\n    return random.choices(list(self.demand.keys()), list(self.demand.values()), k=1)[0]\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner","title":"<code>TourPlanner(stops, hour, minute, o_zone, d_dist, d_freq, facility_sampler, activity_params, threshold_matrix=None, threshold_value=None)</code>","text":"<p>Object for agents to efficiently plan their tours by sequencing stops and adding activities and legs.</p> <p>The TourPlanner optimises the sequence of stops using a Greedy Travelling Salesman Problem (TSP) algorithm based on Eucledian distances between sampled stops. It takes into account origin and destination zones, facility distributions, and other relevant parameters to build a tour plan for agents.</p> PARAMETER  DESCRIPTION <code>stops</code> <p> TYPE: <code>int</code> </p> <code>hour</code> <p>input of sampled hour.</p> <p> TYPE: <code>int</code> </p> <code>minute</code> <p>input of sampled minute.</p> <p> TYPE: <code>int</code> </p> <code>o_zone</code> <p>origin zone.</p> <p> TYPE: <code>str</code> </p> <code>d_dist</code> <p>distribution of destination zones.</p> <p> TYPE: <code>Union[Iterable, DataFrame]</code> </p> <code>d_freq</code> <p>frequency value to sample of destination distribution.</p> <p> TYPE: <code>Union[str, Iterable]</code> </p> <code>facility_sampler</code> <p> TYPE: <code>FacilitySampler</code> </p> <code>activity_params</code> <p>dictionary of str of origin activity (str) and destination activity (str).</p> <p> TYPE: <code>dict[str, str]</code> </p> <code>threshold_matrix</code> <p>dataframe that will be reduced based on threshold value. Defaults to None.</p> <p> TYPE: <code>optional</code> DEFAULT: <code>None</code> </p> <code>threshold_value</code> <p>maximum threshold value allowed between origin and destination in threshold_matrix. Defaults to None.</p> <p> TYPE: <code>optional</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(\n    self,\n    stops: int,\n    hour: int,\n    minute: int,\n    o_zone: str,\n    d_dist: pd.DataFrame,\n    d_freq: Union[str, Iterable],\n    facility_sampler: FacilitySampler,\n    activity_params: dict[str, str],\n    threshold_matrix=None,\n    threshold_value=None,\n):\n    \"\"\"\n    Args:\n        stops (int): # of stops.\n        hour (int): input of sampled hour.\n        minute (int): input of sampled minute.\n        o_zone (str): origin zone.\n        d_dist (Union[Iterable, pd.DataFrame]): distribution of destination zones.\n        d_freq (Union[str, Iterable]): frequency value to sample of destination distribution.\n        facility_sampler (FacilitySampler):\n        activity_params (dict[str, str]): dictionary of str of origin activity (str) and destination activity (str).\n        threshold_matrix (optional): dataframe that will be reduced based on threshold value. Defaults to None.\n        threshold_value (optional): maximum threshold value allowed between origin and destination in threshold_matrix. Defaults to None.\n    \"\"\"\n    self.stops = stops\n    self.hour = hour\n    self.minute = minute\n    self.o_zone = o_zone\n    self.threshold_matrix = threshold_matrix\n    self.d_dist = d_dist\n    self.d_freq = d_freq\n    self.threshold_value = threshold_value\n    self.facility_sampler = facility_sampler\n    self.o_activity = activity_params[\"o_activity\"]\n    self.d_activity = activity_params[\"d_activity\"]\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner--of-stops","title":"of stops.","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.d_activity","title":"<code>d_activity = activity_params['d_activity']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.d_dist","title":"<code>d_dist = d_dist</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.d_freq","title":"<code>d_freq = d_freq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.facility_sampler","title":"<code>facility_sampler = facility_sampler</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.hour","title":"<code>hour = hour</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.minute","title":"<code>minute = minute</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.o_activity","title":"<code>o_activity = activity_params['o_activity']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.o_zone","title":"<code>o_zone = o_zone</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.stops","title":"<code>stops = stops</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.threshold_matrix","title":"<code>threshold_matrix = threshold_matrix</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.threshold_value","title":"<code>threshold_value = threshold_value</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.add_tour_activity","title":"<code>add_tour_activity(agent, k, zone, loc, activity_type, time_params)</code>","text":"<p>Add activity to tour plan. This will add an activity to the agent plan after each leg within the tour.</p> PARAMETER  DESCRIPTION <code>agent</code> <p>agent for which the activity will be added to Plan</p> <p> TYPE: <code>str</code> </p> <code>k</code> <p>when used in a for loop, k populates the next sequence value</p> <p> TYPE: <code>int</code> </p> <code>zone</code> <p>zone where activity takes place</p> <p> TYPE: <code>str</code> </p> <code>loc</code> <p>facility location where activity takes place</p> <p> TYPE: <code>Point</code> </p> <code>activity_type</code> <p>this function has specific logic for 'return_origin'</p> <p> TYPE: <code>str</code> </p> <code>time_params</code> <p>dictionary of time_params that may be time samplers or times of previous journeys</p> <p> TYPE: <code>dict[str, str]</code> </p> RETURNS DESCRIPTION <code>int</code> <p>end_tm of activity.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def add_tour_activity(\n    self, agent: str, k: Iterable, zone: str, loc: Point, activity_type: str, time_params: dict\n) -&gt; int:\n    \"\"\"Add activity to tour plan. This will add an activity to the agent plan after each leg within the tour.\n\n    Args:\n      agent (str): agent for which the activity will be added to Plan\n      k (int): when used in a for loop, k populates the next sequence value\n      zone (str): zone where activity takes place\n      loc (shapely.Point): facility location where activity takes place\n      activity_type (str): this function has specific logic for 'return_origin'\n      time_params (dict[str, str]): dictionary of time_params that may be time samplers or times of previous journeys\n\n    Returns:\n      int: end_tm of activity.\n\n    \"\"\"\n    if activity_type == self.o_activity:\n        start_tm = 0\n        end_tm = (time_params[\"hour\"] * 60) + time_params[\"minute\"]\n        seq = 1\n        act = activity_type\n    elif activity_type == \"return_origin\":\n        start_tm = time_params[\"start_tm\"]  # end_tm\n        end_tm = time_params[\"end_tm\"]  # END_OF_DAY we'll let pam trim this to 24 hours later\n        seq = k + 2\n        act = self.o_activity\n    else:\n        start_tm = time_params[\"end_tm\"]\n        end_tm = time_params[\"end_tm\"] + int(time_params[\"stop_duration\"] / 60)\n        seq = k + 2\n        act = activity_type\n\n    # Activity plan requires mtdt format, but int format needs to passed for other functions to calculate new start time.\n    # END_OF_DAY is already in mtdt format, adding an exception to keep set mtdt format when not END_OF_DAY.\n    if end_tm is not END_OF_DAY:\n        end_tm_mtdt = mtdt(end_tm)\n    else:\n        end_tm_mtdt = end_tm\n\n    agent.add(\n        Activity(\n            seq=seq,\n            act=act,\n            area=zone,\n            loc=loc,\n            start_time=mtdt(start_tm),\n            end_time=end_tm_mtdt,\n        )\n    )\n\n    return end_tm\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.add_tour_leg","title":"<code>add_tour_leg(agent, k, o_zone, o_loc, d_zone, d_loc, start_tm, end_tm)</code>","text":"<p>Leg to Next Activity within the tour. This adds a leg to the agent plan after each activity is complete within the tour. Args:   agent (str): agent for which the leg will be added to Plan   k (Iterable): when used in a for loop, k populates the next sequence value   o_zone (str): origin zone of leg   o_loc (shapely.point): origin facility of leg   d_zone (str): destination zone of leg   d_loc (shapely.point): destination facility of leg   start_tm (int): obtained from DurationEstimator object   end_tm (int): obtained from DurationEstimator object</p> RETURNS DESCRIPTION <code>int</code> <p>new end_tm after leg is added to plan.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def add_tour_leg(\n    self,\n    agent: str,\n    k: Iterable,\n    o_zone: str,\n    o_loc: Point,\n    d_zone: str,\n    d_loc: Point,\n    start_tm: int,\n    end_tm: int,\n) -&gt; int:\n    \"\"\"Leg to Next Activity within the tour. This adds a leg to the agent plan after each activity is complete within the tour.\n    Args:\n      agent (str): agent for which the leg will be added to Plan\n      k (Iterable): when used in a for loop, k populates the next sequence value\n      o_zone (str): origin zone of leg\n      o_loc (shapely.point): origin facility of leg\n      d_zone (str): destination zone of leg\n      d_loc (shapely.point): destination facility of leg\n      start_tm (int): obtained from DurationEstimator object\n      end_tm (int): obtained from DurationEstimator object\n\n    Returns:\n      int: new end_tm after leg is added to plan.\n    \"\"\"\n    agent.add(\n        Leg(\n            seq=k + 1,\n            mode=\"car\",\n            start_area=o_zone,\n            end_area=d_zone,\n            start_loc=o_loc,\n            end_loc=d_loc,\n            start_time=mtdt(start_tm),\n            end_time=mtdt(end_tm),\n        )\n    )\n\n    return end_tm\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.apply","title":"<code>apply(agent, o_loc, d_zones, d_locs)</code>","text":"<p>Apply the above functions to the agent to build a plan. 1. Add first activity 2. cycle through d_plan and add leg/activity 3. add leg/activity to return to origin</p> PARAMETER  DESCRIPTION <code>agent</code> <p>agent to build a plan fory</p> <p> TYPE: <code>str</code> </p> <code>o_loc</code> <p>origin facility of leg &amp; activity</p> <p> TYPE: <code>Point</code> </p> <code>d_zones</code> <p>destination zones of leg &amp; activity</p> <p> TYPE: <code>list</code> </p> <code>d_locs</code> <p>destination facilities of leg &amp; activity.</p> <p> TYPE: <code>list</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def apply(self, agent: str, o_loc: Point, d_zones: list, d_locs: list) -&gt; None:\n    \"\"\"Apply the above functions to the agent to build a plan.\n    1. Add first activity\n    2. cycle through d_plan and add leg/activity\n    3. add leg/activity to return to origin\n\n    Args:\n      agent (str): agent to build a plan fory\n      o_loc (shapely.Point): origin facility of leg &amp; activity\n      d_zones (list): destination zones of leg &amp; activity\n      d_locs (list): destination facilities of leg &amp; activity.\n    \"\"\"\n\n    # add origin activity\n    time_params = {\"hour\": self.hour, \"minute\": self.minute}\n    # first activity\n    end_tm = self.add_tour_activity(\n        agent=agent,\n        k=1,\n        zone=self.o_zone,\n        loc=o_loc,\n        activity_type=self.o_activity,\n        time_params=time_params,\n    )\n    # add stops to plan\n    for k in range(len(d_locs)):\n        if k == 0:\n            previous_zone = self.o_zone\n            previous_loc = o_loc\n        else:\n            previous_zone = d_zones[k - 1]\n            previous_loc = d_locs[k - 1]\n\n        start_tm = end_tm\n        trip_distance = model_distance(previous_loc, d_locs[k])\n        trip_duration = model_journey_time(trip_distance)\n        activity_duration = model_activity_time(trip_duration)\n        end_tm = end_tm + int(trip_duration / 60)\n\n        end_tm = self.add_tour_leg(\n            agent=agent,\n            k=k,\n            o_zone=previous_zone,\n            o_loc=previous_loc,\n            d_zone=d_zones[k],\n            d_loc=d_locs[k],\n            start_tm=start_tm,\n            end_tm=end_tm,\n        )\n\n        time_params = {\"end_tm\": end_tm, \"stop_duration\": activity_duration}\n        end_tm = self.add_tour_activity(\n            agent=agent,\n            k=k,\n            zone=d_zones[k],\n            loc=d_locs[k],\n            activity_type=self.d_activity,\n            time_params=time_params,\n        )\n    # returning to origin\n\n    start_tm = end_tm\n    trip_distance = model_distance(d_locs[len(d_locs) - 1], o_loc)\n    trip_duration = model_journey_time(trip_distance)\n    end_tm = end_tm + int(trip_duration / 60)\n\n    end_tm = self.add_tour_leg(\n        agent=agent,\n        k=k + 1,\n        o_zone=d_zones[-1],\n        o_loc=d_locs[-1],\n        d_zone=self.o_zone,\n        d_loc=o_loc,\n        start_tm=start_tm,\n        end_tm=end_tm,\n    )\n\n    time_params = {\"start_tm\": end_tm, \"end_tm\": END_OF_DAY}\n    end_tm = self.add_tour_activity(\n        agent=agent,\n        k=k,\n        zone=self.o_zone,\n        loc=o_loc,\n        activity_type=\"return_origin\",\n        time_params=time_params,\n    )\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.approx_greedy_tsp","title":"<code>approx_greedy_tsp(dist_matrix)</code>","text":"<p>Approximate solution to the Travelling Saleman Problem using the GreedyTSP algorithm.</p> PARAMETER  DESCRIPTION <code>dist_matrix</code> <p>2D NumPy array representing the distance matrix between origin and destinations.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>List[int]</code> <p>List[int]: List of integers representing the optimised sequence of stops.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def approx_greedy_tsp(self, dist_matrix) -&gt; List[int]:\n    \"\"\"Approximate solution to the Travelling Saleman Problem using the GreedyTSP algorithm.\n\n    Args:\n        dist_matrix (np.ndarray): 2D NumPy array representing the distance matrix between origin and destinations.\n\n    Returns:\n        List[int]: List of integers representing the optimised sequence of stops.\n    \"\"\"\n    distance_graph = nx.from_numpy_array(dist_matrix)\n    seq = nx.algorithms.approximation.greedy_tsp(distance_graph, source=0)\n\n    return seq\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.create_distance_matrix","title":"<code>create_distance_matrix(o_loc, d_seq)</code>","text":"<p>Create a distance matrix between the origin location and a list of destinations.</p> PARAMETER  DESCRIPTION <code>o_loc</code> <p>shapely.geometry.Point representing the sampled origin location.</p> <p> TYPE: <code>Point</code> </p> <code>d_seq</code> <p>A list of dictionaries containing information about each stop in the tour.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: 2D NumPy array representing the distance matrix between origin and destinations.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def create_distance_matrix(self, o_loc: Point, d_seq: list) -&gt; np.ndarray:\n    \"\"\"Create a distance matrix between the origin location and a list of destinations.\n\n    Args:\n        o_loc (Point): shapely.geometry.Point representing the sampled origin location.\n        d_seq (List[Dict[str, Any]]): A list of dictionaries containing information about each stop in the tour.\n\n    Returns:\n        np.ndarray: 2D NumPy array representing the distance matrix between origin and destinations.\n    \"\"\"\n    # extract o_loc coordinates into array\n    o_location = np.array([[o_loc.x, o_loc.y]])\n\n    # extract d_facility\n    d_locations = np.array(\n        [[location.x, location.y] for location in [d[\"destination_facility\"] for d in d_seq]]\n    )\n\n    locs = np.concatenate([o_location, d_locations], 0)\n    dist_matrix = distance_matrix(locs, locs)\n\n    return dist_matrix\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.d_zone_sample_choice","title":"<code>d_zone_sample_choice()</code>","text":"<p>Samples a destination zone (d_zone) as a string, dependent on the presence of a threshold matrix.</p> RETURNS DESCRIPTION <code>str</code> <p>d_zone</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def d_zone_sample_choice(self) -&gt; str:\n    \"\"\"Samples a destination zone (d_zone) as a string, dependent on the presence of a threshold matrix.\n\n    Returns:\n        str: d_zone\n\n    \"\"\" \"\"\n    if self.threshold_matrix is None:\n        d_zone = FrequencySampler(self.d_dist.index, self.d_dist[self.d_freq]).sample()\n    else:\n        d_zone = FrequencySampler(\n            dist=self.d_dist,\n            freq=self.d_freq,\n            threshold_matrix=self.threshold_matrix.loc[self.o_zone],\n            threshold_value=self.threshold_value,\n        ).threshold_sample()\n\n    return d_zone\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.reorder_destinations","title":"<code>reorder_destinations(d_seq, seq)</code>","text":"<p>Reorder the destinations based on the provided sequence.</p> PARAMETER  DESCRIPTION <code>d_seq</code> <p>A list of dictionaries containing information about each stop (destination) in the tour.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>seq</code> <p>List of integers representing the optimised sequence of stops.</p> <p> TYPE: <code>List[int]</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing the reordered stops (destinations)</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def reorder_destinations(self, d_seq, seq) -&gt; List[Dict[str, Any]]:\n    \"\"\"Reorder the destinations based on the provided sequence.\n\n    Args:\n        d_seq (List[Dict[str, Any]]): A list of dictionaries containing information about each stop (destination) in the tour.\n        seq (List[int]): List of integers representing the optimised sequence of stops.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing the reordered stops (destinations)\n    \"\"\"\n    # use `seq` to re-order `d_locs` into an ordered list of dictionaries\n    # remove o_loc (first and last stop) from sequence &amp; adjust sequence range\n    d_seq = [d_seq[order - 1] for order in seq[1:-1]]\n\n    return d_seq\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.sample_destinations","title":"<code>sample_destinations(o_loc)</code>","text":"<p>Samples destinations and prevents repeated sampling of destinations, and prevents origin from be sampled as a destination</p> PARAMETER  DESCRIPTION <code>o_loc</code> <p>shapely.geometry.Point representing the sampled origin location.</p> <p> TYPE: <code>Point</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries containing information about each stop in the tour.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def sample_destinations(self, o_loc) -&gt; List[Dict[str, Any]]:\n    \"\"\"Samples destinations and prevents repeated sampling of destinations, and prevents origin from be sampled as a destination\n\n    Args:\n        o_loc (Point): shapely.geometry.Point representing the sampled origin location.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries containing information about each stop in the tour.\n    \"\"\"\n    d_seq = []\n    sampled_d_facilities = []\n\n    for stop in range(self.stops):\n        # If threshold matrix is none, sample a random d_zone, else select a d_zone within threshold value\n        d_zone = TourPlanner.d_zone_sample_choice(self)\n        # once d_zone is selected, select a specific point location for d_activity\n        d_facility = self.facility_sampler.sample(d_zone, self.d_activity)\n\n        # prevent the depot from being sampled as a delivery (destination) or duplicate sampling of delivery (destination) locations\n        while d_facility == o_loc or d_facility in sampled_d_facilities:\n            d_zone = TourPlanner.d_zone_sample_choice(self)\n            d_facility = self.facility_sampler.sample(d_zone, self.d_activity)\n\n        # append select d_facility to sampled list for tracking\n        sampled_d_facilities.append(d_facility)\n\n        # append to a dictionary to sequence destinations\n        d_seq.append(\n            {\n                \"stops\": stop,\n                \"destination_zone\": d_zone,\n                \"destination_facility\": d_facility,\n                \"distance\": model_distance(o_loc, d_facility),\n            }\n        )\n    return d_seq\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.TourPlanner.sequence_stops","title":"<code>sequence_stops()</code>","text":"<p>Creates a sequence for a number of stops. Sequence is determined by approximated greedy TSP</p> RETURNS DESCRIPTION <code>tuple[Point, list[Point], list[Point]]</code> <p>tuple[Point, list, list]: (o_loc, d_zones, d_locs).</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def sequence_stops(self) -&gt; tuple[Point, list[Point], list[Point]]:\n    \"\"\"Creates a sequence for a number of stops. Sequence is determined by approximated greedy TSP\n\n    Returns:\n      tuple[Point, list, list]: (o_loc, d_zones, d_locs).\n\n    \"\"\"\n    o_loc = self.facility_sampler.sample(self.o_zone, self.o_activity)\n\n    d_seq = TourPlanner.sample_destinations(self, o_loc)\n    dist_matrix = TourPlanner.create_distance_matrix(self, o_loc, d_seq)\n\n    seq = TourPlanner.approx_greedy_tsp(self, dist_matrix)\n\n    d_optimised_seq = TourPlanner.reorder_destinations(self, d_seq, seq)\n\n    # sort distance: furthest facility to closest facility to origin facility. The final stop should be closest to origin.\n    d_zones = [item.get(\"destination_zone\") for item in d_optimised_seq]\n    d_locs = [item.get(\"destination_facility\") for item in d_optimised_seq]\n\n    return o_loc, d_zones, d_locs\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.ValidateTourOD","title":"<code>ValidateTourOD(trips, zone, o_dist, d_dist, o_activity, d_activity, o_freq, d_freq)</code>","text":"<p>Object to build a dataframe that produces both spatial and statistical plots to validate the tour origin and destinations align with input data.</p> <p>Create a dataframe that counts the number of origin and destination activities.</p> <p>Merge this against the density information from the input origin and destination samplers.</p> PARAMETER  DESCRIPTION <code>trips</code> <p>the legs.csv output after building population.</p> <p> TYPE: <code>DataFrame</code> </p> <code>zone</code> <p> TYPE: <code>GeoDataFrame</code> </p> <code>o_dist</code> <p>sampler containing origin distributions to be sampled.</p> <p> TYPE: <code>DataFrame</code> </p> <code>d_dist</code> <p>sampler containing destination distributions to be sampled.</p> <p> TYPE: <code>DataFrame</code> </p> <code>o_activity</code> <p>activity utilised within o_dist.</p> <p> TYPE: <code>str</code> </p> <code>d_activity</code> <p>activity utilised within d_dist.</p> <p> TYPE: <code>str</code> </p> <code>o_freq</code> <p>destination frequency that is used to sample origin distributions.</p> <p> TYPE: <code>str</code> </p> <code>d_freq</code> <p>destination frequency that is used to sample destination distributions.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(\n    self,\n    trips: pd.DataFrame,\n    zone: gp.GeoDataFrame,\n    o_dist: pd.DataFrame,\n    d_dist: pd.DataFrame,\n    o_activity: str,\n    d_activity: str,\n    o_freq: str,\n    d_freq: str,\n):\n    \"\"\"Create a dataframe that counts the number of origin and destination activities.\n\n    Merge this against the density information from the input origin and destination samplers.\n\n    Args:\n        trips (pd.DataFrame): the legs.csv output after building population.\n        zone (gp.GeoDataFrame):\n        o_dist (pd.DataFrame): sampler containing origin distributions to be sampled.\n        d_dist (pd.DataFrame): sampler containing destination distributions to be sampled.\n        o_activity (str): activity utilised within o_dist.\n        d_activity (str): activity utilised within d_dist.\n        o_freq (str): destination frequency that is used to sample origin distributions.\n        d_freq (str): destination frequency that is used to sample destination distributions.\n    \"\"\"\n    # Create a dataframe to plot od trips and compare against facility density and flows density.\n    df_trips_o = (\n        trips[trips[\"origin activity\"] == o_activity]\n        .groupby([\"ozone\"])\n        .agg({\"pid\": \"count\"})\n        .reset_index()\n    )\n    df_trips_o.rename(columns={\"pid\": \"origin_trips\"}, inplace=True)\n    df_trips_o.set_index(\"ozone\", inplace=True)\n\n    df_trips_d = (\n        trips[trips[\"destination activity\"] == d_activity]\n        .groupby([\"dzone\"])\n        .agg({\"pid\": \"count\"})\n        .reset_index()\n    )\n    df_trips_d.rename(columns={\"pid\": \"destination_trips\"}, inplace=True)\n    df_trips_d.set_index(\"dzone\", inplace=True)\n\n    self.od_density = zone.copy()\n\n    # Merge in trips information\n    self.od_density = pd.merge(\n        self.od_density,\n        df_trips_o,\n        left_on=self.od_density.index,\n        right_on=df_trips_o.index,\n        how=\"left\",\n    )\n    self.od_density = pd.merge(\n        self.od_density, df_trips_d, left_on=\"key_0\", right_on=df_trips_d.index, how=\"left\"\n    )\n\n    # Merge in density information\n    o_density = o_dist.reset_index()\n    o_density = o_density.groupby(o_dist.index).agg({o_freq: \"sum\"})\n    d_density = d_dist.reset_index()\n    d_density = d_density.groupby(d_dist.index).agg({d_freq: \"sum\"})\n\n    self.od_density[f\"{o_activity}_density\"] = self.od_density.key_0.map(o_density[o_freq])\n    self.od_density[f\"{d_activity}_density\"] = self.od_density.key_0.map(d_density[d_freq])\n\n    self.od_density.rename(columns={\"key_0\": zone.index.name}, inplace=True)\n    self.od_density.set_index(zone.index.name, inplace=True)\n\n    # Add in features for analysis\n    self.od_density = self.od_density.fillna(0)\n    self.od_density[\"origin_trip_density\"] = (\n        self.od_density.origin_trips / self.od_density.origin_trips.sum()\n    )\n    self.od_density[\"destination_trip_density\"] = (\n        self.od_density.destination_trips / self.od_density.destination_trips.sum()\n    )\n    self.od_density[\"origin_diff\"] = (\n        self.od_density[\"origin_trip_density\"] - self.od_density[f\"{o_activity}_density\"]\n    )\n    self.od_density[\"destination_diff\"] = (\n        self.od_density[\"destination_trip_density\"] - self.od_density[f\"{d_activity}_density\"]\n    )\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.ValidateTourOD.od_density","title":"<code>od_density = self.od_density.fillna(0)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.ValidateTourOD.plot_compare_density","title":"<code>plot_compare_density(title_1, title_2, o_activity, d_activity)</code>","text":"<p>Compares density of input origin/destination activities and trips. As density of locations increases, so should trips.</p> PARAMETER  DESCRIPTION <code>title_1</code> <p>input for plot origin title name.</p> <p> TYPE: <code>str</code> </p> <code>title_2</code> <p>input for plot destination title name.</p> <p> TYPE: <code>str</code> </p> <code>o_activity</code> <p>activity used to measure density of origin locations.</p> <p> TYPE: <code>str</code> </p> <code>d_activity</code> <p>activity used to measure density of destination locations.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>plt.Figure:</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot_compare_density(\n    self, title_1: str, title_2: str, o_activity: str, d_activity: str\n) -&gt; plt.Figure:\n    \"\"\"Compares density of input origin/destination activities and trips. As density of locations increases, so should trips.\n\n    Args:\n      title_1 (str): input for plot origin title name.\n      title_2 (str): input for plot destination title name.\n      o_activity (str): activity used to measure density of origin locations.\n      d_activity (str): activity used to measure density of destination locations.\n\n    Returns:\n        plt.Figure:\n    \"\"\"\n    fig, ax = plt.subplots(1, 2, figsize=(15, 7))\n\n    m1, b1 = np.polyfit(self.od_density[o_activity], self.od_density.origin_trip_density, 1)\n    m2, b2 = np.polyfit(\n        self.od_density[d_activity], self.od_density.destination_trip_density, 1\n    )\n\n    ax[0].scatter(x=o_activity, y=\"origin_trip_density\", data=self.od_density)\n    ax[0].plot(\n        self.od_density[o_activity],\n        (m1 * self.od_density[o_activity] + b1),\n        label=\"y = {:.2f} + {:.2f}*x\".format(m1, b1),\n    )\n    ax[0].legend(loc=\"lower right\")\n    ax[0].set_title(title_1)\n\n    ax[1].scatter(x=d_activity, y=\"destination_trip_density\", data=self.od_density)\n    ax[1].plot(\n        self.od_density[o_activity],\n        (m2 * self.od_density[o_activity] + b2),\n        label=\"y = {:.2f} + {:.2f}*x\".format(m2, b2),\n    )\n    ax[1].legend(loc=\"lower right\")\n    ax[1].set_title(title_2)\n\n    return fig\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.ValidateTourOD.plot_density_difference","title":"<code>plot_density_difference(title_1, title_2, cmap='coolwarm')</code>","text":"<p>Creates a spatial plot of the difference between input and output densities.</p> PARAMETER  DESCRIPTION <code>title_1</code> <p>input for plot origin title name.</p> <p> TYPE: <code>str</code> </p> <code>title_2</code> <p>input for plot destination title name.</p> <p> TYPE: <code>str</code> </p> <code>cmap</code> <p>Defaults to \"coolwarm\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'coolwarm'</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>plt.Figure:</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot_density_difference(\n    self, title_1: str, title_2: str, cmap: str = \"coolwarm\"\n) -&gt; plt.Figure:\n    \"\"\"Creates a spatial plot of the difference between input and output densities.\n\n    Args:\n      title_1 (str): input for plot origin title name.\n      title_2 (str): input for plot destination title name.\n      cmap (str, optional): Defaults to \"coolwarm\"\n\n    Returns:\n        plt.Figure:\n    \"\"\"\n    fig, ax = plt.subplots(1, 2, figsize=(20, 10))\n\n    self.od_density.plot(\"origin_diff\", ax=ax[0], cmap=cmap)\n    ax[0].axis(\"off\")\n    ax[0].set_title(title_1)\n\n    self.od_density.plot(\"destination_diff\", ax=ax[1], cmap=cmap)\n    ax[1].axis(\"off\")\n    ax[1].set_title(title_2)\n\n    im = plt.gca().get_children()[0]\n    cax = fig.add_axes([1, 0.2, 0.03, 0.6])\n    plt.colorbar(im, cax=cax)\n\n    return fig\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.ValidateTourOD.plot_validate_spatial_density","title":"<code>plot_validate_spatial_density(title_1, title_2, density_metric, density_trips, cmap='coolwarm')</code>","text":"<p>Creates a spatial plot between input densities and resulting trips to validate trips spatially align with input densities.</p> PARAMETER  DESCRIPTION <code>title_1</code> <p>Input densities plot title.</p> <p> TYPE: <code>str</code> </p> <code>title_2</code> <p>Resulting trips plot title.</p> <p> TYPE: <code>str</code> </p> <code>density_metric</code> <p>the measure for density output from the above dataframe, in the format of 'activity_density'</p> <p> TYPE: <code>str</code> </p> <code>density_trips</code> <p>the measure of trips that require validation, either 'origin_trips' or 'destination_trips'.</p> <p> TYPE: <code>str</code> </p> <code>cmap</code> <p>Defaults to \"coolwarm\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'coolwarm'</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>plt.Figure:</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot_validate_spatial_density(\n    self,\n    title_1: str,\n    title_2: str,\n    density_metric: str,\n    density_trips: str,\n    cmap: str = \"coolwarm\",\n) -&gt; plt.Figure:\n    \"\"\"Creates a spatial plot between input densities and resulting trips to validate trips spatially align with input densities.\n\n    Args:\n      title_1 (str): Input densities plot title.\n      title_2 (str): Resulting trips plot title.\n      density_metric (str): the measure for density output from the above dataframe, in the format of 'activity_density'\n      density_trips (str): the measure of trips that require validation, either 'origin_trips' or 'destination_trips'.\n      cmap (str): Defaults to \"coolwarm\".\n\n    Returns:\n        plt.Figure:\n    \"\"\"\n    fig, ax = plt.subplots(1, 2, figsize=(20, 10))\n\n    self.od_density.plot(density_metric, ax=ax[0], cmap=cmap)\n    ax[0].axis(\"off\")\n    ax[0].set_title(title_1)\n\n    self.od_density.plot(density_trips, ax=ax[1], cmap=cmap)\n    ax[1].axis(\"off\")\n    ax[1].set_title(title_2)\n\n    im = plt.gca().get_children()[0]\n    cax = fig.add_axes([1, 0.2, 0.03, 0.6])\n    plt.colorbar(im, cax=cax)\n\n    return fig\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.create_density_gdf","title":"<code>create_density_gdf(facility_zone, zone, activity, normalise=None)</code>","text":"<p>Calculate the spatial density of input activity.</p> PARAMETER  DESCRIPTION <code>facility_zone</code> <p>Spatial join between facility and zone information.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>zone</code> <p>zones information.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>activity</code> <p>a list of activities that are within facility data.</p> <p> TYPE: <code>list[str]</code> </p> <code>normalise</code> <p>If given, normalise density against this variable. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>gp.GeoDataFrame: measure of density of activities in each zone</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def create_density_gdf(\n    facility_zone: gp.GeoDataFrame,\n    zone: gp.GeoDataFrame,\n    activity: list[str],\n    normalise: Optional[str] = None,\n) -&gt; gp.GeoDataFrame:\n    \"\"\"Calculate the spatial density of input activity.\n\n    Args:\n        facility_zone (gp.GeoDataFrame): Spatial join between facility and zone information.\n        zone (gp.GeoDataFrame): zones information.\n        activity (list[str]): a list of activities that are within facility data.\n        normalise (Optional[str], optional): If given, normalise density against this variable. Defaults to None.\n\n    Returns:\n        gp.GeoDataFrame: measure of density of activities in each zone\n    \"\"\"\n    if normalise is not None:\n        density = (\n            facility_zone.groupby([facility_zone.index, \"activity\", normalise])\n            .agg({\"id\": \"count\"})\n            .reset_index()\n        )\n        density.set_index(facility_zone.index.name, inplace=True)\n        density = density[density[\"activity\"].isin(activity)]\n        density[\"density\"] = density[\"id\"] / density[normalise]\n        total_density = density[~(density[normalise] == 0)][\"density\"].sum()\n        density[\"density\"] = density[\"density\"] / total_density\n    else:\n        density = (\n            facility_zone.groupby([facility_zone.index, \"activity\"])\n            .agg({\"id\": \"count\"})\n            .reset_index()\n        )\n        density.set_index(facility_zone.index.name, inplace=True)\n        density = density[density[\"activity\"].isin(activity)]\n        density[\"density\"] = density[\"id\"] / density[\"id\"].sum()\n\n    # Convert back to geodataframe for merging.\n    density = pd.merge(\n        density, zone[\"geometry\"], left_on=density.index, right_on=zone.index, how=\"left\"\n    )\n    density.rename(columns={\"key_0\": facility_zone.index.name}, inplace=True)\n    density = gp.GeoDataFrame(data=density, geometry=\"geometry\")\n    density.set_index(facility_zone.index.name, inplace=True)\n\n    if np.isinf(density[\"density\"]).sum() &gt;= 1:\n        warnings.warn(\"Your density gdf has infinite values\")\n\n    return density\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.model_activity_time","title":"<code>model_activity_time(time, maxi=3600, mini=600)</code>","text":"<p>Returns a duration that is between the minimum amount of seconds, an input journey time, or maximum time.</p> PARAMETER  DESCRIPTION <code>time</code> <p>Time in seconds.</p> <p> TYPE: <code>int</code> </p> <code>maxi</code> <p>maximum time for a journey. Defaults to 3600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3600</code> </p> <code>mini</code> <p>minimum time for a journey. Defaults to 600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>600</code> </p> RETURNS DESCRIPTION <code>int</code> <p>maximum value between minimum time or the minimum of journey time and maximum time.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_activity_time(time: int, maxi: int = 3600, mini: int = 600) -&gt; int:\n    \"\"\"Returns a duration that is between the minimum amount of seconds, an input journey time, or maximum time.\n\n    Args:\n        time (int): Time in seconds.\n        maxi (int, optional): maximum time for a journey. Defaults to 3600.\n        mini (int, optional): minimum time for a journey. Defaults to 600.\n\n    Returns:\n        int: maximum value between minimum time or the minimum of journey time and maximum time.\n\n    \"\"\"\n    return max([mini, min([time, maxi])])\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.model_distance","title":"<code>model_distance(o, d, scale=1.4)</code>","text":"<p>Models distance between two shapely points.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_distance(o, d, scale=1.4):\n    \"\"\"Models distance between two shapely points.\"\"\"\n    return o.distance(d) * scale\n</code></pre>"},{"location":"reference/pam/samplers/tour/#pam.samplers.tour.model_journey_time","title":"<code>model_journey_time(distance, speed=EXPECTED_EUCLIDEAN_SPEEDS['freight'])</code>","text":"PARAMETER  DESCRIPTION <code>distance</code> <p>Distance in metres.</p> <p> TYPE: <code>Union[float, int]</code> </p> <code>speed</code> <p>Speed in metres/second. Defaults to 50000 / 3600 (50km/hr).</p> <p> TYPE: <code>float</code> DEFAULT: <code>EXPECTED_EUCLIDEAN_SPEEDS['freight']</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Modelled journey time.</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_journey_time(\n    distance: Union[float, int], speed: float = EXPECTED_EUCLIDEAN_SPEEDS[\"freight\"]\n) -&gt; float:\n    \"\"\"\n\n    Args:\n        distance (Union[float, int]): Distance in metres.\n        speed (float, optional): Speed in metres/second. Defaults to 50000 / 3600 (50km/hr).\n\n    Returns:\n        float: Modelled journey time.\n\n    \"\"\"\n    return distance / speed\n</code></pre>"},{"location":"reference/pam/scoring/","title":"pam.scoring","text":""},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer","title":"<code>CharyparNagelPlanScorer(cnfg)</code>","text":"<p>             Bases: <code>PlanScorer</code></p> <p>Object for scoring agent plans. This is a prelim interface.</p> PARAMETER  DESCRIPTION <code>cnfg</code> <p>scoring configuration.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>def __init__(self, cnfg: dict) -&gt; None:\n    \"\"\"Object for scoring agent plans. This is a prelim interface.\n\n    Args:\n        cnfg (dict): scoring configuration.\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.cnfg = cnfg\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.cnfg","title":"<code>cnfg = cnfg</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.example_config","title":"<code>example_config = {'default': {'mUM': 10, 'utilityOfLineSwitch': -1, 'performing': 6, 'waiting': -0, 'waitingPt': -1, 'lateArrival': -18, 'earlyDeparture': -10, 'work': {'typicalDuration': '08:00:00', 'openingTime': '06:00:00', 'closingTime': '20:00:00', 'latestStartTime': '09:30:00', 'earliestEndTime': '16:00:00', 'minimalDuration': '01:00:00'}, 'home': {'typicalDuration': '12:00:00', 'minimalDuration': '05:00:00'}, 'shop': {'typicalDuration': '00:30:00', 'openingTime': '06:00:00', 'closingTime': '20:00:00'}, 'car': {'constant': -10, 'dailyMonetaryConstant': -1, 'dailyUtilityConstant': -1, 'marginalUtilityOfDistance': -0.001, 'marginalUtilityOfTravelling': -1, 'monetaryDistanceRate': -0.0001}, 'walk': {'constant': -20}}}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.activities_wrapper","title":"<code>activities_wrapper(activities)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def activities_wrapper(self, activities):\n    non_wrapped = activities[1:-1]\n    wrapped_act = Activity(\n        act=activities[0].act,\n        start_time=activities[-1].start_time,\n        end_time=activities[0].end_time + td(days=1),\n    )\n    return wrapped_act, non_wrapped\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.duration_score","title":"<code>duration_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def duration_score(self, activity, cnfg) -&gt; float:\n    prio = 1\n    performing = cnfg[\"performing\"]\n    typical_dur = utils.matsim_duration_to_hours(cnfg[activity.act][\"typicalDuration\"])\n\n    opening_time = cnfg[activity.act].get(\"openingTime\")\n    if opening_time is not None:\n        opening_time = utils.matsim_time_to_datetime(opening_time)\n        if opening_time.time() &gt; activity.start_time.time():\n            actual_start_time = opening_time\n        else:\n            actual_start_time = activity.start_time\n    else:\n        actual_start_time = activity.start_time\n\n    closing_time = cnfg[activity.act].get(\"closingTime\")\n    if closing_time is not None:\n        closing_time = utils.matsim_time_to_datetime(closing_time)\n        if closing_time.time() &lt; activity.end_time.time():\n            actual_end_time = closing_time\n        else:\n            actual_end_time = activity.end_time\n    else:\n        actual_end_time = activity.end_time\n\n    if actual_end_time &lt; actual_start_time or actual_start_time &gt; actual_end_time:\n        duration = 0\n    else:\n        duration = (actual_end_time - actual_start_time) / td(hours=1)\n\n    if duration &lt; typical_dur / np.e:\n        return (duration * np.e - typical_dur) * performing\n\n    return performing * typical_dur * (np.log(duration / typical_dur) + (1 / prio))\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.early_departure_score","title":"<code>early_departure_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def early_departure_score(self, activity, cnfg) -&gt; float:\n    if cnfg[activity.act].get(\"earliestEndTime\") is not None and cnfg.get(\"earlyDeparture\"):\n        earliest_end_time = utils.matsim_time_to_datetime(cnfg[activity.act][\"earliestEndTime\"])\n        if activity.end_time.time() &lt; earliest_end_time.time():\n            return cnfg[\"earlyDeparture\"] * (\n                (earliest_end_time - activity.end_time) / td(hours=1)\n            )\n    return 0.0\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.late_arrival_score","title":"<code>late_arrival_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def late_arrival_score(self, activity, cnfg) -&gt; float:\n    if cnfg[activity.act].get(\"latestStartTime\") is not None and cnfg.get(\"lateArrival\"):\n        latest_start_time = utils.matsim_time_to_datetime(cnfg[activity.act][\"latestStartTime\"])\n        if activity.start_time.time() &gt; latest_start_time.time():\n            return cnfg[\"lateArrival\"] * (\n                (activity.start_time - latest_start_time) / td(hours=1)\n            )\n    return 0.0\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.mode_constant_score","title":"<code>mode_constant_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def mode_constant_score(self, leg, cnfg):\n    return cnfg[leg.mode].get(\"constant\", 0.0)\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.print_summary","title":"<code>print_summary(person, subpopulation='subpopulation')</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def print_summary(self, person, subpopulation=\"subpopulation\"):\n    print(f\"Total plan score: {self.score_person(person)}\")\n    config = self.cnfg[person.attributes[subpopulation]]\n    print(f\"Total activities score: {self.score_plan_activities(person.plan, cnfg=config)}\")\n    print(f\"Total legs score: {self.score_plan_legs(person.plan, cnfg=config)}\")\n    print(f\"Pt interchanges score: {self.score_pt_interchanges(person.plan, cnfg=config)}\")\n    print(f\"Day score: {self.score_plan_daily(person.plan, cnfg=config)}\")\n    print()\n    for i, component in enumerate(person.plan):\n        if isinstance(component, Activity):\n            print()\n            print(f\"({i}) Activity: {component.act}\")\n            print(f\"\\tDuration: {component.duration}\")\n            if component.act in [\"pt interaction\", \"pt_interaction\"]:\n                continue\n            print(f\"\\tScore: {self.score_activity(component, cnfg=config)}\")\n            print(f\"\\tDuration_score: {self.duration_score(component, cnfg=config)}\")\n            print(f\"\\tWaiting_score: {self.waiting_score(component, cnfg=config)}\")\n            print(f\"\\tLate_arrival_score: {self.late_arrival_score(component, cnfg=config)}\")\n            print(\n                f\"\\tEarly_departure_score: {self.early_departure_score(component, cnfg=config)}\"\n            )\n            print(f\"\\tToo_short_score: {self.too_short_score(component, cnfg=config)}\")\n\n        if isinstance(component, Leg):\n            print()\n            print(f\"({i}) Leg: {component.mode}\")\n            print(f\"\\tDistance: {component.distance} Duration: {component.duration}\")\n            print(f\"\\tScore: {self.score_leg(component, cnfg=config)}\")\n            print(\n                f\"\\tPt_waiting_time_score: {self.pt_waiting_time_score(component, cnfg=config)}\"\n            )\n            print(f\"\\tConstant: {self.mode_constant_score(component, cnfg=config)}\")\n            print(f\"\\tTravel_time_score: {self.travel_time_score(component, cnfg=config)}\")\n            print(\n                f\"\\tTravel_distance_score: {self.travel_distance_score(component, cnfg=config)}\"\n            )\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.pt_waiting_time_score","title":"<code>pt_waiting_time_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def pt_waiting_time_score(self, leg, cnfg):\n    if cnfg.get(\"waitingPt\") and leg.boarding_time:\n        waiting = (leg.boarding_time - leg.start_time) / td(hours=1)\n        if waiting &gt; 0:\n            return cnfg[\"waitingPt\"] * waiting\n    return 0.0\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_activity","title":"<code>score_activity(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_activity(self, activity, cnfg):\n    return sum(\n        [\n            self.duration_score(activity, cnfg),\n            self.waiting_score(activity, cnfg),\n            self.late_arrival_score(activity, cnfg),\n            self.early_departure_score(activity, cnfg),\n        ]\n    )\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_day_mode_use","title":"<code>score_day_mode_use(mode, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_day_mode_use(self, mode, cnfg) -&gt; float:\n    return cnfg[mode].get(\"dailyUtilityConstant\", 0) + (\n        cnfg[mode].get(\"dailyMonetaryConstant\", 0) * cnfg.get(\"mUM\", 1)\n    )\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_leg","title":"<code>score_leg(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_leg(self, leg, cnfg):\n    return sum(\n        [\n            self.pt_waiting_time_score(leg, cnfg),\n            self.mode_constant_score(leg, cnfg),\n            self.travel_time_score(leg, cnfg),\n            self.travel_distance_score(leg, cnfg),\n        ]\n    )\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_person","title":"<code>score_person(person, key='subpopulation', plan_costs=None)</code>","text":"<p>Score a pam.core.Person Plan.</p> PARAMETER  DESCRIPTION <code>person</code> <p> TYPE: <code>Person</code> </p> <code>key</code> <p>person attribute name for subpopulation. Defaults to \"subpopulation\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'subpopulation'</code> </p> <code>plan_costs</code> <p>Optionally add monetary costs such as tolls. Defaults to None.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>score</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>def score_person(\n    self, person: Person, key: str = \"subpopulation\", plan_costs: Optional[float] = None\n) -&gt; float:\n    \"\"\"Score a pam.core.Person Plan.\n\n    Args:\n      person (Person):\n      key (str, optional): person attribute name for subpopulation. Defaults to \"subpopulation\".\n      plan_costs (float, optional): Optionally add monetary costs such as tolls. Defaults to None.\n\n    Returns:\n        float: score\n    \"\"\"\n    subpop = person.attributes[key]\n    cnfg = self.cnfg[subpop]\n    return self.score_plan(person.plan, plan_cost=plan_costs, cnfg=cnfg)\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan","title":"<code>score_plan(plan, cnfg, plan_cost=None)</code>","text":"<p>Score a pam.activity.Plan.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>activity plan to be scored.</p> <p> TYPE: <code>Plan</code> </p> <code>cnfg</code> <p>configuration for plan scoring, refer to self.example_config for example.</p> <p> TYPE: <code>dict</code> </p> <code>plan_cost</code> <p>Optionally add a plan monetary cost. Defaults to None.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Charypar-Nagel score</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>def score_plan(self, plan: Plan, cnfg: dict, plan_cost: Optional[float] = None) -&gt; float:\n    \"\"\"Score a pam.activity.Plan.\n\n    Args:\n      plan (Plan): activity plan to be scored.\n      cnfg (dict): configuration for plan scoring, refer to self.example_config for example.\n      plan_cost (float, optional): Optionally add a plan monetary cost. Defaults to None.\n\n    Returns:\n      float: Charypar-Nagel score\n\n    \"\"\"\n    return (\n        self.score_plan_activities(plan, cnfg)\n        + self.score_plan_legs(plan, cnfg)\n        + self.score_plan_monetary_cost(plan_cost, cnfg)\n        + self.score_plan_daily(plan, cnfg)\n    )\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_activities","title":"<code>score_plan_activities(plan, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_activities(self, plan, cnfg):\n    activities = list(plan.activities)\n    if len(activities) == 1:\n        return self.score_activity(activities[0], cnfg)\n    if activities[0].act != activities[-1].act:\n        # if the first and last activity are not of the same type\n        # then the activities are not wrapped\n        # see https://github.com/matsim-org/matsim-libs/blob/77536f9f05ff70b69bdf54f19604f5732d81949c/matsim/src/main/java/org/matsim/core/scoring/functions/CharyparNagelActivityScoring.java#L241-L265\n        score = sum(\n            [\n                self.score_activity(act, cnfg)\n                for act in activities\n                if act.act not in [\"pt interaction\", \"pt_interaction\"]\n            ]\n        )\n    else:\n        wrapped_activity, other_activities = self.activities_wrapper(activities)\n        score = self.score_activity(wrapped_activity, cnfg) + sum(\n            [\n                self.score_activity(act, cnfg)\n                for act in other_activities\n                if act.act not in [\"pt interaction\", \"pt_interaction\"]\n            ]\n        )\n\n    return score\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_daily","title":"<code>score_plan_daily(plan, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_daily(self, plan, cnfg) -&gt; float:\n    modes = plan.mode_classes\n    return sum([self.score_day_mode_use(mode, cnfg) for mode in modes])\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_legs","title":"<code>score_plan_legs(plan, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_legs(self, plan, cnfg):\n    return self.score_pt_interchanges(plan, cnfg) + sum(\n        [self.score_leg(leg, cnfg) for leg in plan.legs]\n    )\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_monetary_cost","title":"<code>score_plan_monetary_cost(plan_cost, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_monetary_cost(self, plan_cost, cnfg) -&gt; float:\n    if plan_cost is not None:\n        return cnfg.get(\"mUM\", 1) * plan_cost\n    return 0.0\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.score_pt_interchanges","title":"<code>score_pt_interchanges(plan, cnfg)</code>","text":"<p>Calculates utility of line switch.</p> PARAMETER  DESCRIPTION <code>plan</code> <p> TYPE: <code>Plan</code> </p> <code>cnfg</code> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>float</code> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>def score_pt_interchanges(self, plan: Plan, cnfg: dict) -&gt; float:\n    \"\"\"Calculates utility of line switch.\n\n    Args:\n      plan (Plan):\n      cnfg (dict):\n\n    Returns:\n        float:\n    \"\"\"\n    if not cnfg.get(\"utilityOfLineSwitch\"):\n        return 0.0\n    transits = []\n    in_transit = 0\n    for i in plan:\n        if isinstance(i, Activity):\n            if i.act not in [\"pt interaction\", \"pt_interaction\"]:\n                if in_transit &gt; 0:\n                    in_transit -= 1  # the first PT vehicle does not incur a line switch penalty\n                transits.append(in_transit)\n                in_transit = 0\n        elif isinstance(i, Leg):\n            if i.mode in TRANSIT_MODES:\n                # number of PT modes used in each trip\n                in_transit += 1\n    cost = sum(transits) * cnfg.get(\"utilityOfLineSwitch\", 0)\n    return cost\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.too_short_score","title":"<code>too_short_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def too_short_score(self, activity, cnfg) -&gt; float:\n    if cnfg[activity.act].get(\"minimalDuration\") and cnfg.get(\"earlyDeparture\"):\n        minimal_duration = utils.matsim_duration_to_hours(cnfg[activity.act][\"minimalDuration\"])\n        if activity.hours &lt; minimal_duration:\n            return cnfg[\"earlyDeparture\"] * (minimal_duration - activity.hours)\n    return 0.0\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.travel_distance_score","title":"<code>travel_distance_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def travel_distance_score(self, leg, cnfg) -&gt; float:\n    return leg.distance * (\n        cnfg[leg.mode].get(\"marginalUtilityOfDistance\", 0.0)\n        + (cnfg.get(\"mUM\", 1.0) * cnfg[leg.mode].get(\"monetaryDistanceRate\", 0.0))\n    )\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.travel_time_score","title":"<code>travel_time_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def travel_time_score(self, leg, cnfg) -&gt; float:\n    duration = leg.hours\n    if cnfg.get(\"waitingPt\") and leg.boarding_time:\n        duration -= (leg.boarding_time - leg.start_time) / td(hours=1)\n    return duration * cnfg[leg.mode].get(\"marginalUtilityOfTravelling\", 0.0)\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.CharyparNagelPlanScorer.waiting_score","title":"<code>waiting_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def waiting_score(self, activity, cnfg) -&gt; float:\n    waiting = cnfg[\"waiting\"]\n    if not waiting:\n        return 0.0\n    opening_time = cnfg[activity.act].get(\"openingTime\")\n    if opening_time is None:\n        return 0.0\n    opening_dt = utils.matsim_time_to_datetime(opening_time)\n    start_dt = activity.start_time\n    if start_dt.time() &lt; opening_dt.time():\n        return waiting * ((opening_dt - start_dt) / td(hours=1))\n    return 0.0\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.PlanScorer","title":"<code>PlanScorer(cnfg)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Object for scoring agent plans. This is a prelim interface.</p> PARAMETER  DESCRIPTION <code>cnfg</code> <p>scoring configuration.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>def __init__(self, cnfg: dict) -&gt; None:\n    \"\"\"Object for scoring agent plans. This is a prelim interface.\n\n    Args:\n        cnfg (dict): scoring configuration.\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.cnfg = cnfg\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.PlanScorer.cnfg","title":"<code>cnfg = cnfg</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/scoring/#pam.scoring.PlanScorer.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/scoring/#pam.scoring.PlanScorer.score_person","title":"<code>score_person(person, key='subpopulation', plan_costs=None)</code>  <code>abstractmethod</code>","text":"<p>Score person.</p> PARAMETER  DESCRIPTION <code>person</code> <p>Person to be scores.</p> <p> TYPE: <code>Person</code> </p> <code>key</code> <p>Person attribute key used for config segmentation (\"subpopulations\"). Defaults to \"subpopulation\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'subpopulation'</code> </p> <code>plan_costs</code> <p>Monetary costs, such as tolls. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Score.</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>@abstractmethod\ndef score_person(\n    self, person: Person, key: str = \"subpopulation\", plan_costs: Optional[float] = None\n) -&gt; float:\n    \"\"\"Score person.\n\n    Args:\n        person (Person): Person to be scores.\n        key (str, optional): Person attribute key used for config segmentation (\"subpopulations\"). Defaults to \"subpopulation\".\n        plan_costs (Optional[float], optional): Monetary costs, such as tolls. Defaults to None.\n\n    Returns:\n        float: Score.\n    \"\"\"\n</code></pre>"},{"location":"reference/pam/scoring/#pam.scoring.PlanScorer.score_plan","title":"<code>score_plan(plan, cnfg, plan_cost=None)</code>  <code>abstractmethod</code>","text":"<p>Score plan.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>Plan to be scored.</p> <p> TYPE: <code>Plan</code> </p> <code>cnfg</code> <p>Scorer configuration.</p> <p> TYPE: <code>dict</code> </p> <code>plan_cost</code> <p>Monetary costs, such as tolls. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Score.</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>@abstractmethod\ndef score_plan(self, plan: Plan, cnfg: dict, plan_cost: Optional[float] = None) -&gt; float:\n    \"\"\"Score plan.\n\n    Args:\n        plan (Plan): Plan to be scored.\n        cnfg (dict): Scorer configuration.\n        plan_cost (Optional[float], optional): Monetary costs, such as tolls. Defaults to None.\n\n    Returns:\n        float: Score.\n    \"\"\"\n</code></pre>"},{"location":"reference/pam/utils/","title":"pam.utils","text":""},{"location":"reference/pam/utils/#pam.utils.DEFAULT_GZIP_COMPRESSION","title":"<code>DEFAULT_GZIP_COMPRESSION = 6</code>  <code>module-attribute</code>","text":""},{"location":"reference/pam/utils/#pam.utils.create_crs_attribute","title":"<code>create_crs_attribute(coordinate_reference_system)</code>","text":"<p>Create a CRS attribute as expected by MATSim's ProjectionUtils.getCRS.</p> PARAMETER  DESCRIPTION <code>coordinate_reference_system</code> <p>coordinate reference system.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>et.Element: CRS attribute as xml element</p> Source code in <code>pam/utils.py</code> <pre><code>def create_crs_attribute(coordinate_reference_system: str) -&gt; et.Element:\n    \"\"\"Create a CRS attribute as expected by MATSim's ProjectionUtils.getCRS.\n\n    Args:\n        coordinate_reference_system (str): coordinate reference system.\n\n    Returns:\n        et.Element: CRS attribute as xml element\n    \"\"\"\n    attributes_element = et.Element(\"attributes\")\n    crs_attribute = et.SubElement(\n        attributes_element,\n        \"attribute\",\n        {\"class\": \"java.lang.String\", \"name\": \"coordinateReferenceSystem\"},\n    )\n    crs_attribute.text = str(coordinate_reference_system)\n    return attributes_element\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.create_local_dir","title":"<code>create_local_dir(directory)</code>","text":"<p>Safely create new directory. TODO this can be replaced with pathlib I think</p> PARAMETER  DESCRIPTION <code>directory</code> <p>new directory path</p> <p> TYPE: <code>Union[str, Path]</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def create_local_dir(directory: Union[str, Path]):\n    \"\"\"Safely create new directory.\n    TODO this can be replaced with pathlib I think\n\n    Args:\n        directory (Union[str, Path]): new directory path\n    \"\"\"\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.datetime_string_to_datetime","title":"<code>datetime_string_to_datetime(string)</code>","text":"<p>Convert datetime formatted string to datetime.</p> PARAMETER  DESCRIPTION <code>string</code> <p>time string formatted \"%Y-%m-%d %H:%M:%S\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def datetime_string_to_datetime(string: str) -&gt; datetime:\n    \"\"\"Convert datetime formatted string to datetime.\n\n    Args:\n        string (str): time string formatted \"%Y-%m-%d %H:%M:%S\".\n\n    Returns:\n        datetime: datetime\n    \"\"\"\n    return datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.datetime_to_matsim_time","title":"<code>datetime_to_matsim_time(dt)</code>","text":"<p>Convert datetime to matsim format time (<code>hh:mm:ss</code>).</p> <p>Datetimes beyond 1 day will be converted to hours, eg 25:00:00, for 1am the next day.</p> PARAMETER  DESCRIPTION <code>dt</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> RETURNS DESCRIPTION <code>str</code> <p>MATSim time format (<code>hh:mm:ss</code>)</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def datetime_to_matsim_time(dt: datetime) -&gt; str:\n    \"\"\"Convert datetime to matsim format time (`hh:mm:ss`).\n\n    Datetimes beyond 1 day will be converted to hours, eg 25:00:00, for 1am the next day.\n\n    Args:\n        dt (datetime): datetime\n\n    Returns:\n        str: MATSim time format (`hh:mm:ss`)\n    \"\"\"\n    return timedelta_to_matsim_time(dt - START_OF_DAY)\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.dt_to_s","title":"<code>dt_to_s(dt)</code>","text":"<p>Convert datetime to seconds since start of day.</p> PARAMETER  DESCRIPTION <code>dt</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> RETURNS DESCRIPTION <code>int</code> <p>seconds as integer</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def dt_to_s(dt: datetime) -&gt; int:\n    \"\"\"Convert datetime to seconds since start of day.\n\n    Args:\n        dt (datetime): datetime\n\n    Returns:\n        int: seconds as integer\n    \"\"\"\n    return (((dt.hour * 60) + dt.minute) * 60) + dt.second\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.get_elems","title":"<code>get_elems(path, tag)</code>","text":"<p>Wrapper for unzipping and dealing with xml namespaces</p> PARAMETER  DESCRIPTION <code>path</code> <p>xml path</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>tag</code> <p>The tag type to extract , e.g. 'link'</p> <p> TYPE: <code>str</code> </p> YIELDS DESCRIPTION <code>Generator</code> <p>Generator of elements</p> <p> TYPE:: <code>Generator</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def get_elems(path: Union[str, Path], tag: str) -&gt; Generator:\n    \"\"\"Wrapper for unzipping and dealing with xml namespaces\n\n    Args:\n        path (Union[str, Path]): xml path\n        tag (str): The tag type to extract , e.g. 'link'\n\n    Yields:\n        Generator:  Generator of elements\n    \"\"\"\n    target = try_unzip(path)\n    tag = get_tag(target, tag)\n    target = try_unzip(path)  # need to repeat :(\n    return parse_elems(target, tag)\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.get_linestring","title":"<code>get_linestring(from_point, to_point)</code>","text":"<p>Makes a shapely.geometry.LineString out of two points.</p> PARAMETER  DESCRIPTION <code>from_point</code> <p>shapely.geometry.Point or s2sphere.CellId</p> <p> TYPE: <code>Union[Point, CellId]</code> </p> <code>to_point</code> <p>shapely.geometry.Point or s2sphere.CellId</p> <p> TYPE: <code>Union[Point, CellId]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>Failure to parse inputs</p> RETURNS DESCRIPTION <code>LineString</code> <p>LineString</p> <p> TYPE: <code>LineString</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def get_linestring(from_point: Union[Point, CellId], to_point: Union[Point, CellId]) -&gt; LineString:\n    \"\"\"Makes a shapely.geometry.LineString out of two points.\n\n    Args:\n        from_point (Union[Point, CellId]): shapely.geometry.Point or s2sphere.CellId\n        to_point (Union[Point, CellId])): shapely.geometry.Point or s2sphere.CellId\n\n    Raises:\n        TypeError: Failure to parse inputs\n\n    Returns:\n        LineString: LineString\n    \"\"\"\n    if all(isinstance(p, CellId) for p in [from_point, to_point]):\n        from_point = from_point.to_lat_lng()\n        from_point = Point(from_point.lng().degrees, from_point.lat().degrees)\n        to_point = to_point.to_lat_lng()\n        to_point = Point(to_point.lng().degrees, to_point.lat().degrees)\n\n    if not all(isinstance(p, Point) for p in [from_point, to_point]):\n        raise TypeError(\n            f\"You need to pass points of type {type(Point)} or {type(CellId)}.\"\n            f\"Types passed: type(from_point)={type(from_point)} and type(to_point)={type(to_point)}\"\n        )\n    return LineString([from_point, to_point])\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.get_tag","title":"<code>get_tag(target, tag)</code>","text":"<p>Check for namespace declaration.</p> <p>If they exists return tag string with namespace [''] ie {namespaces['']}tag. If no namespaces declared return original tag.</p> <p>TODO: Not working with iterparse, generated elem also have ns which is dealt with later.</p> PARAMETER  DESCRIPTION <code>target</code> <p>Target xml, either BytesIO object or path.</p> <p> TYPE: <code>Union[BytesIO, str, Path]</code> </p> <code>tag</code> <p>The tag type to extract , e.g. 'link'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>tag.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def get_tag(target: Union[BytesIO, str, Path], tag: str) -&gt; str:\n    \"\"\"Check for namespace declaration.\n\n    If they exists return tag string with namespace [''] ie {namespaces['']}tag.\n    If no namespaces declared return original tag.\n\n    TODO: Not working with iterparse, generated elem also have ns which is dealt with later.\n\n    Args:\n        target (Union[BytesIO, str, Path]): Target xml, either BytesIO object or path.\n        tag (str): The tag type to extract , e.g. 'link'.\n\n    Returns:\n        str: tag.\n    \"\"\"\n    nsmap = {}\n    doc = et.iterparse(target, events=(\"end\", \"start-ns\"))\n    count = 0\n    for event, element in doc:\n        count += 1\n        if event == \"start-ns\":\n            nsmap[element[0]] = element[1]\n        if count == 10:  # assume namespace declared at top so can break early\n            del doc\n            break\n    if not nsmap:\n        return tag\n    else:\n        tag = \"{\" + nsmap[\"\"] + \"}\" + tag\n        return tag\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.is_gzip","title":"<code>is_gzip(location)</code>","text":"<p>Checks if file is gzipped based on extension.</p> PARAMETER  DESCRIPTION <code>location</code> <p>file path</p> <p> TYPE: <code>Union[str, Path]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>is gzipped?</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def is_gzip(location: Union[str, Path]) -&gt; bool:\n    \"\"\"Checks if file is gzipped based on extension.\n\n    Args:\n        location (Union[str, Path]): file path\n\n    Returns:\n        bool: is gzipped?\n    \"\"\"\n    suffix = Path(location).suffix.lower()\n    return suffix == \".gz\" or suffix == \".gzip\"\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.is_xml","title":"<code>is_xml(location)</code>","text":"<p>Checks if file is xml based on extension.</p> PARAMETER  DESCRIPTION <code>location</code> <p>file path.</p> <p> TYPE: <code>Union[str, Path]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>is xml?</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def is_xml(location: Union[str, Path]) -&gt; bool:\n    \"\"\"Checks if file is xml based on extension.\n\n    Args:\n        location (Union[str, Path]): file path.\n\n    Returns:\n        bool: is xml?\n    \"\"\"\n    return Path(location).suffix.lower() == \".xml\"\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.matsim_duration_to_hours","title":"<code>matsim_duration_to_hours(mt)</code>","text":"<p>Turn MATSim time string (<code>hh:mm:ss</code> or <code>hh:mm</code>) into hours.</p> PARAMETER  DESCRIPTION <code>mt</code> <p>MATSim time string (<code>hh:mm:ss</code> or <code>hh:mm</code>)</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Incorrect formatted input</p> RETURNS DESCRIPTION <code>int</code> <p>hours as integer</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def matsim_duration_to_hours(mt: str) -&gt; float:\n    \"\"\"Turn MATSim time string (`hh:mm:ss` or `hh:mm`) into hours.\n\n    Args:\n        mt (str): MATSim time string (`hh:mm:ss` or `hh:mm`)\n\n    Raises:\n        UserWarning: Incorrect formatted input\n\n    Returns:\n        int: hours as integer\n    \"\"\"\n    td = safe_strpdelta(mt)\n    return timedelta_to_hours(td)\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.matsim_time_to_datetime","title":"<code>matsim_time_to_datetime(string)</code>","text":"<p>Convert matsim format time (<code>hh:mm:ss</code>) to datetime.</p> <p>Can read MATSim times for any day of a simulation (ie 25:00:00 is read as 01:00:00 of the next day).</p> PARAMETER  DESCRIPTION <code>string</code> <p>MATSim time from start of the simulation (%H:%M:%S)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def matsim_time_to_datetime(string: str) -&gt; datetime:\n    \"\"\"Convert matsim format time (`hh:mm:ss`) to datetime.\n\n    Can read MATSim times for any day of a simulation (ie 25:00:00 is read as 01:00:00 of the next day).\n\n    Args:\n        string (str): MATSim time from start of the simulation (%H:%M:%S)\n\n    Returns:\n        datetime: datetime\n    \"\"\"\n    return safe_strptime(string)\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.minutes_to_datetime","title":"<code>minutes_to_datetime(minutes)</code>","text":"<p>Convert minutes to datetime.</p> PARAMETER  DESCRIPTION <code>minutes</code> <p>minutes.</p> <p> TYPE: <code>Union[int, float]</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def minutes_to_datetime(minutes: Union[int, float]) -&gt; datetime:\n    \"\"\"Convert minutes to datetime.\n\n    Args:\n        minutes (Union[int, float]): minutes.\n\n    Returns:\n        datetime: datetime\n    \"\"\"\n    return START_OF_DAY + minutes_to_timedelta(minutes)\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.minutes_to_timedelta","title":"<code>minutes_to_timedelta(minutes)</code>","text":"<p>Convert minutes to timedelta.</p> PARAMETER  DESCRIPTION <code>minutes</code> <p>minutes.</p> <p> TYPE: <code>Union[int, float]</code> </p> RETURNS DESCRIPTION <code>timedelta</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def minutes_to_timedelta(minutes: Union[int, float]) -&gt; timedelta:\n    \"\"\"Convert minutes to timedelta.\n\n    Args:\n        minutes (Union[int, float]): minutes.\n\n    Returns:\n        timedelta: timedelta\n    \"\"\"\n    return timedelta(minutes=float(minutes))\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.parse_elems","title":"<code>parse_elems(target, tag)</code>","text":"<p>Traverse the given XML tree, retrieving the elements of the specified tag.</p> PARAMETER  DESCRIPTION <code>target</code> <p>Target xml, either BytesIO object or string path</p> <p> TYPE: <code>Union[BytesIO, str, Path]</code> </p> <code>tag</code> <p>The tag type to extract , e.g. 'link'</p> <p> TYPE: <code>str</code> </p> YIELDS DESCRIPTION <code>Generator</code> <p>Generator of elements.</p> <p> TYPE:: <code>Generator</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def parse_elems(target: Union[BytesIO, str, Path], tag: str) -&gt; Generator:\n    \"\"\"Traverse the given XML tree, retrieving the elements of the specified tag.\n\n    Args:\n        target (Union[BytesIO, str, Path]): Target xml, either BytesIO object or string path\n        tag (str): The tag type to extract , e.g. 'link'\n\n    Yields:\n        Generator: Generator of elements.\n    \"\"\"\n    doc = et.iterparse(target, tag=tag)\n    for _, element in doc:\n        yield element\n        element.clear()\n        while element.getprevious() is not None:\n            del element.getparent()[0]\n    del doc\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.parse_time","title":"<code>parse_time(time)</code>","text":"<p>Generic parse time into datetime.</p> <p>Integers are assumed to be minutes. Strings are assumed to be datetime formatted as (%Y-%m-%d %H:%M:%S).</p> PARAMETER  DESCRIPTION <code>time</code> <p>time</p> <p> TYPE: <code>Union[int, str]</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>raised if wrong types provided</p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def parse_time(time: Union[int, str]) -&gt; datetime:\n    \"\"\"Generic parse time into datetime.\n\n    Integers are assumed to be minutes.\n    Strings are assumed to be datetime formatted as (%Y-%m-%d %H:%M:%S).\n\n    Args:\n        time (Union[int, str]): time\n\n    Raises:\n        UserWarning: raised if wrong types provided\n\n    Returns:\n        datetime: datetime\n    \"\"\"\n\n    if isinstance(time, (int, np.integer)) and not isinstance(time, bool):\n        return minutes_to_datetime(time)\n    elif isinstance(time, str):\n        return datetime_string_to_datetime(time)\n    else:\n        raise TypeError(\n            f\"Cannot parse {time} of type {type(time)} that is not int (assuming minutes) or str (%Y-%m-%d %H:%M:%S)\"\n        )\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.safe_strpdelta","title":"<code>safe_strpdelta(mt)</code>","text":"<p>Parse string into timedelta.</p> <p>Can cope with time strings in format <code>hh:mm:ss</code> or <code>hh:mm</code>.</p> PARAMETER  DESCRIPTION <code>mt</code> <p>MATSim time string (<code>hh:mm:ss</code> or <code>hh:mm</code>)</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Incorrect formatted input</p> RETURNS DESCRIPTION <code>timedelta</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def safe_strpdelta(mt: str) -&gt; timedelta:\n    \"\"\"Parse string into timedelta.\n\n    Can cope with time strings in format `hh:mm:ss` or `hh:mm`.\n\n    Args:\n        mt (str): MATSim time string (`hh:mm:ss` or `hh:mm`)\n\n    Raises:\n        UserWarning: Incorrect formatted input\n\n    Returns:\n        timedelta: timedelta\n    \"\"\"\n    units = mt.split(\":\")\n    if len(units) == 3:\n        h, m, s = mt.split(\":\")\n        return timedelta(hours=int(h), minutes=int(m), seconds=int(s))\n    if len(units) == 2:\n        h, m = mt.split(\":\")\n        return timedelta(hours=int(h), minutes=int(m))\n    raise UserWarning(f\"Unrecognised timedelta format: {mt}\")\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.safe_strptime","title":"<code>safe_strptime(mt)</code>","text":"<p>Safely parse string into datetime.</p> <p>Can cope with time strings in format <code>hh:mm:ss</code> if hh &gt; 24 then adds a day.</p> PARAMETER  DESCRIPTION <code>mt</code> <p>MATSim time string (<code>hh:mm:ss</code> or <code>hh:mm</code>)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def safe_strptime(mt: str) -&gt; datetime:\n    \"\"\"Safely parse string into datetime.\n\n    Can cope with time strings in format `hh:mm:ss` if hh &gt; 24 then adds a day.\n\n    Args:\n        mt (str): MATSim time string (`hh:mm:ss` or `hh:mm`)\n\n    Returns:\n        datetime: datetime\n    \"\"\"\n    return START_OF_DAY + safe_strpdelta(mt)\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.strip_namespace","title":"<code>strip_namespace(elem)</code>","text":"<p>Strips namespaces from given xml element</p> PARAMETER  DESCRIPTION <code>elem</code> <p>xml element</p> <p> TYPE: <code>Element</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def strip_namespace(elem: et.Element):\n    \"\"\"Strips namespaces from given xml element\n\n    Args:\n        elem (et.Element): xml element\n    \"\"\"\n    if elem.tag.startswith(\"{\"):\n        # strip namespace\n        elem.tag = elem.tag.split(\"}\", 1)[1]\n    for k in elem.attrib.keys():\n        if k.startswith(\"{\"):\n            k2 = k.split(\"}\", 1)[1]\n            elem.attrib[k2] = elem.attrib[k]\n            del elem.attrib[k]\n    for child in elem:\n        strip_namespace(child)\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.td_to_s","title":"<code>td_to_s(td)</code>","text":"<p>Convert timedelta to seconds since start of day.</p> PARAMETER  DESCRIPTION <code>td</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>int</code> <p>seconds as integer</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def td_to_s(td: timedelta) -&gt; int:\n    \"\"\"Convert timedelta to seconds since start of day.\n\n    Args:\n        td (timedelta): timedelta\n\n    Returns:\n        int: seconds as integer\n    \"\"\"\n    return (td.days * 86400) + td.seconds\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.timedelta_to_hours","title":"<code>timedelta_to_hours(td)</code>","text":"<p>Timedelta to hours.</p> PARAMETER  DESCRIPTION <code>td</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>float</code> <p>hours as float</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def timedelta_to_hours(td: timedelta) -&gt; float:\n    \"\"\"Timedelta to hours.\n\n    Args:\n        td (timedelta): timedelta\n\n    Returns:\n        float: hours as float\n    \"\"\"\n    return td.total_seconds() / 3600\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.timedelta_to_matsim_time","title":"<code>timedelta_to_matsim_time(td)</code>","text":"<p>Convert datetime timedelta object to matsim string format (<code>hh:mm:ss</code>).</p> PARAMETER  DESCRIPTION <code>td</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>str</code> <p>MATSim time string (<code>hh:mm:ss</code>)</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def timedelta_to_matsim_time(td: timedelta) -&gt; str:\n    \"\"\"Convert datetime timedelta object to matsim string format (`hh:mm:ss`).\n\n    Args:\n        td (timedelta): timedelta\n\n    Returns:\n        str: MATSim time string (`hh:mm:ss`)\n    \"\"\"\n    hours, remainder = divmod(td.total_seconds(), 3600)\n    minutes, seconds = divmod(remainder, 60)\n    return f\"{int(hours):02}:{int(minutes):02}:{int(seconds):02}\"\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.try_unzip","title":"<code>try_unzip(path)</code>","text":"<p>Attempts to unzip xml at given path, if fails, returns path</p> PARAMETER  DESCRIPTION <code>path</code> <p>xml path.</p> <p> TYPE: <code>Union[str, Path]</code> </p> RETURNS DESCRIPTION <code>Union[BytesIO, str, Path]</code> <p>Union[BytesIO, str, Path]: BytesIO object or path if already unzipped.</p> Source code in <code>pam/utils.py</code> <pre><code>def try_unzip(path: Union[str, Path]) -&gt; Union[BytesIO, str, Path]:\n    \"\"\"Attempts to unzip xml at given path, if fails, returns path\n\n    Args:\n        path (Union[str, Path]): xml path.\n\n    Returns:\n        Union[BytesIO, str, Path]: BytesIO object or path if already unzipped.\n    \"\"\"\n    try:\n        with gzip.open(path) as unzipped:\n            xml = unzipped.read()\n            target = BytesIO(xml)\n            return target\n    except OSError:\n        return path\n</code></pre>"},{"location":"reference/pam/utils/#pam.utils.xml_tree","title":"<code>xml_tree(content)</code>","text":"<p>Return pretty formatted string of xml tree.</p> PARAMETER  DESCRIPTION <code>content</code> <p>xml</p> <p> TYPE: <code>Element</code> </p> RETURNS DESCRIPTION <code>str</code> <p>pretty string of xml</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def xml_tree(content: et.Element) -&gt; str:\n    \"\"\"Return pretty formatted string of xml tree.\n\n    Args:\n        content (et.Element): xml\n\n    Returns:\n        str: pretty string of xml\n    \"\"\"\n    tree = et.tostring(content, pretty_print=True, xml_declaration=False, encoding=\"UTF-8\")\n    return tree\n</code></pre>"},{"location":"reference/pam/vehicles/","title":"pam.vehicles","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.CapacityType","title":"<code>CapacityType</code>  <code>dataclass</code>","text":"<p>Vehicle capacity dataclass with read/write methods.</p> ATTRIBUTE DESCRIPTION <code>seats</code> <p>Seats in/on vehicle.</p> <p> TYPE: <code>int</code> </p> <code>standingRoomInPersons</code> <p>Standing room in/on vehicle.</p> <p> TYPE: <code>int</code> </p>"},{"location":"reference/pam/vehicles/#pam.vehicles.CapacityType.seats","title":"<code>seats: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.CapacityType.standingRoomInPersons","title":"<code>standingRoomInPersons: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.CapacityType.from_xml_elem","title":"<code>from_xml_elem(elem)</code>  <code>classmethod</code>","text":"Source code in <code>pam/vehicles.py</code> <pre><code>@classmethod\ndef from_xml_elem(cls, elem):\n    attribs = {k: int(v) for k, v in elem.attrib.items()}\n    return cls(**attribs)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.CapacityType.to_xml","title":"<code>to_xml(xf)</code>","text":"Source code in <code>pam/vehicles.py</code> <pre><code>def to_xml(self, xf):\n    xf.write(\n        et.Element(\n            \"capacity\",\n            {\n                \"seats\": str(self.seats),\n                \"standingRoomInPersons\": str(self.standingRoomInPersons),\n            },\n        )\n    )\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.ElectricVehicle","title":"<code>ElectricVehicle</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Vehicle</code></p> <p>Electric vehicle data representation. Required for MATSim EV extension.</p> ATTRIBUTE DESCRIPTION <code>vid</code> <p>Unique vehicle identifier.</p> <p> TYPE: <code>str</code> </p> <code>type_id</code> <p>Type of vehicle, eg \"default_car\".</p> <p> TYPE: <code>str</code> </p> <code>battery_capacity</code> <p>Charge capacity.</p> <p> TYPE: <code>float</code> </p> <code>initial_soc</code> <p>Initial state of charge.</p> <p> TYPE: <code>float</code> </p> <code>charger_types</code> <p>Types of chargers vehicle may use.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/pam/vehicles/#pam.vehicles.ElectricVehicle.battery_capacity","title":"<code>battery_capacity: float = 60</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.ElectricVehicle.charger_types","title":"<code>charger_types: str = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.ElectricVehicle.initial_soc","title":"<code>initial_soc: float = battery_capacity</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.ElectricVehicle.type_id","title":"<code>type_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.ElectricVehicle.vid","title":"<code>vid: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.ElectricVehicle.to_ev_xml","title":"<code>to_ev_xml(xf)</code>","text":"<p>Write vehicle to MATSim formatted xml.</p> PARAMETER  DESCRIPTION <code>xf</code> <p>Parent xml element.</p> <p> TYPE: <code>Element</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_ev_xml(self, xf) -&gt; None:\n    \"\"\"Write vehicle to MATSim formatted xml.\n\n    Args:\n        xf (et.Element): Parent xml element.\n    \"\"\"\n    xf.write(\n        et.Element(\n            \"vehicle\",\n            {\n                \"id\": str(self.vid),\n                \"battery_capacity\": str(self.battery_capacity),\n                \"initial_soc\": str(self.initial_soc),\n                \"charger_types\": str(self.charger_types),\n                \"vehicle_type\": str(self.type_id),\n            },\n        )\n    )\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.ElectricVehicle.to_xml","title":"<code>to_xml(xf)</code>","text":"<p>Write vehicle to MATSim formatted xml.</p> PARAMETER  DESCRIPTION <code>xf</code> <p>Parent xml element.</p> <p> TYPE: <code>Element</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_xml(self, xf: et.Element) -&gt; None:\n    \"\"\"Write vehicle to MATSim formatted xml.\n\n    Args:\n        xf (et.Element): Parent xml element.\n    \"\"\"\n    xf.write(et.Element(\"vehicle\", {\"id\": str(self.vid), \"type\": str(self.type_id)}))\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.Vehicle","title":"<code>Vehicle</code>  <code>dataclass</code>","text":"<p>Vehicle parent data class, holds required vehicle data (id and type) and read/write methods.</p> ATTRIBUTE DESCRIPTION <code>vid</code> <p>Unique vehicle identifier.</p> <p> TYPE: <code>str</code> </p> <code>type_id</code> <p>Type of vehicle, eg \"default_car\".</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/pam/vehicles/#pam.vehicles.Vehicle.type_id","title":"<code>type_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.Vehicle.vid","title":"<code>vid: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.Vehicle.to_xml","title":"<code>to_xml(xf)</code>","text":"<p>Write vehicle to MATSim formatted xml.</p> PARAMETER  DESCRIPTION <code>xf</code> <p>Parent xml element.</p> <p> TYPE: <code>Element</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_xml(self, xf: et.Element) -&gt; None:\n    \"\"\"Write vehicle to MATSim formatted xml.\n\n    Args:\n        xf (et.Element): Parent xml element.\n    \"\"\"\n    xf.write(et.Element(\"vehicle\", {\"id\": str(self.vid), \"type\": str(self.type_id)}))\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager","title":"<code>VehicleManager()</code>","text":"<p>Vehicles and vehicle types representation, responsible for read/write from MATSim vehicles files.</p> ATTRIBUTE DESCRIPTION <code>_veh_types</code> <p>Mapping of type ids to vehicle types data.</p> <p> TYPE: <code>dict[str, VehicleType]</code> </p> <code>_vehicles</code> <p>Mapping of vehicle ids to vehicle data.</p> <p> TYPE: <code>dict[str, Vehicle]</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._veh_types = {}\n    self._vehicles = {}\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.evs","title":"<code>evs: dict[str, ElectricVehicle]</code>  <code>property</code>","text":"<p>Return dictionary of electric vehicles in manager.</p> RETURNS DESCRIPTION <code>dict[str, ElectricVehicle]</code> <p>dict[str, ElectricVehicle]: Dictionary of electric vehicles.</p>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.add_type","title":"<code>add_type(vehicle_type)</code>","text":"<p>Add vehicle type to manager.</p> PARAMETER  DESCRIPTION <code>vehicle_type</code> <p>Vehicle type dataclass.</p> <p> TYPE: <code>VehicleType</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def add_type(self, vehicle_type: VehicleType) -&gt; None:\n    \"\"\"Add vehicle type to manager.\n\n    Args:\n        vehicle_type (VehicleType): Vehicle type dataclass.\n    \"\"\"\n    if vehicle_type.id in self._veh_types:\n        logging.info(f\"Warning, overwriting existing vehicle type '{vehicle_type.id}'.\")\n    self._veh_types[vehicle_type.id] = vehicle_type\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.add_veh","title":"<code>add_veh(v)</code>","text":"<p>Add vehicle to manager.</p> PARAMETER  DESCRIPTION <code>v</code> <p>Vehicle dataclass.</p> <p> TYPE: <code>Vehicle</code> </p> RAISES DESCRIPTION <code>PAMVehicleIdError</code> <p>Unknown vehicle type.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def add_veh(self, v: Vehicle):\n    \"\"\"Add vehicle to manager.\n\n    Args:\n        v (Vehicle): Vehicle dataclass.\n\n    Raises:\n        PAMVehicleIdError: Unknown vehicle type.\n    \"\"\"\n    if v.type_id not in self._veh_types:\n        raise PAMVehicleTypeError(\n            f\"Failed to add vehicle: {v.vid}, the vehicle type '{v.type_id}' is an unknown veh type.\"\n        )\n    if v.vid in self._vehicles:\n        logging.info(f\"Warning, overwriting existing vehicle: '{v.vid}'.\")\n    self._vehicles[v.vid] = v\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.charger_types","title":"<code>charger_types()</code>","text":"<p>Return set of electric charger types used by evs.</p> RETURNS DESCRIPTION <code>set[str]</code> <p>set[str]: Electric charger types.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def charger_types(self) -&gt; set[str]:\n    \"\"\"Return set of electric charger types used by evs.\n\n    Returns:\n        set[str]: Electric charger types.\n    \"\"\"\n    chargers = set()\n    for v in self.evs.values():\n        chargers |= set(v.charger_types.split(\",\"))\n    return chargers\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.clear_types","title":"<code>clear_types()</code>","text":"<p>Remove all types from manager.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def clear_types(self):\n    \"\"\"Remove all types from manager.\"\"\"\n    self._veh_types = {}\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.clear_vehs","title":"<code>clear_vehs()</code>","text":"<p>Remove all vehciles from manager.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def clear_vehs(self):\n    \"\"\"Remove all vehciles from manager.\"\"\"\n    self._vehicles = {}\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.evs_from_xml","title":"<code>evs_from_xml(path)</code>","text":"<p>Reads vehicles from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).</p> PARAMETER  DESCRIPTION <code>path</code> <p>path to matsim all_vehicles xml file</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def evs_from_xml(self, path):\n    \"\"\"Reads vehicles from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).\n\n    Args:\n        path (str): path to matsim all_vehicles xml file\n    \"\"\"\n    evs = {}\n    for vehicle_elem in utils.get_elems(path, \"vehicle\"):\n        attribs = dict(vehicle_elem.attrib)\n        vid = attribs.pop(\"id\")\n        vehicle_type = attribs.pop(\"vehicle_type\")\n        attribs[\"battery_capacity\"] = float(attribs[\"battery_capacity\"])\n        attribs[\"initial_soc\"] = float(attribs[\"initial_soc\"])\n        evs[vid] = ElectricVehicle(vid=vid, type_id=vehicle_type, **attribs)\n    keys = set(evs) &amp; set(self._vehicles)\n    if keys:\n        PAMVehicleIdError(\n            f\"Failed to read evs from xml due to duplicate keys with existing: {keys}\"\n        )\n    self._vehicles.update(evs)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.from_xml","title":"<code>from_xml(vehs_path, evs_path=None)</code>","text":"<p>Reads MATSim vehicles from https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd and reads electric_vehicles from https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd. Requires a vehicles file to load an evs file because the electric vehicle type is expected to be defined in the vehicles input.</p> PARAMETER  DESCRIPTION <code>vehs_path</code> <p>path to matsim all_vehicles xml file</p> <p> TYPE: <code>str</code> </p> <code>evs_path</code> <p>optional path to matsim electric_vehicles xml file. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Cannot load evs without a vehs file.</p> <code>UserWarning</code> <p>Fails consistency check.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def from_xml(self, vehs_path: str, evs_path: Optional[str] = None):\n    \"\"\"Reads MATSim vehicles from https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd\n    and reads electric_vehicles from https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd.\n    Requires a vehicles file to load an evs file because the electric vehicle type is expected to be defined in\n    the vehicles input.\n\n    Args:\n        vehs_path (str): path to matsim all_vehicles xml file\n        evs_path (Optional[str], optional): optional path to matsim electric_vehicles xml file. Defaults to None.\n\n    Raises:\n        UserWarning: Cannot load evs without a vehs file.\n        UserWarning: Fails consistency check.\n    \"\"\"\n\n    if not vehs_path and evs_path:\n        raise UserWarning(\"Cannot load an evs file without a vehs file.\")\n    self.types_from_xml(vehs_path)\n    self.vehs_from_xml(vehs_path)\n    if evs_path is not None:\n        self.evs_from_xml(evs_path)\n    if not self.is_consistent():\n        raise UserWarning(\"Inputs not consistent, refer to log.\")\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.get","title":"<code>get(k, default=None)</code>","text":"Source code in <code>pam/vehicles.py</code> <pre><code>def get(self, k: str, default: Optional[Vehicle] = None) -&gt; Optional[Vehicle]:\n    return self._vehicles.get(k, default)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.is_consistent","title":"<code>is_consistent()</code>","text":"<p>Check that manager vehicle population and types are consistent.</p> RAISES DESCRIPTION <code>PAMVehicleIdError</code> <p>Unknown vehicle type.</p> RETURNS DESCRIPTION <code>bool</code> <p>Manager is consistent. Note that this doesn't check for unused types.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def is_consistent(self) -&gt; bool:\n    \"\"\"Check that manager vehicle population and types are consistent.\n\n    Raises:\n        PAMVehicleIdError: Unknown vehicle type.\n\n    Returns:\n        bool: Manager is consistent. Note that this doesn't check for unused types.\n    \"\"\"\n    veh_types = set(self._veh_types.keys())\n    for k, v in self._vehicles.items():\n        if v.type_id not in veh_types:\n            raise PAMVehicleIdError(\n                f\"Failed to find veh type of id '{v}', specified for veh id '{k}'.\"\n            )\n    return True\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.len","title":"<code>len()</code>","text":"<p>Number of vehicles.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def len(self) -&gt; int:\n    \"\"\"Number of vehicles.\"\"\"\n    return len(self._vehicles)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.pop","title":"<code>pop(vid)</code>","text":"Source code in <code>pam/vehicles.py</code> <pre><code>def pop(self, vid):\n    return self._vehicles.pop(vid)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.redundant_types","title":"<code>redundant_types()</code>","text":"<p>Check for ununsed vehicle types.</p> RETURNS DESCRIPTION <code>dict</code> <p>unused types.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def redundant_types(self) -&gt; dict:\n    \"\"\"Check for ununsed vehicle types.\n\n    Returns:\n        dict: unused types.\n    \"\"\"\n    unused = {}\n    veh_types = set(self._veh_types.keys())\n    veh_veh_types = set([v.type_id for v in self._vehicles.values()])\n    for t in veh_types:\n        if t not in veh_veh_types:\n            unused[t] = self._veh_types[t]\n    return unused\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.remove_type","title":"<code>remove_type(tid)</code>","text":"<p>Remove vehicle type.</p> PARAMETER  DESCRIPTION <code>tid</code> <p>Vehicle type id.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def remove_type(self, tid: str):\n    \"\"\"Remove vehicle type.\n\n    Args:\n        tid (str): Vehicle type id.\n    \"\"\"\n    logging.info(\"Warning, removing a vehicle type may invalidate your vehicles.\")\n    if self._veh_types.pop(tid, None) is None:\n        raise PAMVehicleTypeError(f\"Failed to remove vehicle type {tid}, id not found.\")\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.to_ev_xml","title":"<code>to_ev_xml(path)</code>","text":"<p>Writes MATSim electric vehciles file as per https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd.</p> PARAMETER  DESCRIPTION <code>path</code> <p>name of output file</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_ev_xml(self, path: str):\n    \"\"\"Writes MATSim electric vehciles file as per https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd.\n\n    Args:\n        path (str): name of output file\n    \"\"\"\n    with et.xmlfile(path, encoding=\"utf-8\") as xf:\n        logging.info(f\"Writing electric vehicles to {path}\")\n        xf.write_declaration(\n            doctype='&lt;!DOCTYPE vehicles SYSTEM \"http://matsim.org/files/dtd/electric_vehicles_v1.dtd\"&gt;'\n        )\n        with xf.element(\"vehicles\"):\n            for veh in self.evs.values():\n                veh.to_ev_xml(xf)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.to_veh_xml","title":"<code>to_veh_xml(path)</code>","text":"<p>Writes MATSim vehicles file as per https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd.</p> PARAMETER  DESCRIPTION <code>path</code> <p>name of output file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_veh_xml(self, path: str):\n    \"\"\"Writes MATSim vehicles file as per https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd.\n\n    Args:\n        path (str): name of output file.\n    \"\"\"\n    with et.xmlfile(path, encoding=\"utf-8\") as xf:\n        xf.write_declaration()\n        vehicleDefinitions_attribs = {\n            \"xmlns\": \"http://www.matsim.org/files/dtd\",\n            \"xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n            \"xsi:schemaLocation\": \"http://www.matsim.org/files/dtd \"\n            \"http://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd\",\n        }\n        with xf.element(\"vehicleDefinitions\", vehicleDefinitions_attribs):\n            logging.info(f\"Writing vehicle types to {path}\")\n            for vehicle_type in self._veh_types.values():\n                vehicle_type.to_xml(xf)\n            logging.info(f\"Writing vehicles to {path}\")\n            for veh in self._vehicles.values():\n                veh.to_xml(xf)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.to_xml","title":"<code>to_xml(vehs_path, evs_path=None)</code>","text":"<p>Write manager to MATSim formatted xml.</p> PARAMETER  DESCRIPTION <code>vehs_path</code> <p>Write path for MATSim vehicles file.</p> <p> TYPE: <code>str</code> </p> <code>evs_path</code> <p>Write path for MATSim electric vehicles file. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_xml(self, vehs_path: str, evs_path: Optional[str] = None):\n    \"\"\"Write manager to MATSim formatted xml.\n\n    Args:\n        vehs_path (str): Write path for MATSim vehicles file.\n        evs_path (Optional[str], optional): Write path for MATSim electric vehicles file. Defaults to None.\n    \"\"\"\n    self.to_veh_xml(vehs_path)\n    if evs_path:\n        self.to_ev_xml(evs_path)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.types_from_xml","title":"<code>types_from_xml(path)</code>","text":"<p>Reads vehicle types from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).</p> PARAMETER  DESCRIPTION <code>path</code> <p>path to matsim all_vehicles xml file</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def types_from_xml(self, path: str):\n    \"\"\"Reads vehicle types from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).\n\n    Args:\n        path (str): path to matsim all_vehicles xml file\n    \"\"\"\n    vehs = dict(\n        (elem.get(\"id\"), VehicleType.from_xml_elem(elem))\n        for elem in utils.get_elems(path, \"vehicleType\")\n    )\n    keys = set(vehs) &amp; set(self._veh_types)\n    if keys:\n        raise PAMVehicleIdError(\n            f\"Failed to read types from xml due to duplicate keys with existing types: {keys}\"\n        )\n    self._veh_types.update(vehs)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleManager.vehs_from_xml","title":"<code>vehs_from_xml(path)</code>","text":"<p>Reads vehicles from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).</p> PARAMETER  DESCRIPTION <code>path</code> <p>path to matsim all_vehicles xml file</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def vehs_from_xml(self, path: str):\n    \"\"\"Reads vehicles from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).\n\n    Args:\n        path (str): path to matsim all_vehicles xml file\n    \"\"\"\n\n    vehs = {\n        elem.get(\"id\"): Vehicle(vid=elem.get(\"id\"), type_id=elem.get(\"type\"))\n        for elem in utils.get_elems(path, \"vehicle\")\n    }\n    keys = set(vehs) &amp; set(self._vehicles)\n    if keys:\n        raise PAMVehicleIdError(\n            f\"Failed to read vehs from xml due to duplicate keys with existing: {keys}\"\n        )\n    self._vehicles.update(vehs)\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType","title":"<code>VehicleType</code>  <code>dataclass</code>","text":"<p>Vehicle type data with read/write methods.</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>type id.</p> <p> TYPE: <code>str</code> </p> <code>length</code> <p>Vehicle length in m.</p> <p> TYPE: <code>float</code> </p> <code>width</code> <p>Vehicle width in m.</p> <p> TYPE: <code>float</code> </p> <code>networkMode</code> <p>MATSim network mode (used for routing).</p> <p> TYPE: <code>str</code> </p> <code>capacity</code> <p>Vehicle seating and standing capacity.</p> <p> TYPE: <code>CapacityType</code> </p> <code>description</code> <p>Vehicle description.</p> <p> TYPE: <code>str</code> </p> <code>passengerCarEquivalents</code> <p>Vehicle size as passenger car equivalents (PCUs).</p> <p> TYPE: <code>float</code> </p> <code>flowEfficiencyFactor</code> <p>Vehicle flow efficiency factor.</p> <p> TYPE: <code>float</code> </p>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.capacity","title":"<code>capacity: CapacityType = field(default_factory=CapacityType)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.description","title":"<code>description: str = 'personal_vehicle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.flowEfficiencyFactor","title":"<code>flowEfficiencyFactor: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.length","title":"<code>length: float = 7.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.networkMode","title":"<code>networkMode: str = 'car'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.passengerCarEquivalents","title":"<code>passengerCarEquivalents: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.width","title":"<code>width: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.from_xml_elem","title":"<code>from_xml_elem(elem)</code>  <code>classmethod</code>","text":"<p>Construct VehicleType from MATSim xml element.</p> PARAMETER  DESCRIPTION <code>elem</code> <p>MATSim formatted vehicle type xml element.</p> <p> TYPE: <code>Element</code> </p> RETURNS DESCRIPTION <code>VehicleType</code> <p>Vehicle type dataclass.</p> <p> TYPE: <code>VehicleType</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>@classmethod\ndef from_xml_elem(cls, elem: et.Element) -&gt; VehicleType:\n    \"\"\"Construct VehicleType from MATSim xml element.\n\n    Args:\n        elem (et.Element): MATSim formatted vehicle type xml element.\n\n    Returns:\n        VehicleType: Vehicle type dataclass.\n    \"\"\"\n    attribs = {\n        attrib.tag.replace(\"{http://www.matsim.org/files/dtd}\", \"\"): attrib for attrib in elem\n    }\n    return cls(\n        id=elem.get(\"id\"),\n        length=float(attribs[\"length\"].attrib[\"meter\"]),\n        width=float(attribs[\"width\"].attrib[\"meter\"]),\n        passengerCarEquivalents=float(attribs[\"passengerCarEquivalents\"].attrib[\"pce\"]),\n        networkMode=attribs[\"networkMode\"].attrib[\"networkMode\"],\n        flowEfficiencyFactor=float(attribs[\"flowEfficiencyFactor\"].attrib[\"factor\"]),\n        capacity=CapacityType.from_xml_elem(attribs[\"capacity\"]),\n        description=attribs[\"description\"].text,\n    )\n</code></pre>"},{"location":"reference/pam/vehicles/#pam.vehicles.VehicleType.to_xml","title":"<code>to_xml(xf)</code>","text":"<p>Write vehicle type to MATSim formatted xml.</p> PARAMETER  DESCRIPTION <code>xf</code> <p>Parent xml element.</p> <p> TYPE: <code>Element</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_xml(self, xf: et.Element) -&gt; None:\n    \"\"\"Write vehicle type to MATSim formatted xml.\n\n    Args:\n        xf (et.Element): Parent xml element.\n    \"\"\"\n    with xf.element(\"vehicleType\", {\"id\": self.id}):\n        rec = et.Element(\"description\")\n        rec.text = self.description\n        xf.write(rec)\n        self.capacity.to_xml(xf)\n        xf.write(et.Element(\"length\", {\"meter\": str(self.length)}))\n        xf.write(et.Element(\"width\", {\"meter\": str(self.width)}))\n        xf.write(\n            et.Element(\"passengerCarEquivalents\", {\"pce\": str(self.passengerCarEquivalents)})\n        )\n        xf.write(et.Element(\"networkMode\", {\"networkMode\": str(self.networkMode)}))\n        xf.write(et.Element(\"flowEfficiencyFactor\", {\"factor\": str(self.flowEfficiencyFactor)}))\n</code></pre>"},{"location":"reference/pam/write/diary/","title":"pam.write.diary","text":""},{"location":"reference/pam/write/diary/#pam.write.diary.dump","title":"<code>dump(population, dir, crs=None, to_crs='EPSG:4326')</code>","text":"<p>Write a population to disk as tabular data in csv format.</p> <p>Outputs saved to file are: - households.csv: household ids and attributes - people.csv: agent ids and attributes - legs.csv: activity plan trip records - activities.csv: corresponding plan activities If activity locs (shapely.Point) data is available then geojsons will also be written.</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> <code>dir</code> <p>path to output directory</p> <p> TYPE: <code>str</code> </p> <code>crs</code> <p>population coordinate system (generally we use local grid systems). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>to_crs</code> <p>output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'EPSG:4326'</code> </p> Source code in <code>pam/write/diary.py</code> <pre><code>def dump(\n    population: Population, dir: str, crs: Optional[str] = None, to_crs: Optional[str] = \"EPSG:4326\"\n) -&gt; None:\n    \"\"\"Write a population to disk as tabular data in csv format.\n\n    Outputs saved to file are:\n    - households.csv: household ids and attributes\n    - people.csv: agent ids and attributes\n    - legs.csv: activity plan trip records\n    - activities.csv: corresponding plan activities\n    If activity locs (shapely.Point) data is available then geojsons will also be written.\n\n    Args:\n      population (Population):\n      dir (str): path to output directory\n      crs (Optional[str]): population coordinate system (generally we use local grid systems). Defaults to None.\n      to_crs (Optional[str]): output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".\n    \"\"\"\n    to_csv(population=population, dir=dir, crs=crs, to_crs=to_crs)\n</code></pre>"},{"location":"reference/pam/write/diary/#pam.write.diary.save_csv","title":"<code>save_csv(df, path)</code>","text":"<p>Write GeoDataFrame as csv by dropping geometry column.</p> Source code in <code>pam/write/diary.py</code> <pre><code>def save_csv(df, path):\n    \"\"\"Write GeoDataFrame as csv by dropping geometry column.\"\"\"\n    if \"geometry\" in df.columns:\n        df = df.drop(\"geometry\", axis=1)\n    df.to_csv(path)\n</code></pre>"},{"location":"reference/pam/write/diary/#pam.write.diary.save_geojson","title":"<code>save_geojson(df, crs, to_crs, path)</code>","text":"Source code in <code>pam/write/diary.py</code> <pre><code>def save_geojson(df, crs, to_crs, path):\n    if \"geometry\" in df.columns:\n        df = gp.GeoDataFrame(df, geometry=\"geometry\")\n        if crs is not None:\n            df.crs = crs\n            df.to_crs(to_crs, inplace=True)\n        df.to_file(path, driver=\"GeoJSON\")\n</code></pre>"},{"location":"reference/pam/write/diary/#pam.write.diary.to_csv","title":"<code>to_csv(population, dir, crs=None, to_crs='EPSG:4326')</code>","text":"<p>Write a population to disk as tabular data in csv format.</p> <p>Outputs saved to file are: - households.csv: household ids and attributes - people.csv: agent ids and attributes - legs.csv: activity plan trip records - activities.csv: corresponding plan activities If activity locs (shapely.Point) data is available then geojsons will also be written.</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> <code>dir</code> <p>path to output directory</p> <p> TYPE: <code>str</code> </p> <code>crs</code> <p>population coordinate system (generally we use local grid systems). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>to_crs</code> <p>output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'EPSG:4326'</code> </p> Source code in <code>pam/write/diary.py</code> <pre><code>def to_csv(\n    population: Population, dir: str, crs: Optional[str] = None, to_crs: Optional[str] = \"EPSG:4326\"\n) -&gt; None:\n    \"\"\"Write a population to disk as tabular data in csv format.\n\n    Outputs saved to file are:\n    - households.csv: household ids and attributes\n    - people.csv: agent ids and attributes\n    - legs.csv: activity plan trip records\n    - activities.csv: corresponding plan activities\n    If activity locs (shapely.Point) data is available then geojsons will also be written.\n\n    Args:\n      population (Population):\n      dir (str): path to output directory\n      crs (Optional[str]): population coordinate system (generally we use local grid systems). Defaults to None.\n      to_crs (Optional[str]): output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".\n\n    \"\"\"\n    create_local_dir(dir)\n\n    hhs = []\n    people = []\n    acts = []\n    legs = []\n\n    for hid, hh in population.households.items():\n        hh_data = {\"hid\": hid, \"freq\": hh.freq, \"hzone\": hh.location.area}\n        if isinstance(hh.attributes, dict):\n            hh_data.update(hh.attributes)\n        if hh.location.loc is not None:\n            hh_data[\"geometry\"] = hh.location.loc\n\n        hhs.append(hh_data)\n\n        for pid, person in hh.people.items():\n            people_data = {\"pid\": pid, \"hid\": hid, \"freq\": person.freq, \"hzone\": hh.location.area}\n            if isinstance(person.attributes, dict):\n                people_data.update(person.attributes)\n            if hh.location.loc is not None:\n                people_data[\"geometry\"] = hh.location.loc\n\n            people.append(people_data)\n\n            for seq, component in enumerate(person.plan):\n                if isinstance(component, Leg):\n                    leg_data = {\n                        \"pid\": pid,\n                        \"hid\": hid,\n                        \"freq\": component.freq,\n                        \"ozone\": component.start_location.area,\n                        \"dzone\": component.end_location.area,\n                        \"purp\": component.purp,\n                        \"origin activity\": person.plan[seq - 1].act,\n                        \"destination activity\": person.plan[seq + 1].act,\n                        \"mode\": component.mode,\n                        \"seq\": component.seq,\n                        \"tst\": component.start_time,\n                        \"tet\": component.end_time,\n                        \"duration\": str(component.duration),\n                    }\n                    if (\n                        component.start_location.loc is not None\n                        and component.end_location.loc is not None\n                    ):\n                        leg_data[\"geometry\"] = LineString(\n                            (component.start_location.loc, component.end_location.loc)\n                        )\n\n                    legs.append(leg_data)\n\n                if isinstance(component, Activity):\n                    act_data = {\n                        \"pid\": pid,\n                        \"hid\": hid,\n                        \"freq\": component.freq,\n                        \"activity\": component.act,\n                        \"seq\": component.seq,\n                        \"start time\": component.start_time,\n                        \"end time\": component.end_time,\n                        \"duration\": str(component.duration),\n                        \"zone\": component.location.area,\n                    }\n                    if component.location.loc is not None:\n                        act_data[\"geometry\"] = component.location.loc\n\n                    acts.append(act_data)\n\n    hhs = pd.DataFrame(hhs).set_index(\"hid\")\n    save_geojson(hhs, crs, to_crs, os.path.join(dir, \"households.geojson\"))\n    save_csv(hhs, os.path.join(dir, \"households.csv\"))\n\n    people = pd.DataFrame(people).set_index(\"pid\")\n    save_geojson(people, crs, to_crs, os.path.join(dir, \"people.geojson\"))\n    save_csv(people, os.path.join(dir, \"people.csv\"))\n\n    legs = pd.DataFrame(legs)\n    save_geojson(legs, crs, to_crs, os.path.join(dir, \"legs.geojson\"))\n    save_csv(legs, os.path.join(dir, \"legs.csv\"))\n\n    acts = pd.DataFrame(acts)\n    save_geojson(acts, crs, to_crs, os.path.join(dir, \"activities.geojson\"))\n    save_csv(acts, os.path.join(dir, \"activities.csv\"))\n</code></pre>"},{"location":"reference/pam/write/diary/#pam.write.diary.write_population_csvs","title":"<code>write_population_csvs(list_of_populations, dir, crs=None, to_crs='EPSG:4326')</code>","text":"<p>Write a list of populations to disk as tabular data in csv format.</p> <p>Outputs saved to file are: - populations.csv: summary of populations - households.csv: household ids and attributes - people.csv: agent ids and attributes - legs.csv: activity plan trip records - activities.csv: corresponding plan activities If activity locs (shapely.Point) data is available then geojsons will also be written.</p> PARAMETER  DESCRIPTION <code>list_of_populations</code> <p> TYPE: <code>list[Population]</code> </p> <code>dir</code> <p>path to output directory</p> <p> TYPE: <code>str</code> </p> <code>crs</code> <p>population coordinate system (generally we use local grid systems). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>to_crs</code> <p>output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'EPSG:4326'</code> </p> Source code in <code>pam/write/diary.py</code> <pre><code>def write_population_csvs(\n    list_of_populations: list[Population],\n    dir: str,\n    crs: Optional[str] = None,\n    to_crs: Optional[str] = \"EPSG:4326\",\n) -&gt; None:\n    \"\"\"Write a list of populations to disk as tabular data in csv format.\n\n    Outputs saved to file are:\n    - populations.csv: summary of populations\n    - households.csv: household ids and attributes\n    - people.csv: agent ids and attributes\n    - legs.csv: activity plan trip records\n    - activities.csv: corresponding plan activities\n    If activity locs (shapely.Point) data is available then geojsons will also be written.\n\n    Args:\n      list_of_populations (list[Population]):\n      dir (str): path to output directory\n      crs (Optional[str]): population coordinate system (generally we use local grid systems). Defaults to None.\n      to_crs (Optional[str]): output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".\n    \"\"\"\n    create_local_dir(dir)\n\n    populations = []\n    for idx, population in enumerate(list_of_populations):\n        if population.name is None:\n            population.name = idx\n        populations.append({\"population_id\": idx, \"population_name\": population.name})\n        to_csv(\n            population=population, dir=os.path.join(dir, population.name), crs=crs, to_crs=to_crs\n        )\n\n    pd.DataFrame(populations).to_csv(os.path.join(dir, \"populations.csv\"), index=False)\n</code></pre>"},{"location":"reference/pam/write/matrices/","title":"pam.write.matrices","text":""},{"location":"reference/pam/write/matrices/#pam.write.matrices.write_od_matrices","title":"<code>write_od_matrices(population, path, leg_filter=None, person_filter=None, time_minutes_filter=None)</code>","text":"<p>Write a core population object to tabular O-D weighted matrices.</p> <p>Optionally segment matrices by leg attributes(mode/ purpose), person attributes or specific time periods. A single filter can be applied each time.</p> <p>TODO include freq (assume hh).</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> <code>path</code> <p>directory to write OD matrix files</p> <p> TYPE: <code>str</code> </p> <code>leg_filter</code> <p>select between 'Mode', 'Purpose'. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>person_filter</code> <p>select between given attribute categories (column names) from person attribute data. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>time_minutes_filter</code> <p>a list of tuples to slice times, e.g. [(start_of_slicer_1, end_of_slicer_1), (start_of_slicer_2, end_of_slicer_2), ... ]. Defaults to None.</p> <p> TYPE: <code>Optional[List[Tuple[int]]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/write/matrices.py</code> <pre><code>def write_od_matrices(\n    population: Population,\n    path: str,\n    leg_filter: Optional[str] = None,\n    person_filter: Optional[str] = None,\n    time_minutes_filter: Optional[List[Tuple[int]]] = None,\n) -&gt; None:\n    \"\"\"Write a core population object to tabular O-D weighted matrices.\n\n    Optionally segment matrices by leg attributes(mode/ purpose), person attributes or specific time periods.\n    A single filter can be applied each time.\n\n    TODO include freq (assume hh).\n\n    Args:\n        population (Population):\n        path (str): directory to write OD matrix files\n        leg_filter (Optional[str], optional): select between 'Mode', 'Purpose'. Defaults to None.\n        person_filter (Optional[str], optional): select between given attribute categories (column names) from person attribute data. Defaults to None.\n        time_minutes_filter (Optional[List[Tuple[int]]], optional): a list of tuples to slice times, e.g. [(start_of_slicer_1, end_of_slicer_1), (start_of_slicer_2, end_of_slicer_2), ... ]. Defaults to None.\n\n    \"\"\"\n    create_local_dir(path)\n\n    legs = []\n\n    for hid, household in population.households.items():\n        for pid, person in household.people.items():\n            for leg in person.legs:\n                data = {\n                    \"Household ID\": hid,\n                    \"Person ID\": pid,\n                    \"Origin\": leg.start_location.area,\n                    \"Destination\": leg.end_location.area,\n                    \"Purpose\": leg.purp,\n                    \"Mode\": leg.mode,\n                    \"Sequence\": leg.seq,\n                    \"Start time\": leg.start_time,\n                    \"End time\": leg.end_time,\n                    \"Freq\": household.freq,\n                }\n                if person_filter:\n                    legs.append({**data, **person.attributes})\n                else:\n                    legs.append(data)\n\n    df_total = pd.DataFrame(data=legs, columns=[\"Origin\", \"Destination\"]).set_index(\"Origin\")\n    matrix = df_total.pivot_table(\n        values=\"Destination\", index=\"Origin\", columns=\"Destination\", fill_value=0, aggfunc=len\n    )\n    matrix.to_csv(os.path.join(path, \"total_od.csv\"))\n\n    data_legs = pd.DataFrame(data=legs)\n\n    if leg_filter:\n        data_legs_grouped = data_legs.groupby(leg_filter)\n        for filter, leg in data_legs_grouped:\n            df = pd.DataFrame(data=leg, columns=[\"Origin\", \"Destination\"]).set_index(\"Origin\")\n            matrix = df.pivot_table(\n                values=\"Destination\",\n                index=\"Origin\",\n                columns=\"Destination\",\n                fill_value=0,\n                aggfunc=len,\n            )\n            matrix.to_csv(os.path.join(path, filter + \"_od.csv\"))\n        return None\n\n    elif person_filter:\n        data_legs_grouped = data_legs.groupby(person_filter)\n        for filter, leg in data_legs_grouped:\n            df = pd.DataFrame(data=leg, columns=[\"Origin\", \"Destination\"]).set_index(\"Origin\")\n            matrix = df.pivot_table(\n                values=\"Destination\",\n                index=\"Origin\",\n                columns=\"Destination\",\n                fill_value=0,\n                aggfunc=len,\n            )\n            matrix.to_csv(os.path.join(path, filter + \"_od.csv\"))\n        return None\n\n    elif time_minutes_filter:\n        periods = []\n        for time in time_minutes_filter:\n            periods.append(time)\n        for start_time, end_time in periods:\n            file_name = str(start_time) + \"_to_\" + str(end_time)\n            start_time = mtdt(start_time)\n            end_time = mtdt(end_time)\n            data_time = data_legs[\n                (data_legs[\"Start time\"] &gt;= start_time) &amp; (data_legs[\"Start time\"] &lt; end_time)\n            ]\n            df = pd.DataFrame(data=data_time, columns=[\"Origin\", \"Destination\"]).set_index(\"Origin\")\n            matrix = df.pivot_table(\n                values=\"Destination\",\n                index=\"Origin\",\n                columns=\"Destination\",\n                fill_value=0,\n                aggfunc=len,\n            )\n            matrix.to_csv(os.path.join(path, \"time_\" + file_name + \"_od.csv\"))\n        return None\n</code></pre>"},{"location":"reference/pam/write/matsim/","title":"pam.write.matsim","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer","title":"<code>Writer(path, household_key='hid', comment=None, keep_non_selected=False, coordinate_reference_system=None)</code>","text":"<p>Context Manager for writing to xml.</p> <p>Designed to handle the boilerplate xml.</p> Example <pre><code>with pam.write.matsim.Writer(PATH) as writer:\n    for hid, household in population:\n        writer.add_hh(household)\n</code></pre> <pre><code>with pam.write.matsim.Writer(OUT_PATH) as writer:\n    for person in pam.read.matsim.stream_matsim_persons(IN_PATH):\n        pam.samplers.time.apply_jitter_to_plan(person.plan)\n        writer.add_person(household)\n</code></pre> Source code in <code>pam/write/matsim.py</code> <pre><code>def __init__(\n    self,\n    path: str,\n    household_key: Optional[str] = \"hid\",\n    comment: Optional[str] = None,\n    keep_non_selected: bool = False,\n    coordinate_reference_system: str = None,\n) -&gt; None:\n    if os.path.dirname(path):\n        create_local_dir(os.path.dirname(path))\n    self.path = path\n    self.household_key = household_key\n    self.comment = comment\n    self.keep_non_selected = keep_non_selected\n    self.coordinate_reference_system = coordinate_reference_system\n    self.compression = DEFAULT_GZIP_COMPRESSION if is_gzip(path) else 0\n    self.xmlfile = None\n    self.writer = None\n    self.population_writer = None\n</code></pre>"},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.comment","title":"<code>comment = comment</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.compression","title":"<code>compression = DEFAULT_GZIP_COMPRESSION if is_gzip(path) else 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.coordinate_reference_system","title":"<code>coordinate_reference_system = coordinate_reference_system</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.household_key","title":"<code>household_key = household_key</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.keep_non_selected","title":"<code>keep_non_selected = keep_non_selected</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.path","title":"<code>path = path</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.population_writer","title":"<code>population_writer = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.writer","title":"<code>writer = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.xmlfile","title":"<code>xmlfile = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.add_hh","title":"<code>add_hh(household)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def add_hh(self, household) -&gt; None:\n    for _, person in household:\n        if self.household_key is not None:\n            # force add hid as an attribute\n            person.attributes[self.household_key] = household.hid\n        self.add_person(person)\n</code></pre>"},{"location":"reference/pam/write/matsim/#pam.write.matsim.Writer.add_person","title":"<code>add_person(person)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def add_person(self, person) -&gt; None:\n    e = create_person_element(person.pid, person, self.keep_non_selected)\n    self.writer.write(e, pretty_print=True)\n</code></pre>"},{"location":"reference/pam/write/matsim/#pam.write.matsim.add_attribute","title":"<code>add_attribute(attributes, k, v)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def add_attribute(attributes, k, v):\n    if isinstance(v, str):\n        attribute = et.SubElement(\n            attributes, \"attribute\", {\"class\": \"java.lang.String\", \"name\": str(k)}\n        )\n        attribute.text = str(v)\n    elif isinstance(v, bool):\n        attribute = et.SubElement(\n            attributes, \"attribute\", {\"class\": \"java.lang.Boolean\", \"name\": str(k)}\n        )\n        attribute.text = str(v)\n    elif isinstance(v, int):\n        attribute = et.SubElement(\n            attributes, \"attribute\", {\"class\": \"java.lang.Integer\", \"name\": str(k)}\n        )\n        attribute.text = str(v)\n    elif isinstance(v, float):\n        attribute = et.SubElement(\n            attributes, \"attribute\", {\"class\": \"java.lang.Double\", \"name\": str(k)}\n        )\n        attribute.text = str(v)\n    elif k == \"vehicles\":\n        attribute = et.SubElement(\n            attributes,\n            \"attribute\",\n            {\"class\": \"org.matsim.vehicles.PersonVehicles\", \"name\": str(\"vehicles\")},\n        )\n        attribute.text = str(v).replace(\"'\", '\"')\n    else:\n        attribute = et.SubElement(\n            attributes, \"attribute\", {\"class\": \"java.lang.String\", \"name\": str(k)}\n        )\n        attribute.text = str(v)\n</code></pre>"},{"location":"reference/pam/write/matsim/#pam.write.matsim.create_person_element","title":"<code>create_person_element(pid, person, keep_non_selected=False)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def create_person_element(pid, person, keep_non_selected: bool = False):\n    person_xml = et.Element(\"person\", {\"id\": str(pid)})\n\n    attributes = et.SubElement(person_xml, \"attributes\", {})\n    if person.vehicles:\n        attribute = et.SubElement(\n            attributes,\n            \"attribute\",\n            {\"class\": \"org.matsim.vehicles.PersonVehicles\", \"name\": \"vehicles\"},\n        )\n        attribute.text = str({k: v.vid for k, v in person.vehicles.items()}).replace(\"'\", '\"')\n\n    for k, v in person.attributes.items():\n        add_attribute(attributes, k, v)\n\n    write_plan(person_xml, person.plan, selected=True)\n    if keep_non_selected:\n        for plan in person.plans_non_selected:\n            write_plan(person_xml, plan, selected=False)\n    return person_xml\n</code></pre>"},{"location":"reference/pam/write/matsim/#pam.write.matsim.object_attributes_dtd","title":"<code>object_attributes_dtd()</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def object_attributes_dtd():\n    dtd_path = importlib_resources.files(\"pam\") / \"fixtures\" / \"dtd\" / \"objectattributes_v1.dtd\"\n    return et.DTD(dtd_path)\n</code></pre>"},{"location":"reference/pam/write/matsim/#pam.write.matsim.population_v6_dtd","title":"<code>population_v6_dtd()</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def population_v6_dtd():\n    dtd_path = importlib_resources.files(\"pam\") / \"fixtures\" / \"dtd\" / \"population_v6.dtd\"\n    return et.DTD(dtd_path)\n</code></pre>"},{"location":"reference/pam/write/matsim/#pam.write.matsim.write_matsim","title":"<code>write_matsim(population, plans_path, attributes_path=None, vehs_path=None, evs_path=None, version=None, comment=None, household_key='hid', keep_non_selected=False, coordinate_reference_system=None)</code>","text":"<p>Write a core population to matsim population v6 xml format. Note that this requires activity locs to be set (shapely.Point).</p> PARAMETER  DESCRIPTION <code>population</code> <p>population to be writen to disk</p> <p> TYPE: <code>Population</code> </p> <code>plans_path</code> <p>output path (.xml or .xml.gz)</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>attributes_path</code> <p>legacy parameter, does not have an effect. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>vehs_path</code> <p>path to output vehicle file. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>evs_path</code> <p>path to output ev file. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>legacy parameter, does not have an effect. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>comment</code> <p>default None, optionally add a comment string to the xml outputs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>household_key</code> <p>optionally add household id to person attributes. Defaults to \"hid\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'hid'</code> </p> <code>keep_non_selected</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>coordinate_reference_system</code> <p>optionally add CRS attribute to xml outputs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>If population includes vehicles, <code>vehicles_dir</code> must be defined.</p> Source code in <code>pam/write/matsim.py</code> <pre><code>def write_matsim(\n    population,\n    plans_path: Union[Path, str],\n    attributes_path: Optional[Union[Path, str]] = None,\n    vehs_path: Optional[Union[Path, str]] = None,\n    evs_path: Optional[Union[Path, str]] = None,\n    version: int = None,\n    comment: Optional[str] = None,\n    household_key: Optional[str] = \"hid\",\n    keep_non_selected: bool = False,\n    coordinate_reference_system: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Write a core population to matsim population v6 xml format.\n    Note that this requires activity locs to be set (shapely.Point).\n\n    Args:\n        population (Population): population to be writen to disk\n        plans_path (Union[str, Path]): output path (.xml or .xml.gz)\n        attributes_path (Optional[Union[str, Path]], optional): legacy parameter, does not have an effect. Defaults to None.\n        vehs_path (Optional[Union[str, Path]], optional): path to output vehicle file. Defaults to None.\n        evs_path (Optional[Union[str, Path]], optional): path to output ev file. Defaults to None.\n        version (Optional[int], optional): legacy parameter, does not have an effect. Defaults to None.\n        comment (Optional[str], optional): default None, optionally add a comment string to the xml outputs. Defaults to None.\n        household_key (Optional[str], optional): optionally add household id to person attributes. Defaults to \"hid\".\n        keep_non_selected (bool, optional): Defaults to False.\n        coordinate_reference_system (Optional[str], optional): optionally add CRS attribute to xml outputs. Defaults to None.\n\n    Raises:\n        UserWarning: If population includes vehicles, `vehicles_dir` must be defined.\n    \"\"\"\n    if version is not None:\n        warn(\n            'parameter \"version\" is no longer supported by write_matsim(), this will be removed in future release.'\n        )\n    if attributes_path is not None:\n        logging.warning('parameter \"attributes_path\" is no longer supported by write_matsim()')\n    if vehs_path is None and evs_path is not None:\n        raise UserWarning(\"You must provide a vehs_path in addition to evs_path.\")\n\n    write_matsim_population_v6(\n        population=population,\n        path=plans_path,\n        comment=comment,\n        household_key=household_key,\n        keep_non_selected=keep_non_selected,\n        coordinate_reference_system=coordinate_reference_system,\n    )\n\n    # write vehicles\n    if vehs_path is not None:\n        logging.info(\"Building population vehicles output.\")\n        # rebuild vehicles output from population\n        population.rebuild_vehicles_manager()\n        population._vehicles_manager.to_xml(vehs_path, evs_path)\n</code></pre>"},{"location":"reference/pam/write/matsim/#pam.write.matsim.write_matsim_population_v6","title":"<code>write_matsim_population_v6(population, path, household_key='hid', comment=None, keep_non_selected=False, coordinate_reference_system=None)</code>","text":"<p>Write matsim population v6 xml (persons plans and attributes combined).</p> PARAMETER  DESCRIPTION <code>population</code> <p>population to be writen to disk</p> <p> TYPE: <code>Population</code> </p> <code>path</code> <p>output path (.xml or .xml.gz)</p> <p> TYPE: <code>str</code> </p> <code>household_key</code> <p>Defaults to \"hid\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'hid'</code> </p> <code>comment</code> <p>optionally add a comment string to the xml outputs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>keep_non_selected</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>coordinate_reference_system</code> <p>Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/write/matsim.py</code> <pre><code>def write_matsim_population_v6(\n    population: Population,\n    path: str,\n    household_key: Optional[str] = \"hid\",\n    comment: Optional[str] = None,\n    keep_non_selected: bool = False,\n    coordinate_reference_system: str = None,\n) -&gt; None:\n    \"\"\"Write matsim population v6 xml (persons plans and attributes combined).\n\n    Args:\n        population (Population): population to be writen to disk\n        path (str): output path (.xml or .xml.gz)\n        household_key (Optional[str], optional): Defaults to \"hid\".\n        comment (Optional[str], optional): optionally add a comment string to the xml outputs. Defaults to None.\n        keep_non_selected (bool, optional): Defaults to False.\n        coordinate_reference_system (str, optional): Defaults to None.\n    \"\"\"\n    with Writer(\n        path=path,\n        household_key=household_key,\n        comment=comment,\n        keep_non_selected=keep_non_selected,\n        coordinate_reference_system=coordinate_reference_system,\n    ) as writer:\n        for _, household in population:\n            writer.add_hh(household)\n</code></pre>"},{"location":"reference/pam/write/matsim/#pam.write.matsim.write_plan","title":"<code>write_plan(person_xml, plan, selected=None)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def write_plan(person_xml: et.SubElement, plan: Plan, selected: Optional[bool] = None):\n    plan_attributes = {}\n    if selected is not None:\n        plan_attributes[\"selected\"] = {True: \"yes\", False: \"no\"}[selected]\n    if plan.score is not None:\n        plan_attributes[\"score\"] = str(plan.score)\n\n    plan_xml = et.SubElement(person_xml, \"plan\", plan_attributes)\n    for component in plan:\n        if isinstance(component, Activity):\n            component.validate_matsim()\n            act_data = {\"type\": component.act}\n            if component.start_time is not None:\n                act_data[\"start_time\"] = dttm(component.start_time)\n            if component.end_time is not None:\n                act_data[\"end_time\"] = dttm(component.end_time)\n            if component.location.link is not None:\n                act_data[\"link\"] = str(component.location.link)\n            if component.location.x is not None:\n                act_data[\"x\"] = str(component.location.x)\n            if component.location.y is not None:\n                act_data[\"y\"] = str(component.location.y)\n            et.SubElement(plan_xml, \"activity\", act_data)\n\n        if isinstance(component, Leg):\n            leg = et.SubElement(\n                plan_xml, \"leg\", {\"mode\": component.mode, \"trav_time\": tdtm(component.duration)}\n            )\n\n            if component.attributes:\n                attributes = et.SubElement(leg, \"attributes\")\n                for k, v in component.attributes.items():\n                    if (\n                        k == \"enterVehicleTime\"\n                    ):  # todo make something more robust for future 'special' classes\n                        attribute = et.SubElement(\n                            attributes, \"attribute\", {\"class\": \"java.lang.Double\", \"name\": str(k)}\n                        )\n                        attribute.text = str(v)\n                    else:\n                        add_attribute(attributes, k, v)\n\n            if component.route.exists:\n                leg.append(component.route.xml)\n</code></pre>"}]}