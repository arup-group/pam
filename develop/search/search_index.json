{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#population-activity-modeller","title":"Population Activity Modeller","text":"<p>PAM is a python library for population activity sequence modelling. Example use cases:</p> <ul> <li>Read an existing population then write to a new format.</li> <li>Modify an existing population, for example to model activity locations.</li> <li>Create your own activity-based model.</li> </ul> <p>PAM supports common travel and activity formats, including MATSim.</p>"},{"location":"#activity-sequences","title":"Activity Sequences?","text":"<p>Population activity sequences (sometimes called activity plans) are used to model the activities (where and when people are at home, work, education and so on) and associated travel of a population:</p> <p></p> <p>Activity sequences are used by transport planners to model travel demand, but can also be used in other domains, such as for virus transmission or energy use modelling.</p>"},{"location":"#brief-history","title":"Brief History","text":"<p>PAM was originally built and shared to rapidly modify existing activity models to respond to pandemic lock-down scenarios.</p> <p></p> <p>This functionality used a read-modify-write pattern. Where modifications are made by applying policies. Example policies might be (a) infected persons quarantine at home, (b) only critical workers travel to work, and (c) everyone shops locally.</p> <p></p>"},{"location":"#features","title":"Features","text":""},{"location":"#activity-modelling","title":"Activity Modelling","text":"<p>In addition to the original read-modify-write pattern and functionality, PAM has modules for:</p> <ul> <li>location modelling</li> <li>discretionary activity modelling</li> <li>mode choice modelling</li> <li>facility sampling</li> <li>vehicle ownership</li> </ul> <p>More generally the core PAM data structure and modules can be used as a library to support your own use cases, including building your own activity-based model.</p>"},{"location":"#matsim","title":"MATSim","text":"<p>PAM fully supports the MATSim population/plans format. This includes vehicles, unselected plans, leg routes and leg attributes. A core use case of PAM is to read-modify-write experienced plans from MATSim. This can allow new MATSim scenarios to be \"warm started\" from existing scenarios, significantly reducing MATSim compute time.</p>"},{"location":"#why-activity-plans","title":"Why Activity Plans?","text":"<ol> <li> <p>They are the ideal mechanism for applying changes, allowing for example, consideration of joint dis-aggregate features across an entire day.</p> </li> <li> <p>They can be post processed for many other output formats such as origin-destination matrices or activity diaries. These outputs can the be used in many different applications such as transport, utility demand, social impact and so on.</p> </li> </ol>"},{"location":"activity_plans/","title":"Activity Plans","text":"<p>PAM supports arbitrarily complex chains of activities connected by 'legs' (these are equivalent to 'trips'). The main rules are (i) that plans must consist of sequences of alternate <code>pam.activity.Activity</code> and <code>pam.activity.Leg</code> objects and (ii) that a plan must start and end with an <code>Activity</code>:</p> <pre><code>from pam.core import Person\nfrom pam.activity import Leg, Activity\nfrom pam\nperson = Person('Tony', attributes = {'age': 9, 'philosophy': 'stoicism'})\nperson.add(\nActivity(\nact='home',\narea='zone A',\n)\n)\nperson.add(\nLeg(\nmode='car',\nstart_time=utils.parse_time(600),  # (minutes)\nend_time=utils.parse_time(630),\n)\n)\nperson.add(\nActivity(\nact='work',\narea='zone B',\n)\n)\nperson.add(\nLeg(\nmode='car',\nstart_time=utils.parse_time(1800),\nend_time=utils.parse_time(1830),\n)\n)\n# Continue adding Activities and Legs alternately.\n# A sequence must start and end with an activity.\n# ...\nperson.add(\nActivity(\nact='home',\narea='zone B'\n)\n)\nactivities = list(person.plan.activities)\ntrips = list(person.plan.legs)\nperson.print()\n</code></pre>"},{"location":"activity_plans/#how-travel-diaries-relate-to-activity-plans","title":"How travel diaries relate to activity plans","text":"<p>A key component of this project is the conversion of Travel Diaries to Activity Plans. We define a Travel Diary as a sequence of travel legs from zone to zone for a given purpose over a single day. The Activity Plan takes these legs and infers the activity types between. Example activity types are <code>home</code>, <code>work</code>, <code>education</code>, <code>escort_education</code> and so on.</p> <p>Activity Plan chains can be pretty complex, consider for example a business person attending meetings in many different locations and stopping to eat and shop. We always require the plan to last 24 hours and start and stop with an activity. We like these start and stop activities to both be the same and ideally <code>home</code>. We think of this as 'looping', but they don't have to. Night shift workers, for example, do not start or end the day at <code>home</code>.</p> <p>When we try to infer activity purpose from trip purpose, we expect a return trip to have the same purpose as the outbound trip, e.g.:</p> <p>trip1(work) + trip2(work) --&gt; activity1(home) + activity2(work) + activity3(home)</p> <p>But this logic is hard to follow for more complex chains, eg:</p> <p>trip1(work) + trip2(shop) + trip3(work) --&gt; activity1(home) + activity2(work) + activity3(shop) + activity4(home)</p> <p>The test cases in <code>test_3_parse_challenge</code> capture some of the difficult and edge cases observed so far.</p> <p>It is important to note that as a consequence of encoding outbound and return purpose as an activity, we never observe a trip purpose as <code>home</code>. Luckily we do know the home area from the travel diary data (<code>hzone</code>). But have to be careful with our logic, as travel between different activities locations can be intra-zonal, e.g.:</p> <p>activity1(home, zoneA) + activity2(shop, zoneA) + activity2(shop, zoneA)</p> <p>Activity Plans are represented in this project as regular python <code>lists()</code>, containing ordered <code>activity.Activity</code> and <code>activity.Leg</code> objects. Plans must start and end with a <code>activity.Activity</code>. Two <code>activity.Actvity</code> objects must be separated by a <code>core.Leg</code>.</p> <p>Plans belong to <code>core.People</code> which belong to <code>core.Households</code> which belong to a <code>core.Population</code>. For example:</p> <pre><code>from pam.core import Population, Household, Person\nfrom pam.activity import Activity, Leg\npopulation = Population()  # init\nhousehold = Household(hid=1)  # hid is household id\nperson = Person(pid=1)  # pid is person id\nperson.add(\nActivity(seq=1, act='home', area='a', start_time=0, end_time=450)  # time in minutes\n)\nperson.add(\nLeg(seq=1, mode='car', start_area='a', end_area='b', start_time=450, end_time=480)\n)\nperson.add(\nActivity(2, 'work', 'b', 480, 880)\n)\nperson.add(\nLeg(2, 'car', 'b', 'a', 880, 900)\n)\nperson.add(\nActivity(3, 'home', 'a', 900, 24*60-1)  # last activity must end at 23:59(:59)\n)\nhousehold.add(person)\npopulation.add(household)\n</code></pre>"},{"location":"activity_plans/#a-note-on-the-pain-of-wrapping","title":"A note on the pain of wrapping","text":"<p>Activity Plans often enforce that a plan returns to the same activity (type and location) that they started at. Furthermore they sometimes enforce that this activity be <code>home</code>. Such plans can be thought of as wrapping plans. Where the last and first activity can be though of as linked. This need not be a <code>home</code> activity, for example in the case of night workers.</p> <p>We have encountered many variations of sequences for plans, including wrapping and wrapping. Although they are generally edge cases, they exists and generally represent real people. We are therefore endeavoring to support all these cases in our plan modifiers. This is resulting some difficult to follow logic (eg <code>pam.activity.Plan.fill_plan()</code>).</p>"},{"location":"activity_plans/#plan-cropping","title":"Plan cropping","text":"<p>The <code>pam.cropping</code> module allows to spatially subset populations, by simplifying plan components that take place outside the \"core\" area. Any activities or legs that do not affect that core area are removed from the agents' plans, and agents with fully-external plans are removed from the population. Examples of using the module can be found in the <code>18_plan_cropping.ipynb</code> notebook.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#setting-up-a-user-environment","title":"Setting up a user environment","text":"<p>As a PAM user, it is easiest to install PAM using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Download (a.k.a., clone) the PAM repository: <code>git clone git@github.com:arup-group/pam.git</code></li> <li>Change into the <code>pam</code> directory: <code>cd pam</code></li> <li>Create the PAM mamba environment: <code>mamba create -n pam -c conda-forge -c city-modelling-lab --file requirements/base.txt</code></li> <li>Activate the PAM mamba environment: <code>mamba activate pam</code></li> <li>Install the PAM package into the environment, ignoring dependencies (we have dealt with those when creating the mamba environment): <code>pip install --no-deps .</code></li> </ol> <p>All together:</p> <pre><code>git clone git@github.com:arup-group/pam.git\ncd pam\nmamba create -n pam -c conda-forge -c city-modelling-lab --file requirements/base.txt\nmamba activate pam\npip install --no-deps .\n</code></pre> <p>We do not recommend trying to install PAM directly with pip (e.g. in a virtual environment) as you need to first install underlying native geospatial libraries, the method for which differs by operating system. If you choose to install into a virtual environment, ensure you have <code>libgdal</code> and <code>libspatialindex</code> installed on your device before installing with pip. </p>"},{"location":"installation/#running-the-example-notebooks","title":"Running the example notebooks","text":"<p>If you have followed the non-developer installation instructions above, you will need to install <code>jupyter</code> into your <code>pam</code> environment to run the example notebooks:</p> <pre><code>mamba install -n pam jupyter\n</code></pre> <p>With Jupyter installed, it's easiest to then add the environment as a jupyter kernel: </p> <pre><code>mamba activate pam\nipython kernel install --user --name=pam\njupyter notebook\n</code></pre>"},{"location":"installation/#choosing-a-different-environment-name","title":"Choosing a different environment name","text":"<p>If you would like to use a different name to <code>pam</code> for your mamba environment, the installation becomes (where <code>[my-env-name]</code> is your preferred name for the environment):</p> <pre><code>mamba create -n [my-env-name] -c conda-forge -c city-modelling-lab --file requirements/base.txt\nmamba activate [my-env-name]\nipython kernel install --user --name=[my-env-name]\n</code></pre>"},{"location":"installation/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>The install instructions are slightly different to create a development environment compared to a user environment:</p> <pre><code>git clone git@github.com:arup-group/pam.git\ncd pam\nmamba create -n pam -c conda-forge -c city-modelling-lab --file requirements/base.txt --file requirements/dev.txt\nmamba activate pam\npip install --no-deps -e .\n</code></pre> <p>For more detailed installation instructions specific to developing the PAM codebase, see our development documentation.</p>"},{"location":"modelling_policy_impact/","title":"Modelling the impact of policies on populations","text":"<p>PAM uses policies to model change to a population.  For example, based on social distancing requirements we might want to reflect that people are expected to make less shared shopping trips or tours.  We can do this using the following policy, if you want to define the policy from first principles:</p> <pre><code>policy_reduce_shopping_activities = HouseholdPolicy(\nReduceSharedActivity(['shop', 'shop_food']),\nActivityProbability(['shop', 'shop_food'], 1)\n)\n</code></pre> <p>There exists a convenience class for this policy and an equivalent policy can be defined in the following way:</p> <pre><code>policy_reduce_shopping_activities = ReduceSharedHouseholdActivities(\n['shop', 'shop_food'],\nActivityProbability(['shop', 'shop_food'], 1)\n)\n</code></pre> <p>This policy removes all but one the household's shared shopping tours:</p> <p></p> <p>In general, a policy is defined in the following way:</p> <ol> <li>You first select the level at which is should be applied:<ul> <li><code>HouseholdPolicy</code></li> <li><code>PersonPolicy</code></li> <li><code>ActivityPolicy</code></li> </ul> </li> <li>You then select the modifier, which performs the actions to a person's activities<ul> <li><code>RemoveActivity</code></li> <li><code>ReduceSharedActivity</code></li> <li><code>MoveActivityTourToHomeLocation</code></li> </ul> </li> <li> <p>Finally, you give a likelihood value with which the policy should be applied with.      You have a few choices here:</p> <ul> <li> <p>a number greater than 0 and less or equal to 1.  This will be understood to be at the level at which the policy is applied. E.g. <code>PersonPolicy(RemoveActivity(['work']), 0.5)</code> will give each person a fifty-fifty chance of having their work activities removed.</p> </li> <li> <p>you can explicitly define at which level a number greater than 0 and less or equal to 1 will be applied. E.g. <code>HouseholdPolicy(RemoveActivity(['work']), PersonProbability(0.5))</code> will apply a probability of 0.5 per person in a household, and apply the policy to all persons within a household if selected.</p> </li> <li> <p>you can also pass a function that operates on a <code>core.Household</code>, <code>core.Person</code> or <code>core.Activity</code> object and returns a number between 0 and 1. E.g. if our function is: <pre><code>def sampler(person):\nif person.attributes['key_worker'] == True:\nreturn 0\nelse:\nreturn 1\n</code></pre> we can define <code>PersonPolicy(RemoveActivity(['work']), PersonProbability(sampler))</code> which will remove all work activities from anyone who is not a 'key_worker'</p> </li> <li> <p>you can choose from:</p> <ul> <li><code>HouseholdProbability</code></li> <li><code>PersonProbability</code></li> <li><code>ActivityProbability</code></li> </ul> </li> </ul> </li> </ol> <p>PAM allows multiple of such policies to be combined to build realistic and complex scenarios. Leveraging activity plans means that PAM can implement detailed policies that are dependent on:</p> <ul> <li>person attributes</li> <li>household attributes</li> <li>activity types</li> <li>travel modes</li> <li>times</li> <li>spatial locations</li> <li>sequences such as tours</li> <li>any combination of the above</li> </ul> <p>A full overview of policies and examples of the policies available are detailed in this example.</p>"},{"location":"modelling_policy_impact/#example-modifierspolicies","title":"Example modifiers/policies:","text":""},{"location":"modelling_policy_impact/#ill-and-self-quarantined","title":"Ill and self-quarantined","text":"<ul> <li>Person quarantine based on age</li> <li>Household quarantine based on household members</li> </ul>"},{"location":"modelling_policy_impact/#education-activities","title":"Education activities","text":"<p>Remove or reduce education based tours/trips including escorts:</p> <ul> <li>Remove education activities based on age</li> <li>Maintain education for 'care-constrained' households (critical workers)</li> </ul>"},{"location":"modelling_policy_impact/#work-activities","title":"Work activities","text":"<ul> <li>Furlough and unemployment based on sector</li> <li>Work from home based on sector</li> <li>Increase or reduce activities and activity durations based on sector</li> </ul>"},{"location":"modelling_policy_impact/#shopping-activities","title":"Shopping activities","text":"<ul> <li>Remove or reduce discretionary shopping</li> <li>Reduce food shopping</li> <li>Remove shared tours</li> <li>Move tours closer to home</li> </ul>"},{"location":"modelling_policy_impact/#discretionary-activities","title":"Discretionary activities","text":"<ul> <li>Remove or reduce discretionary activities such as leisure</li> <li>Move tours closer to home</li> </ul>"},{"location":"modelling_policy_impact/#in-progress-modifierspolicies","title":"In-progress modifiers/policies","text":"<p>Logic also be added to apply:</p> <ul> <li>mode shift</li> <li>location shift</li> <li>times</li> <li>durations</li> </ul>"},{"location":"read_data/","title":"Reading data","text":""},{"location":"read_data/#populations","title":"Populations","text":"<p>We have some read methods for common input data formats - but first let's take a quick look at the core pam data structure for populations:</p> <pre><code>from pam.core import Population, Household, Person\npopulation = Population()  # initialise an empty population\nhousehold = Household('hid0', attributes = {'struct': 'A', 'dogs': 2, ...})\npopulation.add(household)\nperson = Person('pid0', attributes = {'age': 33, 'height': 'tall', ...})\nhousehold.add(person)\nperson = Person('pid1', attributes = {'age': 35, 'cats_or_dogs?': 'dogs', ...})\nhousehold.add(person)\npopulation.print()\n</code></pre>"},{"location":"read_data/#read-methods","title":"Read methods","text":"<p>The first step in any application is to load your data into the core pam format (pam.core.Population). We are trying to support common tabular formats ('travel diaries') using <code>pam.read.load_travel_diary</code>. A travel diary can be composed of three tables:</p> <ul> <li><code>trips</code> (required) -  a trip diary for all people in the population, with rows representing trips</li> <li><code>persons_attributes</code> (optional) - optionally include persons attributes (eg: <code>person income</code>)</li> <li><code>households_attributes</code> (optional) - optionally include households attributes (eg: <code>hh number of cars</code>)</li> </ul> <p>The input tables are expected as pandas.DataFrame, eg: <pre><code>import pandas as pd\nimport pam\ntrips_df = pd.read_csv(trips.csv)\npersons_df = pd.read_csv(persons.csv)\n# Fix headers and wrangle as required\n# ...\npopulation = pam.read.load_travel_diary(\ntrips = trips_df,\npersons_attributes = persons_df,\nhhs_attributes = None,\n)\nprint(population.stats)\nexample_person = population.random_person\nexample_person.print()\nexample_person.plot()\n</code></pre></p> <p>PAM requires tabular inputs to follow a basic structure. Rows in the <code>trips</code> dataframe represent unique trips by all persons, rows in the <code>persons_attributes</code> dataframe represent unique persons and rows in the <code>hhs_attributes</code> dataframe represent unique households. Fields named <code>pid</code> (person ID) and <code>hid</code> (household ID) are used to provide unique identifiers to people and households.</p> <p>Trips Input:</p> <p>eg:</p> pid hid seq hzone ozone dzone purp mode tst tet freq 0 0 0 Harrow Harrow Camden work pt 444 473 4.54 0 0 1 Harrow Camden Harrow home pt 890 919 4.54 1 0 0 Harrow Harrow Tower Hamlets work car 507 528 2.2 1 0 1 Harrow Tower Hamlets Harrow home car 1065 1086 2.2 2 1 0 Islington Islington Hackney shop pt 422 425 12.33 2 1 1 Islington Hackney Hackney leisure walk 485 500 12.33 2 1 2 Islington Croydon Islington home pt 560 580 12.33 <p>A <code>trips</code> table is composed of rows representing unique trips for all persons in the population. Trips must be correctly ordered according to their sequence unless a numeric <code>seq</code> (trip sequence) field is provided, in which case trips will be ordered accordingly for each person.</p> <p>The <code>trips</code> input must include the following fields: - <code>pid</code> - person ID, used as a unique identifier to associate trips belonging to the same person and to join trips with person attributes if provided. - <code>ozone</code> - trip origin zone ID - <code>dzone</code> - trip destination zone ID - <code>mode</code> - trip mode - note that lower case strings are enforced - <code>tst</code> - trip start time in minutes (integer) or a datetime string (eg: \"2020-01-01 14:00:00\") - <code>tet</code> - trip end time in minutes (integer) or a datetime string (eg: \"2020-01-01 14:00:00\")</p> <p>The <code>trips</code> input must either: - <code>purp</code> - trip or tour purpose, eg 'work' - <code>oact</code> and <code>dact</code> - origin activity type and destination activity type, eg 'home' and 'work'</p> <p>Note that lower case strings are enforced and that 'home' activities should be encoded as <code>home</code>.</p> <p>The <code>trips</code> input may also include the following fields: - <code>hid</code> - household ID, used as a unique identifier to associate persons belonging to the same household and to join with household attributes if provided - <code>freq</code> - trip weighting for representative population - <code>seq</code> - trip sequence number, if omitted pam will assume that trips are already ordered - <code>hzone</code> - household zone</p> <p>'trip purpose' vs 'tour purpose':</p> <p>We've encountered a few different ways that trip purpose can be encoded. The preferred way being to encode a trip purpose as being the activity of the destination, so that a trip home would be encoded as <code>purp = home</code>. However we've also seen the more complex 'tour purpose' encoding, in which case a return trip from work to home is encoded as <code>purp = work</code>. Good news is that the <code>pam.read.load_travel_diary</code> will deal ok with either. But it's worth checking.</p> <p>Using persons_attributes and /or households_attributes</p> <p>eg:</p> <p><code>persons.csv</code></p> pid hid hzone freq income age driver cats or dogs 0 0 Harrow 10.47 high high yes dogs 1 0 Harrow 0.034 low medium no dogs 2 1 Islington 8.9 medium low yes dogs <p><code>households.csv</code></p> hid hzone freq persons cars 0 Harrow 10.47 2 1 1 Islington 0.034 1 1 <p>If you are using persons_attributes (<code>persons_attributes</code>) this table must contain a <code>pid</code> field (person ID). If you are using persons_attributes (<code>households_attributes</code>) this table must contain a <code>hid</code> field (household ID). In both cases, the frequency field <code>freq</code> may be used. All other attributes can be included with column names to suit the attribute. Note that <code>hzone</code> (home zone) can optionally be provided in the attribute tables.</p> <p>A note about 'freq':</p> <p>Frequencies (aka 'weights') for trips, persons or households can optionally be added to the respective input tables using columns called <code>freq</code>. We generally assume a frequency to represent expected occurrences in a full population. For example if we use a person frequency (<code>person.freq</code>) the the sum of all these frequencies (<code>population.size</code>), will equal the expected population size.</p> <p>Because it is quite common to provide a person or household <code>freq</code> in the trips table, there are two special options (<code>trip_freq_as_person_freq = True</code> and <code>trip_freq_as_hh_freq = True</code>) that can be used to pass the <code>freq</code> field from the trips table to either the people or households table instead.</p> <p>Generally PAM will assume when you want some weighted output, that it should use household frequencies. If these have not been set then PAM will assume that the household frequency is the average frequency of persons within the household. If person frequencies are not set the PAM will assume that the person frequency is the average frequency of legs within the persons plan. If you wish to adjust frequencies of a population then you should use the <code>set_freq()</code> method, eg:</p> <pre><code>factor = 1.2\nhousehold.set_freq(household.freq * factor)\nfor pid, person in household:\nperson.set_freq(person.freq * factor)\n</code></pre>"},{"location":"read_data/#readwriteother-formats","title":"Read/Write/Other formats","text":"<p>PAM can read/write to tabular formats and MATSim xml (<code>pam.read.read_matsim</code> and <code>pam.write.write_matsim</code>). PAM can also write to segmented OD matrices using <code>pam.write.write_od_matrices</code>.</p> <p>Benchmark or summary data and cross-tabulations can be extracted with the <code>pam.write.write_benchmarks</code> method, passing as arguments the data field(s) to summarise, the dimension(s) to group by, and the aggregation function(s). For example <code>pam.write_benchmarks(population, dimensions = ['duration_category'], data_fields= ['freq'], aggfunc = [sum]</code> returns the frequency breakdown of trips' duration. The <code>write</code> module also provides a number of wrappers for frequently-used benchmarks under the <code>write_*****_benchmark</code> name.</p> <p>Please get in touch if you would like additional support or feel free to add your own.</p>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"api/cli/#examples","title":"Examples","text":"<ul> <li>to get a summary or a MATSim plans file: <code>pam report summary tests/test_data/test_matsim_plansv12.xml</code>.</li> <li>plan cropping: <code>pam crop &lt;path_population_xml&gt; &lt;path_core_area_geojson&gt; &lt;path_output_directory&gt;</code>.</li> <li>down/up-sampling an xml population: <code>pam sample &lt;path_population_xml&gt; &lt;path_output_directory&gt; -s &lt;sample_percentage&gt; -v &lt;matsim_version&gt;</code>. For example, you can use: <code>pam sample tests/test_data/test_matsim_plansv12.xml tests/test_data/output/sampled -s 0.1</code> to create a downsampled (to 10%) version of the input (<code>test_matsim_plansv12.xml</code>) population.</li> <li>combining populations: <code>pam combine &lt;input_population_1&gt; &lt;input_population_2&gt; &lt;input_population_3...etc&gt; -o &lt;outpath_directory&gt; -m &lt;comment&gt; -v &lt;matsim_version&gt;</code>.</li> </ul>"},{"location":"api/cli/#pam","title":"pam","text":"<p>Population Activity Modeller (PAM) Command Line Tool.</p> <p>Usage:</p> <pre><code>pam [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-combine","title":"pam combine","text":"<p>Combine multiple populations (e.g. household, freight.. etc).</p> <p>Usage:</p> <pre><code>pam combine [OPTIONS] [POPULATION_PATHS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--population_output</code>, <code>-o</code> path Specify outpath for combined_population.xml, default is cwd <code>combined_population.xml</code> <code>--force</code>, <code>-f</code> boolean Forces overwrite of existing file. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-crop","title":"pam crop","text":"<p>Crop a population's plans outside a core area.</p> <p>Usage:</p> <pre><code>pam crop [OPTIONS] PATH_POPULATION_INPUT PATH_BOUNDARY DIR_POPULATION_OUTPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--buffer</code>, <code>-b</code> integer A buffer distance to (optionally) apply to the core area shapefile. <code>0</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report","title":"pam report","text":"<p>Various reporting for MATSim formatted plans.</p> <p>Usage:</p> <pre><code>pam report [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report-benchmarks","title":"pam report benchmarks","text":"<p>Write batch of benchmarks to directory.</p> <p>Usage:</p> <pre><code>pam report benchmarks [OPTIONS] POPULATION_INPUT_PATH OUTPUT_DIRECTORY\n</code></pre> <p>Options:</p> Name Type Description Default <code>--sample_size</code>, <code>-s</code> float Input sample size. Default 1. Required for downsampled populations. eg, use 0.1 for a 10% input population. <code>1</code> <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report-stringify","title":"pam report stringify","text":"<p>ASCII plot activity plans to terminal.</p> <p>Usage:</p> <pre><code>pam report stringify [OPTIONS] PATH_POPULATION_INPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>--colour</code> / <code>--bw</code> boolean Choose a colour or grey-scale (bw) output, default 'colour' <code>True</code> <code>--width</code>, <code>-w</code> integer Target character width for plot, default 72 <code>72</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to crop. <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report-summary","title":"pam report summary","text":"<p>Summarise a population.</p> <p>Usage:</p> <pre><code>pam report summary [OPTIONS] PATH_POPULATION_INPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--sample_size</code>, <code>-s</code> float Input sample size. Default 1. For example, use 0.1 to apply a 10% weighting to the input population. <code>1</code> <code>--attribute_key</code>, <code>-k</code> text Optional population attribute key to segment output, eg 'subpopulation'. None <code>--rich</code> / <code>--text</code> boolean Formatted (for terminal) or regular text output (for .txt). <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-sample","title":"pam sample","text":"<p>Down- or up-sample a PAM population.</p> <p>Usage:</p> <pre><code>pam sample [OPTIONS] PATH_POPULATION_INPUT DIR_POPULATION_OUTPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--sample_size</code>, <code>-s</code> text The sample size, eg, use 0.1 to produce a 10% version of the input population. None <code>--household_key</code>, <code>-h</code> text Household key, defaults to 'hid'. <code>hid</code> <code>--seed</code> text Random seed. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-wipe-all-links","title":"pam wipe-all-links","text":"<p>Clear all link information from agent plans. Including routes and activity locations.</p> <p>Usage:</p> <pre><code>pam wipe-all-links [OPTIONS] PATH_POPULATION_INPUT PATH_POPULATION_OUTPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-wipe-links","title":"pam wipe-links","text":"<p>Clear selected link information from agent plans. Includes routes and activity locations.</p> <p>eg: <code>pam wipe-links INPUT_PLANS.xml OUTPUT_PLANS.xml link_a link_b link_c</code></p> <p>Usage:</p> <pre><code>pam wipe-links [OPTIONS] PATH_POPULATION_INPUT PATH_POPULATION_OUTPUT\n               [LINKS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"contributing/","title":"Contributing","text":"<p>PAM is an actively maintained and utilised project.  Our goals are to enhance:</p> <ul> <li>Theoretical Quality: Expert driven features with research and open case studies.</li> <li>Feature Quality: Broadly useful and extendable features with good documentation and testing.</li> </ul> <p>Less abstractly, there are a good number of coding and non-coding tasks that you can contribute to.</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>to report issues, request features, or exchange with our community, just follow the links below.</p> <p>Is something not working?</p> <p> Report a bug</p> <p>Missing information in our docs?</p> <p> Report a docs issue</p> <p>Want to submit an idea?</p> <p> Request a change</p> <p>Have a question or need help?</p> <p> Ask a question</p>"},{"location":"contributing/coding/","title":"Coding contributions","text":"<p>To find beginner-friendly existing bugs and feature requests you may like to start out with, take a look at our good first issues.</p> <p>We need help to go faster as we would like to deal with populations in the tens of millions. This means we would like help with profiling and implementing parallel compute, in particular.</p>"},{"location":"contributing/coding/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>To create a development environment for PAM, with all libraries required for development and quality assurance installed, it is easiest to install PAM using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Download (a.k.a., clone) the PAM repository: <code>git clone git@github.com:arup-group/pam.git</code></li> <li>Change into the <code>pam</code> directory: <code>cd pam</code></li> <li>Create the PAM mamba environment: <code>mamba create -n pam -c conda-forge -c city-modelling-lab --file requirements/base.txt --file requirements/dev.txt</code></li> <li>Activate the PAM mamba environment: <code>mamba activate pam</code></li> <li>Install the PAM package into the environment, in editable mode and ignoring dependencies (we have dealt with those when creating the mamba environment): <code>pip install --no-deps -e .</code></li> </ol> <p>All together:</p> <pre><code>git clone git@github.com:arup-group/pam.git\ncd pam\nmamba create -n pam -c conda-forge -c city-modelling-lab --file requirements/base.txt --file requirements/dev.txt\nmamba activate pam\npip install --no-deps -e .\n</code></pre> <p>If installing directly with pip, you can install these libraries using the <code>dev</code> option, i.e., <code>pip install -e '.[dev]'</code> Either way, you should add your environment as a jupyter kernel, so the example notebooks can run in the tests: <code>ipython kernel install --user --name=pam</code></p> <p>If you plan to make changes to the code then please make regular use of the following tools to verify the codebase while you work:</p> <ul> <li><code>pre-commit</code>: run <code>pre-commit install</code> in your command line to load inbuilt checks that will run every time you commit your changes. The checks are: 1. check no large files have been staged, 2. lint python files for major errors, 3. format python files to conform with the PEP8 standard. You can also run these checks yourself at any time to ensure staged changes are clean by calling <code>pre-commit</code>.</li> <li><code>pytest</code> - run the unit test suite, check test coverage, and test that the example notebooks successfully run.</li> </ul> <p>Note</p> <p>If you already have an environment called <code>pam</code> on your system (e.g., for a stable installation of the package), you will need to chose a different environment name. You will then need to add this as a pytest argument when running the tests: <code>pytest --nbmake-kernel=[my-env-name]</code>.</p>"},{"location":"contributing/coding/#rapid-fire-testing","title":"Rapid-fire testing","text":"<p>The following options allow you to strip down the test suite to the bare essentials:</p> <ol> <li>The test suite includes unit tests and integration tests (in the form of jupyter notebooks found in the <code>examples</code> directory). The integration tests can be slow, so if you want to avoid them during development, you should run <code>pytest tests/</code>.</li> <li>You can avoid generating coverage reports, by adding the <code>--no-cov</code> argument: <code>pytest --no-cov</code>.</li> <li>By default, the tests run with up to two parallel threads, to increase this to e.g. 4 threads: <code>pytest -n4</code>.</li> </ol> <p>All together:</p> <pre><code>pytest tests/ --no-cov -n4\n</code></pre> <p>Note</p> <p>You cannot debug failing tests and have your tests run in parallel, you will need to set <code>-n0</code> if using the <code>--pdb</code> flag</p>"},{"location":"contributing/coding/#memory-profiling","title":"Memory profiling","text":"<p>Note</p> <p>When you open a pull request (PR), one of the GitHub actions will run memory profiling for you. This means you don't have to do any profiling locally. However, if you can, it is still good practice to do so as you will catch issues earlier.</p> <p>PAM can be memory intensive; we like to ensure that any development to the core code does not exacerbate this. If you are running on a UNIX device (i.e., not on Windows), you can test whether any changes you have made adversely impact memory and time performance as follows:</p> <ol> <li>Install memray in your <code>pam</code> mamba environment: <code>mamba install memray pytest-memray</code>.</li> <li>Run the memory profiling integration test: <code>pytest -p memray -m \"high_mem\" --no-cov</code>.</li> <li>Optionally, to visualise the memory allocation, run <code>pytest -p memray -m \"high_mem\" --no-cov --memray-bin-path=[my_path] --memray-bin-prefix=[my_prefix]</code> - where you must define <code>[my_path]</code> and <code>[my_prefix]</code> - followed by <code>memray flamegraph [my_path]/[my_prefix]-tests-test_100_memory_profiling.py-test_activity_loader.bin</code>. You will then find the HTML report at <code>[my_path]/memray-flamegraph-[my_prefix]-tests-test_100_memory_profiling.py-test_activity_loader.html</code>.</li> </ol> <p>All together:</p> <pre><code>mamba install memray pytest-memray\npytest -p memray -m \"high_mem\" --no-cov --memray-bin-path=[my_path] --memray-bin-prefix=[my_prefix]\nmemray flamegraph [my_path]/[my_prefix]-tests-test_100_memory_profiling.py-test_activity_loader.bin\n</code></pre> <p>For more information on using memray, refer to their documentation.</p>"},{"location":"contributing/coding/#submitting-changes","title":"Submitting changes","text":"<p>To contribute changes:</p> <ol> <li>Fork the project on GitHub.</li> <li>Create a feature branch to work on in your fork (<code>git checkout -b new-fix-or-feature</code>).</li> <li>Test your changes using <code>pytest</code>.</li> <li>Commit your changes to the feature branch (you should have <code>pre-commit</code> installed to ensure your code is correctly formatted when you commit changes).</li> <li>Push the branch to GitHub (<code>git push origin new-fix-or-feature</code>).</li> <li>On GitHub, create a new pull request from the feature branch.</li> </ol>"},{"location":"contributing/coding/#pull-requests","title":"Pull requests","text":"<p>Before submitting a pull request, check whether you have:</p> <ul> <li>Added your changes to <code>CHANGELOG.md</code>.</li> <li>Added or updated documentation for your changes.</li> <li>Added tests if you implemented new functionality.</li> </ul> <p>When opening a pull request, please provide a clear summary of your changes!</p>"},{"location":"contributing/coding/#commit-messages","title":"Commit messages","text":"<p>Please try to write clear commit messages. One-line messages are fine for small changes, but bigger changes should look like this:</p> <pre><code>A brief summary of the commit (max 50 characters)\n\nA paragraph or bullet-point list describing what changed and its impact,\ncovering as many lines as needed.\n</code></pre>"},{"location":"contributing/coding/#code-conventions","title":"Code conventions","text":"<p>Start reading our code and you'll get the hang of it.</p> <p>We mostly follow the official Style Guide for Python Code (PEP8).</p> <p>We have chosen to use the uncompromising code formatter <code>black</code> and the linter <code>ruff</code>. When run from the root directory of this repo, <code>pyproject.toml</code> should ensure that formatting and linting fixes are in line with our custom preferences (e.g., 100 character maximum line length). The philosophy behind using <code>black</code> is to have uniform style throughout the project dictated by code. Since <code>black</code> is designed to minimise diffs, and make patches more human readable, this also makes code reviews more efficient. To make this a smooth experience, you should run <code>pre-commit install</code> after setting up your development environment, so that <code>black</code> makes all the necessary fixes to your code each time you commit, and so that <code>ruff</code> will highlight any errors in your code. If you prefer, you can also set up your IDE to run these two tools whenever you save your files, and to have <code>ruff</code> highlight erroneous code directly as you type. Take a look at their documentation for more information on configuring this.</p> <p>We require all new contributions to have docstrings for all modules, classes and methods. When adding docstrings, we request you use the Google docstring style.</p>"},{"location":"contributing/coding/#release-checklist","title":"Release checklist","text":""},{"location":"contributing/coding/#pre-release","title":"Pre-release","text":"<ul> <li> Re-run tutorial Jupyter notebooks (<code>pytest examples/ --overwrite</code>).</li> <li> Make sure documentation builds without errors (<code>mike deploy [version]</code>, where <code>[version]</code> is the current minor release of the form <code>X.Y</code>).</li> <li> Make sure the changelog is up-to-date, especially that new features and backward incompatible changes are clearly marked.</li> </ul>"},{"location":"contributing/coding/#create-release","title":"Create release","text":"<ul> <li> Bump the version number in <code>pyproject.toml</code></li> <li> Update the changelog with final version number of the form <code>vX.Y.Z</code>, release date, and github <code>compare</code> link (at the bottom of the page).</li> <li> Commit with message <code>Release vX.Y.Z</code>, then add a <code>vX.Y.Z</code> tag.</li> <li> Create a release pull request to verify that the conda package builds successfully.</li> <li> Once the PR is approved and merged, create a release through the GitHub web interface, using the same tag, titling it <code>Release vX.Y.Z</code> and include all the changelog elements that are not flagged as internal.</li> </ul>"},{"location":"contributing/coding/#post-release","title":"Post-release","text":"<ul> <li> Update the changelog, adding a new <code>[Unreleased]</code> heading.</li> <li> Update <code>pyproject.toml</code> to the next version appended with <code>.dev0</code>, in preparation for the next main commit.</li> </ul>"},{"location":"contributing/non_coding/","title":"Non-coding contributions","text":""},{"location":"contributing/non_coding/#literature-review","title":"Literature review","text":"<p>We still need validation of the overall approach. Much of the methodology (detailed in this document) is based on what can pragmatically be done, not what theoretically should be done. We'd appreciate links to relevant papers. Or even better we'd love a lit review - we'll add it to this document.</p>"},{"location":"contributing/non_coding/#research","title":"Research","text":"<p>We need help with designing useful features, applying them to real problems. As part of this we need:</p>"},{"location":"contributing/non_coding/#evidence-and-data-for-validation","title":"Evidence and data for validation","text":"<p>We know, for example, that many people have removed certain activities from their daily plans, such as to school or university. But we don't know how many. We'd like help finding and eventually applying validation data such as recent change in mobility.</p>"},{"location":"contributing/non_coding/#evidence-for-new-features","title":"Evidence for new features","text":"<p>We currently support the following activity plan modifications:</p> <ul> <li>probabilistic removal of all activities, i.e., full quarantine or isolation</li> <li>probabilistic removal of specific activities, i.e., education</li> <li>automatic extension of other (typically staying at home) activities</li> </ul> <p>But we'd like help to find evidence for other modifications that we think are occurring:</p> <ul> <li>changing duration of an activity</li> <li>moving activity closer to home, i.e., shopping trips</li> <li>changing travel choice, i.e., mode</li> <li>moving home location (i.e., national and local emigration)</li> <li>household shared activities/no longer shared activities, such as leisure</li> <li>defining key workers</li> </ul>"},{"location":"contributing/non_coding/#evidence-for-technical-methodology","title":"Evidence for technical methodology","text":"<p>Modifying a plan to remove an activity can cascade into other changes. In the case of people with complex chains of activities, the removal of a single activity requires adjustments to the remainder. Do people leave later of earlier if they have more time for example? The methods for this logic is in [pam.core].People.</p>"},{"location":"overrides/","title":"Index","text":"<p>Directory to customise the mkdocs \"material\" theme. See here for more detail.</p>"},{"location":"examples/06_travel_plots/","title":"Plot Activity Plan Travel","text":"In\u00a0[1]: Copied! <pre>import os\n\nfrom pam import read\n</pre> import os  from pam import read In\u00a0[2]: Copied! <pre>pop = read.read_matsim(\n    os.path.join(\"data\", \"example_data\", \"example_plans.xml\")\n)  # load small sample from the test suite\n</pre> pop = read.read_matsim(     os.path.join(\"data\", \"example_data\", \"example_plans.xml\") )  # load small sample from the test suite <p>You can generate <code>geopandas.GeoDataFrames</code> for <code>Population</code>'s, <code>Household</code>'s or <code>Person</code>'s travel. the <code>route_id</code>, <code>service_id</code> and <code>network_route</code> refer to the network used for running the simulation. <code>GeoDataFrame</code>s are very useful, they let you to generate geojsons simply and quickly, which you can then load up in kepler.</p> <pre><code>gdf.to_file('path/to/file/gdf.geojson'), driver='GeoJSON')\n</code></pre> <p>note that to use this geojson with kepler you will need the geometry to be in <code>'epsg:4326'</code>. You can do this with the method below.</p> In\u00a0[3]: Copied! <pre>pop.build_travel_geodataframe(from_epsg=\"epsg:27700\", to_epsg=\"epsg:4326\").head()\n</pre> pop.build_travel_geodataframe(from_epsg=\"epsg:27700\", to_epsg=\"epsg:4326\").head() Out[3]: mode purp seq freq start_time end_time start_location end_location geometry distance service_id route_id o_stop d_stop network_route pid hid 0 pt work 1 None 1900-01-01 07:24:52 1900-01-01 07:24:52 (515226.0, 188222.0) (529652.0, 183897.0) LINESTRING (-0.33840 51.58109, -0.13191 51.53909) 15060.381834 None None None None [] census_0 census_0 1 pt None 2 None 1900-01-01 14:50:52 1900-01-01 14:50:52 (529652.0, 183897.0) (515226.0, 188222.0) LINESTRING (-0.13191 51.53909, -0.33840 51.58109) 15060.381834 None None None None [] census_0 census_0 2 pt work 1 None 1900-01-01 08:27:33 1900-01-01 08:27:33 (542920.0, 174494.0) (534457.0, 181724.0) LINESTRING (0.05547 51.45140, -0.06349 51.51844) 11130.825172 None None None None [] census_1 census_1 3 pt None 2 None 1900-01-01 17:45:33 1900-01-01 17:45:33 (534457.0, 181724.0) (542920.0, 174494.0) LINESTRING (-0.06349 51.51844, 0.05547 51.45140) 11130.825172 None None None None [] census_1 census_1 4 pt work 1 None 1900-01-01 07:01:09 1900-01-01 07:01:09 (535063.0, 163365.0) (531998.0, 166080.0) LINESTRING (-0.06176 51.35331, -0.10474 51.37843) 4094.563469 None None None None [] census_10 census_10 <p>You can also plot travel using plotly. You will need a mapbox token, which you can get here: https://docs.mapbox.com/help/how-mapbox-works/access-tokens/. Be careful not to commit your token in the repo.</p> In\u00a0[4]: Copied! <pre>mapbox_access_token = \"token\"\n</pre> mapbox_access_token = \"token\" <p>You need to specify the coordinate system to plot it on a map. By default the plot will colour by mode:</p> pop.plot_travel_plotly(     epsg='epsg:27700',      mapbox_access_token=mapbox_access_token )  <p></p> <p>You can also colour by any column you see in the <code>GeoDataFrame</code> (see above). E.g. to colour by agent id (<code>pid</code>)</p> pop.plot_travel_plotly(     epsg='epsg:27700',     mapbox_access_token=mapbox_access_token,      colour_by='pid' )  <p></p>"},{"location":"examples/06_travel_plots/#plot-activity-plan-travel","title":"Plot Activity Plan Travel\u00b6","text":"<p>In this example, we show how plans can be plotted spatially using <code>plotly</code></p>"},{"location":"examples/01_basics/","title":"PAM Basics","text":"<p>This notebook demonstrates the core mechanics of PAM by creating a demonstration population.</p> In\u00a0[1]: Copied! <pre>from pam.core import Household, Person, Population\n</pre> from pam.core import Household, Person, Population In\u00a0[2]: Copied! <pre>population = Population()  # initialise an empty population\nhousehold = Household(hid=0)\nperson = Person(pid=0, attributes={\"income\": \"medium\"})\n\nhousehold.add(person)\npopulation.add(household)\n\npopulation.stats\n</pre> population = Population()  # initialise an empty population household = Household(hid=0) person = Person(pid=0, attributes={\"income\": \"medium\"})  household.add(person) population.add(household)  population.stats Out[2]: <pre>{'num_households': 1, 'num_people': 1, 'num_activities': 0, 'num_legs': 0}</pre> In\u00a0[3]: Copied! <pre># If you are not modelling household, the above is equivalent to:\npopulation = Population()\npopulation.add(Person(pid=0, attributes={\"income\": \"medium\"}))\npopulation.stats\n# In this case a unique household is created for the person with the same id.\n</pre> # If you are not modelling household, the above is equivalent to: population = Population() population.add(Person(pid=0, attributes={\"income\": \"medium\"})) population.stats # In this case a unique household is created for the person with the same id. Out[3]: <pre>{'num_households': 1, 'num_people': 1, 'num_activities': 0, 'num_legs': 0}</pre> In\u00a0[4]: Copied! <pre>from pam.activity import Activity, Trip\nfrom pam.utils import minutes_to_datetime as mtdt\n</pre> from pam.activity import Activity, Trip from pam.utils import minutes_to_datetime as mtdt In\u00a0[5]: Copied! <pre>activity = Activity(act=\"home\", area=\"A\", start_time=mtdt(0), end_time=mtdt(445))\ntrip = Trip(mode=\"car\", start_area=\"A\", end_area=\"B\", start_time=mtdt(445), end_time=mtdt(505))\nprint(activity)\nprint(trip)\n</pre> activity = Activity(act=\"home\", area=\"A\", start_time=mtdt(0), end_time=mtdt(445)) trip = Trip(mode=\"car\", start_area=\"A\", end_area=\"B\", start_time=mtdt(445), end_time=mtdt(505)) print(activity) print(trip) <pre>Activity(act:home, location:A, time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\nLeg(mode:car, area:A --&gt; B, time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n</pre> <p>Activities and Trips can be added to a Person object using <code>Person.add</code>:</p> In\u00a0[6]: Copied! <pre>person = Person(pid=0, attributes={\"type\": \"example\"})\n\nperson.add(Activity(act=\"home\", area=\"A\", start_time=mtdt(0), end_time=mtdt(445)))\nperson.add(Trip(mode=\"car\", start_area=\"A\", end_area=\"B\", start_time=mtdt(445), end_time=mtdt(505)))\nperson.add(Activity(act=\"hotel\", area=\"B\", start_time=mtdt(505), end_time=mtdt(1000)))\n\nperson.validate()  # the validate method check for consistency in the sequence of locations and times\nperson.print()\n</pre> person = Person(pid=0, attributes={\"type\": \"example\"})  person.add(Activity(act=\"home\", area=\"A\", start_time=mtdt(0), end_time=mtdt(445))) person.add(Trip(mode=\"car\", start_area=\"A\", end_area=\"B\", start_time=mtdt(445), end_time=mtdt(505))) person.add(Activity(act=\"hotel\", area=\"B\", start_time=mtdt(505), end_time=mtdt(1000)))  person.validate()  # the validate method check for consistency in the sequence of locations and times person.print() <pre>Person: 0\n{'type': 'example'}\n0:\tActivity(act:home, location:A, time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\n1:\tLeg(mode:car, area:A --&gt; B, time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n2:\tActivity(act:hotel, location:B, time:08:25:00 --&gt; 16:40:00, duration:8:15:00)\n</pre> In\u00a0[7]: Copied! <pre>person.plot()\n</pre> person.plot() In\u00a0[8]: Copied! <pre>from shapely.geometry import Point\n</pre> from shapely.geometry import Point In\u00a0[9]: Copied! <pre>person = Person(pid=0, attributes={\"type\": \"example\"})\n\nperson.add(\n    Activity(act=\"home\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(445))\n)\nperson.add(\n    Trip(\n        mode=\"car\",\n        start_area=\"A\",\n        end_area=\"B\",\n        start_loc=Point((0, 0)),\n        end_loc=Point((1234, 1234)),\n        start_time=mtdt(445),\n        end_time=mtdt(505),\n    )\n)\nperson.add(Activity(act=\"hotel\", area=\"B\", start_time=mtdt(505), end_time=mtdt(1000)))\n\nperson.validate()  # the validate method check for consistency in the sequence of locations and times\nperson.print()\n</pre> person = Person(pid=0, attributes={\"type\": \"example\"})  person.add(     Activity(act=\"home\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(445)) ) person.add(     Trip(         mode=\"car\",         start_area=\"A\",         end_area=\"B\",         start_loc=Point((0, 0)),         end_loc=Point((1234, 1234)),         start_time=mtdt(445),         end_time=mtdt(505),     ) ) person.add(Activity(act=\"hotel\", area=\"B\", start_time=mtdt(505), end_time=mtdt(1000)))  person.validate()  # the validate method check for consistency in the sequence of locations and times person.print() <pre>Person: 0\n{'type': 'example'}\n0:\tActivity(act:home, location:POINT (0 0), time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\n1:\tLeg(mode:car, area:POINT (0 0) --&gt; POINT (1234 1234), time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n2:\tActivity(act:hotel, location:B, time:08:25:00 --&gt; 16:40:00, duration:8:15:00)\n</pre> In\u00a0[10]: Copied! <pre>population = Population()  # create a new empty population\n</pre> population = Population()  # create a new empty population In\u00a0[11]: Copied! <pre>the_smiths = Household(\"Smiths\")\n\ntom = Person(\"Tom\", attributes={\"age\": \"low\"})\ntammy = Person(\"Tammy\", attributes={\"age\": \"low\"})\nthe_smiths.add([tom, tammy])\n\npopulation.add(the_smiths)  # and add the household to the population\n\ntammy.add(\n    [\n        Activity(act=\"home\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(445)),\n        Trip(\n            mode=\"car\",\n            start_area=\"A\",\n            end_area=\"B\",\n            start_loc=Point((0, 0)),\n            end_loc=Point((1234, 1234)),\n            start_time=mtdt(445),\n            end_time=mtdt(505),\n        ),\n        Activity(\n            act=\"work\", area=\"B\", loc=Point((1233, 1234)), start_time=mtdt(505), end_time=mtdt(990)\n        ),\n        Trip(\n            mode=\"car\",\n            start_area=\"B\",\n            end_area=\"A\",\n            start_loc=Point((1234, 1234)),\n            end_loc=Point((0, 0)),\n            start_time=mtdt(990),\n            end_time=mtdt(1050),\n        ),\n        Activity(\n            act=\"home\",\n            area=\"A\",\n            loc=Point((0, 0)),\n            start_time=mtdt(1050),\n            end_time=mtdt(24 * 60),  # assuming a 24 hour day\n        ),\n    ]\n)\n\ntom.add(\n    [\n        Activity(\n            act=\"home\",\n            area=\"A\",\n            loc=Point((0, 0)),\n            start_time=mtdt(0),\n            end_time=mtdt(24 * 60),  # assuming a 24 hour day\n        )\n    ]\n)\n</pre> the_smiths = Household(\"Smiths\")  tom = Person(\"Tom\", attributes={\"age\": \"low\"}) tammy = Person(\"Tammy\", attributes={\"age\": \"low\"}) the_smiths.add([tom, tammy])  population.add(the_smiths)  # and add the household to the population  tammy.add(     [         Activity(act=\"home\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(445)),         Trip(             mode=\"car\",             start_area=\"A\",             end_area=\"B\",             start_loc=Point((0, 0)),             end_loc=Point((1234, 1234)),             start_time=mtdt(445),             end_time=mtdt(505),         ),         Activity(             act=\"work\", area=\"B\", loc=Point((1233, 1234)), start_time=mtdt(505), end_time=mtdt(990)         ),         Trip(             mode=\"car\",             start_area=\"B\",             end_area=\"A\",             start_loc=Point((1234, 1234)),             end_loc=Point((0, 0)),             start_time=mtdt(990),             end_time=mtdt(1050),         ),         Activity(             act=\"home\",             area=\"A\",             loc=Point((0, 0)),             start_time=mtdt(1050),             end_time=mtdt(24 * 60),  # assuming a 24 hour day         ),     ] )  tom.add(     [         Activity(             act=\"home\",             area=\"A\",             loc=Point((0, 0)),             start_time=mtdt(0),             end_time=mtdt(24 * 60),  # assuming a 24 hour day         )     ] ) In\u00a0[12]: Copied! <pre>the_smiths.plot()\n</pre> the_smiths.plot() In\u00a0[13]: Copied! <pre>milkman = Person(\"milk_bot\", attributes={\"bot\": \"yes\", \"electric vehicle\": \"yes\"})\n\npopulation.add(\n    milkman\n)  # adding a person directly to the population is possible but a household with the same id will be auto generated\n\nmilkman.add(\n    [\n        Activity(act=\"depot\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(300)),\n        Trip(\n            mode=\"car\",\n            start_area=\"A\",\n            end_area=\"A\",\n            start_loc=Point((0, 0)),\n            end_loc=Point((1000, 1000)),\n            start_time=mtdt(300),\n            end_time=mtdt(310),\n        ),\n        Activity(\n            act=\"delivery\",\n            area=\"A\",\n            loc=Point((1000, 1000)),\n            start_time=mtdt(310),\n            end_time=mtdt(320),\n        ),\n        Trip(\n            mode=\"car\",\n            start_area=\"A\",\n            end_area=\"A\",\n            start_loc=Point((1000, 1000)),\n            end_loc=Point((0, 1000)),\n            start_time=mtdt(320),\n            end_time=mtdt(330),\n        ),\n        Activity(\n            act=\"delivery\", area=\"A\", loc=Point((0, 1000)), start_time=mtdt(330), end_time=mtdt(340)\n        ),\n        Trip(\n            mode=\"car\",\n            start_area=\"A\",\n            start_loc=Point((0, 1000)),\n            end_loc=Point((0, 0)),\n            end_area=\"A\",\n            start_time=mtdt(340),\n            end_time=mtdt(350),\n        ),\n        Activity(\n            act=\"depot\",\n            area=\"A\",\n            loc=Point((0, 0)),\n            start_time=mtdt(350),\n            end_time=mtdt(24 * 60),  # assuming a 24 hour day\n        ),\n    ]\n)\n</pre> milkman = Person(\"milk_bot\", attributes={\"bot\": \"yes\", \"electric vehicle\": \"yes\"})  population.add(     milkman )  # adding a person directly to the population is possible but a household with the same id will be auto generated  milkman.add(     [         Activity(act=\"depot\", area=\"A\", loc=Point((0, 0)), start_time=mtdt(0), end_time=mtdt(300)),         Trip(             mode=\"car\",             start_area=\"A\",             end_area=\"A\",             start_loc=Point((0, 0)),             end_loc=Point((1000, 1000)),             start_time=mtdt(300),             end_time=mtdt(310),         ),         Activity(             act=\"delivery\",             area=\"A\",             loc=Point((1000, 1000)),             start_time=mtdt(310),             end_time=mtdt(320),         ),         Trip(             mode=\"car\",             start_area=\"A\",             end_area=\"A\",             start_loc=Point((1000, 1000)),             end_loc=Point((0, 1000)),             start_time=mtdt(320),             end_time=mtdt(330),         ),         Activity(             act=\"delivery\", area=\"A\", loc=Point((0, 1000)), start_time=mtdt(330), end_time=mtdt(340)         ),         Trip(             mode=\"car\",             start_area=\"A\",             start_loc=Point((0, 1000)),             end_loc=Point((0, 0)),             end_area=\"A\",             start_time=mtdt(340),             end_time=mtdt(350),         ),         Activity(             act=\"depot\",             area=\"A\",             loc=Point((0, 0)),             start_time=mtdt(350),             end_time=mtdt(24 * 60),  # assuming a 24 hour day         ),     ] ) In\u00a0[14]: Copied! <pre>milkman.plot()\n</pre> milkman.plot() In\u00a0[15]: Copied! <pre># iterate through households and persons\nfor hid, household in population:\n    household.attributes[\"checked\"] = True\n    for pid, person in household:\n        person.attributes[\"checked\"] = True\n\n# iterate through persons only\nfor hid, pid, person in population.people():\n    person.attributes[\"checked_again\"] = True\n\n# access household directly\npopulation[\"Smiths\"].attributes[\"smiths_check\"] = True\n\n# access person directly\npopulation[\"Smiths\"][\"Tammy\"].attributes[\"tammy_check\"] = True\n\n# access a random household\npopulation.random_household().attributes[\"random_check\"] = True\n\n# access a random person\npopulation.random_person().attributes[\"random_check\"] = True\n</pre> # iterate through households and persons for hid, household in population:     household.attributes[\"checked\"] = True     for pid, person in household:         person.attributes[\"checked\"] = True  # iterate through persons only for hid, pid, person in population.people():     person.attributes[\"checked_again\"] = True  # access household directly population[\"Smiths\"].attributes[\"smiths_check\"] = True  # access person directly population[\"Smiths\"][\"Tammy\"].attributes[\"tammy_check\"] = True  # access a random household population.random_household().attributes[\"random_check\"] = True  # access a random person population.random_person().attributes[\"random_check\"] = True <p>Person plans can be similarly accessed and modified in a variety of ways:</p> In\u00a0[16]: Copied! <pre>from copy import deepcopy\n\nperson = population[\"Smiths\"][\"Tom\"]\n\n# modify a persons plan\nperson.plan = deepcopy(population[\"Smiths\"][\"Tammy\"].plan)\n\n# access plan components via index\nassert person.plan[0].act == \"home\"\n\n# iterate plan components\nfor component in person.plan:\n    print(component)\n\n# iterate plan activities\nfor activity in person.activities:\n    if activity.act == \"work\":\n        activity.act = \"golf\"\n\n# iterate plan legs\nfor leg in person.legs:\n    leg.mode = \"walk\"\n\nperson.plot()\n</pre> from copy import deepcopy  person = population[\"Smiths\"][\"Tom\"]  # modify a persons plan person.plan = deepcopy(population[\"Smiths\"][\"Tammy\"].plan)  # access plan components via index assert person.plan[0].act == \"home\"  # iterate plan components for component in person.plan:     print(component)  # iterate plan activities for activity in person.activities:     if activity.act == \"work\":         activity.act = \"golf\"  # iterate plan legs for leg in person.legs:     leg.mode = \"walk\"  person.plot() <pre>Activity(act:home, location:POINT (0 0), time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\nLeg(mode:car, area:POINT (0 0) --&gt; POINT (1234 1234), time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\nActivity(act:work, location:POINT (1233 1234), time:08:25:00 --&gt; 16:30:00, duration:8:05:00)\nLeg(mode:car, area:POINT (1234 1234) --&gt; POINT (0 0), time:16:30:00 --&gt; 17:30:00, duration:1:00:00)\nActivity(act:home, location:POINT (0 0), time:17:30:00 --&gt; 00:00:00, duration:6:30:00)\n</pre> In\u00a0[17]: Copied! <pre>from pam.write import write_matsim\nfrom pam.write.diary import to_csv\n</pre> from pam.write import write_matsim from pam.write.diary import to_csv In\u00a0[18]: Copied! <pre>to_csv(population=population, dir=\"tmp\")\nwrite_matsim(population=population, plans_path=\"tmp/plans.xml\")\n</pre> to_csv(population=population, dir=\"tmp\") write_matsim(population=population, plans_path=\"tmp/plans.xml\") <pre>Missing person weight in hh Smiths, returning None.\nMissing person weight in hh milk_bot, returning None.\n</pre>"},{"location":"examples/01_basics/#pam-basics","title":"PAM Basics\u00b6","text":""},{"location":"examples/01_basics/#the-core-objects","title":"The Core Objects\u00b6","text":"<p>PAM populations are built from three core objects:</p> <p><code>Population</code>, <code>Household</code> and <code>Person</code> objects. Persons belong to a <code>Household</code> and households belong to a <code>Population</code>. This relationship can be created using the <code>Population.add</code> and <code>Household.add</code> methods.</p> <p>Note that <code>Household</code> and <code>Person</code> objects require unique identifiers. households require a <code>hid</code> (household id) and persons a <code>pid</code> (person id).</p> <p>Households and Persons can also be given attributes as a simple dictionary. Attributes can include useful features such as income or car ownership.</p>"},{"location":"examples/01_basics/#activity-plans-or-sequences","title":"Activity Plans (or \"Sequences\")\u00b6","text":"<p><code>Person</code> activity plans use the <code>pam.activity.Plan</code> object. All Persons have a <code>Plan</code>, even if it is empty. A <code>Plan</code> is simply a sequence of <code>Activity</code> and <code>Trip</code> (or <code>Leg</code> if you prefer - they are equivalent) objects.</p> <p>Plans must start and end with an <code>Activity</code> and the two objects must alternate, for example; <code>Activity(\"home\")</code>, <code>Trip()</code>, <code>Activity(\"work\")</code>, <code>Trip()</code>, <code>Activity(\"home\")</code>.</p> <p>Both Activities and Trips can have start and end times (using datetime objects). Activities have locations whereas Trips have start and end locations. When manually creating your own sequences care should be taken to make these times and locations consistent. Such that, for example, a trip ends when the next activity starts and a trip start is at the same location as the preceding activity.</p> <p>Activities are expected to have a type, for example, <code>'work'</code> or <code>'golf'</code>. Trips are expected to have a mode, for example <code>'car'</code> etc. These examples generally use strings for these features but this is not a requirement.</p>"},{"location":"examples/01_basics/#locations","title":"Locations\u00b6","text":"<p>Pam uses <code>pam.location.Location</code> objects to keep track of <code>Activity</code> and <code>Trip</code> locations.</p> <p>These locations can be any combination of <code>area</code> or <code>loc</code> or <code>link</code>. Area is assumed to be spatial zone id, for example, \"City of London\".</p> <p><code>Loc</code> must be a coordinate (using a <code>shapely.geometry.Point</code>). <code>Link</code> is a network id. Locs and Links are only required for specific applications such as MATSim and can be added or sampled later, so are not covered further here.</p>"},{"location":"examples/01_basics/#all-togther-now","title":"All Togther Now\u00b6","text":"<p>PAM has read methods for common travel diary data formats and for MATSim. Pam also has modules for modelling new activity sequences. But below we show how you might create a simple demonstration population from scratch.</p> <p>Note that for conveneince the <code>add</code> methods will also try to unpack lists.</p>"},{"location":"examples/01_basics/#accessing-data","title":"Accessing Data\u00b6","text":"<p>Households and Persons can be accessed and modified in a variety of ways:</p>"},{"location":"examples/01_basics/#export","title":"Export\u00b6","text":"<p>Exports plans to csv or xml format for MATSim.</p>"},{"location":"examples/02b_matsim_read_write/","title":"MATSim Read-Write","text":"In\u00a0[1]: Copied! <pre>import os\n\nfrom pam import read\n</pre> import os  from pam import read In\u00a0[2]: Copied! <pre>population = read.read_matsim(plans_path=os.path.join(\"data\", \"example_data\", \"example_plans.xml\"))\npopulation.stats\n</pre> population = read.read_matsim(plans_path=os.path.join(\"data\", \"example_data\", \"example_plans.xml\")) population.stats Out[2]: <pre>{'num_households': 51,\n 'num_people': 51,\n 'num_activities': 153,\n 'num_legs': 102}</pre> In\u00a0[3]: Copied! <pre>from pam import write\n\nwrite.write_matsim(population, plans_path=os.path.join(\"tmp\", \"plans.xml\"))\n</pre> from pam import write  write.write_matsim(population, plans_path=os.path.join(\"tmp\", \"plans.xml\")) In\u00a0[4]: Copied! <pre>from pam.read import stream_matsim_persons\nfrom pam.write import Writer\n\nread_path = os.path.join(\"data\", \"example_data\", \"example_plans.xml\")\nwrite_path = os.path.join(\"tmp\", \"plans.xml\")\n\nwith Writer(\n    path=write_path, keep_non_selected=True, coordinate_reference_system=\"EPSG:27700\"\n) as writer:\n    for person in stream_matsim_persons(\n        plans_path=read_path,\n        weight=10,\n        simplify_pt_trips=False,\n        leg_route=False,\n        keep_non_selected=True,\n    ):\n        # add age attribute\n        person.attributes[\"age\"] = \"unknown\"\n        writer.add_person(person)\n</pre> from pam.read import stream_matsim_persons from pam.write import Writer  read_path = os.path.join(\"data\", \"example_data\", \"example_plans.xml\") write_path = os.path.join(\"tmp\", \"plans.xml\")  with Writer(     path=write_path, keep_non_selected=True, coordinate_reference_system=\"EPSG:27700\" ) as writer:     for person in stream_matsim_persons(         plans_path=read_path,         weight=10,         simplify_pt_trips=False,         leg_route=False,         keep_non_selected=True,     ):         # add age attribute         person.attributes[\"age\"] = \"unknown\"         writer.add_person(person) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/02b_matsim_read_write/#matsim-read-write","title":"MATSim Read-Write\u00b6","text":"<p>This notebook is an introduction to the PAM MATSim read-write methods. It has four parts:</p> <ol> <li>Read</li> <li>Write</li> <li>Experienced Plans</li> <li>Streaming</li> </ol>"},{"location":"examples/02b_matsim_read_write/#read-matsim-format","title":"Read MATSim Format\u00b6","text":"<p>PAM can read from MATSim formatted xml using <code>pam.read.read_matsim</code>. <code>read_matsim</code> will except xml or gzipped xml (<code>.xml.gz</code>). It supports multiple additional options for your use-case (read the docs).</p>"},{"location":"examples/02b_matsim_read_write/#write-matsim-format","title":"Write MATSim Format\u00b6","text":"<p>PAM can write to MATSim formatted xml using <code>pam.write.write_matsim</code>.</p>"},{"location":"examples/02b_matsim_read_write/#experienced-plans","title":"Experienced Plans\u00b6","text":"<p>PAM supports MATSim experienced plans:</p> <ul> <li>unselected plans</li> <li>missing person attributes (attributes can be retrieved from regular MATSim plans)</li> <li>leg attributes</li> <li>leg routes</li> </ul> <p>The <code>read_matsim</code> and <code>write_matsim</code> functions support experienced plans. Reading, modifying and writing experienced plans is a useful way of building MATSim scenarios without loosing too much information from a previous scenario.</p>"},{"location":"examples/02b_matsim_read_write/#streaming","title":"Streaming\u00b6","text":"<p>Low memory applications can be created by streaming MATSim plans from <code>read.stream_matsim_persons</code> into your application logic and then back to disk using <code>write.Writer</code>. For example:</p>"},{"location":"examples/16_advanced_matsim_warmstarting/","title":"MATSim Warm-Starting","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nfrom pam.read import read_matsim\nfrom pam.write import write_matsim\n</pre> from pathlib import Path  from pam.read import read_matsim from pam.write import write_matsim In\u00a0[2]: Copied! <pre>population = read_matsim(\n    plans_path=Path(\"data/example_data/output_experienced_plans.xml\"), keep_non_selected=True\n)\npopulation.stats\n</pre> population = read_matsim(     plans_path=Path(\"data/example_data/output_experienced_plans.xml\"), keep_non_selected=True ) population.stats Out[2]: <pre>{'num_households': 6, 'num_people': 6, 'num_activities': 23, 'num_legs': 18}</pre> In\u00a0[3]: Copied! <pre>removed_links = [\"1-5\", \"5-1\"]\n\n\ndef leg_filter(leg):\n    for link in removed_links:\n        if link in leg.route.network_route:\n            return True\n        if leg.route.get(\"start_link\") in removed_links:\n            return True\n        if leg.route.get(\"end_link\") in removed_links:\n            return True\n\n\ndef plan_filter(plan):\n    for leg in plan.legs:\n        if leg_filter(leg):\n            return True\n\n    for act in plan.activities:\n        if act.location.link in removed_links:\n            return True\n</pre> removed_links = [\"1-5\", \"5-1\"]   def leg_filter(leg):     for link in removed_links:         if link in leg.route.network_route:             return True         if leg.route.get(\"start_link\") in removed_links:             return True         if leg.route.get(\"end_link\") in removed_links:             return True   def plan_filter(plan):     for leg in plan.legs:         if leg_filter(leg):             return True      for act in plan.activities:         if act.location.link in removed_links:             return True In\u00a0[4]: Copied! <pre>for _, _, person in population.people():\n    if plan_filter(person.plan):\n        for leg in person.legs:\n            leg.route.xml = {}\n        for activity in person.activities:\n            activity.location.link = None\n\n    for plan in person.plans_non_selected:\n        if plan_filter(plan):\n            for leg in plan.legs:\n                leg.route.xml = {}\n            for activity in plan.activities:\n                activity.location.link = None\n</pre> for _, _, person in population.people():     if plan_filter(person.plan):         for leg in person.legs:             leg.route.xml = {}         for activity in person.activities:             activity.location.link = None      for plan in person.plans_non_selected:         if plan_filter(plan):             for leg in plan.legs:                 leg.route.xml = {}             for activity in plan.activities:                 activity.location.link = None In\u00a0[5]: Copied! <pre>write_matsim(population, Path(\"tmp/warm_plans.xml\"))\n</pre> write_matsim(population, Path(\"tmp/warm_plans.xml\")) <p>If we check these \"warm\" plans we will find that the agent \"Nick\" has had their plan modified. But all other agents have maintained all the original information.</p> <p>It is easy to get warm starting wrong. But it also has great potential to reduce MATSim compute in many cases. Common pitfalls include:</p> <ul> <li>failing to remove all the required information (remember that link and transit facility ids are also included in agent leg attributes and activity attributes)</li> <li>accidentally removing plans or activities (make sure that crop=False when reading plans)</li> <li>creating impossible plans (such as by using an unknown mode)</li> </ul> <p>We have added three common methods for warm starting to the PAM cli:</p> <ul> <li>crop (but note this does not currently support unselected plans)</li> <li>wipe_links</li> <li>wipe_all_links</li> </ul>"},{"location":"examples/16_advanced_matsim_warmstarting/#matsim-warm-starting","title":"MATSim Warm-Starting\u00b6","text":"<p>PAM can load experienced MATSim plans, make modifications, then write new input MATSim plans. This allows for changes to be made to a population or network without invalidating the MATSim plans.</p> <p>For example, consider the case where we have the outputs from a MATSim baseline simulation. We want to test a new scenario that makes a minor change to some parts of the network, this includes removing some links. We would like to reuse the output baseline plans. They contain our best initial guess for agent choices for times, modes and routes, including for unselected plans. However, we cannot resue these plans as they are, because they include routes that are now impossible due to our new scenario removing some links.</p> <p>PAM allows us to read in these experienced plans, remove routes from agents that use these links, then write back to a valid format for our new scenario.</p>"},{"location":"examples/16_advanced_matsim_warmstarting/#load","title":"Load\u00b6","text":""},{"location":"examples/16_advanced_matsim_warmstarting/#define-filters","title":"Define Filters\u00b6","text":""},{"location":"examples/16_advanced_matsim_warmstarting/#modify","title":"Modify\u00b6","text":""},{"location":"examples/16_advanced_matsim_warmstarting/#write","title":"Write\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/","title":"Plan Cropping","text":"In\u00a0[1]: Copied! <pre>from copy import deepcopy\n\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Point, Polygon\n\nfrom pam.activity import Activity, Leg, Plan\nfrom pam.core import Household, Person, Population\nfrom pam.operations import cropping\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n</pre> from copy import deepcopy  import geopandas as gp import matplotlib.pyplot as plt from shapely.geometry import Point, Polygon  from pam.activity import Activity, Leg, Plan from pam.core import Household, Person, Population from pam.operations import cropping from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY <p>Create a simple zoning system:</p> In\u00a0[2]: Copied! <pre>def test_zoning_system() -&gt; gp.GeoDataFrame:\n\"\"\"Dummy orthogonal zoning system.\"\"\"\n    zones = []\n    labels = [chr(x) for x in range(97, 106)]\n    for x in range(3):\n        for y in range(3):\n            zones.append(Polygon([(x, y), (x, y + 1), (x + 1, y + 1), (x + 1, y)]))\n    zones_gdf = gp.GeoDataFrame({\"zone\": labels}, geometry=zones)\n    zones_gdf.index = zones_gdf.zone\n\n    return zones_gdf\n\n\nzoning_system = test_zoning_system()\n</pre> def test_zoning_system() -&gt; gp.GeoDataFrame:     \"\"\"Dummy orthogonal zoning system.\"\"\"     zones = []     labels = [chr(x) for x in range(97, 106)]     for x in range(3):         for y in range(3):             zones.append(Polygon([(x, y), (x, y + 1), (x + 1, y + 1), (x + 1, y)]))     zones_gdf = gp.GeoDataFrame({\"zone\": labels}, geometry=zones)     zones_gdf.index = zones_gdf.zone      return zones_gdf   zoning_system = test_zoning_system() <p>Create a simple plan:</p> In\u00a0[3]: Copied! <pre>plan = Plan()\nplan.day = [\n    Activity(seq=1, act=\"home\", loc=Point(0.31, 0.81), start_time=mtdt(0), end_time=mtdt(420)),\n    Leg(\n        seq=1,\n        mode=\"car\",\n        start_loc=Point(0.31, 0.81),\n        end_loc=Point(0.12, 1.45),\n        start_time=mtdt(420),\n        end_time=mtdt(480),\n        distance=1000,\n    ),\n    Activity(seq=2, act=\"shop\", loc=Point(0.12, 1.45), start_time=mtdt(480), end_time=mtdt(510)),\n    Leg(\n        seq=2,\n        mode=\"car\",\n        start_loc=Point(0.12, 1.45),\n        end_loc=Point(0.84, 2.12),\n        start_time=mtdt(510),\n        end_time=mtdt(540),\n        distance=1000,\n    ),\n    Activity(seq=3, act=\"work\", loc=Point(0.84, 2.12), start_time=mtdt(540), end_time=mtdt(800)),\n    Leg(\n        seq=3,\n        mode=\"walk\",\n        start_loc=Point(0.84, 2.12),\n        end_loc=Point(1.90, 0.23),\n        start_time=mtdt(800),\n        end_time=mtdt(900),\n        distance=1000,\n    ),\n    Activity(seq=4, act=\"medical\", loc=Point(1.90, 0.23), start_time=mtdt(900), end_time=mtdt(960)),\n    Leg(\n        seq=4,\n        mode=\"walk\",\n        start_loc=Point(1.90, 0.23),\n        end_loc=Point(2.26, 0.24),\n        start_time=mtdt(960),\n        end_time=mtdt(990),\n        distance=1000,\n    ),\n    Activity(seq=5, act=\"other\", loc=Point(2.26, 0.24), start_time=mtdt(990), end_time=mtdt(1010)),\n    Leg(\n        seq=5,\n        mode=\"walk\",\n        start_loc=Point(2.26, 0.24),\n        end_loc=Point(2.77, 1.82),\n        start_time=mtdt(1010),\n        end_time=mtdt(1030),\n        distance=1000,\n    ),\n    Activity(seq=6, act=\"other\", loc=Point(2.77, 1.82), start_time=mtdt(1030), end_time=mtdt(1060)),\n    Leg(\n        seq=6,\n        mode=\"walk\",\n        start_loc=Point(2.77, 1.82),\n        end_loc=Point(1.88, 1.72),\n        start_time=mtdt(1060),\n        end_time=mtdt(1100),\n        distance=1000,\n    ),\n    Activity(seq=7, act=\"other\", loc=Point(1.88, 1.72), start_time=mtdt(1100), end_time=mtdt(1200)),\n    Leg(\n        seq=7,\n        mode=\"car\",\n        start_loc=Point(1.88, 1.72),\n        end_loc=Point(0.23, 0.10),\n        start_time=mtdt(1200),\n        end_time=mtdt(1210),\n        distance=1000,\n    ),\n    Activity(seq=8, act=\"home\", loc=Point(0.23, 0.10), start_time=mtdt(1210), end_time=END_OF_DAY),\n]\n\nhh = Household(1, loc=Point(0.31, 0.81))\npopulation = Population()\nperson = Person(1)\nperson.plan = plan\nhh.add(person)\npopulation.add(hh)\n</pre> plan = Plan() plan.day = [     Activity(seq=1, act=\"home\", loc=Point(0.31, 0.81), start_time=mtdt(0), end_time=mtdt(420)),     Leg(         seq=1,         mode=\"car\",         start_loc=Point(0.31, 0.81),         end_loc=Point(0.12, 1.45),         start_time=mtdt(420),         end_time=mtdt(480),         distance=1000,     ),     Activity(seq=2, act=\"shop\", loc=Point(0.12, 1.45), start_time=mtdt(480), end_time=mtdt(510)),     Leg(         seq=2,         mode=\"car\",         start_loc=Point(0.12, 1.45),         end_loc=Point(0.84, 2.12),         start_time=mtdt(510),         end_time=mtdt(540),         distance=1000,     ),     Activity(seq=3, act=\"work\", loc=Point(0.84, 2.12), start_time=mtdt(540), end_time=mtdt(800)),     Leg(         seq=3,         mode=\"walk\",         start_loc=Point(0.84, 2.12),         end_loc=Point(1.90, 0.23),         start_time=mtdt(800),         end_time=mtdt(900),         distance=1000,     ),     Activity(seq=4, act=\"medical\", loc=Point(1.90, 0.23), start_time=mtdt(900), end_time=mtdt(960)),     Leg(         seq=4,         mode=\"walk\",         start_loc=Point(1.90, 0.23),         end_loc=Point(2.26, 0.24),         start_time=mtdt(960),         end_time=mtdt(990),         distance=1000,     ),     Activity(seq=5, act=\"other\", loc=Point(2.26, 0.24), start_time=mtdt(990), end_time=mtdt(1010)),     Leg(         seq=5,         mode=\"walk\",         start_loc=Point(2.26, 0.24),         end_loc=Point(2.77, 1.82),         start_time=mtdt(1010),         end_time=mtdt(1030),         distance=1000,     ),     Activity(seq=6, act=\"other\", loc=Point(2.77, 1.82), start_time=mtdt(1030), end_time=mtdt(1060)),     Leg(         seq=6,         mode=\"walk\",         start_loc=Point(2.77, 1.82),         end_loc=Point(1.88, 1.72),         start_time=mtdt(1060),         end_time=mtdt(1100),         distance=1000,     ),     Activity(seq=7, act=\"other\", loc=Point(1.88, 1.72), start_time=mtdt(1100), end_time=mtdt(1200)),     Leg(         seq=7,         mode=\"car\",         start_loc=Point(1.88, 1.72),         end_loc=Point(0.23, 0.10),         start_time=mtdt(1200),         end_time=mtdt(1210),         distance=1000,     ),     Activity(seq=8, act=\"home\", loc=Point(0.23, 0.10), start_time=mtdt(1210), end_time=END_OF_DAY), ]  hh = Household(1, loc=Point(0.31, 0.81)) population = Population() person = Person(1) person.plan = plan hh.add(person) population.add(hh) <p>The core area scope is defined as a geometry:</p> In\u00a0[4]: Copied! <pre>def plot_legs(plan: Plan):\n    for i, leg in enumerate(plan.legs):\n        path = cropping.get_leg_path(leg)\n        plt.annotate(\n            i,\n            xy=(path.xy[0][1], path.xy[1][1]),\n            xytext=(path.xy[0][0], path.xy[1][0]),\n            arrowprops={\"arrowstyle\": \"-&gt;\", \"color\": \"gray\"},\n        )\n</pre> def plot_legs(plan: Plan):     for i, leg in enumerate(plan.legs):         path = cropping.get_leg_path(leg)         plt.annotate(             i,             xy=(path.xy[0][1], path.xy[1][1]),             xytext=(path.xy[0][0], path.xy[1][0]),             arrowprops={\"arrowstyle\": \"-&gt;\", \"color\": \"gray\"},         ) In\u00a0[5]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(10, 10))\nzoning_system.boundary.plot(ax=ax)\nfor _i, irow in zoning_system.iterrows():\n    x = irow.geometry.centroid.x\n    y = irow.geometry.centroid.y\n    plt.annotate(irow.zone, xy=(x, y))\nplot_legs(plan)\n\nplan.plot()\n</pre> fig, ax = plt.subplots(1, 1, figsize=(10, 10)) zoning_system.boundary.plot(ax=ax) for _i, irow in zoning_system.iterrows():     x = irow.geometry.centroid.x     y = irow.geometry.centroid.y     plt.annotate(irow.zone, xy=(x, y)) plot_legs(plan)  plan.plot() <p>Trips that enter or exit the core area (here, zone <code>h</code>) are kept in the agent's plan:</p> In\u00a0[6]: Copied! <pre>boundary = zoning_system.loc[\"h\"].geometry\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n</pre> boundary = zoning_system.loc[\"h\"].geometry  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary) In\u00a0[7]: Copied! <pre>def plot_results(plan: Plan, boundary: gp.GeoDataFrame):\n    fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n    zoning_system.boundary.plot(ax=ax)\n    for _i, irow in zoning_system.iterrows():\n        x = irow.geometry.centroid.x\n        y = irow.geometry.centroid.y\n        plt.annotate(irow.zone, xy=(x, y))\n    gp.GeoSeries([boundary]).boundary.plot(ax=ax, color=\"red\")\n    plot_legs(plan)\n    plt.title(\"Cropped plan\")\n\n    plan.plot()\n\n\nplot_results(plan_cropped, boundary)\n</pre> def plot_results(plan: Plan, boundary: gp.GeoDataFrame):     fig, ax = plt.subplots(1, 1, figsize=(10, 10))     zoning_system.boundary.plot(ax=ax)     for _i, irow in zoning_system.iterrows():         x = irow.geometry.centroid.x         y = irow.geometry.centroid.y         plt.annotate(irow.zone, xy=(x, y))     gp.GeoSeries([boundary]).boundary.plot(ax=ax, color=\"red\")     plot_legs(plan)     plt.title(\"Cropped plan\")      plan.plot()   plot_results(plan_cropped, boundary) <p>Any trips that are expected to go through the core area (as a straight-line path) are retained in the plan:</p> In\u00a0[8]: Copied! <pre># define boundary\nboundary = zoning_system.loc[\"e\"].geometry\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n\n\nplot_results(plan_cropped, boundary)\n</pre> # define boundary boundary = zoning_system.loc[\"e\"].geometry  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)   plot_results(plan_cropped, boundary) <p>By passing the <code>snap_to_boundary=True</code> argument, we can completely remove any leg parts that fall outside the core area:</p> In\u00a0[9]: Copied! <pre># crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary, snap_to_boundary=True)\n\n# plot\nplot_results(plan_cropped, boundary)\n</pre> # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary, snap_to_boundary=True)  # plot plot_results(plan_cropped, boundary) <p>If no leg crosses the core area (here, zone i), then an empty plan is returned, and the person is removed from the population:</p> In\u00a0[10]: Copied! <pre>boundary = zoning_system.loc[\"i\"].geometry\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n\n# plot\nplot_results(plan_cropped, boundary)\n</pre> boundary = zoning_system.loc[\"i\"].geometry  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)  # plot plot_results(plan_cropped, boundary) <p>Any agents with fully external plans are dropped entirely:</p> In\u00a0[11]: Copied! <pre>population_cropped = deepcopy(population)\nassert len(population_cropped) == 1\n\n# after simplification, there are no agents left\ncropping.simplify_population(population_cropped, boundary)\nassert len(population_cropped) == 0\n</pre> population_cropped = deepcopy(population) assert len(population_cropped) == 1  # after simplification, there are no agents left cropping.simplify_population(population_cropped, boundary) assert len(population_cropped) == 0 <p>If all activities fall within the core area, plans remain unchanged:</p> In\u00a0[12]: Copied! <pre>boundary = zoning_system.dissolve().geometry[0]\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n\n# plot\nplot_results(plan_cropped, boundary)\n</pre> boundary = zoning_system.dissolve().geometry[0]  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)  # plot plot_results(plan_cropped, boundary)"},{"location":"examples/14_Advanced_Plan_Cropping/#plan-cropping","title":"Plan Cropping\u00b6","text":"<p>In this example, we show how you can simplify any activities happening outside a defined \"core\" area.</p> <p>Method:</p> <ol> <li>Identify which legs touch the core area</li> <li>Keep the relevant legs/activities and drop the remaining components</li> <li>Infill: create any new legs between external activities as necessary</li> <li>Ensure plan consistency: start/end times, sequences, etc</li> <li>(optional) : Rename activities to \"external\"</li> <li>(optional) : Crop the leg geometries to start/stop at the core area boundaries</li> </ol>"},{"location":"examples/14_Advanced_Plan_Cropping/#data","title":"Data\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#examples","title":"Examples\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-1-internal-external-trips","title":"Example 1 - Internal-external trips\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-2-through-trips","title":"Example 2 - Through trips\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-3-snap-trip-ends-to-zone-boundaries","title":"Example 3 - Snap trip ends to zone boundaries\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-3-fully-external-plan","title":"Example 3 - Fully external plan\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-4-fully-internal-plan","title":"Example 4 - Fully internal plan\u00b6","text":""},{"location":"examples/04_point_sampling/","title":"Point Sampling","text":"In\u00a0[1]: Copied! <pre>import os\n\nimport geopandas as gp\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom pam import read\nfrom pam.samplers.spatial import RandomPointSampler\n</pre> import os  import geopandas as gp import pandas as pd from matplotlib import pyplot as plt  from pam import read from pam.samplers.spatial import RandomPointSampler In\u00a0[2]: Copied! <pre>trips = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\"\n)\nattributes = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\"\n)\ntrips.head(10)\n</pre> trips = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\" ) attributes = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\" ) trips.head(10) Out[2]: pid hid seq hzone ozone dzone purp mode tst tet freq uid 0 census_0 census_0 0 Harrow Harrow Camden work pt 444 473 1000 1 census_0 census_0 1 Harrow Camden Harrow work pt 890 919 1000 2 census_1 census_1 0 Greenwich Greenwich Tower Hamlets work pt 507 528 1000 3 census_1 census_1 1 Greenwich Tower Hamlets Greenwich work pt 1065 1086 1000 4 census_2 census_2 0 Croydon Croydon Croydon work pt 422 425 1000 5 census_2 census_2 1 Croydon Croydon Croydon work pt 917 920 1000 6 census_3 census_3 0 Haringey Haringey Redbridge work pt 428 447 1000 7 census_3 census_3 1 Haringey Redbridge Haringey work pt 1007 1026 1000 8 census_4 census_4 0 Hounslow Hounslow Westminster,City of London work car 483 516 1000 9 census_4 census_4 1 Hounslow Westminster,City of London Hounslow work car 1017 1050 1000 In\u00a0[3]: Copied! <pre>population = read.load_travel_diary(trips, attributes)\npopulation.stats\n</pre> population = read.load_travel_diary(trips, attributes) population.stats <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all persons.\n</pre> Out[3]: <pre>{'num_households': 51,\n 'num_people': 51,\n 'num_activities': 152,\n 'num_legs': 101}</pre> In\u00a0[4]: Copied! <pre>zones = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\")).set_index(\"NAME\")\nzones.head()\n</pre> zones = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\")).set_index(\"NAME\") zones.head() Out[4]: HECTARES NONLD_AREA ONS_INNER SUB_2009 SUB_2006 geometry NAME Kingston upon Thames 3726.117 0.000 F None None POLYGON ((516401.600 160201.800, 516407.300 16... Croydon 8649.441 0.000 F None None POLYGON ((535009.200 159504.700, 535005.500 15... Bromley 15013.487 0.000 F None None POLYGON ((540373.600 157530.400, 540361.200 15... Hounslow 5658.541 60.755 F None None POLYGON ((521975.800 178100.000, 521967.700 17... Ealing 5554.428 0.000 F None None POLYGON ((510253.500 182881.600, 510249.900 18... In\u00a0[5]: Copied! <pre>random_sampler = RandomPointSampler(geoms=zones)\n</pre> random_sampler = RandomPointSampler(geoms=zones) In\u00a0[6]: Copied! <pre># test\nfig, ax = plt.subplots(1)\nzones.plot(ax=ax, color=\"grey\")\nzones.loc[[\"Camden\"]].plot(ax=ax)\npoint = random_sampler.sample(\"Camden\", activity=None)\nax.scatter(point.x, point.y, c=\"red\")\n</pre> # test fig, ax = plt.subplots(1) zones.plot(ax=ax, color=\"grey\") zones.loc[[\"Camden\"]].plot(ax=ax) point = random_sampler.sample(\"Camden\", activity=None) ax.scatter(point.x, point.y, c=\"red\") Out[6]: <pre>&lt;matplotlib.collections.PathCollection at 0x166069e50&gt;</pre> In\u00a0[7]: Copied! <pre>population.sample_locs(random_sampler)  # apply to whole population\n</pre> population.sample_locs(random_sampler)  # apply to whole population <p>Let's check out an example Activity Plan and Attributes:</p> In\u00a0[8]: Copied! <pre>person = population[\"census_0\"][\"census_0\"]\nperson.print()\nperson.plot()\n</pre> person = population[\"census_0\"][\"census_0\"] person.print() person.plot() <pre>Person: census_0\n{'gender': 'female', 'job': 'work', 'occ': 'white', 'inc': 'low', 'hzone': 'Harrow'}\n0:\tActivity(act:home, location:POINT (517702.1519748939 192671.19281313664), time:00:00:00 --&gt; 07:24:00, duration:7:24:00)\n1:\tLeg(mode:pt, area:POINT (517702.1519748939 192671.19281313664) --&gt; POINT (528040.8831878359 184646.90405632465), time:07:24:00 --&gt; 07:53:00, duration:0:29:00)\n2:\tActivity(act:work, location:POINT (528040.8831878359 184646.90405632465), time:07:53:00 --&gt; 14:50:00, duration:6:57:00)\n3:\tLeg(mode:pt, area:POINT (528040.8831878359 184646.90405632465) --&gt; POINT (517702.1519748939 192671.19281313664), time:14:50:00 --&gt; 15:19:00, duration:0:29:00)\n4:\tActivity(act:home, location:POINT (517702.1519748939 192671.19281313664), time:15:19:00 --&gt; 00:00:00, duration:8:41:00)\n</pre>"},{"location":"examples/04_point_sampling/#point-sampling","title":"Point Sampling\u00b6","text":"<p>MATSim requires point locations for all activities and trips. More generally it can be useful to assign geometries to activity location and/or trip origin and destinations. This notebook shows how to sample geometric locations from ozone/dzone regions using a simple random point sampler.</p> <p>More advanced samplers are available in <code>pam.samplers.spatial</code>.</p>"},{"location":"examples/04_point_sampling/#sample-geometries","title":"Sample Geometries\u00b6","text":"<p>Transform trip ozone/dzone to geographically sampled points</p>"},{"location":"examples/10_advanced_spatial_sampling/","title":"Advanced Spatial Sampling","text":"<p>The purpose of this notebook is to demonstrate weighted and rule-based facility sampling methods.</p> <p>PAM offers a facility sampler, which can be called wtih <code>pam.samplers.facility.FacilitySampler(facilities, zones, ...)</code>, where <code>facilities</code> and <code>zones</code> are geodataframes containing the available activity locations and the model zoning system respectively.</p> <p>The <code>weight_on</code> option of the sampler allows to specify a column of the facilities dataset to be used for weighting the candidate locations (for example, by floorspace). nb: weighted sampling here samples with replacement, while the default (unweighted) option iterates across a shuffled list of the candidate locations instead).</p> <p>By providing a <code>max_walk</code> argument, we constrain activity locations accessed with PT modes (named as <code>bus</code>, <code>rail</code>, or <code>pt</code>) to be located within that distance (crow's fly) from a PT stop. The distance of each facility from a PT stop should be provided in the <code>facilities</code> dataset (under the <code>transit</code> field).</p> <p>We can sample facility locations for a PAM population, with the <code>population.sample_locs(sampler)</code> method, where sampler is an instance of <code>pam.samplers.facility.FacilitySampler</code>. Depending whether we <code>weight_on</code> option was activated for the sampler, it will undertake simple or weighted sampling.</p> <p>To accommodate more complex sampling techniques, we have introduced <code>population.sample_locs_complex(sampler)</code>. This method passes additional information to the sampler, such as the duration and mode of arriving trip and the previous activity location. The sampler then applies some extra rules:</p> <ul> <li>distance-weighted sampling: for the given trip duration, try to adjust candidate facility weights so that their distance from the previous location is consistent with the trip duration and mode speed. The weights are adjusted as $ adjusted\\_weight_j =  \\frac{weight_j}{expected\\_distance_{ij}^2}$, where $ expected\\_distance_{ij} = \\lvert{distance_{ij} - (duration * speed)}\\rvert $. The mode speeds (expressed in euclidean distance terms) are defined in <code>pam.variables.EXPECTED_EUCLIDEAN_SPEEDS</code> dictionary.</li> <li>distance from PT stop rule: if the mode is PT and <code>max_walk</code> has been provided, contrain the options within the specified radius from a stop</li> </ul> <p>Caveats</p> <ul> <li>The complex sampler is experimental at this stage and should be used with care.</li> <li>All distance units are calculated as euclidean distances. Expected speeds should also be expressed in euclidean measures. Distance calculations assume a linear-unit (meters) coordinate system. In the future, we should try to integrate model skims in the calculation.</li> <li>Distance-based weighting can be used to help better align sampled durations with locations. However, it only looks one trip ahead, and it is likely to be inconsistent for the last trip (ie the path doesn't necessarily \"close\" well).</li> </ul> In\u00a0[1]: Copied! <pre>import logging\n\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom shapely.geometry import Point, Polygon\n\nimport pam\nfrom pam.activity import Activity, Leg\nfrom pam.core import Household, Person, Population\nfrom pam.samplers import facility\nfrom pam.utils import minutes_to_datetime\n</pre> import logging  import geopandas as gp import matplotlib.pyplot as plt import numpy as np import pandas as pd from shapely.geometry import Point, Polygon  import pam from pam.activity import Activity, Leg from pam.core import Household, Person, Population from pam.samplers import facility from pam.utils import minutes_to_datetime <p>Create a dummy dataset of facilities and their locations:</p> In\u00a0[2]: Copied! <pre># create random spatial data\n\n# create zones\nlength = 10000  # square length in meters\npolygon_list = []\nzone_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"]\nactivities_list = [\"home\", \"work\", \"other\", \"shop\", \"escort\", \"education\"]\n\nfor y in [2 * length, length, 0]:\n    for x in [0, length, 2 * length]:\n        polygon_list.append(\n            Polygon([[x, y], [x + length, y], [x + length, y + length], [x, y + length], [x, y]])\n        )\n\nzones = gp.GeoDataFrame(geometry=polygon_list)\nzones[\"zone\"] = zone_list\nzones = zones.set_index(\"zone\")\n\n# create facilities\npoint_list = []\nfor activity in activities_list:\n    for _i in range(1000):\n        point = Point(np.random.rand() * 3 * length, np.random.rand() * 3 * length)\n        point_list.append(\n            {\n                \"activity\": activity,\n                \"floors\": np.random.randint(1, 4),\n                \"units\": np.random.randint(1, 20),\n                \"area\": np.random.randint(1, 100),\n                \"transit\": np.random.randint(1, 10000),\n                \"geometry\": point,\n            }\n        )\n\nfacilities = gp.GeoDataFrame(point_list)\nfacilities = gp.sjoin(facilities, zones.reset_index()).drop(columns=\"index_right\")\n\n\n# plot\nfig, ax = plt.subplots(1, 1, figsize=(10, 7))\nzones.boundary.plot(ax=ax)\nfacilities.plot(ax=ax, markersize=2, color=\"purple\")\nfor zone, centroid in zip(zones.index, zones.centroid):\n    ax.annotate(zone, xy=(centroid.x, centroid.y), size=15)\nax.axis(\"off\")\nplt.show()\n</pre> # create random spatial data  # create zones length = 10000  # square length in meters polygon_list = [] zone_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"] activities_list = [\"home\", \"work\", \"other\", \"shop\", \"escort\", \"education\"]  for y in [2 * length, length, 0]:     for x in [0, length, 2 * length]:         polygon_list.append(             Polygon([[x, y], [x + length, y], [x + length, y + length], [x, y + length], [x, y]])         )  zones = gp.GeoDataFrame(geometry=polygon_list) zones[\"zone\"] = zone_list zones = zones.set_index(\"zone\")  # create facilities point_list = [] for activity in activities_list:     for _i in range(1000):         point = Point(np.random.rand() * 3 * length, np.random.rand() * 3 * length)         point_list.append(             {                 \"activity\": activity,                 \"floors\": np.random.randint(1, 4),                 \"units\": np.random.randint(1, 20),                 \"area\": np.random.randint(1, 100),                 \"transit\": np.random.randint(1, 10000),                 \"geometry\": point,             }         )  facilities = gp.GeoDataFrame(point_list) facilities = gp.sjoin(facilities, zones.reset_index()).drop(columns=\"index_right\")   # plot fig, ax = plt.subplots(1, 1, figsize=(10, 7)) zones.boundary.plot(ax=ax) facilities.plot(ax=ax, markersize=2, color=\"purple\") for zone, centroid in zip(zones.index, zones.centroid):     ax.annotate(zone, xy=(centroid.x, centroid.y), size=15) ax.axis(\"off\") plt.show() In\u00a0[3]: Copied! <pre># facilities dataset:\nfacilities.head()\n</pre> # facilities dataset: facilities.head() Out[3]: activity floors units area transit geometry zone 0 home 2 8 16 7755 POINT (1362.374 1937.675) g 2 home 3 7 24 4153 POINT (5640.784 1503.689) g 6 home 3 5 78 9194 POINT (464.992 4231.939) g 17 home 2 4 6 4995 POINT (7653.300 1743.242) g 33 home 2 9 60 3065 POINT (2149.642 7965.579) g <p>Let's assume a 30-min walking commute trip from home.</p> <p>The expected straight-line speed for the trip is:</p> In\u00a0[4]: Copied! <pre>print(\n    \"The expected straight-line speed for the trip is: {} kph\".format(\n        pam.variables.EXPECTED_EUCLIDEAN_SPEEDS[\"walk\"]\n    )\n)\n</pre> print(     \"The expected straight-line speed for the trip is: {} kph\".format(         pam.variables.EXPECTED_EUCLIDEAN_SPEEDS[\"walk\"]     ) ) <pre>The expected straight-line speed for the trip is: 1.3888888888888888 kph\n</pre> <p>Therefore, we expect the sampler to pick a workplace location approx 5 * 0.5=2.5km from home.</p> In\u00a0[5]: Copied! <pre>p1 = Person(\"p1\", attributes={\"age\": 40})\np1.add(\n    Activity(\n        seq=1,\n        act=\"home\",\n        area=\"a\",\n        start_time=minutes_to_datetime(0),\n        end_time=minutes_to_datetime(60),\n    )\n)\np1.add(\n    Leg(\n        seq=1,\n        mode=\"walk\",\n        start_area=\"a\",\n        end_area=\"a\",\n        start_time=minutes_to_datetime(60),\n        end_time=minutes_to_datetime(90),\n    )\n)\np1.add(\n    Activity(\n        seq=2,\n        act=\"work\",\n        area=\"a\",\n        start_time=minutes_to_datetime(90),\n        end_time=minutes_to_datetime(120),\n    )\n)\n\nhh1 = Household(0)\nhh1.add(p1)\n\npopulation = Population()\npopulation.add(hh1)\n</pre> p1 = Person(\"p1\", attributes={\"age\": 40}) p1.add(     Activity(         seq=1,         act=\"home\",         area=\"a\",         start_time=minutes_to_datetime(0),         end_time=minutes_to_datetime(60),     ) ) p1.add(     Leg(         seq=1,         mode=\"walk\",         start_area=\"a\",         end_area=\"a\",         start_time=minutes_to_datetime(60),         end_time=minutes_to_datetime(90),     ) ) p1.add(     Activity(         seq=2,         act=\"work\",         area=\"a\",         start_time=minutes_to_datetime(90),         end_time=minutes_to_datetime(120),     ) )  hh1 = Household(0) hh1.add(p1)  population = Population() population.add(hh1) In\u00a0[6]: Copied! <pre># supress logger warnings\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.CRITICAL)\n</pre> # supress logger warnings  logger = logging.getLogger() logger.setLevel(logging.CRITICAL) In\u00a0[7]: Copied! <pre>def test_sampler_distance(\n    population, sampler, n_iterations=20, complex_sampler=False, title=None\n):  # increase this\n    distance_commute = []\n\n    for _i in range(n_iterations):\n        if complex_sampler:\n            population.sample_locs_complex(sampler)\n        else:\n            population.sample_locs(sampler)\n        distance_commute.append(population.trips_df()[\"euclidean_distance\"][0])\n\n    pd.Series(distance_commute).hist(bins=20)\n    if title is not None:\n        plt.title(title)\n    plt.xlabel(\"distance\")\n    plt.ylabel(\"frequency\")\n    plt.show()\n</pre> def test_sampler_distance(     population, sampler, n_iterations=20, complex_sampler=False, title=None ):  # increase this     distance_commute = []      for _i in range(n_iterations):         if complex_sampler:             population.sample_locs_complex(sampler)         else:             population.sample_locs(sampler)         distance_commute.append(population.trips_df()[\"euclidean_distance\"][0])      pd.Series(distance_commute).hist(bins=20)     if title is not None:         plt.title(title)     plt.xlabel(\"distance\")     plt.ylabel(\"frequency\")     plt.show() In\u00a0[8]: Copied! <pre># simple sampling\n\n\nfacility_sampler_nonweighted = facility.FacilitySampler(\n    facilities=facilities, zones=zones, build_xml=True, fail=False, random_default=True\n)\n\ntest_sampler_distance(\n    population,\n    facility_sampler_nonweighted,\n    complex_sampler=False,\n    title=\"Commute distance, simple sampling\",\n)\n</pre> # simple sampling   facility_sampler_nonweighted = facility.FacilitySampler(     facilities=facilities, zones=zones, build_xml=True, fail=False, random_default=True )  test_sampler_distance(     population,     facility_sampler_nonweighted,     complex_sampler=False,     title=\"Commute distance, simple sampling\", ) In\u00a0[9]: Copied! <pre># distance-weighted sampling\n\ndistance_commute_weighted = []\n\nfacility_sampler_weighted = facility.FacilitySampler(\n    facilities=facilities.assign(weight1=1),\n    zones=zones,\n    build_xml=True,\n    fail=False,\n    random_default=True,\n    weight_on=\"weight1\",\n)\n\ntest_sampler_distance(\n    population,\n    facility_sampler_weighted,\n    complex_sampler=True,\n    title=\"Commute distance, distance-weighted sampling\",\n)\n</pre> # distance-weighted sampling  distance_commute_weighted = []  facility_sampler_weighted = facility.FacilitySampler(     facilities=facilities.assign(weight1=1),     zones=zones,     build_xml=True,     fail=False,     random_default=True,     weight_on=\"weight1\", )  test_sampler_distance(     population,     facility_sampler_weighted,     complex_sampler=True,     title=\"Commute distance, distance-weighted sampling\", ) <p>Similar experiment to above, with a 30-min car trip from zone a to zone b:</p> In\u00a0[10]: Copied! <pre>print(\n    \"The expected straight-line speed for the trip is: {} kph\".format(\n        pam.variables.EXPECTED_EUCLIDEAN_SPEEDS[\"car\"]\n    )\n)\n</pre> print(     \"The expected straight-line speed for the trip is: {} kph\".format(         pam.variables.EXPECTED_EUCLIDEAN_SPEEDS[\"car\"]     ) ) <pre>The expected straight-line speed for the trip is: 5.555555555555555 kph\n</pre> <p>--&gt; we should expect higher sampling of locations in a radius closer to 20 * 0.5= 10km.</p> In\u00a0[11]: Copied! <pre>p2 = Person(\"p2\", attributes={\"age\": 40})\np2.add(\n    Activity(\n        seq=1,\n        act=\"home\",\n        area=\"a\",\n        start_time=minutes_to_datetime(0),\n        end_time=minutes_to_datetime(60),\n    )\n)\np2.add(\n    Leg(\n        seq=1,\n        mode=\"car\",\n        start_area=\"a\",\n        end_area=\"b\",\n        start_time=minutes_to_datetime(60),\n        end_time=minutes_to_datetime(90),\n    )\n)\np2.add(\n    Activity(\n        seq=2,\n        act=\"work\",\n        area=\"b\",\n        start_time=minutes_to_datetime(90),\n        end_time=minutes_to_datetime(120),\n    )\n)\n\nhh2 = Household(0)\nhh2.add(p2)\n\npopulation2 = Population()\npopulation2.add(hh2)\n\ntest_sampler_distance(\n    population2,\n    facility_sampler_nonweighted,\n    complex_sampler=False,\n    title=\"Commute distance, simple sampling, car\",\n)\ntest_sampler_distance(\n    population2,\n    facility_sampler_weighted,\n    complex_sampler=True,\n    title=\"Commute distance, distance-weighted sampling, car\",\n)\n</pre> p2 = Person(\"p2\", attributes={\"age\": 40}) p2.add(     Activity(         seq=1,         act=\"home\",         area=\"a\",         start_time=minutes_to_datetime(0),         end_time=minutes_to_datetime(60),     ) ) p2.add(     Leg(         seq=1,         mode=\"car\",         start_area=\"a\",         end_area=\"b\",         start_time=minutes_to_datetime(60),         end_time=minutes_to_datetime(90),     ) ) p2.add(     Activity(         seq=2,         act=\"work\",         area=\"b\",         start_time=minutes_to_datetime(90),         end_time=minutes_to_datetime(120),     ) )  hh2 = Household(0) hh2.add(p2)  population2 = Population() population2.add(hh2)  test_sampler_distance(     population2,     facility_sampler_nonweighted,     complex_sampler=False,     title=\"Commute distance, simple sampling, car\", ) test_sampler_distance(     population2,     facility_sampler_weighted,     complex_sampler=True,     title=\"Commute distance, distance-weighted sampling, car\", ) <p>As expected, between long-distance alternatives (ie from zone a to zone i), deviation from expected distance makes less difference (but does slightly shift the distribution towards the correct direction).</p> In\u00a0[12]: Copied! <pre>p3 = Person(\"p3\", attributes={\"age\": 40})\np3.add(\n    Activity(\n        seq=1,\n        act=\"home\",\n        area=\"a\",\n        start_time=minutes_to_datetime(0),\n        end_time=minutes_to_datetime(60),\n    )\n)\np3.add(\n    Leg(\n        seq=1,\n        mode=\"car\",\n        start_area=\"a\",\n        end_area=\"c\",\n        start_time=minutes_to_datetime(60),\n        end_time=minutes_to_datetime(90),\n    )\n)\np3.add(\n    Activity(\n        seq=2,\n        act=\"work\",\n        area=\"c\",\n        start_time=minutes_to_datetime(90),\n        end_time=minutes_to_datetime(120),\n    )\n)\n\nhh3 = Household(0)\nhh3.add(p3)\n\npopulation3 = Population()\npopulation3.add(hh3)\n\ntest_sampler_distance(\n    population3,\n    facility_sampler_nonweighted,\n    complex_sampler=False,\n    title=\"Commute distance, simple sampling, car\",\n)\ntest_sampler_distance(\n    population3,\n    facility_sampler_weighted,\n    complex_sampler=True,\n    title=\"Commute distance, distance-weighted sampling, car\",\n)\n</pre> p3 = Person(\"p3\", attributes={\"age\": 40}) p3.add(     Activity(         seq=1,         act=\"home\",         area=\"a\",         start_time=minutes_to_datetime(0),         end_time=minutes_to_datetime(60),     ) ) p3.add(     Leg(         seq=1,         mode=\"car\",         start_area=\"a\",         end_area=\"c\",         start_time=minutes_to_datetime(60),         end_time=minutes_to_datetime(90),     ) ) p3.add(     Activity(         seq=2,         act=\"work\",         area=\"c\",         start_time=minutes_to_datetime(90),         end_time=minutes_to_datetime(120),     ) )  hh3 = Household(0) hh3.add(p3)  population3 = Population() population3.add(hh3)  test_sampler_distance(     population3,     facility_sampler_nonweighted,     complex_sampler=False,     title=\"Commute distance, simple sampling, car\", ) test_sampler_distance(     population3,     facility_sampler_weighted,     complex_sampler=True,     title=\"Commute distance, distance-weighted sampling, car\", )"},{"location":"examples/10_advanced_spatial_sampling/#advanced-spatial-sampling","title":"Advanced Spatial Sampling\u00b6","text":""},{"location":"examples/10_advanced_spatial_sampling/#generate-data","title":"Generate Data\u00b6","text":""},{"location":"examples/10_advanced_spatial_sampling/#geography","title":"Geography\u00b6","text":""},{"location":"examples/10_advanced_spatial_sampling/#population","title":"Population\u00b6","text":""},{"location":"examples/10_advanced_spatial_sampling/#distance-based-sampling","title":"Distance-based sampling\u00b6","text":""},{"location":"examples/03_read_modify_write/","title":"PAM Read-Modify-Write","text":"In\u00a0[1]: Copied! <pre>import os\nfrom collections import defaultdict\n\nimport geopandas as gp\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom pam import policy, read\nfrom pam.policy import apply_policies\n\n%matplotlib inline\n</pre> import os from collections import defaultdict  import geopandas as gp import pandas as pd from matplotlib import pyplot as plt  from pam import policy, read from pam.policy import apply_policies  %matplotlib inline In\u00a0[2]: Copied! <pre>trips = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\"\n)\nattributes = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\"\n)\n</pre> trips = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\" ) attributes = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\" ) In\u00a0[3]: Copied! <pre>trips.head(10)\n</pre> trips.head(10) Out[3]: pid hid seq hzone ozone dzone purp mode tst tet freq uid 0 census_0 census_0 0 Harrow Harrow Camden work pt 444 473 1000 1 census_0 census_0 1 Harrow Camden Harrow work pt 890 919 1000 2 census_1 census_1 0 Greenwich Greenwich Tower Hamlets work pt 507 528 1000 3 census_1 census_1 1 Greenwich Tower Hamlets Greenwich work pt 1065 1086 1000 4 census_2 census_2 0 Croydon Croydon Croydon work pt 422 425 1000 5 census_2 census_2 1 Croydon Croydon Croydon work pt 917 920 1000 6 census_3 census_3 0 Haringey Haringey Redbridge work pt 428 447 1000 7 census_3 census_3 1 Haringey Redbridge Haringey work pt 1007 1026 1000 8 census_4 census_4 0 Hounslow Hounslow Westminster,City of London work car 483 516 1000 9 census_4 census_4 1 Hounslow Westminster,City of London Hounslow work car 1017 1050 1000 In\u00a0[4]: Copied! <pre>population = read.load_travel_diary(trips, attributes, trip_freq_as_person_freq=True)\n</pre> population = read.load_travel_diary(trips, attributes, trip_freq_as_person_freq=True) <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all trips.\n</pre> <p>Let's check out an example Activity Plan and Attributes:</p> In\u00a0[5]: Copied! <pre>household = population.households[\"census_12\"]\nperson = household.people[\"census_12\"]\nperson.print()\n</pre> household = population.households[\"census_12\"] person = household.people[\"census_12\"] person.print() <pre>Person: census_12\n{'gender': 'female', 'job': 'education', 'occ': 'white', 'inc': 'high', 'hzone': 'Croydon'}\n0:\tActivity(act:home, location:Croydon, time:00:00:00 --&gt; 07:06:00, duration:7:06:00)\n1:\tLeg(mode:pt, area:Croydon --&gt; Tower Hamlets, time:07:06:00 --&gt; 07:45:00, duration:0:39:00)\n2:\tActivity(act:education, location:Tower Hamlets, time:07:45:00 --&gt; 15:54:00, duration:8:09:00)\n3:\tLeg(mode:pt, area:Tower Hamlets --&gt; Croydon, time:15:54:00 --&gt; 16:33:00, duration:0:39:00)\n4:\tActivity(act:home, location:Croydon, time:16:33:00 --&gt; 00:00:00, duration:7:27:00)\n</pre> <p>Before we do any activity modification - we create a simple function to extract some example statistics. We include this as a simple demo, but would love to add more.</p> <p>Note that activity plans allow us to consider detailed joint segmentations, such as socio-economic, spatial, temporal, modal, activity sequence and so on.</p> In\u00a0[6]: Copied! <pre>def print_simple_stats(population):\n\"\"\"Print some simple population statistics.\"\"\"\n    time_at_home = 0\n    travel_time = 0\n    low_income_central_trips = 0\n    high_income_central_trips = 0\n\n    for hh in population.households.values():\n        for person in hh.people.values():\n            freq = person.freq\n\n            for p in person.plan:\n                if p.act == \"travel\":\n                    duration = p.duration.seconds * freq / 3600\n                    travel_time += duration\n\n                    if p.end_location.area == \"Westminster,City of London\":\n                        if person.attributes[\"inc\"] == \"low\":\n                            low_income_central_trips += freq\n\n                        elif person.attributes[\"inc\"] == \"high\":\n                            high_income_central_trips += freq\n\n                else:  # activity\n                    if p.act == \"home\":\n                        duration = p.duration.seconds * freq / 3600\n                        time_at_home += duration\n\n    print(f\"Population total time at home: {time_at_home/1000000:.2f} million hours\")\n    print(f\"Population total travel time: {travel_time/1000000:.2f} million hours\")\n    print(f\"Low income trips to Central London: {low_income_central_trips} trips\")\n    print(f\"High income trips to Central London: {high_income_central_trips} trips\")\n</pre> def print_simple_stats(population):     \"\"\"Print some simple population statistics.\"\"\"     time_at_home = 0     travel_time = 0     low_income_central_trips = 0     high_income_central_trips = 0      for hh in population.households.values():         for person in hh.people.values():             freq = person.freq              for p in person.plan:                 if p.act == \"travel\":                     duration = p.duration.seconds * freq / 3600                     travel_time += duration                      if p.end_location.area == \"Westminster,City of London\":                         if person.attributes[\"inc\"] == \"low\":                             low_income_central_trips += freq                          elif person.attributes[\"inc\"] == \"high\":                             high_income_central_trips += freq                  else:  # activity                     if p.act == \"home\":                         duration = p.duration.seconds * freq / 3600                         time_at_home += duration      print(f\"Population total time at home: {time_at_home/1000000:.2f} million hours\")     print(f\"Population total travel time: {travel_time/1000000:.2f} million hours\")     print(f\"Low income trips to Central London: {low_income_central_trips} trips\")     print(f\"High income trips to Central London: {high_income_central_trips} trips\") In\u00a0[7]: Copied! <pre>print_simple_stats(population)\n</pre> print_simple_stats(population) <pre>Population total time at home: 0.76 million hours\nPopulation total travel time: 0.03 million hours\nLow income trips to Central London: 3000 trips\nHigh income trips to Central London: 4000 trips\n</pre> In\u00a0[8]: Copied! <pre>def plot_simple_stats(population):\n\"\"\"Plot some simple population statistics.\"\"\"\n    geoms = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\"))\n\n    departures = defaultdict(int)\n    arrivals = defaultdict(int)\n\n    for _hid, hh in population.households.items():\n        for _pid, person in hh.people.items():\n            freq = person.freq\n\n            for p in person.plan:\n                if p.act == \"travel\":\n                    departures[p.start_location.area] += freq\n                    arrivals[p.end_location.area] += freq\n    geoms[\"departures\"] = geoms.NAME.map(departures)\n    geoms[\"arrivals\"] = geoms.NAME.map(arrivals)\n\n    fig, ax = plt.subplots(1, 2, figsize=(16, 6))\n    for i, name in enumerate([\"departures\", \"arrivals\"]):\n        ax[i].title.set_text(name)\n        geoms.plot(name, ax=ax[i])\n        ax[i].axis(\"off\")\n</pre> def plot_simple_stats(population):     \"\"\"Plot some simple population statistics.\"\"\"     geoms = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\"))      departures = defaultdict(int)     arrivals = defaultdict(int)      for _hid, hh in population.households.items():         for _pid, person in hh.people.items():             freq = person.freq              for p in person.plan:                 if p.act == \"travel\":                     departures[p.start_location.area] += freq                     arrivals[p.end_location.area] += freq     geoms[\"departures\"] = geoms.NAME.map(departures)     geoms[\"arrivals\"] = geoms.NAME.map(arrivals)      fig, ax = plt.subplots(1, 2, figsize=(16, 6))     for i, name in enumerate([\"departures\", \"arrivals\"]):         ax[i].title.set_text(name)         geoms.plot(name, ax=ax[i])         ax[i].axis(\"off\") In\u00a0[9]: Copied! <pre>plot_simple_stats(population)\n</pre> plot_simple_stats(population) In\u00a0[10]: Copied! <pre>policy1 = policy.HouseholdQuarantined(probability=0.025)\npolicy2 = policy.PersonStayAtHome(probability=0.1)\npolicy3 = policy.RemoveHouseholdActivities([\"education\", \"work\"], probability=0.9)\n\ndo_minimum = apply_policies(population, [policy1, policy2])\nlockdown = apply_policies(population, [policy1, policy2, policy3])\n</pre> policy1 = policy.HouseholdQuarantined(probability=0.025) policy2 = policy.PersonStayAtHome(probability=0.1) policy3 = policy.RemoveHouseholdActivities([\"education\", \"work\"], probability=0.9)  do_minimum = apply_policies(population, [policy1, policy2]) lockdown = apply_policies(population, [policy1, policy2, policy3]) In\u00a0[11]: Copied! <pre>print_simple_stats(do_minimum)\nplot_simple_stats(do_minimum)\n</pre> print_simple_stats(do_minimum) plot_simple_stats(do_minimum) <pre>Population total time at home: 0.64 million hours\nPopulation total travel time: 0.02 million hours\nLow income trips to Central London: 3000 trips\nHigh income trips to Central London: 3000 trips\n</pre> In\u00a0[12]: Copied! <pre>print_simple_stats(lockdown)\nplot_simple_stats(lockdown)\n</pre> print_simple_stats(lockdown) plot_simple_stats(lockdown) <pre>Population total time at home: 0.11 million hours\nPopulation total travel time: 0.00 million hours\nLow income trips to Central London: 1000 trips\nHigh income trips to Central London: 0 trips\n</pre> In\u00a0[13]: Copied! <pre>do_minimum.to_csv(os.path.join(\"tmp\", \"do_min\"))\nlockdown.to_csv(os.path.join(\"tmp\", \"lockdown\"))\n</pre> do_minimum.to_csv(os.path.join(\"tmp\", \"do_min\")) lockdown.to_csv(os.path.join(\"tmp\", \"lockdown\"))"},{"location":"examples/03_read_modify_write/#pam-read-modify-write","title":"PAM Read-Modify-Write\u00b6","text":"<p>This notebook is an introduction to the basic read - modify - write use case of PAM:</p> <ul> <li>Read: Load activity plans from existing data (either tabular or MATSim)</li> <li>Modify: Use the PAM api to modify the activity plans</li> <li>Write: Write activity plans back to disk in the chosen format</li> </ul> <p>For this example, we use policies to make our modifications. But you might also try the following:</p> <ul> <li>spatial sampling</li> <li>location modelling</li> <li>rescheduling</li> <li>adding noise</li> <li>simulating aging or the passing of time</li> <li>and so on...</li> </ul>"},{"location":"examples/03_read_modify_write/#load-data","title":"Load Data\u00b6","text":"<p>Here we load simple travel diary data of London commuters. This is a very simple 0.1% sample of data about work and education commutes from the 2011 census. Because we're sharing this data, we've aggregated locations to borough level and randomized personal attributes; so, don't get too excited about the results.</p> <p>The data is available in the <code>data/example_data</code> sub-directory. All data paths in this example are relative to the notebook directory in the PAM repository</p>"},{"location":"examples/03_read_modify_write/#read","title":"Read\u00b6","text":"<p>First we load example travel diary data to Activity Plans. This data represents 2011 baseline London population of commuters.</p>"},{"location":"examples/03_read_modify_write/#modify","title":"Modify\u00b6","text":"<p>Our 2011 baseline London population of commuters seems sensible, they spend about 50 million hours at home and 1.6 million hours travelling.</p> <p>But what if we want to try and build some more up to date scenarios?</p> <p>We consider two scenarios from a combination of policies:</p> <p>Scenario A - Do Minimum:</p> <ol> <li>A household will be quarantined with p=0.025 (for example due to a possitive virus test within the household)</li> <li>A person will be staying at home (self isolating) with p=0.1 (for example due to being a vulnerable person)</li> </ol> <p>Scenario B - Lockdown:</p> <ol> <li>As above plus education and work activities will be removed and plans adjusted with p=0.9 (for example because schools and work places are closed)</li> </ol>"},{"location":"examples/03_read_modify_write/#write","title":"Write\u00b6","text":"<p>Assuming we are happy with our modified activity sequences we can write them to disk in our desired format. For this example we haven't prepared the population for MATSim so we write to disk as travel plans/diaries:</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/","title":"Freight Synthesis","text":"In\u00a0[1]: Copied! <pre>import os\nfrom datetime import date\n\nimport geopandas as gp\nimport matplotlib\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom pam.core import Household, Person, Population\nfrom pam.samplers import tour\nfrom pam.samplers.facility import FacilitySampler\nfrom pam.write import write_matsim\n\nmatplotlib.style.use(\"ggplot\")\n</pre> import os from datetime import date  import geopandas as gp import matplotlib import numpy as np import pandas as pd from matplotlib import pyplot as plt  from pam.core import Household, Person, Population from pam.samplers import tour from pam.samplers.facility import FacilitySampler from pam.write import write_matsim  matplotlib.style.use(\"ggplot\") In\u00a0[2]: Copied! <pre>output_path = \"./data/outputs\"\n</pre> output_path = \"./data/outputs\" In\u00a0[3]: Copied! <pre>zones = gp.read_file(\"./data/lsoas/LSOA_2004_London_Low_Resolution.shp\")\nzones = zones.set_crs(\"EPSG:27700\", allow_override=True)\nzones = zones.rename(columns={\"LSOA_CODE\": \"zone\"})\nzones.plot()\nplt.show()\n</pre> zones = gp.read_file(\"./data/lsoas/LSOA_2004_London_Low_Resolution.shp\") zones = zones.set_crs(\"EPSG:27700\", allow_override=True) zones = zones.rename(columns={\"LSOA_CODE\": \"zone\"}) zones.plot() plt.show() In\u00a0[4]: Copied! <pre># load facilities\nfacilities = gp.read_file(\"./data/londinium_facilities_sample.geojson\")\nfacilities = facilities.set_crs(\"EPSG:27700\", allow_override=True)\n\n# dummy create depots and deliveries\nfacilities[\"activity\"] = np.where(facilities[\"activity\"] == \"shop\", \"depot\", facilities[\"activity\"])\nfacilities[\"activity\"] = np.where(\n    facilities[\"activity\"] == \"leisure\", \"delivery\", facilities[\"activity\"]\n)\n\nfacilities.plot()\n</pre> # load facilities facilities = gp.read_file(\"./data/londinium_facilities_sample.geojson\") facilities = facilities.set_crs(\"EPSG:27700\", allow_override=True)  # dummy create depots and deliveries facilities[\"activity\"] = np.where(facilities[\"activity\"] == \"shop\", \"depot\", facilities[\"activity\"]) facilities[\"activity\"] = np.where(     facilities[\"activity\"] == \"leisure\", \"delivery\", facilities[\"activity\"] )  facilities.plot() Out[4]: <pre>&lt;Axes: &gt;</pre> <p>The zones data is for all of London, below, we crop the zones data to the Londinium study area.</p> In\u00a0[5]: Copied! <pre>cols = list(zones.columns)\n\nzones_londinium = gp.sjoin(zones, facilities, how=\"inner\", predicate=\"intersects\")\nzones_londinium = zones_londinium[cols]\nzones = zones_londinium.drop_duplicates()\nzones = zones.set_index(\"zone\")\n</pre> cols = list(zones.columns)  zones_londinium = gp.sjoin(zones, facilities, how=\"inner\", predicate=\"intersects\") zones_londinium = zones_londinium[cols] zones = zones_londinium.drop_duplicates() zones = zones.set_index(\"zone\") In\u00a0[6]: Copied! <pre>facility_sampler = FacilitySampler(\n    facilities=facilities, zones=zones, build_xml=True, fail=False, random_default=True\n)\n\nfacility_sampler.activities\n</pre> facility_sampler = FacilitySampler(     facilities=facilities, zones=zones, build_xml=True, fail=False, random_default=True )  facility_sampler.activities <pre>Joining facilities data to zones, this may take a while.\nBuilding sampler, this may take a while.\n</pre> Out[6]: <pre>['home',\n 'pub',\n 'park',\n 'depot',\n 'other',\n 'transit',\n 'education',\n 'medical',\n 'gym',\n 'work',\n 'delivery']</pre> In\u00a0[7]: Copied! <pre># Create a facility zone dataset to be used in samplers\nfacility_zone = gp.sjoin(facilities, zones, how=\"inner\", predicate=\"intersects\")\nfacility_zone = facility_zone.rename(columns={\"index_right\": \"zone\"})\nfacility_zone = facility_zone.set_index(\"zone\")\n</pre> # Create a facility zone dataset to be used in samplers facility_zone = gp.sjoin(facilities, zones, how=\"inner\", predicate=\"intersects\") facility_zone = facility_zone.rename(columns={\"index_right\": \"zone\"}) facility_zone = facility_zone.set_index(\"zone\") In\u00a0[8]: Copied! <pre>bins = range(3, 12)\npivots = {3: 36.0, 4: 28.0, 5: 15.0, 6: 7.0, 7: 4.0, 8: 2.5, 9: 2.5, 10: 1.0, 11: 4.0}\nstop_sampler = tour.PivotDistributionSampler(bins=bins, pivots=pivots)\nstop_sampler.plot(plot_title=\"Stops Distribution\", x_label=\"Stops\", y_label=\"Frequency\")\n</pre> bins = range(3, 12) pivots = {3: 36.0, 4: 28.0, 5: 15.0, 6: 7.0, 7: 4.0, 8: 2.5, 9: 2.5, 10: 1.0, 11: 4.0} stop_sampler = tour.PivotDistributionSampler(bins=bins, pivots=pivots) stop_sampler.plot(plot_title=\"Stops Distribution\", x_label=\"Stops\", y_label=\"Frequency\") Out[8]: In\u00a0[9]: Copied! <pre># Set up freight params for both LGV and HGV movements\nlgv_params = {\n    \"total\": 2500,\n    \"pivots\": {\n        7: 14,\n        8: 9,\n        9: 13,\n        10: 16,\n        11: 18,\n        12: 13,\n        13: 15,\n        14: 16,\n        15: 14,\n        16: 13,\n        17: 9,\n        18: 5,\n        19: 3,\n        20: 3,\n        21: 3,\n        22: 2,\n    },\n    \"agent_id\": \"LGV\",\n    \"agent_attributes\": \"lgv\",\n}\n</pre> # Set up freight params for both LGV and HGV movements lgv_params = {     \"total\": 2500,     \"pivots\": {         7: 14,         8: 9,         9: 13,         10: 16,         11: 18,         12: 13,         13: 15,         14: 16,         15: 14,         16: 13,         17: 9,         18: 5,         19: 3,         20: 3,         21: 3,         22: 2,     },     \"agent_id\": \"LGV\",     \"agent_attributes\": \"lgv\", } <p>Below, we decide if we will use the LGV or HGV parameters defined above.</p> In\u00a0[10]: Copied! <pre>freight_params = lgv_params.copy()\n</pre> freight_params = lgv_params.copy() In\u00a0[11]: Copied! <pre># Create Distribution\nbins = range(0, 24)\n\nhour_sampler = tour.PivotDistributionSampler(\n    bins=bins, pivots=freight_params[\"pivots\"], total=freight_params[\"total\"]\n)\nhour_sampler.plot(\n    plot_title=f\"{freight_params['agent_id']} Distribution\", x_label=\"Hour\", y_label=\"Frequency\"\n)\n</pre> # Create Distribution bins = range(0, 24)  hour_sampler = tour.PivotDistributionSampler(     bins=bins, pivots=freight_params[\"pivots\"], total=freight_params[\"total\"] ) hour_sampler.plot(     plot_title=f\"{freight_params['agent_id']} Distribution\", x_label=\"Hour\", y_label=\"Frequency\" ) Out[11]: In\u00a0[12]: Copied! <pre># Create a minute sampler\nminute_sampler = tour.FrequencySampler(range(60))\nminute_sampler.sample()\n</pre> # Create a minute sampler minute_sampler = tour.FrequencySampler(range(60)) minute_sampler.sample() Out[12]: <pre>54</pre> In\u00a0[13]: Copied! <pre>origin_density = tour.create_density_gdf(\n    facility_zone=facility_zone, zone=zones, activity=[\"depot\"]\n)\ndestination_density = tour.create_density_gdf(\n    facility_zone=facility_zone, zone=zones, activity=[\"delivery\"]\n)\n</pre> origin_density = tour.create_density_gdf(     facility_zone=facility_zone, zone=zones, activity=[\"depot\"] ) destination_density = tour.create_density_gdf(     facility_zone=facility_zone, zone=zones, activity=[\"delivery\"] ) In\u00a0[14]: Copied! <pre># Input Demand, in this case defined as facility density location\ndepot_sampler = tour.FrequencySampler(origin_density.index, origin_density.density)\n</pre> # Input Demand, in this case defined as facility density location depot_sampler = tour.FrequencySampler(origin_density.index, origin_density.density) In\u00a0[15]: Copied! <pre># Constraint, defined as distance between origin and destination centroids. This dataframe will be filtered based on threshold values defined later.\nzones_list = np.array(zones.centroid.apply(lambda x: [x.x, x.y]).to_list())\nod_matrix = np.linalg.norm(zones_list[:, None, :] - zones_list[None, :, :], axis=-1)\ndf_od = pd.DataFrame(od_matrix, index=zones.index, columns=zones.index)\n</pre> # Constraint, defined as distance between origin and destination centroids. This dataframe will be filtered based on threshold values defined later. zones_list = np.array(zones.centroid.apply(lambda x: [x.x, x.y]).to_list()) od_matrix = np.linalg.norm(zones_list[:, None, :] - zones_list[None, :, :], axis=-1) df_od = pd.DataFrame(od_matrix, index=zones.index, columns=zones.index) In\u00a0[16]: Copied! <pre># Factor to scale trips (To better match validation counts when needed)\nfactor = 1\n\n# Sample Size\nsamples = [0.01]  # increase\n\n# Set Distance threshold, in this case arbitrarily set to median distance of od dataframe.\nthreshold_value = df_od.median().agg(\"median\")\n\n# used for fnames\ntoday = date.today().strftime(\"%d%b%y\")\ntoday\n</pre> # Factor to scale trips (To better match validation counts when needed) factor = 1  # Sample Size samples = [0.01]  # increase  # Set Distance threshold, in this case arbitrarily set to median distance of od dataframe. threshold_value = df_od.median().agg(\"median\")  # used for fnames today = date.today().strftime(\"%d%b%y\") today Out[16]: <pre>'09Aug23'</pre> In\u00a0[17]: Copied! <pre>#### Sample Agents\n\n\ndef sample_agents(size):\n    facility_sampler.clear()\n    population = Population()\n\n    for i in range(size):\n        agent_id = f\"{freight_params['agent_id']}_{i}\"\n\n        hh = Household(agent_id)\n\n        agent = Person(\n            agent_id,\n            freq=100,\n            attributes={\n                \"subpopulation\": freight_params[\"agent_attributes\"],\n                \"CarType\": freight_params[\"agent_attributes\"],\n                \"CarCO2\": freight_params[\"agent_attributes\"],\n            },\n        )\n\n        hh.add(agent)\n        population.add(hh)\n\n        hour = hour_sampler.sample()\n        minute = minute_sampler.sample()\n        o_zone = depot_sampler.sample()\n\n        stops = stop_sampler.sample() if freight_params[\"agent_id\"] == \"LGV\" else 1\n\n        agent_plan = tour.TourPlanner(\n            stops=stops,\n            hour=hour,\n            minute=minute,\n            o_zone=o_zone,\n            d_dist=destination_density,\n            d_freq=\"density\",\n            threshold_matrix=df_od,\n            threshold_value=threshold_value,\n            facility_sampler=facility_sampler,\n            activity_params={\"o_activity\": \"depot\", \"d_activity\": \"delivery\"},\n        )\n\n        o_loc, d_zones, d_locs = agent_plan.sequence_stops()\n        agent_plan.apply(agent=agent, o_loc=o_loc, d_zones=d_zones, d_locs=d_locs)\n\n    return population\n</pre> #### Sample Agents   def sample_agents(size):     facility_sampler.clear()     population = Population()      for i in range(size):         agent_id = f\"{freight_params['agent_id']}_{i}\"          hh = Household(agent_id)          agent = Person(             agent_id,             freq=100,             attributes={                 \"subpopulation\": freight_params[\"agent_attributes\"],                 \"CarType\": freight_params[\"agent_attributes\"],                 \"CarCO2\": freight_params[\"agent_attributes\"],             },         )          hh.add(agent)         population.add(hh)          hour = hour_sampler.sample()         minute = minute_sampler.sample()         o_zone = depot_sampler.sample()          stops = stop_sampler.sample() if freight_params[\"agent_id\"] == \"LGV\" else 1          agent_plan = tour.TourPlanner(             stops=stops,             hour=hour,             minute=minute,             o_zone=o_zone,             d_dist=destination_density,             d_freq=\"density\",             threshold_matrix=df_od,             threshold_value=threshold_value,             facility_sampler=facility_sampler,             activity_params={\"o_activity\": \"depot\", \"d_activity\": \"delivery\"},         )          o_loc, d_zones, d_locs = agent_plan.sequence_stops()         agent_plan.apply(agent=agent, o_loc=o_loc, d_zones=d_zones, d_locs=d_locs)      return population In\u00a0[18]: Copied! <pre># Function to build population\n\n\ndef build_population(sample, factor):\n    population = sample_agents(int(factor * int(freight_params[\"total\"] * sample)))\n\n    return population\n</pre> # Function to build population   def build_population(sample, factor):     population = sample_agents(int(factor * int(freight_params[\"total\"] * sample)))      return population In\u00a0[19]: Copied! <pre># Build + Crop + Write Population for samples\nfor s in samples:\n    # build\n    population = build_population(s, factor)\n\n    # Crop and Validate Plans\n    population.fix_plans()\n    population.validate()\n\n    # Write to Disk\n    xml_comment = f\"prelim {s*100}% {freight_params['agent_id']} {today}\"\n    output_path = os.path.join(output_path)\n\n    write_matsim(\n        population,\n        os.path.join(output_path, \"plans.xml\"),\n        os.path.join(output_path, \"attributes.xml\"),\n        comment=xml_comment,\n    )\n\n    population.to_csv(output_path, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\")\n\n    facility_sampler.write_facilities_xml(\n        os.path.join(output_path, \"facilities.xml\"), comment=xml_comment\n    )\n</pre> # Build + Crop + Write Population for samples for s in samples:     # build     population = build_population(s, factor)      # Crop and Validate Plans     population.fix_plans()     population.validate()      # Write to Disk     xml_comment = f\"prelim {s*100}% {freight_params['agent_id']} {today}\"     output_path = os.path.join(output_path)      write_matsim(         population,         os.path.join(output_path, \"plans.xml\"),         os.path.join(output_path, \"attributes.xml\"),         comment=xml_comment,     )      population.to_csv(output_path, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\")      facility_sampler.write_facilities_xml(         os.path.join(output_path, \"facilities.xml\"), comment=xml_comment     ) <pre>WARNING:root:parameter \"attributes_path\" is no longer supported by write_matsim()\n</pre> In\u00a0[20]: Copied! <pre>trips = pd.read_csv(os.path.join(output_path, \"legs.csv\"))\n\n\ndef get_hour(dt):\n    return int(dt.split(\" \")[1].split(\":\")[0])\n\n\ntrips[\"start_hour\"] = trips[\"tst\"].apply(get_hour)\n</pre> trips = pd.read_csv(os.path.join(output_path, \"legs.csv\"))   def get_hour(dt):     return int(dt.split(\" \")[1].split(\":\")[0])   trips[\"start_hour\"] = trips[\"tst\"].apply(get_hour) In\u00a0[21]: Copied! <pre>freight_density = tour.ValidateTourOD(\n    trips=trips,\n    zone=zones,\n    o_dist=origin_density,\n    d_dist=destination_density,\n    o_activity=\"depot\",\n    d_activity=\"delivery\",\n    o_freq=\"density\",\n    d_freq=\"density\",\n)\n</pre> freight_density = tour.ValidateTourOD(     trips=trips,     zone=zones,     o_dist=origin_density,     d_dist=destination_density,     o_activity=\"depot\",     d_activity=\"delivery\",     o_freq=\"density\",     d_freq=\"density\", ) In\u00a0[22]: Copied! <pre>freight_density.plot_validate_spatial_density(\n    title_1=\"Depot Density (origin)\",\n    title_2=\"Trips from Depot (origin)\",\n    density_metric=\"depot_density\",\n    density_trips=\"origin_trips\",\n)\n</pre> freight_density.plot_validate_spatial_density(     title_1=\"Depot Density (origin)\",     title_2=\"Trips from Depot (origin)\",     density_metric=\"depot_density\",     density_trips=\"origin_trips\", ) Out[22]: In\u00a0[23]: Copied! <pre>freight_density.plot_validate_spatial_density(\n    title_1=\"Delivery Density (destination)\",\n    title_2=\"Trips to Delivery (destination)\",\n    density_metric=\"delivery_density\",\n    density_trips=\"destination_trips\",\n)\n</pre> freight_density.plot_validate_spatial_density(     title_1=\"Delivery Density (destination)\",     title_2=\"Trips to Delivery (destination)\",     density_metric=\"delivery_density\",     density_trips=\"destination_trips\", ) Out[23]: In\u00a0[24]: Copied! <pre>freight_density.plot_compare_density(\n    title_1=\"Depot Density vs. Origin Trips\",\n    title_2=\"Delivery Density vs. Destination Trips\",\n    o_activity=\"depot_density\",\n    d_activity=\"delivery_density\",\n)\n</pre> freight_density.plot_compare_density(     title_1=\"Depot Density vs. Origin Trips\",     title_2=\"Delivery Density vs. Destination Trips\",     o_activity=\"depot_density\",     d_activity=\"delivery_density\", ) Out[24]:"},{"location":"examples/13_Advanced_Freight_Synthesis/#freight-synthesis","title":"Freight Synthesis\u00b6","text":"<p>This notebook simulates freight trips and generates a freight population file.</p> <p>The following steps are undertaken:</p> <ol> <li>Read, process, and plot data</li> <li>Input Assumptions &amp; Sampler Creation</li> <li>Create Activity Model &amp; Population</li> <li>Validation</li> </ol>"},{"location":"examples/13_Advanced_Freight_Synthesis/#1-read-process-plot-data","title":"1. Read, process, plot Data\u00b6","text":"<p>Below, we load in data required to build a tour plan: zones and facilities data.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#2-input-assumptions","title":"2. Input Assumptions\u00b6","text":"<p>We create a series of samplers that will serve as inputs into the activity model. These samplers include:</p> <ul> <li>Number of Stops</li> <li>Freight Hourly Demand</li> <li>Origin (in this case, Depot) location</li> </ul>"},{"location":"examples/13_Advanced_Freight_Synthesis/#number-of-stops","title":"Number of Stops\u00b6","text":"<p>Build a Stop Number distribution and corresponding sampler.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#freight-hourly-demand","title":"Freight Hourly Demand\u00b6","text":"<p>Hourly demand is a distribution created based on the pivots input. We use the class PivotDistributionSampler to translate 'pivots' into a distribution, plot, and sampler.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#input-demand-constraints","title":"Input Demand &amp; Constraints\u00b6","text":"<p>We calculate the density of depots and deliveries across all zones. This information will be utilised by the class FrequencySampler to create a distribution. We also create an origin/destination matrix of distances between centroids that will be used to selected the destination locations.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#3-activity-modeller","title":"3. Activity Modeller\u00b6","text":"<p>Parameters are defined to model a population of activity plans. Activities are encoded as \"car\". Subpopulation is encoded as \"lgv\" or \"hgv\".</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#population-parameters","title":"Population Parameters\u00b6","text":""},{"location":"examples/13_Advanced_Freight_Synthesis/#activity-modeller","title":"Activity Modeller\u00b6","text":""},{"location":"examples/13_Advanced_Freight_Synthesis/#4-validation","title":"4. Validation\u00b6","text":""},{"location":"examples/07_travel_survey_to_matsim/","title":"Converting the National Travel Survey into a Simple MATSim Format Population","text":"In\u00a0[1]: Copied! <pre>import os\nfrom copy import deepcopy\n\nimport geopandas as gp\nimport pandas as pd\n\nfrom pam import read, write\nfrom pam.core import Population\nfrom pam.plot.stats import plot_activity_times, plot_leg_times\nfrom pam.samplers.basic import freq_sample\nfrom pam.samplers.spatial import RandomPointSampler\n</pre> import os from copy import deepcopy  import geopandas as gp import pandas as pd  from pam import read, write from pam.core import Population from pam.plot.stats import plot_activity_times, plot_leg_times from pam.samplers.basic import freq_sample from pam.samplers.spatial import RandomPointSampler In\u00a0[2]: Copied! <pre>use_dummy_data = True\n</pre> use_dummy_data = True In\u00a0[3]: Copied! <pre>out_dir = \"./outputs\"  # outputs are writen here\n\n# required inputs from the National Travel Survey\nif use_dummy_data:\n    households_csv = \"./data/dummyNTS/householdeul2017.tab\"\n    individuals_csv = \"./data/dummyNTS/individualeul2017.tab\"\n    trips_csv = \"./data/dummyNTS/tripeul2017.tab\"\n\nelse:\n    households_csv = \"~/Data/UKDA-5340-tab/tab/householdeul2017.tab\"\n    individuals_csv = \"~/Data/UKDA-5340-tab/tab/individualeul2017.tab\"\n    trips_csv = \"~/Data/UKDA-5340-tab/tab/tripeul2017.tab\"\n</pre> out_dir = \"./outputs\"  # outputs are writen here  # required inputs from the National Travel Survey if use_dummy_data:     households_csv = \"./data/dummyNTS/householdeul2017.tab\"     individuals_csv = \"./data/dummyNTS/individualeul2017.tab\"     trips_csv = \"./data/dummyNTS/tripeul2017.tab\"  else:     households_csv = \"~/Data/UKDA-5340-tab/tab/householdeul2017.tab\"     individuals_csv = \"~/Data/UKDA-5340-tab/tab/individualeul2017.tab\"     trips_csv = \"~/Data/UKDA-5340-tab/tab/tripeul2017.tab\" In\u00a0[4]: Copied! <pre>hh_in = pd.read_csv(\n    households_csv,\n    sep=\"\\t\",\n    usecols=[\n        \"HouseholdID\",\n        \"SurveyYear\",\n        \"PSUID\",\n        \"W2\",\n        \"OutCom_B02ID\",\n        \"HHIncome2002_B02ID\",\n        \"AddressType_B01ID\",\n        \"Ten1_B02ID\",\n        \"Landlord_B01ID\",\n        \"ResLength_B01ID\",\n        \"HHoldCountry_B01ID\",\n        \"HHoldGOR_B02ID\",\n        \"HHoldNumAdults\",\n        \"HHoldNumChildren\",\n        \"HHoldNumPeople\",\n        \"HHoldStruct_B02ID\",\n        \"NumLicHolders\",\n        \"HHoldEmploy_B01ID\",\n        \"NumVehicles\",\n        \"NumBike\",\n        \"NumCar\",\n        \"NumMCycle\",\n        \"NumVanLorry\",\n        \"NumCarVan\",\n        \"WalkBus_B01ID\",\n        \"Getbus_B01ID\",\n        \"WalkRail_B01ID\",\n        \"WalkRailAlt_B01ID\",\n        \"HRPWorkStat_B02ID\",\n        \"HRPSEGWorkStat_B01ID\",\n        \"HHoldOAClass2011_B03ID\",\n        \"Settlement2011EW_B03ID\",\n        \"Settlement2011EW_B04ID\",\n    ],\n)\n\nhh_in.HHIncome2002_B02ID = pd.to_numeric(hh_in.HHIncome2002_B02ID, errors=\"coerce\")\nhh_in.NumLicHolders = pd.to_numeric(hh_in.NumLicHolders, errors=\"coerce\")\nhh_in.NumVehicles = pd.to_numeric(hh_in.NumVehicles, errors=\"coerce\")\nhh_in.NumCar = pd.to_numeric(hh_in.NumCar, errors=\"coerce\")\nhh_in.NumMCycle = pd.to_numeric(hh_in.NumMCycle, errors=\"coerce\")\nhh_in.NumVanLorry = pd.to_numeric(hh_in.NumVanLorry, errors=\"coerce\")\nhh_in.NumCarVan = pd.to_numeric(hh_in.NumCarVan, errors=\"coerce\")\nhh_in.Settlement2011EW_B04ID = pd.to_numeric(hh_in.Settlement2011EW_B04ID, errors=\"coerce\")\n\nhh_in.head()\n</pre> hh_in = pd.read_csv(     households_csv,     sep=\"\\t\",     usecols=[         \"HouseholdID\",         \"SurveyYear\",         \"PSUID\",         \"W2\",         \"OutCom_B02ID\",         \"HHIncome2002_B02ID\",         \"AddressType_B01ID\",         \"Ten1_B02ID\",         \"Landlord_B01ID\",         \"ResLength_B01ID\",         \"HHoldCountry_B01ID\",         \"HHoldGOR_B02ID\",         \"HHoldNumAdults\",         \"HHoldNumChildren\",         \"HHoldNumPeople\",         \"HHoldStruct_B02ID\",         \"NumLicHolders\",         \"HHoldEmploy_B01ID\",         \"NumVehicles\",         \"NumBike\",         \"NumCar\",         \"NumMCycle\",         \"NumVanLorry\",         \"NumCarVan\",         \"WalkBus_B01ID\",         \"Getbus_B01ID\",         \"WalkRail_B01ID\",         \"WalkRailAlt_B01ID\",         \"HRPWorkStat_B02ID\",         \"HRPSEGWorkStat_B01ID\",         \"HHoldOAClass2011_B03ID\",         \"Settlement2011EW_B03ID\",         \"Settlement2011EW_B04ID\",     ], )  hh_in.HHIncome2002_B02ID = pd.to_numeric(hh_in.HHIncome2002_B02ID, errors=\"coerce\") hh_in.NumLicHolders = pd.to_numeric(hh_in.NumLicHolders, errors=\"coerce\") hh_in.NumVehicles = pd.to_numeric(hh_in.NumVehicles, errors=\"coerce\") hh_in.NumCar = pd.to_numeric(hh_in.NumCar, errors=\"coerce\") hh_in.NumMCycle = pd.to_numeric(hh_in.NumMCycle, errors=\"coerce\") hh_in.NumVanLorry = pd.to_numeric(hh_in.NumVanLorry, errors=\"coerce\") hh_in.NumCarVan = pd.to_numeric(hh_in.NumCarVan, errors=\"coerce\") hh_in.Settlement2011EW_B04ID = pd.to_numeric(hh_in.Settlement2011EW_B04ID, errors=\"coerce\")  hh_in.head() Out[4]: HouseholdID SurveyYear PSUID W2 OutCom_B02ID HHIncome2002_B02ID AddressType_B01ID Ten1_B02ID Landlord_B01ID ResLength_B01ID ... NumCarVan WalkBus_B01ID Getbus_B01ID WalkRail_B01ID WalkRailAlt_B01ID HRPWorkStat_B02ID HRPSEGWorkStat_B01ID HHoldOAClass2011_B03ID Settlement2011EW_B03ID Settlement2011EW_B04ID 0 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1 2 2002 1 1 1 1 3 1 -10 8 ... 0 1 5 2 -9 3 5 -10 1 1 2 3 2002 1 1 1 3 3 1 -10 8 ... 2 1 4 3 -9 1 3 -10 1 1 <p>3 rows \u00d7 33 columns</p> In\u00a0[5]: Copied! <pre>participation_mapping = dict(zip(hh_in.HouseholdID, hh_in.OutCom_B02ID))\nweight_mapping = dict(zip(hh_in.HouseholdID, hh_in.W2))\n</pre> participation_mapping = dict(zip(hh_in.HouseholdID, hh_in.OutCom_B02ID)) weight_mapping = dict(zip(hh_in.HouseholdID, hh_in.W2)) In\u00a0[6]: Copied! <pre>persons_in = pd.read_csv(\n    individuals_csv,\n    sep=\"\\t\",\n    usecols=[\n        \"SurveyYear\",\n        \"IndividualID\",\n        \"HouseholdID\",\n        \"PSUID\",\n        \"VehicleID\",\n        \"PersNo\",\n        \"Age_B01ID\",\n        \"OfPenAge_B01ID\",\n        \"Sex_B01ID\",\n        \"EdAttn1_B01ID\",\n        \"EdAttn2_B01ID\",\n        \"EdAttn3_B01ID\",\n        \"DrivLic_B02ID\",\n        \"CarAccess_B01ID\",\n        \"DrivDisable_B01ID\",\n        \"WkPlace_B01ID\",\n        \"ES2000_B01ID\",\n        \"NSSec_B03ID\",\n        \"SC_B01ID\",\n        \"Stat_B01ID\",\n        \"SVise_B01ID\",\n        \"EcoStat_B02ID\",\n        \"PossHom_B01ID\",\n    ],\n)\npersons_in.head()\n</pre> persons_in = pd.read_csv(     individuals_csv,     sep=\"\\t\",     usecols=[         \"SurveyYear\",         \"IndividualID\",         \"HouseholdID\",         \"PSUID\",         \"VehicleID\",         \"PersNo\",         \"Age_B01ID\",         \"OfPenAge_B01ID\",         \"Sex_B01ID\",         \"EdAttn1_B01ID\",         \"EdAttn2_B01ID\",         \"EdAttn3_B01ID\",         \"DrivLic_B02ID\",         \"CarAccess_B01ID\",         \"DrivDisable_B01ID\",         \"WkPlace_B01ID\",         \"ES2000_B01ID\",         \"NSSec_B03ID\",         \"SC_B01ID\",         \"Stat_B01ID\",         \"SVise_B01ID\",         \"EcoStat_B02ID\",         \"PossHom_B01ID\",     ], ) persons_in.head() Out[6]: SurveyYear IndividualID HouseholdID PSUID VehicleID PersNo Age_B01ID OfPenAge_B01ID Sex_B01ID EdAttn1_B01ID ... CarAccess_B01ID DrivDisable_B01ID WkPlace_B01ID ES2000_B01ID NSSec_B03ID SC_B01ID Stat_B01ID SVise_B01ID EcoStat_B02ID PossHom_B01ID 0 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1 2002 2 1 1 2 2 13 2 1 -10 ... 2 -9 1 7 3 4 1 2 1 2 2 2002 3 1 1 3 4 2 1 -10 ... 4 -9 -9 -9 -9 -9 -9 -9 -9 -9 3 2002 4 1 1 4 2 2 2 -10 ... 4 -9 -9 -9 -9 -9 -9 -9 -9 -9 4 2002 5 2 1 1 18 1 2 -10 ... 6 2 -9 6 1 3 1 1 4 -9 <p>5 rows \u00d7 23 columns</p> In\u00a0[7]: Copied! <pre>travel_diaries_in = pd.read_csv(\n    trips_csv,\n    sep=\"\\t\",\n    usecols=[\n        \"TripID\",\n        \"SurveyYear\",\n        \"DayID\",\n        \"IndividualID\",\n        \"HouseholdID\",\n        \"PSUID\",\n        \"PersNo\",\n        \"TravDay\",\n        \"JourSeq\",\n        \"ShortWalkTrip_B01ID\",\n        \"NumStages\",\n        \"MainMode_B04ID\",\n        \"TripPurpFrom_B01ID\",\n        \"TripPurpTo_B01ID\",\n        \"TripPurpose_B04ID\",\n        \"TripStart\",\n        \"TripEnd\",\n        \"TripOrigUA2009_B01ID\",\n        \"TripDestUA2009_B01ID\",\n    ],\n)\n\ntravel_diaries_in.TripStart = pd.to_numeric(travel_diaries_in.TripStart, errors=\"coerce\")\ntravel_diaries_in.TripEnd = pd.to_numeric(travel_diaries_in.TripEnd, errors=\"coerce\")\n\ntravel_diaries_in.head()\n</pre> travel_diaries_in = pd.read_csv(     trips_csv,     sep=\"\\t\",     usecols=[         \"TripID\",         \"SurveyYear\",         \"DayID\",         \"IndividualID\",         \"HouseholdID\",         \"PSUID\",         \"PersNo\",         \"TravDay\",         \"JourSeq\",         \"ShortWalkTrip_B01ID\",         \"NumStages\",         \"MainMode_B04ID\",         \"TripPurpFrom_B01ID\",         \"TripPurpTo_B01ID\",         \"TripPurpose_B04ID\",         \"TripStart\",         \"TripEnd\",         \"TripOrigUA2009_B01ID\",         \"TripDestUA2009_B01ID\",     ], )  travel_diaries_in.TripStart = pd.to_numeric(travel_diaries_in.TripStart, errors=\"coerce\") travel_diaries_in.TripEnd = pd.to_numeric(travel_diaries_in.TripEnd, errors=\"coerce\")  travel_diaries_in.head() Out[7]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay JourSeq ShortWalkTrip_B01ID NumStages MainMode_B04ID TripPurpose_B04ID TripPurpFrom_B01ID TripPurpTo_B01ID TripStart TripEnd TripOrigUA2009_B01ID TripDestUA2009_B01ID 0 1 2002 2 1 1 1 1 2 1 2 1 4 7 23 10 675 683 530 550 1 2 2002 2 1 1 1 1 2 2 2 1 4 6 10 8 720 735 530 550 2 3 2002 2 1 1 1 1 2 3 2 1 4 7 8 10 770 780 530 550 3 4 2002 2 1 1 1 1 2 4 2 1 12 7 10 23 1110 1130 530 550 4 5 2002 3 1 1 1 1 3 1 2 1 4 7 23 10 760 770 530 550 In\u00a0[8]: Copied! <pre>travel_diaries_in[\"participation\"] = travel_diaries_in.HouseholdID.map(participation_mapping)\ntravel_diaries_in[\"hh_weight\"] = travel_diaries_in.HouseholdID.map(weight_mapping)\n</pre> travel_diaries_in[\"participation\"] = travel_diaries_in.HouseholdID.map(participation_mapping) travel_diaries_in[\"hh_weight\"] = travel_diaries_in.HouseholdID.map(weight_mapping) In\u00a0[9]: Copied! <pre>travel_diaries = travel_diaries_in.loc[travel_diaries_in.participation.isin([1, 2])]\n</pre> travel_diaries = travel_diaries_in.loc[travel_diaries_in.participation.isin([1, 2])] In\u00a0[10]: Copied! <pre>travel_diaries.head()\n</pre> travel_diaries.head() Out[10]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay JourSeq ShortWalkTrip_B01ID ... MainMode_B04ID TripPurpose_B04ID TripPurpFrom_B01ID TripPurpTo_B01ID TripStart TripEnd TripOrigUA2009_B01ID TripDestUA2009_B01ID participation hh_weight 0 1 2002 2 1 1 1 1 2 1 2 ... 4 7 23 10 675 683 530 550 1 1 1 2 2002 2 1 1 1 1 2 2 2 ... 4 6 10 8 720 735 530 550 1 1 2 3 2002 2 1 1 1 1 2 3 2 ... 4 7 8 10 770 780 530 550 1 1 3 4 2002 2 1 1 1 1 2 4 2 ... 12 7 10 23 1110 1130 530 550 1 1 4 5 2002 3 1 1 1 1 3 1 2 ... 4 7 23 10 760 770 530 550 1 1 <p>5 rows \u00d7 21 columns</p> In\u00a0[11]: Copied! <pre>travel_diaries = travel_diaries.rename(\n    columns={  # rename data\n        \"JourSeq\": \"seq\",\n        \"TripOrigUA2009_B01ID\": \"ozone\",\n        \"TripDestUA2009_B01ID\": \"dzone\",\n        \"TripPurpFrom_B01ID\": \"oact\",\n        \"TripPurpTo_B01ID\": \"dact\",\n        \"MainMode_B04ID\": \"mode\",\n        \"TripStart\": \"tst\",\n        \"TripEnd\": \"tet\",\n    }\n)\n\ntravel_diaries.head()\n</pre> travel_diaries = travel_diaries.rename(     columns={  # rename data         \"JourSeq\": \"seq\",         \"TripOrigUA2009_B01ID\": \"ozone\",         \"TripDestUA2009_B01ID\": \"dzone\",         \"TripPurpFrom_B01ID\": \"oact\",         \"TripPurpTo_B01ID\": \"dact\",         \"MainMode_B04ID\": \"mode\",         \"TripStart\": \"tst\",         \"TripEnd\": \"tet\",     } )  travel_diaries.head() Out[11]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay seq ShortWalkTrip_B01ID ... mode TripPurpose_B04ID oact dact tst tet ozone dzone participation hh_weight 0 1 2002 2 1 1 1 1 2 1 2 ... 4 7 23 10 675 683 530 550 1 1 1 2 2002 2 1 1 1 1 2 2 2 ... 4 6 10 8 720 735 530 550 1 1 2 3 2002 2 1 1 1 1 2 3 2 ... 4 7 8 10 770 780 530 550 1 1 3 4 2002 2 1 1 1 1 2 4 2 ... 12 7 10 23 1110 1130 530 550 1 1 4 5 2002 3 1 1 1 1 3 1 2 ... 4 7 23 10 760 770 530 550 1 1 <p>5 rows \u00d7 21 columns</p> In\u00a0[12]: Copied! <pre>travel_diaries.dtypes\n</pre> travel_diaries.dtypes Out[12]: <pre>TripID                 int64\nSurveyYear             int64\nDayID                  int64\nIndividualID           int64\nHouseholdID            int64\nPSUID                  int64\nPersNo                 int64\nTravDay                int64\nseq                    int64\nShortWalkTrip_B01ID    int64\nNumStages              int64\nmode                   int64\nTripPurpose_B04ID      int64\noact                   int64\ndact                   int64\ntst                    int64\ntet                    int64\nozone                  int64\ndzone                  int64\nparticipation          int64\nhh_weight              int64\ndtype: object</pre> In\u00a0[13]: Copied! <pre>def check_uniques(df):\n    for c in df.columns:\n        print(c)\n        n = df[c].nunique()\n        if n &lt; 1000:\n            print(df[c].unique())\n</pre> def check_uniques(df):     for c in df.columns:         print(c)         n = df[c].nunique()         if n &lt; 1000:             print(df[c].unique()) In\u00a0[14]: Copied! <pre>check_uniques(travel_diaries)\n</pre> check_uniques(travel_diaries) <pre>TripID\n[  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n 145 146 147 148 149]\nSurveyYear\n[2002]\nDayID\n[ 2  3  5  6  7  8  9 10 11 12 13 14 16 17 19 20 21 23 24 26 27 28 29 30\n 33 35 36 37 38 39 40 41 42 43 44 45 46 47 49]\nIndividualID\n[1 2 3 4 5 6 7]\nHouseholdID\n[1 2 3]\nPSUID\n[1]\nPersNo\n[1 2 3 4]\nTravDay\n[2 3 5 6 7 1 4]\nseq\n[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]\nShortWalkTrip_B01ID\n[2 1]\nNumStages\n[1 4 3 2]\nmode\n[ 4 12  3  1 11  7]\nTripPurpose_B04ID\n[7 6 3 4 5 1 2]\noact\n[23 10  8 20  5  9 22  1 12  4  3  6 14  2 18]\ndact\n[10  8 23 20  5  9 22  1 12  4  3  6 14 18]\ntst\n[ 675  720  770 1110  760  790  810  845  865  908  922  940 1015 1080\n  905  738  755 1050 1220 1270  525  546  745  764 1060  833 1320  530\n 1265  605  620  960  970 1075  360  350  875  898 1310  345  870  900\n  923 1311  990  585  560  840  438 1010 1105 1112  440  965  921  980\n 1115  910  820  853 1013 1023 1298 1306  702  975 1087  495 1070 1052]\ntet\n[ 683  735  780 1130  770  805  825  852  873  914  926  955 1032 1108\n  785  917  752  761 1076 1223 1275  540  556  760  774 1127  836 1325\n  535 1272  608  675  690  962  972 1078  363 1080  355  890  912  931\n 1316  348  887  915  933 1314  855 1020  795  730  750  885  465 1036\n 1110 1120  984  950 1005  471  922  830  862  906 1023 1034 1305 1312\n  627  710  468  986 1085 1091  550 1100 1115  559]\nozone\n[530]\ndzone\n[550]\nparticipation\n[1]\nhh_weight\n[1]\n</pre> In\u00a0[15]: Copied! <pre>area_path = \"./data/dummyNTS/NTSareas.geojson\"\n</pre> area_path = \"./data/dummyNTS/NTSareas.geojson\" In\u00a0[16]: Copied! <pre>areas = gp.read_file(area_path)\nareas.head()\n</pre> areas = gp.read_file(area_path) areas.head() Out[16]: id name geometry 0 530.0 West Midlands POLYGON ((-1.95366 52.66273, -1.95457 52.66264... 1 550.0 West Yorkshire POLYGON ((-1.87994 53.95590, -1.87982 53.95681... In\u00a0[17]: Copied! <pre>areas.plot(figsize=(6, 6))\n</pre> areas.plot(figsize=(6, 6)) Out[17]: <pre>&lt;Axes: &gt;</pre> In\u00a0[18]: Copied! <pre>def remove_broken_plans(plan):\n    if plan.isnull().values.any():\n        return None\n    for col in [\"ozone\", \"dzone\"]:\n        if -8 in list(plan[col]):\n            return None\n    return plan\n</pre> def remove_broken_plans(plan):     if plan.isnull().values.any():         return None     for col in [\"ozone\", \"dzone\"]:         if -8 in list(plan[col]):             return None     return plan In\u00a0[19]: Copied! <pre>clean_travel_diaries = (\n    travel_diaries.groupby([\"IndividualID\", \"TravDay\"], group_keys=False)\n    .apply(remove_broken_plans)\n    .reset_index(drop=True)\n)\n</pre> clean_travel_diaries = (     travel_diaries.groupby([\"IndividualID\", \"TravDay\"], group_keys=False)     .apply(remove_broken_plans)     .reset_index(drop=True) ) In\u00a0[20]: Copied! <pre>clean_travel_diaries.head()\n</pre> clean_travel_diaries.head() Out[20]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay seq ShortWalkTrip_B01ID ... mode TripPurpose_B04ID oact dact tst tet ozone dzone participation hh_weight 0 1 2002 2 1 1 1 1 2 1 2 ... 4 7 23 10 675 683 530 550 1 1 1 2 2002 2 1 1 1 1 2 2 2 ... 4 6 10 8 720 735 530 550 1 1 2 3 2002 2 1 1 1 1 2 3 2 ... 4 7 8 10 770 780 530 550 1 1 3 4 2002 2 1 1 1 1 2 4 2 ... 12 7 10 23 1110 1130 530 550 1 1 4 5 2002 3 1 1 1 1 3 1 2 ... 4 7 23 10 760 770 530 550 1 1 <p>5 rows \u00d7 21 columns</p> In\u00a0[21]: Copied! <pre>print(len(travel_diaries))\nprint(len(clean_travel_diaries))\n</pre> print(len(travel_diaries)) print(len(clean_travel_diaries)) <pre>149\n149\n</pre> In\u00a0[22]: Copied! <pre>mode_mapping = {\n    1: \"walk\",\n    2: \"bike\",\n    3: \"car\",  #'Car/van driver'\n    4: \"car\",  #'Car/van driver'\n    5: \"car\",  #'Motorcycle',\n    6: \"car\",  #'Other private transport',\n    7: \"pt\",  # Bus in London',\n    8: \"pt\",  #'Other local bus',\n    9: \"pt\",  #'Non-local bus',\n    10: \"pt\",  #'London Underground',\n    11: \"pt\",  #'Surface Rail',\n    12: \"car\",  #'Taxi/minicab',\n    13: \"pt\",  #'Other public transport',\n    -10: \"DEAD\",\n    -8: \"NA\",\n}\n\npurp_mapping = {\n    1: \"work\",\n    2: \"work\",  #'In course of work',\n    3: \"education\",\n    4: \"shop\",  #'Food shopping',\n    5: \"shop\",  #'Non food shopping',\n    6: \"medical\",  #'Personal business medical',\n    7: \"other\",  #'Personal business eat/drink',\n    8: \"other\",  #'Personal business other',\n    9: \"other\",  #'Eat/drink with friends',\n    10: \"visit\",  #'Visit friends',\n    11: \"other\",  #'Other social',\n    12: \"other\",  #'Entertain/ public activity',\n    13: \"other\",  #'Sport: participate',\n    14: \"home\",  #'Holiday: base',\n    15: \"other\",  #'Day trip/just walk',\n    16: \"other\",  #'Other non-escort',\n    17: \"escort\",  #'Escort home',\n    18: \"escort\",  #'Escort work',\n    19: \"escort\",  #'Escort in course of work',\n    20: \"escort\",  #'Escort education',\n    21: \"escort\",  #'Escort shopping/personal business',\n    22: \"escort\",  #'Other escort',\n    23: \"home\",  #'Home',\n    -10: \"DEAD\",\n    -8: \"NA\",\n}\n\nclean_travel_diaries[\"mode\"] = clean_travel_diaries[\"mode\"].map(mode_mapping)\nclean_travel_diaries[\"oact\"] = clean_travel_diaries[\"oact\"].map(purp_mapping)\nclean_travel_diaries[\"dact\"] = clean_travel_diaries[\"dact\"].map(purp_mapping)\n</pre> mode_mapping = {     1: \"walk\",     2: \"bike\",     3: \"car\",  #'Car/van driver'     4: \"car\",  #'Car/van driver'     5: \"car\",  #'Motorcycle',     6: \"car\",  #'Other private transport',     7: \"pt\",  # Bus in London',     8: \"pt\",  #'Other local bus',     9: \"pt\",  #'Non-local bus',     10: \"pt\",  #'London Underground',     11: \"pt\",  #'Surface Rail',     12: \"car\",  #'Taxi/minicab',     13: \"pt\",  #'Other public transport',     -10: \"DEAD\",     -8: \"NA\", }  purp_mapping = {     1: \"work\",     2: \"work\",  #'In course of work',     3: \"education\",     4: \"shop\",  #'Food shopping',     5: \"shop\",  #'Non food shopping',     6: \"medical\",  #'Personal business medical',     7: \"other\",  #'Personal business eat/drink',     8: \"other\",  #'Personal business other',     9: \"other\",  #'Eat/drink with friends',     10: \"visit\",  #'Visit friends',     11: \"other\",  #'Other social',     12: \"other\",  #'Entertain/ public activity',     13: \"other\",  #'Sport: participate',     14: \"home\",  #'Holiday: base',     15: \"other\",  #'Day trip/just walk',     16: \"other\",  #'Other non-escort',     17: \"escort\",  #'Escort home',     18: \"escort\",  #'Escort work',     19: \"escort\",  #'Escort in course of work',     20: \"escort\",  #'Escort education',     21: \"escort\",  #'Escort shopping/personal business',     22: \"escort\",  #'Other escort',     23: \"home\",  #'Home',     -10: \"DEAD\",     -8: \"NA\", }  clean_travel_diaries[\"mode\"] = clean_travel_diaries[\"mode\"].map(mode_mapping) clean_travel_diaries[\"oact\"] = clean_travel_diaries[\"oact\"].map(purp_mapping) clean_travel_diaries[\"dact\"] = clean_travel_diaries[\"dact\"].map(purp_mapping) In\u00a0[23]: Copied! <pre># reweight and split ids for unique days\n\n\ndef reweight(group):\n\"\"\"\n    Reweight based on multiple diary days, ie if an agent has two diary days, we will treat these as\n    two unique agents, so we half the original weighting.\n    \"\"\"\n    group[\"freq\"] = group.hh_weight / group.DayID.nunique()\n    return group\n\n\ntrips = clean_travel_diaries.groupby(\"IndividualID\", group_keys=False).apply(reweight)\ntrips[\"pid\"] = [f\"{p}_{d}\" for p, d in zip(trips.IndividualID, trips.TravDay)]\ntrips[\"hid\"] = [f\"{h}_{d}\" for h, d in zip(trips.HouseholdID, trips.TravDay)]\n</pre> # reweight and split ids for unique days   def reweight(group):     \"\"\"     Reweight based on multiple diary days, ie if an agent has two diary days, we will treat these as     two unique agents, so we half the original weighting.     \"\"\"     group[\"freq\"] = group.hh_weight / group.DayID.nunique()     return group   trips = clean_travel_diaries.groupby(\"IndividualID\", group_keys=False).apply(reweight) trips[\"pid\"] = [f\"{p}_{d}\" for p, d in zip(trips.IndividualID, trips.TravDay)] trips[\"hid\"] = [f\"{h}_{d}\" for h, d in zip(trips.HouseholdID, trips.TravDay)] In\u00a0[24]: Copied! <pre>trips.head()\n</pre> trips.head() Out[24]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay seq ShortWalkTrip_B01ID ... dact tst tet ozone dzone participation hh_weight freq pid hid 0 1 2002 2 1 1 1 1 2 1 2 ... visit 675 683 530 550 1 1 0.2 1_2 1_2 1 2 2002 2 1 1 1 1 2 2 2 ... other 720 735 530 550 1 1 0.2 1_2 1_2 2 3 2002 2 1 1 1 1 2 3 2 ... visit 770 780 530 550 1 1 0.2 1_2 1_2 3 4 2002 2 1 1 1 1 2 4 2 ... home 1110 1130 530 550 1 1 0.2 1_2 1_2 4 5 2002 3 1 1 1 1 3 1 2 ... visit 760 770 530 550 1 1 0.2 1_3 1_3 <p>5 rows \u00d7 24 columns</p> In\u00a0[25]: Copied! <pre>def expand_days(\n    trips, target, trips_on=\"Diary_number\", target_on=\"Diary_number\", new_id=\"pid\", trim=True\n):\n\"\"\"\n    Expand target df based on mapping between trips target_on and new_id.\n    This is so slow. Fix\n    Set index to new_id.\n    \"\"\"\n    print(\"Building mapping.\")\n    mapping = {}\n    for i, person in trips.groupby(target_on):\n        mapping[i] = list(set(person[new_id]))\n    n = len(mapping)\n\n    if trim:\n        print(\"Trimming target.\")\n        selection = set(trips[trips_on])\n        target = target.loc[target[target_on].isin(selection)]\n\n    expanded = pd.DataFrame()\n    for p, (i, ids) in enumerate(mapping.items()):\n        if not p % 10:\n            print(f\"Building expanded data {p}/{n}\", end=\"\\r\", flush=True)\n        for idx in ids:\n            split = target.loc[target[target_on] == i]\n            expanded = pd.concat([expanded, split.assign(**{new_id: idx})])\n    expanded = expanded.set_index(new_id)\n    print(\"Done\")\n    return expanded\n</pre> def expand_days(     trips, target, trips_on=\"Diary_number\", target_on=\"Diary_number\", new_id=\"pid\", trim=True ):     \"\"\"     Expand target df based on mapping between trips target_on and new_id.     This is so slow. Fix     Set index to new_id.     \"\"\"     print(\"Building mapping.\")     mapping = {}     for i, person in trips.groupby(target_on):         mapping[i] = list(set(person[new_id]))     n = len(mapping)      if trim:         print(\"Trimming target.\")         selection = set(trips[trips_on])         target = target.loc[target[target_on].isin(selection)]      expanded = pd.DataFrame()     for p, (i, ids) in enumerate(mapping.items()):         if not p % 10:             print(f\"Building expanded data {p}/{n}\", end=\"\\r\", flush=True)         for idx in ids:             split = target.loc[target[target_on] == i]             expanded = pd.concat([expanded, split.assign(**{new_id: idx})])     expanded = expanded.set_index(new_id)     print(\"Done\")     return expanded In\u00a0[26]: Copied! <pre>hhs = expand_days(trips, hh_in, trips_on=\"HouseholdID\", target_on=\"HouseholdID\", new_id=\"hid\")\n</pre> hhs = expand_days(trips, hh_in, trips_on=\"HouseholdID\", target_on=\"HouseholdID\", new_id=\"hid\") <pre>Building mapping.\nTrimming target.\nDone\n</pre> In\u00a0[27]: Copied! <pre>hhs.head()\n</pre> hhs.head() Out[27]: HouseholdID SurveyYear PSUID W2 OutCom_B02ID HHIncome2002_B02ID AddressType_B01ID Ten1_B02ID Landlord_B01ID ResLength_B01ID ... NumCarVan WalkBus_B01ID Getbus_B01ID WalkRail_B01ID WalkRailAlt_B01ID HRPWorkStat_B02ID HRPSEGWorkStat_B01ID HHoldOAClass2011_B03ID Settlement2011EW_B03ID Settlement2011EW_B04ID hid 1_6 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_1 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_7 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_4 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_2 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 <p>5 rows \u00d7 33 columns</p> In\u00a0[28]: Copied! <pre>people = expand_days(\n    trips, persons_in, trips_on=\"IndividualID\", target_on=\"IndividualID\", new_id=\"pid\"\n)\n</pre> people = expand_days(     trips, persons_in, trips_on=\"IndividualID\", target_on=\"IndividualID\", new_id=\"pid\" ) <pre>Building mapping.\nTrimming target.\nDone\n</pre> In\u00a0[29]: Copied! <pre>people.head()\n</pre> people.head() Out[29]: SurveyYear IndividualID HouseholdID PSUID VehicleID PersNo Age_B01ID OfPenAge_B01ID Sex_B01ID EdAttn1_B01ID ... CarAccess_B01ID DrivDisable_B01ID WkPlace_B01ID ES2000_B01ID NSSec_B03ID SC_B01ID Stat_B01ID SVise_B01ID EcoStat_B02ID PossHom_B01ID pid 1_6 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_7 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_2 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_3 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_5 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 <p>5 rows \u00d7 23 columns</p> In\u00a0[30]: Copied! <pre>trips.tst = trips.tst.astype(int)\ntrips.tet = trips.tet.astype(int)\n</pre> trips.tst = trips.tst.astype(int) trips.tet = trips.tet.astype(int) In\u00a0[31]: Copied! <pre>population = read.load_travel_diary(\n    trips=trips, persons_attributes=people, hhs_attributes=hhs, trip_freq_as_person_freq=True\n)\n</pre> population = read.load_travel_diary(     trips=trips, persons_attributes=people, hhs_attributes=hhs, trip_freq_as_person_freq=True ) <pre>Using from-to activity parser using 'oact' and 'dact' columns\nAdding pid-&gt;hh mapping to persons_attributes from trips.\n\n        Unable to load household area ('hzone') - not found in trips_diary or unable to build from attributes.\n        Pam will try to infer home location from activities, but this behaviour is not recommended.\n        \nUsing freq of 'None' for all trips.\nUsing freq of 'None' for all households.\n Person pid:2_5 hid:1_5 plan does not start with 'home' activity: work\n Person pid:2_6 hid:1_6 plan does not start with 'home' activity: work\n Person pid:3_6 hid:1_6 plan does not start with 'home' activity: education\n Person pid:2_7 hid:1_7 plan does not start with 'home' activity: work\n</pre> In\u00a0[32]: Copied! <pre>population.fix_plans()\n</pre> population.fix_plans() In\u00a0[33]: Copied! <pre># this should be replaced with a more direct method\nfor hh in population.households.values():\n    for p in hh.people.values():\n        p.validate()\n</pre> # this should be replaced with a more direct method for hh in population.households.values():     for p in hh.people.values():         p.validate() In\u00a0[34]: Copied! <pre>population.size  # this also accounts for the weighting\n</pre> population.size  # this also accounts for the weighting Out[34]: <pre>3.285714285714285</pre> In\u00a0[35]: Copied! <pre>population.stats\n</pre> population.stats Out[35]: <pre>{'num_households': 18,\n 'num_people': 39,\n 'num_activities': 175,\n 'num_legs': 136}</pre> In\u00a0[36]: Copied! <pre>population.activity_classes\n</pre> population.activity_classes Out[36]: <pre>{'education', 'escort', 'home', 'medical', 'other', 'shop', 'visit', 'work'}</pre> In\u00a0[37]: Copied! <pre>population.mode_classes\n</pre> population.mode_classes Out[37]: <pre>{'car', 'pt', 'walk'}</pre> In\u00a0[38]: Copied! <pre>plot_activity_times(population)\n</pre> plot_activity_times(population) Out[38]: In\u00a0[39]: Copied! <pre>plot_leg_times(population)\n</pre> plot_leg_times(population) Out[39]: In\u00a0[40]: Copied! <pre># night shift @ 2016008863_6\n</pre> # night shift @ 2016008863_6 In\u00a0[41]: Copied! <pre>hh = population.random_household()\nhh.print()\nhh.plot()\n</pre> hh = population.random_household() hh.print() hh.plot() <pre>Household: 1_5\n{'HouseholdID': 1, 'SurveyYear': 2002, 'PSUID': 1, 'W2': 1, 'OutCom_B02ID': 1, 'HHIncome2002_B02ID': 2, 'AddressType_B01ID': 3, 'Ten1_B02ID': 1, 'Landlord_B01ID': -10, 'ResLength_B01ID': 3, 'HHoldCountry_B01ID': 1, 'HHoldGOR_B02ID': 7, 'HHoldNumAdults': 2, 'HHoldNumChildren': 2, 'HHoldNumPeople': 4, 'HHoldStruct_B02ID': 5, 'NumLicHolders': 2, 'HHoldEmploy_B01ID': 5, 'NumVehicles': 2, 'NumBike': 0, 'NumCar': 2, 'NumMCycle': 0, 'NumVanLorry': 0, 'NumCarVan': 2, 'WalkBus_B01ID': 1, 'Getbus_B01ID': 5, 'WalkRail_B01ID': 1, 'WalkRailAlt_B01ID': -9, 'HRPWorkStat_B02ID': 1, 'HRPSEGWorkStat_B01ID': 3, 'HHoldOAClass2011_B03ID': -10, 'Settlement2011EW_B03ID': 1, 'Settlement2011EW_B04ID': 1}\nPerson: 1_5\n{'SurveyYear': 2002, 'IndividualID': 1, 'HouseholdID': 1, 'PSUID': 1, 'VehicleID': '1', 'PersNo': 1, 'Age_B01ID': 13, 'OfPenAge_B01ID': 2, 'Sex_B01ID': 2, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': 1, 'CarAccess_B01ID': 2, 'DrivDisable_B01ID': -9, 'WkPlace_B01ID': 1, 'ES2000_B01ID': 7, 'NSSec_B03ID': 2, 'SC_B01ID': 3, 'Stat_B01ID': 1, 'SVise_B01ID': 2, 'EcoStat_B02ID': 2, 'PossHom_B01ID': 2}\n0:\tActivity(act:home, location:530, time:00:00:00 --&gt; 12:50:00, duration:12:50:00)\n1:\tLeg(mode:car, area:530 --&gt; 550, time:12:50:00 --&gt; 13:05:00, duration:0:15:00)\n2:\tActivity(act:other, location:550, time:13:05:00 --&gt; 15:05:00, duration:2:00:00)\n3:\tLeg(mode:car, area:550 --&gt; 550, time:15:05:00 --&gt; 15:17:00, duration:0:12:00)\n4:\tActivity(act:home, location:550, time:15:17:00 --&gt; 00:00:00, duration:8:43:00)\nPerson: 2_5\n{'SurveyYear': 2002, 'IndividualID': 2, 'HouseholdID': 1, 'PSUID': 1, 'VehicleID': '2', 'PersNo': 2, 'Age_B01ID': 13, 'OfPenAge_B01ID': 2, 'Sex_B01ID': 1, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': 1, 'CarAccess_B01ID': 2, 'DrivDisable_B01ID': -9, 'WkPlace_B01ID': 1, 'ES2000_B01ID': 7, 'NSSec_B03ID': 3, 'SC_B01ID': 4, 'Stat_B01ID': 1, 'SVise_B01ID': 2, 'EcoStat_B02ID': 1, 'PossHom_B01ID': 2}\n0:\tActivity(act:work, location:530, time:00:00:00 --&gt; 06:00:00, duration:6:00:00)\n1:\tLeg(mode:car, area:530 --&gt; 550, time:06:00:00 --&gt; 06:03:00, duration:0:03:00)\n2:\tActivity(act:home, location:550, time:06:03:00 --&gt; 12:50:00, duration:6:47:00)\n3:\tLeg(mode:car, area:550 --&gt; 550, time:12:50:00 --&gt; 13:05:00, duration:0:15:00)\n4:\tActivity(act:other, location:550, time:13:05:00 --&gt; 15:05:00, duration:2:00:00)\n5:\tLeg(mode:car, area:550 --&gt; 550, time:15:05:00 --&gt; 15:17:00, duration:0:12:00)\n6:\tActivity(act:home, location:550, time:15:17:00 --&gt; 17:55:00, duration:2:38:00)\n7:\tLeg(mode:car, area:550 --&gt; 550, time:17:55:00 --&gt; 18:00:00, duration:0:05:00)\n8:\tActivity(act:work, location:550, time:18:00:00 --&gt; 00:00:00, duration:6:00:00)\nPerson: 3_5\n{'SurveyYear': 2002, 'IndividualID': 3, 'HouseholdID': 1, 'PSUID': 1, 'VehicleID': ' ', 'PersNo': 3, 'Age_B01ID': 4, 'OfPenAge_B01ID': 2, 'Sex_B01ID': 1, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': -9, 'CarAccess_B01ID': 4, 'DrivDisable_B01ID': -9, 'WkPlace_B01ID': -9, 'ES2000_B01ID': -9, 'NSSec_B03ID': -9, 'SC_B01ID': -9, 'Stat_B01ID': -9, 'SVise_B01ID': -9, 'EcoStat_B02ID': -9, 'PossHom_B01ID': -9}\n0:\tActivity(act:home, location:530, time:00:00:00 --&gt; 12:50:00, duration:12:50:00)\n1:\tLeg(mode:car, area:530 --&gt; 550, time:12:50:00 --&gt; 13:05:00, duration:0:15:00)\n2:\tActivity(act:other, location:550, time:13:05:00 --&gt; 15:05:00, duration:2:00:00)\n3:\tLeg(mode:car, area:550 --&gt; 550, time:15:05:00 --&gt; 15:17:00, duration:0:12:00)\n4:\tActivity(act:home, location:550, time:15:17:00 --&gt; 00:00:00, duration:8:43:00)\nPerson: 4_5\n{'SurveyYear': 2002, 'IndividualID': 4, 'HouseholdID': 1, 'PSUID': 1, 'VehicleID': ' ', 'PersNo': 4, 'Age_B01ID': 2, 'OfPenAge_B01ID': 2, 'Sex_B01ID': 2, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': -9, 'CarAccess_B01ID': 4, 'DrivDisable_B01ID': -9, 'WkPlace_B01ID': -9, 'ES2000_B01ID': -9, 'NSSec_B03ID': -9, 'SC_B01ID': -9, 'Stat_B01ID': -9, 'SVise_B01ID': -9, 'EcoStat_B02ID': -9, 'PossHom_B01ID': -9}\n0:\tActivity(act:home, location:530, time:00:00:00 --&gt; 12:50:00, duration:12:50:00)\n1:\tLeg(mode:car, area:530 --&gt; 550, time:12:50:00 --&gt; 13:05:00, duration:0:15:00)\n2:\tActivity(act:other, location:550, time:13:05:00 --&gt; 15:05:00, duration:2:00:00)\n3:\tLeg(mode:car, area:550 --&gt; 550, time:15:05:00 --&gt; 15:17:00, duration:0:12:00)\n4:\tActivity(act:home, location:550, time:15:17:00 --&gt; 00:00:00, duration:8:43:00)\n</pre> In\u00a0[42]: Copied! <pre>population.activity_classes\n</pre> population.activity_classes Out[42]: <pre>{'education', 'escort', 'home', 'medical', 'other', 'shop', 'visit', 'work'}</pre> In\u00a0[43]: Copied! <pre>population_sample = Population()\n\nfor _hid, household in population.households.items():\n    av_hh_weight = household.freq  # this is currently the av of person freq in the hh\n    freq = freq_sample(av_hh_weight, 10)\n\n    for idx in range(freq):\n        hh = deepcopy(household)\n        hh.hid = f\"{hh.hid}_{idx}\"\n        hh.people = {}\n        for pid, person in household.people.items():\n            p = deepcopy(person)\n            p.pid = f\"{pid}_{idx}\"\n            hh.add(p)\n        population_sample.add(hh)\n</pre> population_sample = Population()  for _hid, household in population.households.items():     av_hh_weight = household.freq  # this is currently the av of person freq in the hh     freq = freq_sample(av_hh_weight, 10)      for idx in range(freq):         hh = deepcopy(household)         hh.hid = f\"{hh.hid}_{idx}\"         hh.people = {}         for pid, person in household.people.items():             p = deepcopy(person)             p.pid = f\"{pid}_{idx}\"             hh.add(p)         population_sample.add(hh) In\u00a0[44]: Copied! <pre>population_sample.size\n</pre> population_sample.size Out[44]: <pre>6.761904761904766</pre> In\u00a0[45]: Copied! <pre>def load_facilities(path, from_crs=\"EPSG:4326\", to_crs=\"EPSG:27700\"):\n    facilities = gp.read_file(path)\n    facilities.crs = from_crs\n    facilities = facilities.to_crs(to_crs)\n    return facilities\n\n\ndef load_zones(zones_path, from_crs=\"EPSG:27700\", to_crs=\"EPSG:27700\"):\n    zones = gp.read_file(zones_path)\n    zones = zones.set_index(\"id\")\n    if from_crs != to_crs:\n        zones.crs = from_crs\n        zones = zones.to_crs(to_crs)\n    return zones\n</pre> def load_facilities(path, from_crs=\"EPSG:4326\", to_crs=\"EPSG:27700\"):     facilities = gp.read_file(path)     facilities.crs = from_crs     facilities = facilities.to_crs(to_crs)     return facilities   def load_zones(zones_path, from_crs=\"EPSG:27700\", to_crs=\"EPSG:27700\"):     zones = gp.read_file(zones_path)     zones = zones.set_index(\"id\")     if from_crs != to_crs:         zones.crs = from_crs         zones = zones.to_crs(to_crs)     return zones In\u00a0[46]: Copied! <pre>zones = load_zones(area_path, from_crs=\"EPSG:4326\")\nsampler = RandomPointSampler(geoms=zones)\n</pre> zones = load_zones(area_path, from_crs=\"EPSG:4326\") sampler = RandomPointSampler(geoms=zones) In\u00a0[47]: Copied! <pre>sampler.sample(530, None)\n</pre> sampler.sample(530, None) Out[47]: In\u00a0[48]: Copied! <pre>population_sample.sample_locs(sampler)\n</pre> population_sample.sample_locs(sampler) In\u00a0[49]: Copied! <pre>person = population_sample.random_person()\nperson.plot()\nperson.print()\n</pre> person = population_sample.random_person() person.plot() person.print() <pre>Person: 5_5_1\n{'SurveyYear': 2002, 'IndividualID': 5, 'HouseholdID': 2, 'PSUID': 1, 'VehicleID': ' ', 'PersNo': 1, 'Age_B01ID': 18, 'OfPenAge_B01ID': 1, 'Sex_B01ID': 2, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': 3, 'CarAccess_B01ID': 6, 'DrivDisable_B01ID': 2, 'WkPlace_B01ID': -9, 'ES2000_B01ID': 6, 'NSSec_B03ID': 1, 'SC_B01ID': 3, 'Stat_B01ID': 1, 'SVise_B01ID': 1, 'EcoStat_B02ID': 4, 'PossHom_B01ID': -9}\n0:\tActivity(act:home, location:POINT (424576.724141471 281968.51024243183), time:00:00:00 --&gt; 09:20:00, duration:9:20:00)\n1:\tLeg(mode:pt, area:POINT (424576.724141471 281968.51024243183) --&gt; POINT (394151.2840013793 427235.14932292566), time:09:20:00 --&gt; 12:10:00, duration:2:50:00)\n2:\tActivity(act:home, location:POINT (394151.2840013793 427235.14932292566), time:12:10:00 --&gt; 00:00:00, duration:11:50:00)\n</pre> In\u00a0[50]: Copied! <pre>comment = \"NTS london prelim 24nov2020 epsg27700\"\n\nwrite.write_matsim(\n    population_sample, plans_path=os.path.join(out_dir, \"plans.xml\"), comment=comment\n)\npopulation_sample.to_csv(out_dir, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\")\n</pre> comment = \"NTS london prelim 24nov2020 epsg27700\"  write.write_matsim(     population_sample, plans_path=os.path.join(out_dir, \"plans.xml\"), comment=comment ) population_sample.to_csv(out_dir, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\")"},{"location":"examples/07_travel_survey_to_matsim/#converting-the-national-travel-survey-into-a-simple-matsim-format-population","title":"Converting the National Travel Survey into a Simple MATSim Format Population\u00b6","text":"<p>This notebook demonstrates an example workflow for converting tabular diary data from UK NTS (household attributes, person attributes and trip data) into MATSim formatted xml population data for London households.</p> <p>This includes:</p> <ul> <li>pre-processing of tabular inputs</li> <li>loading data into pam</li> <li>household sampling</li> <li>facility sampling</li> <li>preliminary investigation</li> <li>writing to xml</li> </ul> <p>This example is highly simplified. Of particular note: the diary data used is spatially very aggregate (trip locations are aggregated to inner/outer London). This creates significant variance in the sampled trip lengths. Generally we would expect more precise spatial data to be used. Alternately the complexity of the facility sampling step can be improved to better account for known trip features such as mode and duration.</p> <p>The diary data used is available from the UK Data Service (https://beta.ukdataservice.ac.uk/datacatalogue/studies/study?id=5340) and is described here:http://doc.ukdataservice.ac.uk/doc/5340/mrdoc/pdf/5340_nts_user_guidance_1995-2016.pdf</p>"},{"location":"examples/07_travel_survey_to_matsim/#load-data","title":"Load data\u00b6","text":""},{"location":"examples/07_travel_survey_to_matsim/#load-households-data","title":"Load households data\u00b6","text":"<ol> <li>Load household data into pandas DataFrame.</li> <li>Create some mappings of participation and weighting by household for use later. These are described in http://doc.ukdataservice.ac.uk/doc/5340/mrdoc/pdf/5340_nts_user_guidance_1995-2016.pdf</li> </ol>"},{"location":"examples/07_travel_survey_to_matsim/#load-person-data","title":"Load person data\u00b6","text":"<p>Load person attributes data into pandas DataFrame.</p>"},{"location":"examples/07_travel_survey_to_matsim/#load-trip-data","title":"load trip data\u00b6","text":"<ol> <li>Load trip data into pandas DataFrame format.</li> <li>Apply some preliminary formatting</li> <li>Replace headers so that we can use pam read method:</li> </ol> <ul> <li>pid - person ID</li> <li>hid - household ID</li> <li>seq - trip sequence number</li> <li>hzone - household zone</li> <li>ozone - trip origin zone</li> <li>dzone - trip destination zone</li> <li>purp - trip purpose</li> <li>mode - trip mode</li> <li>tst - trip start time (minutes)</li> <li>tet - trip end time (minutes)</li> <li>freq - weighting for representative population</li> </ul>"},{"location":"examples/07_travel_survey_to_matsim/#area-mapping","title":"Area Mapping\u00b6","text":"<p>The NTS documentation refers to a 'modified' 2009 Unitary Authorities. The Unmodified 2017 UAs are included below for reference. They 2017 UA names are similar but not the same as the NTS mappings.</p> <p>Found here: https://data.gov.uk/dataset/4e1d5b2c-bb91-42ad-b420-f7fcab638389/counties-and-unitary-authorities-december-2017-full-extent-boundaries-in-uk-wgs84.</p> <p>We have built our own geometry:</p>"},{"location":"examples/07_travel_survey_to_matsim/#clean-out-incomplete-plans","title":"Clean out incomplete plans\u00b6","text":""},{"location":"examples/07_travel_survey_to_matsim/#build-mappings-and-apply-to-common-fields","title":"Build Mappings and apply to common fields\u00b6","text":"<p>We simplify key trip variables such as mode and activity.</p>"},{"location":"examples/07_travel_survey_to_matsim/#reweight-and-split-days","title":"Reweight and Split Days\u00b6","text":"<p>In order to get the most from our small sample we treat individual diary days as new persons. In order to maintain the original household weighting we reduce this accordingly.</p>"},{"location":"examples/07_travel_survey_to_matsim/#load-into-pam","title":"Load into PAM\u00b6","text":"<p>We load the pandas formatted data into Pam using the <code>pam.read.load_travel_diary_from_to</code> read method. We do some very preliminary validation of plans and assurance.</p>"},{"location":"examples/07_travel_survey_to_matsim/#sample-the-population","title":"Sample the Population\u00b6","text":"<p>We sample a very small population based on the given NTS household weightings.</p>"},{"location":"examples/07_travel_survey_to_matsim/#facility-sampling","title":"Facility Sampling\u00b6","text":"<p>The facilities input is prepared using a separate project called OSM-Facility Sampler (OSMFS). This project woulbe be better names the OSM Facility Extractor. We use it to extract viable activity locations for each activity type for each zone. This project is not currently open source, but is described below:</p> <p>OSMFS joins osm data with the geographies of an area to create a mapping between zones, acts and facility locations (points). This is output as a geojson:</p> <p>{\"type\": \"FeatureCollection\", \"features\": [{\"id\": \"0\", \"type\": \"Feature\", \"properties\": {\"activity\": \"other\"}, \"geometry\": {\"type\": \"Point\", \"coordinates\": [-4.5235751, 54.1698685]}},</p> <p>todo: the current methodology does not support shared facilities, ie facilities with more than one activity (schools are places of education and work for example).</p> <p>todo: the above json has to be rejoined with the geography to create a spatial sampler. This is a duplicated operation which could be included in the Bench output, eg:</p> <p>zone_id: activity: (id, point)</p>"},{"location":"examples/07_travel_survey_to_matsim/#random-sampler","title":"Random Sampler\u00b6","text":"<p>Failing a facility sampler - we can use random sampling instead.</p>"},{"location":"examples/07_travel_survey_to_matsim/#write-to-disk","title":"Write to Disk\u00b6","text":"<ol> <li>write MATSim formats to disk (plans and attributes)</li> <li>write csv and geojson summaries to disk</li> <li>write MATSim formatted facilities to disk</li> </ol>"},{"location":"examples/09_advanced_policies/","title":"Modifying the population using complex policies","text":"In\u00a0[1]: Copied! <pre>from pam.activity import Activity, Leg\nfrom pam.core import Household, Person, Population\nfrom pam.policy import (\n    ActivityPolicy,\n    ActivityProbability,\n    HouseholdPolicy,\n    MoveActivityTourToHomeLocation,\n    PersonAttributeFilter,\n    PersonPolicy,\n    PersonProbability,\n    ReduceSharedActivity,\n    RemoveActivity,\n    apply_policies,\n)\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n</pre> from pam.activity import Activity, Leg from pam.core import Household, Person, Population from pam.policy import (     ActivityPolicy,     ActivityProbability,     HouseholdPolicy,     MoveActivityTourToHomeLocation,     PersonAttributeFilter,     PersonPolicy,     PersonProbability,     ReduceSharedActivity,     RemoveActivity,     apply_policies, ) from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY In\u00a0[2]: Copied! <pre>def print_simple_stats(population):\n\"\"\"Print some simple population statistics.\"\"\"\n    time_at_home = 0\n    travel_time = 0\n    low_income_central_trips = 0\n    high_income_central_trips = 0\n\n    for _hid, hh in population.households.items():\n        for _pid, person in hh.people.items():\n            freq = person.freq\n\n            for p in person.plan:\n                if p.act == \"travel\":\n                    duration = p.duration.seconds * freq / 3600\n                    travel_time += duration\n\n                    if p.end_location.area == \"Westminster,City of London\":\n                        if person.attributes[\"inc\"] == \"low\":\n                            low_income_central_trips += freq\n\n                        elif person.attributes[\"inc\"] == \"high\":\n                            high_income_central_trips += freq\n\n                else:  # activity\n                    if p.act == \"home\":\n                        duration = p.duration.seconds * freq / 3600\n                        time_at_home += duration\n\n    print(f\"Population total time at home: {time_at_home:.2f} hours\")\n    print(f\"Population total travel time: {travel_time:.2f} hours\")\n</pre> def print_simple_stats(population):     \"\"\"Print some simple population statistics.\"\"\"     time_at_home = 0     travel_time = 0     low_income_central_trips = 0     high_income_central_trips = 0      for _hid, hh in population.households.items():         for _pid, person in hh.people.items():             freq = person.freq              for p in person.plan:                 if p.act == \"travel\":                     duration = p.duration.seconds * freq / 3600                     travel_time += duration                      if p.end_location.area == \"Westminster,City of London\":                         if person.attributes[\"inc\"] == \"low\":                             low_income_central_trips += freq                          elif person.attributes[\"inc\"] == \"high\":                             high_income_central_trips += freq                  else:  # activity                     if p.act == \"home\":                         duration = p.duration.seconds * freq / 3600                         time_at_home += duration      print(f\"Population total time at home: {time_at_home:.2f} hours\")     print(f\"Population total travel time: {travel_time:.2f} hours\") In\u00a0[3]: Copied! <pre>population = Population()\n</pre> population = Population() In\u00a0[4]: Copied! <pre>smith_id = \"Smith\"\n\nBilly = Person(\n    \"Billy\",\n    freq=1,\n    attributes={\"age\": 26, \"job\": \"employed\", \"gender\": \"female\", \"key_worker\": False},\n)\n\nBilly.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\nBilly.add(\n    Leg(1, \"car\", start_area=\"a\", end_area=\"g\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20))\n)\nBilly.add(Activity(2, \"work\", \"g\", start_time=mtdt(8 * 60 + 20), end_time=mtdt(17 * 60)))\nBilly.add(\n    Leg(\n        2,\n        \"car\",\n        start_area=\"g\",\n        end_area=\"a\",\n        start_time=mtdt(17 * 60),\n        end_time=mtdt(17 * 60 + 25),\n    )\n)\nBilly.add(Activity(3, \"home\", \"a\", start_time=mtdt(17 * 60 + 25), end_time=END_OF_DAY))\n\n\nBobby = Person(\n    \"Bobby\",\n    freq=1,\n    attributes={\"age\": 6, \"job\": \"education\", \"gender\": \"male\", \"key_worker\": False},\n)\nBobby.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\nBobby.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30)))\nBobby.add(Activity(2, \"education\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60)))\nBobby.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 35)))\nBobby.add(Activity(3, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(18 * 60)))\nBobby.add(Leg(3, \"car\", \"a\", \"b\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))\nBobby.add(Activity(4, \"shop_1\", \"b\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50)))\nBobby.add(Leg(4, \"car\", \"b\", \"b\", start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60)))\nBobby.add(Activity(5, \"shop_2\", \"b\", start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50)))\nBobby.add(Leg(5, \"car\", \"b\", \"a\", start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10)))\nBobby.add(Activity(6, \"home\", \"a\", start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))\n\nBradly = Person(\n    \"Bradly\",\n    freq=1,\n    attributes={\"age\": 40, \"job\": \"employed\", \"gender\": \"male\", \"key_worker\": True},\n)\nBradly.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\n\nBradly.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20)))\nBradly.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 20), end_time=mtdt(8 * 60 + 30)))\nBradly.add(Leg(2, \"pt\", \"b\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(9 * 60)))\n\nBradly.add(Activity(4, \"work\", \"b\", start_time=mtdt(9 * 60), end_time=mtdt(10 * 60)))\nBradly.add(Leg(3, \"pt\", \"b\", \"c\", start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 20)))\nBradly.add(Activity(4, \"work\", \"b\", start_time=mtdt(10 * 60 + 20), end_time=mtdt(12 * 60)))\nBradly.add(Leg(4, \"pt\", \"b\", \"c\", start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 20)))\nBradly.add(Activity(5, \"work\", \"b\", start_time=mtdt(12 * 60 + 20), end_time=mtdt(14 * 60)))\nBradly.add(Leg(5, \"pt\", \"b\", \"c\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))\n\nBradly.add(Activity(6, \"leisure\", \"c\", start_time=mtdt(14 * 60 + 20), end_time=mtdt(15 * 60 + 30)))\nBradly.add(Leg(4, \"pt\", \"c\", \"b\", start_time=mtdt(15 * 60 + 30), end_time=mtdt(16 * 60 - 10)))\nBradly.add(Activity(5, \"escort\", \"b\", start_time=mtdt(16 * 60 - 10), end_time=mtdt(16 * 60)))\nBradly.add(Leg(5, \"walk\", \"b\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20)))\n\nBradly.add(Activity(8, \"home\", \"a\", start_time=mtdt(16 * 60 + 20), end_time=mtdt(18 * 60)))\nBradly.add(Leg(8, \"car\", \"a\", \"b\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))\nBradly.add(Activity(9, \"shop_1\", \"b\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50)))\nBradly.add(Leg(9, \"car\", \"b\", \"b\", start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60)))\nBradly.add(Activity(10, \"shop_2\", \"b\", start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50)))\nBradly.add(Leg(10, \"car\", \"b\", \"a\", start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10)))\nBradly.add(Activity(11, \"home\", \"a\", start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))\n\nsmiths = Household(smith_id)\nfor person in [Billy, Bradly, Bobby]:\n    smiths.add(person)\n\nsmiths.people\n</pre> smith_id = \"Smith\"  Billy = Person(     \"Billy\",     freq=1,     attributes={\"age\": 26, \"job\": \"employed\", \"gender\": \"female\", \"key_worker\": False}, )  Billy.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60))) Billy.add(     Leg(1, \"car\", start_area=\"a\", end_area=\"g\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20)) ) Billy.add(Activity(2, \"work\", \"g\", start_time=mtdt(8 * 60 + 20), end_time=mtdt(17 * 60))) Billy.add(     Leg(         2,         \"car\",         start_area=\"g\",         end_area=\"a\",         start_time=mtdt(17 * 60),         end_time=mtdt(17 * 60 + 25),     ) ) Billy.add(Activity(3, \"home\", \"a\", start_time=mtdt(17 * 60 + 25), end_time=END_OF_DAY))   Bobby = Person(     \"Bobby\",     freq=1,     attributes={\"age\": 6, \"job\": \"education\", \"gender\": \"male\", \"key_worker\": False}, ) Bobby.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60))) Bobby.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30))) Bobby.add(Activity(2, \"education\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60))) Bobby.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 35))) Bobby.add(Activity(3, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(18 * 60))) Bobby.add(Leg(3, \"car\", \"a\", \"b\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20))) Bobby.add(Activity(4, \"shop_1\", \"b\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50))) Bobby.add(Leg(4, \"car\", \"b\", \"b\", start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60))) Bobby.add(Activity(5, \"shop_2\", \"b\", start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50))) Bobby.add(Leg(5, \"car\", \"b\", \"a\", start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10))) Bobby.add(Activity(6, \"home\", \"a\", start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))  Bradly = Person(     \"Bradly\",     freq=1,     attributes={\"age\": 40, \"job\": \"employed\", \"gender\": \"male\", \"key_worker\": True}, ) Bradly.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))  Bradly.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20))) Bradly.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 20), end_time=mtdt(8 * 60 + 30))) Bradly.add(Leg(2, \"pt\", \"b\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(9 * 60)))  Bradly.add(Activity(4, \"work\", \"b\", start_time=mtdt(9 * 60), end_time=mtdt(10 * 60))) Bradly.add(Leg(3, \"pt\", \"b\", \"c\", start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 20))) Bradly.add(Activity(4, \"work\", \"b\", start_time=mtdt(10 * 60 + 20), end_time=mtdt(12 * 60))) Bradly.add(Leg(4, \"pt\", \"b\", \"c\", start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 20))) Bradly.add(Activity(5, \"work\", \"b\", start_time=mtdt(12 * 60 + 20), end_time=mtdt(14 * 60))) Bradly.add(Leg(5, \"pt\", \"b\", \"c\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))  Bradly.add(Activity(6, \"leisure\", \"c\", start_time=mtdt(14 * 60 + 20), end_time=mtdt(15 * 60 + 30))) Bradly.add(Leg(4, \"pt\", \"c\", \"b\", start_time=mtdt(15 * 60 + 30), end_time=mtdt(16 * 60 - 10))) Bradly.add(Activity(5, \"escort\", \"b\", start_time=mtdt(16 * 60 - 10), end_time=mtdt(16 * 60))) Bradly.add(Leg(5, \"walk\", \"b\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20)))  Bradly.add(Activity(8, \"home\", \"a\", start_time=mtdt(16 * 60 + 20), end_time=mtdt(18 * 60))) Bradly.add(Leg(8, \"car\", \"a\", \"b\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20))) Bradly.add(Activity(9, \"shop_1\", \"b\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50))) Bradly.add(Leg(9, \"car\", \"b\", \"b\", start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60))) Bradly.add(Activity(10, \"shop_2\", \"b\", start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50))) Bradly.add(Leg(10, \"car\", \"b\", \"a\", start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10))) Bradly.add(Activity(11, \"home\", \"a\", start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))  smiths = Household(smith_id) for person in [Billy, Bradly, Bobby]:     smiths.add(person)  smiths.people Out[4]: <pre>{'Billy': &lt;pam.core.Person at 0x16221b710&gt;,\n 'Bradly': &lt;pam.core.Person at 0x1623255d0&gt;,\n 'Bobby': &lt;pam.core.Person at 0x162324850&gt;}</pre> In\u00a0[5]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[6]: Copied! <pre>population.add(smiths)\n</pre> population.add(smiths) In\u00a0[7]: Copied! <pre>jones_id = \"Jones\"\n\nHugh = Person(\n    \"Hugh\",\n    freq=1,\n    attributes={\"age\": 100, \"job\": \"unemployed\", \"gender\": \"male\", \"key_worker\": False},\n)\nHugh.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\nHugh.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))\nHugh.add(Activity(2, \"health\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(10 * 60)))\nHugh.add(Leg(2, \"walk\", \"b\", \"a\", start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 30)))\nHugh.add(Activity(3, \"home\", \"a\", start_time=mtdt(10 * 60 + 30), end_time=mtdt(14 * 60)))\nHugh.add(Leg(3, \"walk\", \"a\", \"b\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 30)))\nHugh.add(Activity(4, \"health\", \"b\", start_time=mtdt(14 * 60 + 30), end_time=mtdt(16 * 60)))\nHugh.add(Leg(4, \"walk\", \"b\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))\nHugh.add(Activity(5, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=END_OF_DAY))\n\nBridget = Person(\n    \"Bridget\",\n    freq=1,\n    attributes={\"age\": 35, \"job\": \"employed\", \"gender\": \"female\", \"key_worker\": False},\n)\nBridget.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\nBridget.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))\nBridget.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(10 * 60 + 30)))\nBridget.add(Leg(2, \"pt\", \"b\", \"c\", start_time=mtdt(10 * 60 + 30), end_time=mtdt(11 * 60)))\nBridget.add(Activity(3, \"work\", \"c\", start_time=mtdt(11 * 60), end_time=mtdt(16 * 60)))\nBridget.add(Leg(3, \"pt\", \"c\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20)))\nBridget.add(Activity(4, \"home\", \"a\", start_time=mtdt(16 * 60 + 20), end_time=mtdt(17 * 60 + 20)))\nBridget.add(Leg(4, \"pt\", \"c\", \"a\", start_time=mtdt(17 * 60 + 20), end_time=mtdt(17 * 60 + 50)))\nBridget.add(Activity(5, \"shop\", \"a\", start_time=mtdt(17 * 60 + 50), end_time=mtdt(18 * 60 + 30)))\nBridget.add(Leg(5, \"pt\", \"c\", \"a\", start_time=mtdt(18 * 60 + 30), end_time=mtdt(18 * 60 + 50)))\nBridget.add(Activity(6, \"home\", \"a\", start_time=mtdt(18 * 60 + 50), end_time=END_OF_DAY))\n\njones = Household(jones_id)\nfor person in [Hugh, Bridget]:\n    jones.add(person)\n\njones.people\n</pre> jones_id = \"Jones\"  Hugh = Person(     \"Hugh\",     freq=1,     attributes={\"age\": 100, \"job\": \"unemployed\", \"gender\": \"male\", \"key_worker\": False}, ) Hugh.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60))) Hugh.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30))) Hugh.add(Activity(2, \"health\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(10 * 60))) Hugh.add(Leg(2, \"walk\", \"b\", \"a\", start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 30))) Hugh.add(Activity(3, \"home\", \"a\", start_time=mtdt(10 * 60 + 30), end_time=mtdt(14 * 60))) Hugh.add(Leg(3, \"walk\", \"a\", \"b\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 30))) Hugh.add(Activity(4, \"health\", \"b\", start_time=mtdt(14 * 60 + 30), end_time=mtdt(16 * 60))) Hugh.add(Leg(4, \"walk\", \"b\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30))) Hugh.add(Activity(5, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=END_OF_DAY))  Bridget = Person(     \"Bridget\",     freq=1,     attributes={\"age\": 35, \"job\": \"employed\", \"gender\": \"female\", \"key_worker\": False}, ) Bridget.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60))) Bridget.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5))) Bridget.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(10 * 60 + 30))) Bridget.add(Leg(2, \"pt\", \"b\", \"c\", start_time=mtdt(10 * 60 + 30), end_time=mtdt(11 * 60))) Bridget.add(Activity(3, \"work\", \"c\", start_time=mtdt(11 * 60), end_time=mtdt(16 * 60))) Bridget.add(Leg(3, \"pt\", \"c\", \"a\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20))) Bridget.add(Activity(4, \"home\", \"a\", start_time=mtdt(16 * 60 + 20), end_time=mtdt(17 * 60 + 20))) Bridget.add(Leg(4, \"pt\", \"c\", \"a\", start_time=mtdt(17 * 60 + 20), end_time=mtdt(17 * 60 + 50))) Bridget.add(Activity(5, \"shop\", \"a\", start_time=mtdt(17 * 60 + 50), end_time=mtdt(18 * 60 + 30))) Bridget.add(Leg(5, \"pt\", \"c\", \"a\", start_time=mtdt(18 * 60 + 30), end_time=mtdt(18 * 60 + 50))) Bridget.add(Activity(6, \"home\", \"a\", start_time=mtdt(18 * 60 + 50), end_time=END_OF_DAY))  jones = Household(jones_id) for person in [Hugh, Bridget]:     jones.add(person)  jones.people Out[7]: <pre>{'Hugh': &lt;pam.core.Person at 0x10a5243d0&gt;,\n 'Bridget': &lt;pam.core.Person at 0x1626ccd90&gt;}</pre> In\u00a0[8]: Copied! <pre>jones.plot()\n</pre> jones.plot() In\u00a0[9]: Copied! <pre>population.add(jones)\n</pre> population.add(jones) In\u00a0[10]: Copied! <pre>print_simple_stats(population)\n</pre> print_simple_stats(population) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[11]: Copied! <pre>def discrete_joint_distribution_sampler(obj, mapping, distribution):\n\"\"\"\n    Randomly sample from a joint distribution based some discrete features.\n    Where features are a dictionary structure of features, eg: {'gender':'female'}\n    Distribution is a nested dict of probabilities based on possible features, eg:\n    {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': 1}}\n    Mapping provides the feature name for each level of the distribution, eg:\n    ['age', 'gender'].\n    \"\"\"\n    p = distribution\n    for key in mapping:\n        value = obj.attributes.get(key)\n        if value is None:\n            msg = f\"Cannot find mapping: {key} in sampling features: {obj.attributes}\"\n            raise KeyError(msg)\n        p = p.get(value)\n        if p is None:\n            msg = f\"Cannot find feature for {key}: {value} in distribution: {p}\"\n            raise KeyError(msg)\n\n    return p\n</pre> def discrete_joint_distribution_sampler(obj, mapping, distribution):     \"\"\"     Randomly sample from a joint distribution based some discrete features.     Where features are a dictionary structure of features, eg: {'gender':'female'}     Distribution is a nested dict of probabilities based on possible features, eg:     {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': 1}}     Mapping provides the feature name for each level of the distribution, eg:     ['age', 'gender'].     \"\"\"     p = distribution     for key in mapping:         value = obj.attributes.get(key)         if value is None:             msg = f\"Cannot find mapping: {key} in sampling features: {obj.attributes}\"             raise KeyError(msg)         p = p.get(value)         if p is None:             msg = f\"Cannot find feature for {key}: {value} in distribution: {p}\"             raise KeyError(msg)      return p In\u00a0[12]: Copied! <pre>vulnerable_mapping = [\"age\", \"gender\"]\nvulnerable_distribution = dict(\n    zip(\n        list(range(101)),\n        [{\"male\": i / 100, \"female\": i / 100, \"other\": i / 100} for i in range(101)],\n    )\n)\n</pre> vulnerable_mapping = [\"age\", \"gender\"] vulnerable_distribution = dict(     zip(         list(range(101)),         [{\"male\": i / 100, \"female\": i / 100, \"other\": i / 100} for i in range(101)],     ) ) In\u00a0[13]: Copied! <pre>dict(list(vulnerable_distribution.items())[0:15])\n</pre> dict(list(vulnerable_distribution.items())[0:15]) Out[13]: <pre>{0: {'male': 0.0, 'female': 0.0, 'other': 0.0},\n 1: {'male': 0.01, 'female': 0.01, 'other': 0.01},\n 2: {'male': 0.02, 'female': 0.02, 'other': 0.02},\n 3: {'male': 0.03, 'female': 0.03, 'other': 0.03},\n 4: {'male': 0.04, 'female': 0.04, 'other': 0.04},\n 5: {'male': 0.05, 'female': 0.05, 'other': 0.05},\n 6: {'male': 0.06, 'female': 0.06, 'other': 0.06},\n 7: {'male': 0.07, 'female': 0.07, 'other': 0.07},\n 8: {'male': 0.08, 'female': 0.08, 'other': 0.08},\n 9: {'male': 0.09, 'female': 0.09, 'other': 0.09},\n 10: {'male': 0.1, 'female': 0.1, 'other': 0.1},\n 11: {'male': 0.11, 'female': 0.11, 'other': 0.11},\n 12: {'male': 0.12, 'female': 0.12, 'other': 0.12},\n 13: {'male': 0.13, 'female': 0.13, 'other': 0.13},\n 14: {'male': 0.14, 'female': 0.14, 'other': 0.14}}</pre> In\u00a0[14]: Copied! <pre>discrete_joint_distribution_sampler(Bobby, vulnerable_mapping, vulnerable_distribution)\n</pre> discrete_joint_distribution_sampler(Bobby, vulnerable_mapping, vulnerable_distribution) Out[14]: <pre>0.06</pre> In\u00a0[15]: Copied! <pre>policy_quarantine = HouseholdPolicy(\n    RemoveActivity([\"work\", \"health\", \"leisure\", \"escort\", \"shop\", \"education\"]),\n    PersonProbability(0.0000000000001),\n)\n</pre> policy_quarantine = HouseholdPolicy(     RemoveActivity([\"work\", \"health\", \"leisure\", \"escort\", \"shop\", \"education\"]),     PersonProbability(0.0000000000001), ) In\u00a0[16]: Copied! <pre>q_pop = apply_policies(population, [policy_quarantine])\nprint_simple_stats(q_pop)\n</pre> q_pop = apply_policies(population, [policy_quarantine]) print_simple_stats(q_pop) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[17]: Copied! <pre>q_pop.households[\"Smith\"].plot()\n</pre> q_pop.households[\"Smith\"].plot() In\u00a0[18]: Copied! <pre>q_pop.households[\"Jones\"].plot()\n</pre> q_pop.households[\"Jones\"].plot() In\u00a0[19]: Copied! <pre>policy_quarantine = HouseholdPolicy(\n    RemoveActivity([\"work\", \"health\", \"escort\", \"leisure\", \"shop\", \"education\"]),\n    PersonProbability(\n        discrete_joint_distribution_sampler,\n        {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},\n    ),\n)\n</pre> policy_quarantine = HouseholdPolicy(     RemoveActivity([\"work\", \"health\", \"escort\", \"leisure\", \"shop\", \"education\"]),     PersonProbability(         discrete_joint_distribution_sampler,         {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},     ), ) In\u00a0[20]: Copied! <pre>q_pop = apply_policies(population, [policy_quarantine])\nprint_simple_stats(q_pop)\n</pre> q_pop = apply_policies(population, [policy_quarantine]) print_simple_stats(q_pop) <pre>Population total time at home: 43.67 hours\nPopulation total travel time: 1.67 hours\n</pre> In\u00a0[21]: Copied! <pre>q_pop.households[\"Jones\"].plot()\n</pre> q_pop.households[\"Jones\"].plot() In\u00a0[22]: Copied! <pre>policy_quarantine = HouseholdPolicy(\n    RemoveActivity([\"work\", \"health\", \"escort\", \"leisure\", \"shop\", \"education\"]),\n    [\n        PersonProbability(0.5),\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},\n        ),\n    ],\n)\n</pre> policy_quarantine = HouseholdPolicy(     RemoveActivity([\"work\", \"health\", \"escort\", \"leisure\", \"shop\", \"education\"]),     [         PersonProbability(0.5),         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},         ),     ], ) In\u00a0[23]: Copied! <pre>q_pop = apply_policies(population, [policy_quarantine])\nprint_simple_stats(q_pop)\n</pre> q_pop = apply_policies(population, [policy_quarantine]) print_simple_stats(q_pop) <pre>Population total time at home: 43.67 hours\nPopulation total travel time: 1.67 hours\n</pre> In\u00a0[24]: Copied! <pre>q_pop.households[\"Jones\"].plot()\n</pre> q_pop.households[\"Jones\"].plot() In\u00a0[25]: Copied! <pre>edu_mapping = [\"job\"]\nedu_distribution = {\"employed\": 0, \"unemployed\": 0, \"education\": 1}\n</pre> edu_mapping = [\"job\"] edu_distribution = {\"employed\": 0, \"unemployed\": 0, \"education\": 1} In\u00a0[26]: Copied! <pre>key_mapping = [\"key_worker\"]\nkey_distribution = {True: 0, False: 1}\n</pre> key_mapping = [\"key_worker\"] key_distribution = {True: 0, False: 1} In\u00a0[27]: Copied! <pre>edu_distribution, key_distribution\n</pre> edu_distribution, key_distribution Out[27]: <pre>({'employed': 0, 'unemployed': 0, 'education': 1}, {True: 0, False: 1})</pre> In\u00a0[28]: Copied! <pre>policy_remove_education_and_escort = HouseholdPolicy(\n    RemoveActivity([\"education\", \"escort\"]),\n    [\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": edu_mapping, \"distribution\": edu_distribution},\n        ),\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": key_mapping, \"distribution\": key_distribution},\n        ),\n    ],\n)\n</pre> policy_remove_education_and_escort = HouseholdPolicy(     RemoveActivity([\"education\", \"escort\"]),     [         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": edu_mapping, \"distribution\": edu_distribution},         ),         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": key_mapping, \"distribution\": key_distribution},         ),     ], ) In\u00a0[29]: Copied! <pre>edu_pop = apply_policies(population, [policy_remove_education_and_escort])\nprint_simple_stats(edu_pop)\n</pre> edu_pop = apply_policies(population, [policy_remove_education_and_escort]) print_simple_stats(edu_pop) <pre>Population total time at home: 84.25 hours\nPopulation total travel time: 7.83 hours\n</pre> In\u00a0[30]: Copied! <pre>edu_pop.households[\"Smith\"].people[\"Bradly\"].plan.print()\n</pre> edu_pop.households[\"Smith\"].people[\"Bradly\"].plan.print() <pre>0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:20:00, duration:0:20:00)\n2:\tActivity(act:work, location:b, time:08:20:00 --&gt; 09:20:00, duration:1:00:00)\n3:\tLeg(mode:pt, area:b --&gt; c, time:09:20:00 --&gt; 09:40:00, duration:0:20:00)\n4:\tActivity(act:work, location:b, time:09:40:00 --&gt; 11:20:00, duration:1:40:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:11:20:00 --&gt; 11:40:00, duration:0:20:00)\n6:\tActivity(act:work, location:b, time:11:40:00 --&gt; 13:20:00, duration:1:40:00)\n7:\tLeg(mode:pt, area:b --&gt; c, time:13:20:00 --&gt; 13:40:00, duration:0:20:00)\n8:\tActivity(act:leisure, location:c, time:13:40:00 --&gt; 14:50:00, duration:1:10:00)\n9:\tLeg(mode:pt, area:c --&gt; a, time:14:50:00 --&gt; 15:10:00, duration:0:20:00)\n10:\tActivity(act:home, location:a, time:15:10:00 --&gt; 16:50:00, duration:1:40:00)\n11:\tLeg(mode:car, area:a --&gt; b, time:16:50:00 --&gt; 17:10:00, duration:0:20:00)\n12:\tActivity(act:shop_1, location:b, time:17:10:00 --&gt; 17:40:00, duration:0:30:00)\n13:\tLeg(mode:car, area:b --&gt; b, time:17:40:00 --&gt; 17:50:00, duration:0:10:00)\n14:\tActivity(act:shop_2, location:b, time:17:50:00 --&gt; 18:40:00, duration:0:50:00)\n15:\tLeg(mode:car, area:b --&gt; a, time:18:40:00 --&gt; 19:00:00, duration:0:20:00)\n16:\tActivity(act:home, location:a, time:19:00:00 --&gt; 00:00:00, duration:5:00:00)\n</pre> In\u00a0[31]: Copied! <pre>q_pop.households[\"Smith\"].plot()\n</pre> q_pop.households[\"Smith\"].plot() In\u00a0[32]: Copied! <pre>edu_pop.households[\"Smith\"].plot()\n</pre> edu_pop.households[\"Smith\"].plot() In\u00a0[33]: Copied! <pre>edu_pop.households[\"Jones\"].plot()\n</pre> edu_pop.households[\"Jones\"].plot() In\u00a0[34]: Copied! <pre>edu_pop.households[\"Jones\"].people[\"Bridget\"].plan.print()\n</pre> edu_pop.households[\"Jones\"].people[\"Bridget\"].plan.print() <pre>0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:escort, location:b, time:08:05:00 --&gt; 10:30:00, duration:2:25:00)\n3:\tLeg(mode:pt, area:b --&gt; c, time:10:30:00 --&gt; 11:00:00, duration:0:30:00)\n4:\tActivity(act:work, location:c, time:11:00:00 --&gt; 16:00:00, duration:5:00:00)\n5:\tLeg(mode:pt, area:c --&gt; a, time:16:00:00 --&gt; 16:20:00, duration:0:20:00)\n6:\tActivity(act:home, location:a, time:16:20:00 --&gt; 17:20:00, duration:1:00:00)\n7:\tLeg(mode:pt, area:c --&gt; a, time:17:20:00 --&gt; 17:50:00, duration:0:30:00)\n8:\tActivity(act:shop, location:a, time:17:50:00 --&gt; 18:30:00, duration:0:40:00)\n9:\tLeg(mode:pt, area:c --&gt; a, time:18:30:00 --&gt; 18:50:00, duration:0:20:00)\n10:\tActivity(act:home, location:a, time:18:50:00 --&gt; 00:00:00, duration:5:10:00)\n</pre> In\u00a0[35]: Copied! <pre>def condition_job_education(val):\n    return val == \"education\"\n\n\npolicy_remove_education_and_escort = HouseholdPolicy(\n    RemoveActivity([\"education\", \"escort\"]),\n    PersonProbability(\n        discrete_joint_distribution_sampler,\n        {\"mapping\": key_mapping, \"distribution\": key_distribution},\n    ),\n    PersonAttributeFilter({\"job\": condition_job_education}),\n)\n</pre> def condition_job_education(val):     return val == \"education\"   policy_remove_education_and_escort = HouseholdPolicy(     RemoveActivity([\"education\", \"escort\"]),     PersonProbability(         discrete_joint_distribution_sampler,         {\"mapping\": key_mapping, \"distribution\": key_distribution},     ),     PersonAttributeFilter({\"job\": condition_job_education}), ) In\u00a0[36]: Copied! <pre>apply_policies(population, [policy_remove_education_and_escort]).households[\"Smith\"].plot()\n</pre> apply_policies(population, [policy_remove_education_and_escort]).households[\"Smith\"].plot() In\u00a0[37]: Copied! <pre>policy_remove_education_and_escort = HouseholdPolicy(\n    RemoveActivity([\"education\", \"escort\"]),\n    [\n        ActivityProbability([\"education\"], 0.9999),\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": edu_mapping, \"distribution\": edu_distribution},\n        ),\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": key_mapping, \"distribution\": key_distribution},\n        ),\n    ],\n)\n</pre> policy_remove_education_and_escort = HouseholdPolicy(     RemoveActivity([\"education\", \"escort\"]),     [         ActivityProbability([\"education\"], 0.9999),         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": edu_mapping, \"distribution\": edu_distribution},         ),         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": key_mapping, \"distribution\": key_distribution},         ),     ], ) In\u00a0[38]: Copied! <pre>apply_policies(population, [policy_remove_education_and_escort]).households[\"Smith\"].plot()\n</pre> apply_policies(population, [policy_remove_education_and_escort]).households[\"Smith\"].plot() In\u00a0[39]: Copied! <pre>policy_remove_leisure = PersonPolicy(RemoveActivity([\"leisure\"]), PersonProbability(1.0))\n</pre> policy_remove_leisure = PersonPolicy(RemoveActivity([\"leisure\"]), PersonProbability(1.0)) In\u00a0[40]: Copied! <pre>lei_pop = apply_policies(population, [policy_remove_leisure])\nprint_simple_stats(lei_pop)\n</pre> lei_pop = apply_policies(population, [policy_remove_leisure]) print_simple_stats(lei_pop) <pre>Population total time at home: 76.08 hours\nPopulation total travel time: 9.33 hours\n</pre> In\u00a0[41]: Copied! <pre>lei_pop.households[\"Smith\"].plot()\n</pre> lei_pop.households[\"Smith\"].plot() In\u00a0[42]: Copied! <pre>key_mapping = [\"key_worker\"]\nkey_distribution = {True: 0, False: 1}\n</pre> key_mapping = [\"key_worker\"] key_distribution = {True: 0, False: 1} In\u00a0[43]: Copied! <pre>policy_unemployment_and_furlough = PersonPolicy(\n    RemoveActivity([\"work\"]),\n    [\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": key_mapping, \"distribution\": key_distribution},\n        )\n    ],\n)\n</pre> policy_unemployment_and_furlough = PersonPolicy(     RemoveActivity([\"work\"]),     [         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": key_mapping, \"distribution\": key_distribution},         )     ], ) In\u00a0[44]: Copied! <pre>fur_pop = apply_policies(population, [policy_unemployment_and_furlough])\nprint_simple_stats(fur_pop)\n</pre> fur_pop = apply_policies(population, [policy_unemployment_and_furlough]) print_simple_stats(fur_pop) <pre>Population total time at home: 65.33 hours\nPopulation total travel time: 8.58 hours\n</pre> In\u00a0[45]: Copied! <pre>fur_pop.households[\"Smith\"].plot()\n</pre> fur_pop.households[\"Smith\"].plot() In\u00a0[46]: Copied! <pre>fur_pop.households[\"Jones\"].plot()\n</pre> fur_pop.households[\"Jones\"].plot() In\u00a0[47]: Copied! <pre>policy_reduced_work = ActivityPolicy(RemoveActivity([\"work\"]), ActivityProbability([\"work\"], 0.5))\n\napply_policies(population, [policy_reduced_work]).households[\"Smith\"].plot()\n</pre> policy_reduced_work = ActivityPolicy(RemoveActivity([\"work\"]), ActivityProbability([\"work\"], 0.5))  apply_policies(population, [policy_reduced_work]).households[\"Smith\"].plot() In\u00a0[48]: Copied! <pre>policy_remove_shopping = PersonPolicy(RemoveActivity([\"shop\"]), ActivityProbability([\"shop\"], 1.0))\n</pre> policy_remove_shopping = PersonPolicy(RemoveActivity([\"shop\"]), ActivityProbability([\"shop\"], 1.0)) In\u00a0[49]: Copied! <pre>shop_pop = apply_policies(population, [policy_remove_shopping])\nprint_simple_stats(shop_pop)\n</pre> shop_pop = apply_policies(population, [policy_remove_shopping]) print_simple_stats(shop_pop) <pre>Population total time at home: 76.08 hours\nPopulation total travel time: 8.83 hours\n</pre> In\u00a0[50]: Copied! <pre>shop_pop.households[\"Jones\"].people[\"Bridget\"].plot()\n</pre> shop_pop.households[\"Jones\"].people[\"Bridget\"].plot() In\u00a0[51]: Copied! <pre>policy_reduce_shopping_activities = HouseholdPolicy(\n    ReduceSharedActivity([\"shop_1\", \"shop_2\", \"shop\"]),\n    ActivityProbability([\"shop_1\", \"shop_2\", \"shop\"], 1.0),\n)\n</pre> policy_reduce_shopping_activities = HouseholdPolicy(     ReduceSharedActivity([\"shop_1\", \"shop_2\", \"shop\"]),     ActivityProbability([\"shop_1\", \"shop_2\", \"shop\"], 1.0), ) In\u00a0[52]: Copied! <pre>population[\"Smith\"].shared_activities()\n</pre> population[\"Smith\"].shared_activities() Out[52]: <pre>[&lt;pam.activity.Activity at 0x1623256d0&gt;,\n &lt;pam.activity.Activity at 0x162324950&gt;,\n &lt;pam.activity.Activity at 0x1623250d0&gt;,\n &lt;pam.activity.Activity at 0x162325290&gt;,\n &lt;pam.activity.Activity at 0x1623254d0&gt;]</pre> In\u00a0[53]: Copied! <pre>shop_reduce_pop = apply_policies(population, [policy_reduce_shopping_activities])\nprint_simple_stats(shop_reduce_pop)\n</pre> shop_reduce_pop = apply_policies(population, [policy_reduce_shopping_activities]) print_simple_stats(shop_reduce_pop) <pre>Population total time at home: 76.75 hours\nPopulation total travel time: 8.83 hours\n</pre> In\u00a0[54]: Copied! <pre>shop_reduce_pop.households[\"Smith\"].plot()\n</pre> shop_reduce_pop.households[\"Smith\"].plot() In\u00a0[55]: Copied! <pre>shop_reduce_pop.households[\"Smith\"].people[\"Bobby\"].print()\n</pre> shop_reduce_pop.households[\"Smith\"].people[\"Bobby\"].print() <pre>Person: Bobby\n{'age': 6, 'job': 'education', 'gender': 'male', 'key_worker': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:25:00, duration:0:25:00)\n2:\tActivity(act:education, location:b, time:08:25:00 --&gt; 15:55:00, duration:7:30:00)\n3:\tLeg(mode:walk, area:b --&gt; c, time:15:55:00 --&gt; 16:30:00, duration:0:35:00)\n4:\tActivity(act:home, location:a, time:16:30:00 --&gt; 00:00:00, duration:7:30:00)\n</pre> In\u00a0[56]: Copied! <pre>policy_move_shopping_tours = PersonPolicy(\n    MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]),\n    [ActivityProbability([\"shop_1\", \"shop_2\"], 1.0)],\n)\n</pre> policy_move_shopping_tours = PersonPolicy(     MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]),     [ActivityProbability([\"shop_1\", \"shop_2\"], 1.0)], ) In\u00a0[57]: Copied! <pre>shop_tour_pop = apply_policies(population, [policy_move_shopping_tours])\nprint_simple_stats(shop_tour_pop)\n</pre> shop_tour_pop = apply_policies(population, [policy_move_shopping_tours]) print_simple_stats(shop_tour_pop) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[58]: Copied! <pre>shop_tour_pop.households[\"Smith\"].plot()\n</pre> shop_tour_pop.households[\"Smith\"].plot() In\u00a0[59]: Copied! <pre># above is equivalent to\npolicy_move_shopping_tours = PersonPolicy(\n    MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]),\n    [ActivityProbability([\"shop_1\"], 1.0), ActivityProbability([\"shop_2\"], 1.0)],\n)\n</pre> # above is equivalent to policy_move_shopping_tours = PersonPolicy(     MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]),     [ActivityProbability([\"shop_1\"], 1.0), ActivityProbability([\"shop_2\"], 1.0)], ) In\u00a0[60]: Copied! <pre>shop_tour_pop = apply_policies(population, [policy_move_shopping_tours])\nprint_simple_stats(shop_tour_pop)\n</pre> shop_tour_pop = apply_policies(population, [policy_move_shopping_tours]) print_simple_stats(shop_tour_pop) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[61]: Copied! <pre>shop_tour_pop.households[\"Smith\"].plot()\n</pre> shop_tour_pop.households[\"Smith\"].plot() In\u00a0[62]: Copied! <pre>shop_tour_pop.households[\"Smith\"].people[\"Bradly\"].print()\n</pre> shop_tour_pop.households[\"Smith\"].people[\"Bradly\"].print() <pre>Person: Bradly\n{'age': 40, 'job': 'employed', 'gender': 'male', 'key_worker': True}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:20:00, duration:0:20:00)\n2:\tActivity(act:escort, location:b, time:08:20:00 --&gt; 08:30:00, duration:0:10:00)\n3:\tLeg(mode:pt, area:b --&gt; b, time:08:30:00 --&gt; 09:00:00, duration:0:30:00)\n4:\tActivity(act:work, location:b, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:10:00:00 --&gt; 10:20:00, duration:0:20:00)\n6:\tActivity(act:work, location:b, time:10:20:00 --&gt; 12:00:00, duration:1:40:00)\n7:\tLeg(mode:pt, area:b --&gt; c, time:12:00:00 --&gt; 12:20:00, duration:0:20:00)\n8:\tActivity(act:work, location:b, time:12:20:00 --&gt; 14:00:00, duration:1:40:00)\n9:\tLeg(mode:pt, area:b --&gt; c, time:14:00:00 --&gt; 14:20:00, duration:0:20:00)\n10:\tActivity(act:leisure, location:c, time:14:20:00 --&gt; 15:30:00, duration:1:10:00)\n11:\tLeg(mode:pt, area:c --&gt; b, time:15:30:00 --&gt; 15:50:00, duration:0:20:00)\n12:\tActivity(act:escort, location:b, time:15:50:00 --&gt; 16:00:00, duration:0:10:00)\n13:\tLeg(mode:walk, area:b --&gt; a, time:16:00:00 --&gt; 16:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:16:20:00 --&gt; 18:00:00, duration:1:40:00)\n15:\tLeg(mode:walk, area:a --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:a, time:18:20:00 --&gt; 18:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:a --&gt; a, time:18:50:00 --&gt; 19:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:a, time:19:00:00 --&gt; 19:50:00, duration:0:50:00)\n19:\tLeg(mode:walk, area:a --&gt; a, time:19:50:00 --&gt; 20:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:20:10:00 --&gt; 00:00:00, duration:3:50:00)\n</pre> In\u00a0[63]: Copied! <pre>all_together_pop = apply_policies(\n    population,\n    [\n        policy_quarantine,\n        policy_remove_education_and_escort,\n        policy_remove_leisure,\n        policy_unemployment_and_furlough,\n        policy_remove_shopping,\n    ],\n)\n\nprint_simple_stats(all_together_pop)\n</pre> all_together_pop = apply_policies(     population,     [         policy_quarantine,         policy_remove_education_and_escort,         policy_remove_leisure,         policy_unemployment_and_furlough,         policy_remove_shopping,     ], )  print_simple_stats(all_together_pop) <pre>Population total time at home: 38.00 hours\nPopulation total travel time: 3.00 hours\n</pre>"},{"location":"examples/09_advanced_policies/#modifying-the-population-using-complex-policies","title":"Modifying the population using complex policies\u00b6","text":"<p>This notebook shows how complex policies can be applied to people, households, and entire populations.</p>"},{"location":"examples/09_advanced_policies/#create-example-population","title":"Create example Population\u00b6","text":""},{"location":"examples/09_advanced_policies/#add-smith-household","title":"Add Smith household\u00b6","text":""},{"location":"examples/09_advanced_policies/#add-jones-household","title":"Add Jones household\u00b6","text":""},{"location":"examples/09_advanced_policies/#pam-complex-policies","title":"PAM Complex Policies\u00b6","text":"<p>Based on link</p>"},{"location":"examples/09_advanced_policies/#household-quarantine","title":"Household Quarantine\u00b6","text":"<p>Probabilistically apply quarantine to a household (remove all activities - stay at home)</p>"},{"location":"examples/09_advanced_policies/#person-based-all-people-equal","title":"Person-based, all people equal\u00b6","text":"<p>If you have a probability of any person having to be quarantined</p>"},{"location":"examples/09_advanced_policies/#using-joint-distribution","title":"Using joint distribution\u00b6","text":""},{"location":"examples/09_advanced_policies/#chaining-probabilities","title":"Chaining probabilities\u00b6","text":""},{"location":"examples/09_advanced_policies/#remove-education","title":"Remove Education\u00b6","text":"<p>Probabilistically remove education activities from a person and escort from people in the same household</p>"},{"location":"examples/09_advanced_policies/#personattributefilter","title":"PersonAttributeFilter\u00b6","text":"<p>You can also use the <code>modify.PersonAttributeFilter</code> to only affect people with certain attributes.</p>"},{"location":"examples/09_advanced_policies/#remove-leisure-activities","title":"Remove Leisure Activities\u00b6","text":"<p>Remove all leisure activities</p>"},{"location":"examples/09_advanced_policies/#unemploymentfurlough","title":"Unemployment/Furlough\u00b6","text":"<p>Probabilistically remove all work activities from a person</p>"},{"location":"examples/09_advanced_policies/#remove-shopping","title":"Remove Shopping\u00b6","text":"<p>Probabilistically remove individual shopping activities from a person</p>"},{"location":"examples/09_advanced_policies/#reducing-shared-activities","title":"Reducing shared activities\u00b6","text":""},{"location":"examples/09_advanced_policies/#moving-shopping-tours","title":"Moving Shopping tours\u00b6","text":""},{"location":"examples/09_advanced_policies/#all-together-now","title":"All together now!\u00b6","text":""},{"location":"examples/11_Advanced_Plan_Rescheduling/","title":"Plan Rescheduling","text":"In\u00a0[1]: Copied! <pre>from pam.activity import Activity, Leg\nfrom pam.core import Person\nfrom pam.scoring import CharyparNagelPlanScorer\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n\n%matplotlib inline\n</pre> from pam.activity import Activity, Leg from pam.core import Person from pam.scoring import CharyparNagelPlanScorer from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY  %matplotlib inline In\u00a0[2]: Copied! <pre>default_config = {\n    \"mUM\": 1,\n    \"utilityOfLineSwitch\": -1,\n    \"performing\": 6,\n    \"waiting\": -1,\n    \"waitingPt\": -2,\n    \"lateArrival\": -18,\n    \"earlyDeparture\": -6,\n    \"work\": {\n        \"typicalDuration\": \"08:30:00\",\n        \"openingTime\": \"06:00:00\",\n        \"closingTime\": \"20:00:00\",\n        \"latestStartTime\": \"09:30:00\",\n        \"earliestEndTime\": \"16:00:00\",\n        \"minimalDuration\": \"08:00:00\",\n    },\n    \"home\": {\n        \"typicalDuration\": \"09:00:00\",\n        \"minimalDuration\": \"06:00:00\",\n        \"earliestEndTime\": \"06:00:00\",\n    },\n    \"shop\": {\n        \"openingTime\": \"06:00:00\",\n        \"closingTime\": \"20:00:00\",\n        \"typicalDuration\": \"00:30:00\",\n        \"minimalDuration\": \"00:30:00\",\n    },\n    \"car\": {\n        \"constant\": -5,\n        \"dailyMonetaryConstant\": -0,\n        \"dailyUtilityConstant\": -0,\n        \"marginalUtilityOfDistance\": -0,\n        \"marginalUtilityOfTravelling\": -0,\n        \"monetaryDistanceRate\": -0.0005,\n    },\n    \"walk\": {\"marginalUtilityOfTravelling\": -12},\n}\n\nconfig = {subpop: default_config for subpop in [\"default\"]}\n\nscorer = CharyparNagelPlanScorer(cnfg=config)\n</pre> default_config = {     \"mUM\": 1,     \"utilityOfLineSwitch\": -1,     \"performing\": 6,     \"waiting\": -1,     \"waitingPt\": -2,     \"lateArrival\": -18,     \"earlyDeparture\": -6,     \"work\": {         \"typicalDuration\": \"08:30:00\",         \"openingTime\": \"06:00:00\",         \"closingTime\": \"20:00:00\",         \"latestStartTime\": \"09:30:00\",         \"earliestEndTime\": \"16:00:00\",         \"minimalDuration\": \"08:00:00\",     },     \"home\": {         \"typicalDuration\": \"09:00:00\",         \"minimalDuration\": \"06:00:00\",         \"earliestEndTime\": \"06:00:00\",     },     \"shop\": {         \"openingTime\": \"06:00:00\",         \"closingTime\": \"20:00:00\",         \"typicalDuration\": \"00:30:00\",         \"minimalDuration\": \"00:30:00\",     },     \"car\": {         \"constant\": -5,         \"dailyMonetaryConstant\": -0,         \"dailyUtilityConstant\": -0,         \"marginalUtilityOfDistance\": -0,         \"marginalUtilityOfTravelling\": -0,         \"monetaryDistanceRate\": -0.0005,     },     \"walk\": {\"marginalUtilityOfTravelling\": -12}, }  config = {subpop: default_config for subpop in [\"default\"]}  scorer = CharyparNagelPlanScorer(cnfg=config) In\u00a0[3]: Copied! <pre>personA = Person(\"Ahmed\", attributes={\"age\": 20, \"subpopulation\": \"default\"})\npersonA.plan.day = [\n    Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(420)),\n    Leg(mode=\"car\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(act=\"shop\", area=2, start_time=mtdt(480), end_time=mtdt(510)),\n    Leg(mode=\"walk\", start_time=mtdt(510), end_time=mtdt(570), distance=1000),\n    Activity(act=\"work\", area=3, start_time=mtdt(570), end_time=mtdt(1140)),\n    Leg(mode=\"car\", start_time=mtdt(1140), end_time=mtdt(1200), distance=1000),\n    Activity(act=\"home\", area=1, start_time=mtdt(1200), end_time=END_OF_DAY),\n]\n\npersonB = Person(\"Brenda\", attributes={\"age\": 20, \"subpopulation\": \"default\"})\npersonB.plan.day = [\n    Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(300)),\n    Leg(mode=\"car\", start_time=mtdt(300), end_time=mtdt(360), distance=1000),\n    Activity(act=\"shop\", area=2, start_time=mtdt(360), end_time=mtdt(420)),\n    Leg(mode=\"walk\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(act=\"work\", area=3, start_time=mtdt(480), end_time=mtdt(1320)),\n    Leg(mode=\"car\", start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),\n    Activity(act=\"home\", area=1, start_time=mtdt(1380), end_time=END_OF_DAY),\n]\n\npersonC = Person(\"Cookie\", attributes={\"age\": 20, \"subpopulation\": \"default\"})\npersonC.plan.day = [\n    Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(120)),\n    Leg(mode=\"car\", start_time=mtdt(120), end_time=mtdt(180), distance=1000),\n    Activity(act=\"shop\", area=2, start_time=mtdt(180), end_time=mtdt(420)),\n    Leg(mode=\"walk\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(act=\"work\", area=3, start_time=mtdt(480), end_time=mtdt(1320)),\n    Leg(mode=\"car\", start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),\n    Activity(act=\"home\", area=1, start_time=mtdt(1380), end_time=END_OF_DAY),\n]\n\npersonA.plot()\npersonB.plot()\npersonC.plot()\n</pre> personA = Person(\"Ahmed\", attributes={\"age\": 20, \"subpopulation\": \"default\"}) personA.plan.day = [     Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(420)),     Leg(mode=\"car\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(act=\"shop\", area=2, start_time=mtdt(480), end_time=mtdt(510)),     Leg(mode=\"walk\", start_time=mtdt(510), end_time=mtdt(570), distance=1000),     Activity(act=\"work\", area=3, start_time=mtdt(570), end_time=mtdt(1140)),     Leg(mode=\"car\", start_time=mtdt(1140), end_time=mtdt(1200), distance=1000),     Activity(act=\"home\", area=1, start_time=mtdt(1200), end_time=END_OF_DAY), ]  personB = Person(\"Brenda\", attributes={\"age\": 20, \"subpopulation\": \"default\"}) personB.plan.day = [     Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(300)),     Leg(mode=\"car\", start_time=mtdt(300), end_time=mtdt(360), distance=1000),     Activity(act=\"shop\", area=2, start_time=mtdt(360), end_time=mtdt(420)),     Leg(mode=\"walk\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(act=\"work\", area=3, start_time=mtdt(480), end_time=mtdt(1320)),     Leg(mode=\"car\", start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),     Activity(act=\"home\", area=1, start_time=mtdt(1380), end_time=END_OF_DAY), ]  personC = Person(\"Cookie\", attributes={\"age\": 20, \"subpopulation\": \"default\"}) personC.plan.day = [     Activity(act=\"home\", area=1, start_time=mtdt(0), end_time=mtdt(120)),     Leg(mode=\"car\", start_time=mtdt(120), end_time=mtdt(180), distance=1000),     Activity(act=\"shop\", area=2, start_time=mtdt(180), end_time=mtdt(420)),     Leg(mode=\"walk\", start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(act=\"work\", area=3, start_time=mtdt(480), end_time=mtdt(1320)),     Leg(mode=\"car\", start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),     Activity(act=\"home\", area=1, start_time=mtdt(1380), end_time=END_OF_DAY), ]  personA.plot() personB.plot() personC.plot() In\u00a0[4]: Copied! <pre>print(f\"{personA.pid}'s score = {scorer.score_person(personA)}\")\nprint(f\"{personB.pid}'s score = {scorer.score_person(personB)}\")\nprint(f\"{personC.pid}'s score = {scorer.score_person(personC)}\")\n</pre> print(f\"{personA.pid}'s score = {scorer.score_person(personA)}\") print(f\"{personB.pid}'s score = {scorer.score_person(personB)}\") print(f\"{personC.pid}'s score = {scorer.score_person(personC)}\") <pre>Ahmed's score = 101.5087249455776\nBrenda's score = 220.77119050471717\nCookie's score = 162.59537925482084\n</pre> In\u00a0[5]: Copied! <pre>from pam.optimise import grid, random\n</pre> from pam.optimise import grid, random In\u00a0[6]: Copied! <pre>plans = [personA.plan, personB.plan, personC.plan]\n\nprint(\"Random search optimisation:\")\noptimised_by_random = []\nfor plan in plans:\n    optimised, _ = random.reschedule(\n        plan, plans_scorer=scorer, config=config[\"default\"], patience=5000\n    )\n    optimised_by_random.append(optimised)\nprint(\"Grid search optimisation:\")\noptimised_by_grid = []\nfor plan in plans:\n    optimised, _ = grid.grid_search(\n        plan, plans_scorer=scorer, config=config[\"default\"], step=1800  # step size is in seconds\n    )\n    optimised_by_grid.append(optimised)\n</pre> plans = [personA.plan, personB.plan, personC.plan]  print(\"Random search optimisation:\") optimised_by_random = [] for plan in plans:     optimised, _ = random.reschedule(         plan, plans_scorer=scorer, config=config[\"default\"], patience=5000     )     optimised_by_random.append(optimised) print(\"Grid search optimisation:\") optimised_by_grid = [] for plan in plans:     optimised, _ = grid.grid_search(         plan, plans_scorer=scorer, config=config[\"default\"], step=1800  # step size is in seconds     )     optimised_by_grid.append(optimised) <pre>Random search optimisation:\nScore improved from 101.5087249455776 to 216.254252552023 in 5000 steps.\nFailed to improve score from initial 220.77119050471717 in 5000 steps.\nScore improved from 162.59537925482084 to 214.6007531305425 in 5000 steps.\nGrid search optimisation:\nScore improved from 101.5087249455776 to 242.61260211505845 using step size 1800s.\nScore improved from 220.77119050471717 to 242.61260211505845 using step size 1800s.\nScore improved from 162.59537925482084 to 242.61260211505845 using step size 1800s.\n</pre> <p>Note that the random search quality depends upon the level of patience and the grid search on the step size. Setting patience higher or using smaller grid steps may result in better scores but at the cost of more compute. We can think of better ways to implement these schedule optimisers, but we leave it as an exercise to the reader.</p> <p>In this case we can see that the grid search finds a schedule with a short shopping trip at 7.30 and the 10 hours at work. For our example grid search finds the same optima for all, because the plans have the same activities, sequence, and trips.</p> In\u00a0[7]: Copied! <pre>optimised_by_random[1].plot()\noptimised_by_grid[1].plot()\n</pre> optimised_by_random[1].plot() optimised_by_grid[1].plot() In\u00a0[8]: Copied! <pre>config[\"default\"][\"home\"][\"typicalDuration\"] = \"12:00:00\"  # previously \"09:00:00\"\nconfig[\"default\"][\"home\"][\"minimalDuration\"] = \"10:00:00\"  # previously \"06:00:00\"\nconfig[\"default\"][\"home\"][\"earliestEndTime\"] = \"07:00:00\"  # previously \"06:00:00\"\n\nscorer = CharyparNagelPlanScorer(cnfg=config)\n\noptimised, _ = grid.grid_search(\n    plans[0], plans_scorer=scorer, config=config[\"default\"], step=1800  # step size is in seconds\n)\noptimised.plot()\n</pre> config[\"default\"][\"home\"][\"typicalDuration\"] = \"12:00:00\"  # previously \"09:00:00\" config[\"default\"][\"home\"][\"minimalDuration\"] = \"10:00:00\"  # previously \"06:00:00\" config[\"default\"][\"home\"][\"earliestEndTime\"] = \"07:00:00\"  # previously \"06:00:00\"  scorer = CharyparNagelPlanScorer(cnfg=config)  optimised, _ = grid.grid_search(     plans[0], plans_scorer=scorer, config=config[\"default\"], step=1800  # step size is in seconds ) optimised.plot() <pre>Score improved from 102.4076882473681 to 244.0 using step size 1800s.\n</pre> <p>By adjusting our scorer to value time at home more, we can see that the grid search has found a new schedule with later start time and shorter work duration. We can use this approach to refine our configuration to one that we prefer.</p> In\u00a0[9]: Copied! <pre>from pam.array import distance, encode\n\nmapping = {\"home\": 0, \"travel\": 1, \"shop\": 2, \"work\": 3}  # activity type to column index map\n# Example one-hot encoding:\nencode.plan_to_one_hot(plans[0], mapping)\n</pre> from pam.array import distance, encode  mapping = {\"home\": 0, \"travel\": 1, \"shop\": 2, \"work\": 3}  # activity type to column index map # Example one-hot encoding: encode.plan_to_one_hot(plans[0], mapping) Out[9]: <pre>array([[1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 1., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.]])</pre> In\u00a0[10]: Copied! <pre>ranked = []\nfor name, plan, optimised in zip([\"Ahmed\", \"Brenda\", \"Cookie\"], plans, optimised_by_grid):\n    plan_encoded = encode.plan_to_one_hot(plan, mapping, bin_size=900)\n    optimised_encoded = encode.plan_to_one_hot(optimised, mapping, bin_size=900)\n    difference = distance.accuracy(plan_encoded, optimised_encoded)\n    ranked.append((name, difference))\n\nranked = sorted(ranked, key=lambda x: x[1], reverse=True)\n\nfor name, score in ranked:\n    print(name, score)\n</pre> ranked = [] for name, plan, optimised in zip([\"Ahmed\", \"Brenda\", \"Cookie\"], plans, optimised_by_grid):     plan_encoded = encode.plan_to_one_hot(plan, mapping, bin_size=900)     optimised_encoded = encode.plan_to_one_hot(optimised, mapping, bin_size=900)     difference = distance.accuracy(plan_encoded, optimised_encoded)     ranked.append((name, difference))  ranked = sorted(ranked, key=lambda x: x[1], reverse=True)  for name, score in ranked:     print(name, score) <pre>Ahmed 0.7916666666666666\nBrenda 0.75\nCookie 0.6041666666666666\n</pre> <p>Ahmed's plan has changed most. This could be interpretted as them having the \"worst configuration\".</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#plan-rescheduling","title":"Plan Rescheduling\u00b6","text":"<p>This notebook shows how plans can be rescheduled (activity start times and duration changed). For this example we change some example plans in order to optimise each plan score. We use a scoring function based on the MATSim Charypar-Nagel score.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#step-1","title":"Step 1\u00b6","text":"<p>Configure the CharyparNagelPlanScorer. We use the Charypar-Nagel score to be consistent with MATSim, but you mighty decide to create your own.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#step-2","title":"Step 2\u00b6","text":"<p>Load or create some activity plans. In this example we create three persons plans, all with the same sequence of activities and same travel times, but with different activity start times and durations.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#step-3","title":"Step 3\u00b6","text":"<p>Score our plans. Note that for our example Brenda has the highest score.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#step-4","title":"Step 4\u00b6","text":"<p>Seek to reschedule the plans to improve their scores. We do this with the optimisers from <code>pam.optimise</code>.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#considering-different-scorers","title":"Considering Different Scorers\u00b6","text":"<p>As an experiment lets make a small change to our config file and check the outcome:</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#measuring-change","title":"Measuring Change\u00b6","text":"<p>The planner.encode module supports endoding plans in a way that they can be quantitively compared. This might be used as a systematic way to identify plans that are \"wrong\" or not correctly scored. In the following example we use a one-hot encoding of plans to show which of our example plans changes most when resheduled using the grid search:</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/","title":"Adding vehicles to plans","text":"In\u00a0[1]: Copied! <pre>import logging\nimport random\nfrom pathlib import Path\nfrom pprint import pprint\n\nfrom pam import read, write\nfrom pam.core import Person\nfrom pam.vehicles import ElectricVehicle, Vehicle, VehicleType\n</pre> import logging import random from pathlib import Path from pprint import pprint  from pam import read, write from pam.core import Person from pam.vehicles import ElectricVehicle, Vehicle, VehicleType In\u00a0[2]: Copied! <pre># load up example population\ndata_path = Path(\"data/example_data/vehicles\")\npopulation = read.read_matsim(data_path / \"example_plans.xml\")\npopulation.stats\n</pre> # load up example population data_path = Path(\"data/example_data/vehicles\") population = read.read_matsim(data_path / \"example_plans.xml\") population.stats Out[2]: <pre>{'num_households': 51,\n 'num_people': 51,\n 'num_activities': 153,\n 'num_legs': 102}</pre> In\u00a0[3]: Copied! <pre># now we randomly assign some vehicles and electric vehicles using these types\n\nfor hid, pid, p in population.people():\n    if random.random() &lt; 0.2:  # 20% change of having an ev\n        # evs have the type \"small_car\"\n        p.vehicles = {\"car\": ElectricVehicle(pid, type_id=\"small_car\", battery_capacity=100)}\n    else:\n        if random.random() &lt; 0.5:  # 40% change of having a regular vehicle of type \"small_car\"\n            p.vehicles = {\"car\": Vehicle(pid, type_id=\"small_car\")}\n        else:  # 40% change of having a vehicle of type \"ev\"\n            p.vehicles = {\"car\": Vehicle(pid, type_id=\"large_car\")}\n\n    # note that we specify the key as \"car\" as this is the transport \"mode\"\n</pre> # now we randomly assign some vehicles and electric vehicles using these types  for hid, pid, p in population.people():     if random.random() &lt; 0.2:  # 20% change of having an ev         # evs have the type \"small_car\"         p.vehicles = {\"car\": ElectricVehicle(pid, type_id=\"small_car\", battery_capacity=100)}     else:         if random.random() &lt; 0.5:  # 40% change of having a regular vehicle of type \"small_car\"             p.vehicles = {\"car\": Vehicle(pid, type_id=\"small_car\")}         else:  # 40% change of having a vehicle of type \"ev\"             p.vehicles = {\"car\": Vehicle(pid, type_id=\"large_car\")}      # note that we specify the key as \"car\" as this is the transport \"mode\" <p>Pam expects each person to contain their vehicles as a dictionary, mapping the mode of the vehicle (eg \"car\") to the vehicle. Vehicles (both regular and electric) must minimally define a unique vehicle id (<code>vid</code>) and a type (<code>type_id</code>).</p> <p>Please note that MATSim will not support a person having more than one vehicle for a mode. However if we plan to run a complex multi-modal MATSim simulation, then we might define multiple modes (taking care to maintain unique identifiers for each vehicle):</p> In\u00a0[4]: Copied! <pre>person = Person(\"0\")\nperson.vehicles = {\n    \"car\": Vehicle(\"car_0\", \"small_car\"),\n    \"taxi\": Vehicle(\"taxi_0\", \"large_car\"),\n    \"bike\": Vehicle(\"bike_0\", \"pedal_bike\"),\n}\n</pre> person = Person(\"0\") person.vehicles = {     \"car\": Vehicle(\"car_0\", \"small_car\"),     \"taxi\": Vehicle(\"taxi_0\", \"large_car\"),     \"bike\": Vehicle(\"bike_0\", \"pedal_bike\"), } <p>Electric vehicles can contain additional information about the vehicle battery state and charger access. These are designed to work with the MATSim electric vehicles extension:</p> In\u00a0[5]: Copied! <pre>person = Person(\"1\")\nperson.vehicles = {\n    \"car\": ElectricVehicle(\n        vid=\"car_0\",\n        type_id=\"small_car\",\n        battery_capacity=60,  # kWh\n        initial_soc=60,  # kWh\n        charger_types=\"default\",  # supported charger types; comma-separated list: 'default,other'\n    )\n}\n</pre> person = Person(\"1\") person.vehicles = {     \"car\": ElectricVehicle(         vid=\"car_0\",         type_id=\"small_car\",         battery_capacity=60,  # kWh         initial_soc=60,  # kWh         charger_types=\"default\",  # supported charger types; comma-separated list: 'default,other'     ) } In\u00a0[6]: Copied! <pre># first define some vehicle types and add them to the population via the vehicles_manager\npopulation.add_veh_type(VehicleType(\"small_car\"))\npopulation.add_veh_type(VehicleType(\"large_car\", length=15, width=2))\npopulation.add_veh_type(VehicleType(\"pedal_bike\", length=2, width=1))\n</pre> # first define some vehicle types and add them to the population via the vehicles_manager population.add_veh_type(VehicleType(\"small_car\")) population.add_veh_type(VehicleType(\"large_car\", length=15, width=2)) population.add_veh_type(VehicleType(\"pedal_bike\", length=2, width=1)) <p>The population has a vehicles manager will be ultimately responsible for managing our vehicles and their types, including reading and writing them from MATSim format. We can check for consistency between person vehicles and population vehicle types:</p> In\u00a0[7]: Copied! <pre>assert population.check_vehicles()\n</pre> assert population.check_vehicles() <p>So far we are using a lot of default values (especially for the ElectricVehicles). Defaults follow the same defaults as defined in MATSim's dtd files; vehicleDefinitions_v2.0.xsd and electric_vehicles_v1.dtd.</p> In\u00a0[8]: Copied! <pre>logging.basicConfig()\nlogging.getLogger().setLevel(logging.INFO)\n\nwrite.write_matsim(\n    population,\n    plans_path=\"./tmp/plans.xml\",\n    vehs_path=\"./tmp/vehicles.xml\",\n    evs_path=\"./tmp/evs.xml\",\n)\n</pre> logging.basicConfig() logging.getLogger().setLevel(logging.INFO)  write.write_matsim(     population,     plans_path=\"./tmp/plans.xml\",     vehs_path=\"./tmp/vehicles.xml\",     evs_path=\"./tmp/evs.xml\", ) <pre>INFO:root:Building population vehicles output.\nINFO:root:Writing vehicle types to ./tmp/vehicles.xml\nINFO:root:Writing vehicles to ./tmp/vehicles.xml\nINFO:root:Writing electric vehicles to ./tmp/evs.xml\n</pre> <p>Because MATSim has very strict requirements about vehicle identities and types, we also provide a \"safer\" interface for adding vehicles, which ensures that vehicle ids are unique and types defined:</p> In\u00a0[9]: Copied! <pre>population.add_veh(\"census_0\", \"census_0\", \"car\", Vehicle(\"0\", \"large_car\"))\n\ntry:\n    population.add_veh(\"census_1\", \"census_1\", \"car\", Vehicle(\"0\", \"large_car\"))\nexcept Exception as e:\n    print(e)\n\ntry:\n    population.add_veh(\"census_1\", \"census_1\", \"car\", Vehicle(\"1\", \"flying_car\"))\nexcept Exception as e:\n    print(e)\n</pre> population.add_veh(\"census_0\", \"census_0\", \"car\", Vehicle(\"0\", \"large_car\"))  try:     population.add_veh(\"census_1\", \"census_1\", \"car\", Vehicle(\"0\", \"large_car\")) except Exception as e:     print(e)  try:     population.add_veh(\"census_1\", \"census_1\", \"car\", Vehicle(\"1\", \"flying_car\")) except Exception as e:     print(e) <pre>Unable to add vehicle with duplicate vehicle id (vid): 0\nUnable to add vehicle with unknown type: 'flying_car'.\n</pre> <p>This interface is a little clunky and slow (it checks all existing ids each time), so we don't use in the following example.</p> In\u00a0[10]: Copied! <pre>population = read.read_matsim(\n    plans_path=data_path / \"plans.xml\",\n    all_vehicles_path=data_path / \"vehicles.xml\",\n    electric_vehicles_path=data_path / \"evs.xml\",\n)\n</pre> population = read.read_matsim(     plans_path=data_path / \"plans.xml\",     all_vehicles_path=data_path / \"vehicles.xml\",     electric_vehicles_path=data_path / \"evs.xml\", ) In\u00a0[11]: Copied! <pre>pprint(population.vehicle_types)\nprint(\n    f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\"\n)\nprint(f\"Population has {len(list(population.evs()))} evs.\")\n</pre> pprint(population.vehicle_types) print(     f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\" ) print(f\"Population has {len(list(population.evs()))} evs.\") <pre>{'large_car': VehicleType(id='large_car',\n                          length=15.0,\n                          width=2.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0),\n 'small_car': VehicleType(id='small_car',\n                          length=7.5,\n                          width=1.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0)}\nPopulation has 31 small cars.\nPopulation has 11 evs.\n</pre> In\u00a0[12]: Copied! <pre># 50% chance of large_car type switching to small_car\nfor _, pid, person in population.people():\n    veh = person.vehicles.get(\"car\")\n    if isinstance(veh, Vehicle) and veh.type_id == \"large_car\":\n        if random.random() &lt; 0.5:\n            person.vehicles[\"car\"] = Vehicle(pid, \"small_car\")\n</pre> # 50% chance of large_car type switching to small_car for _, pid, person in population.people():     veh = person.vehicles.get(\"car\")     if isinstance(veh, Vehicle) and veh.type_id == \"large_car\":         if random.random() &lt; 0.5:             person.vehicles[\"car\"] = Vehicle(pid, \"small_car\") In\u00a0[13]: Copied! <pre>pprint(population.vehicle_types)\npprint(population.random_person().vehicles)\nprint(\n    f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\"\n)\nprint(f\"Population has {len(list(population.evs()))} evs.\")\n</pre> pprint(population.vehicle_types) pprint(population.random_person().vehicles) print(     f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\" ) print(f\"Population has {len(list(population.evs()))} evs.\") <pre>{'large_car': VehicleType(id='large_car',\n                          length=15.0,\n                          width=2.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0),\n 'small_car': VehicleType(id='small_car',\n                          length=7.5,\n                          width=1.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0)}\n{'car': Vehicle(vid='census_38', type_id='small_car')}\nPopulation has 40 small cars.\nPopulation has 11 evs.\n</pre> In\u00a0[14]: Copied! <pre># 10% chance of small_car type switching to electric vehicle\nfor _, pid, person in population.people():\n    veh = person.vehicles.get(\"car\")\n    if isinstance(veh, Vehicle) and veh.type_id == \"small_car\":\n        if random.random() &lt; 0.5:\n            person.vehicles[\"car\"] = ElectricVehicle(pid, \"small_car\")\n</pre> # 10% chance of small_car type switching to electric vehicle for _, pid, person in population.people():     veh = person.vehicles.get(\"car\")     if isinstance(veh, Vehicle) and veh.type_id == \"small_car\":         if random.random() &lt; 0.5:             person.vehicles[\"car\"] = ElectricVehicle(pid, \"small_car\") In\u00a0[15]: Copied! <pre>pprint(population.vehicle_types)\nprint(\n    f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\"\n)\nprint(f\"Population has {len(list(population.evs()))} evs.\")\n</pre> pprint(population.vehicle_types) print(     f\"Population has {len([v for _, _, _, v  in population.vehicles() if v.type_id == 'small_car'])} small cars.\" ) print(f\"Population has {len(list(population.evs()))} evs.\") <pre>{'large_car': VehicleType(id='large_car',\n                          length=15.0,\n                          width=2.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0),\n 'small_car': VehicleType(id='small_car',\n                          length=7.5,\n                          width=1.0,\n                          networkMode='car',\n                          capacity=CapacityType(seats=4,\n                                                standingRoomInPersons=0),\n                          description='personal_vehicle',\n                          passengerCarEquivalents=1.0,\n                          flowEfficiencyFactor=1.0)}\nPopulation has 40 small cars.\nPopulation has 30 evs.\n</pre> In\u00a0[16]: Copied! <pre>logging.basicConfig()\nlogging.getLogger().setLevel(logging.INFO)\n\nwrite.write_matsim(\n    population,\n    plans_path=\"./tmp/plans.xml\",\n    vehs_path=\"./tmp/vehicles.xml\",\n    evs_path=\"./tmp/evs.xml\",\n)\n</pre> logging.basicConfig() logging.getLogger().setLevel(logging.INFO)  write.write_matsim(     population,     plans_path=\"./tmp/plans.xml\",     vehs_path=\"./tmp/vehicles.xml\",     evs_path=\"./tmp/evs.xml\", ) <pre>INFO:root:Building population vehicles output.\nINFO:root:Writing vehicle types to ./tmp/vehicles.xml\nINFO:root:Writing vehicles to ./tmp/vehicles.xml\nINFO:root:Writing electric vehicles to ./tmp/evs.xml\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/12_Advanced_Adding_Vehicles/#adding-vehicles-to-plans","title":"Adding vehicles to plans\u00b6","text":"<p>In this example, we show how an existing set of plans can be updated to include additional vehicles.</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/#giving-agents-vehicles","title":"Giving agents vehicles\u00b6","text":"<p>A simple approach is to create some vehicles and assign them to our agents</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/#vehicle-types","title":"Vehicle types\u00b6","text":"<p>If we want to write our vehicles to MATSim format, then we need to also define the vehicle types. In the above examples we described three vehicle types, a <code>small_car</code>, <code>large_car</code>, and <code>pedal_bike</code>. We define these types by adding them to the population:</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/#writing-to-matsim-format","title":"Writing to MATSim format\u00b6","text":"<p>We can use the standard pam.write to write these vehicle formats to disk by providing a vehicles and, optionally, an electric vehciles path.</p>"},{"location":"examples/12_Advanced_Adding_Vehicles/#modifying-vehicles-in-existing-matsim-population","title":"Modifying vehicles in existing MATSim population\u00b6","text":"<p>Pam can also read vehicles (and electric vehicles) from an existing MATSim population. These can then be checked and/or modified before writing a new population.</p>"},{"location":"examples/02a_tabular_read_write/","title":"Tabular Read-Write","text":"In\u00a0[1]: Copied! <pre>import os\n\nimport pandas as pd\n\nfrom pam import read\n</pre> import os  import pandas as pd  from pam import read In\u00a0[2]: Copied! <pre>trips = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\"\n)\npersons = pd.read_csv(\n    os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\"\n)\ntrips.head(10)\n</pre> trips = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_travel_diaries.csv\"), index_col=\"uid\" ) persons = pd.read_csv(     os.path.join(\"data\", \"example_data\", \"example_attributes.csv\"), index_col=\"pid\" ) trips.head(10) Out[2]: pid hid seq hzone ozone dzone purp mode tst tet freq uid 0 census_0 census_0 0 Harrow Harrow Camden work pt 444 473 1000 1 census_0 census_0 1 Harrow Camden Harrow work pt 890 919 1000 2 census_1 census_1 0 Greenwich Greenwich Tower Hamlets work pt 507 528 1000 3 census_1 census_1 1 Greenwich Tower Hamlets Greenwich work pt 1065 1086 1000 4 census_2 census_2 0 Croydon Croydon Croydon work pt 422 425 1000 5 census_2 census_2 1 Croydon Croydon Croydon work pt 917 920 1000 6 census_3 census_3 0 Haringey Haringey Redbridge work pt 428 447 1000 7 census_3 census_3 1 Haringey Redbridge Haringey work pt 1007 1026 1000 8 census_4 census_4 0 Hounslow Hounslow Westminster,City of London work car 483 516 1000 9 census_4 census_4 1 Hounslow Westminster,City of London Hounslow work car 1017 1050 1000 In\u00a0[3]: Copied! <pre>persons.head(10)\n</pre> persons.head(10) Out[3]: gender job occ inc pid census_0 female work white low census_1 female work white low census_2 male work blue high census_3 male work blue low census_4 male work blue medium census_5 other education white medium census_6 female work blue low census_7 male education white high census_8 female work blue medium census_9 female work white low In\u00a0[4]: Copied! <pre>population = read.load_travel_diary(trips, persons, trip_freq_as_person_freq=True)\n</pre> population = read.load_travel_diary(trips, persons, trip_freq_as_person_freq=True) <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all trips.\n</pre> In\u00a0[5]: Copied! <pre>household = population.households[\"census_12\"]\nperson = household.people[\"census_12\"]\nperson.print()\n</pre> household = population.households[\"census_12\"] person = household.people[\"census_12\"] person.print() <pre>Person: census_12\n{'gender': 'female', 'job': 'education', 'occ': 'white', 'inc': 'high', 'hzone': 'Croydon'}\n0:\tActivity(act:home, location:Croydon, time:00:00:00 --&gt; 07:06:00, duration:7:06:00)\n1:\tLeg(mode:pt, area:Croydon --&gt; Tower Hamlets, time:07:06:00 --&gt; 07:45:00, duration:0:39:00)\n2:\tActivity(act:education, location:Tower Hamlets, time:07:45:00 --&gt; 15:54:00, duration:8:09:00)\n3:\tLeg(mode:pt, area:Tower Hamlets --&gt; Croydon, time:15:54:00 --&gt; 16:33:00, duration:0:39:00)\n4:\tActivity(act:home, location:Croydon, time:16:33:00 --&gt; 00:00:00, duration:7:27:00)\n</pre> In\u00a0[6]: Copied! <pre>person.plot()\n</pre> person.plot() In\u00a0[7]: Copied! <pre>from pam import write\n\nwrite.to_csv(population, dir=\"tmp\")\n</pre> from pam import write  write.to_csv(population, dir=\"tmp\") <p>PAM can also write directly to O-D matrices using <code>pam.write.write_od_matrices</code>. This can optionally be segmented (read the docs). But does not currently support trip weighting (frequency).</p> In\u00a0[8]: Copied! <pre>write.write_od_matrices(population, \"tmp\")\n</pre> write.write_od_matrices(population, \"tmp\") In\u00a0[9]: Copied! <pre>population.pickle(os.path.join(\"tmp\", \"population.pickle\"))\n</pre> population.pickle(os.path.join(\"tmp\", \"population.pickle\"))"},{"location":"examples/02a_tabular_read_write/#tabular-read-write","title":"Tabular Read-Write\u00b6","text":"<p>This notebook is an introduction to the PAM tabular read-write methods. It has two parts:</p> <ol> <li>Read</li> <li>Write</li> </ol>"},{"location":"examples/02a_tabular_read_write/#read-tabular-format","title":"Read Tabular Format\u00b6","text":"<p>PAM can read from either tabular or MATSim formats. Tabular formats use the <code>pam.read.load_travel_diary</code> function, which will try to automatically infer trips and activities from commonly formatted travel diary data.</p> <p>Tabular data should include a trips table and then optionally, atributes tables for persons and/or households. Tabular data is expected as pandas DataFrames with column names as described in the docs and/or as in the following example.</p> <p>The following demonstration data is available in the <code>data/example_data</code> directory. All data paths in this example are relative to the notebook directory in the PAM repository.</p>"},{"location":"examples/02a_tabular_read_write/#step-1","title":"Step 1\u00b6","text":"<p>Load your trips (and attributes) data into pandas DataFrames. Reformat and rename the columns as required (please read the docs). The following example already has the required data types and column names:</p> <p>trips:</p> <p>Each row represents a trip, where:</p> <ul> <li>pid: person id of trip</li> <li>hid: household id of trip (optional)</li> <li>seq: sequence of trip within day (optional if order is already correct)</li> <li>hzone: home zone of person (optional)</li> <li>ozone: origin zone of trip</li> <li>dzone: destination zone of trip</li> <li>purp: purpose of trip (note that other ways of classifying purpose are supported - read the docs!)</li> <li>mode: trip mode</li> <li>tst: (integer) trip start time in minutes from start of day (typically from midnight)</li> <li>tet: (integer) trip end time as above</li> <li>freq: sample weighting (optional)</li> </ul> <p>persons:</p> <p>Each row represents a persons attributes. These can be arbitrary key - value pairs, with most types supported. The following are examples:</p> <ul> <li>pid: person id, must be consistent with trips data (required)</li> <li>gender: gender of person (example)</li> <li>job: employment status of person (example)</li> <li>occ: employment type of person (example)</li> <li>inc: income of person (example)</li> </ul>"},{"location":"examples/02a_tabular_read_write/#step-2","title":"Step 2:\u00b6","text":"<p>Load the travel diary data:</p>"},{"location":"examples/02a_tabular_read_write/#step-3","title":"Step 3:\u00b6","text":"<p>Check everything is as expected. PAM will try to infer activities from trip data, including for arbitrarily complex sequences of nested tours.</p> <p>However, trip purpose can be encoded in a variety of ways. PAM will try to make sensible inference based on the data provided. If something looks wrong then check the docs, then consider raising an issue. The team are keen to support you!</p>"},{"location":"examples/02a_tabular_read_write/#write-tabular-data","title":"Write Tabular Data\u00b6","text":"<p>PAM can write into a preferred tabular formats using <code>pam.write.to_csv</code>. This outputs trip legs, household attributes and person attributes tables. Where sufficient geometries are found, PAM will write spatial data as geojson.</p>"},{"location":"examples/02a_tabular_read_write/#pickle","title":"Pickle\u00b6","text":"<p>Not a tabular format but if you've read this far - you might like to know that there is a Population.pickle method:</p>"},{"location":"examples/05_policies_walk_through/","title":"Modifying the population using simple policies","text":"In\u00a0[1]: Copied! <pre>from copy import deepcopy\nfrom pprint import pprint\n\nfrom pam.activity import Activity, Leg\nfrom pam.core import Household, Person, Population\nfrom pam.policy import (\n    ActivityPolicy,\n    ActivityProbability,\n    HouseholdPolicy,\n    HouseholdQuarantined,\n    MoveActivityTourToHomeLocation,\n    PersonAttributeFilter,\n    PersonPolicy,\n    PersonProbability,\n    ReduceSharedActivity,\n    RemoveActivity,\n    apply_policies,\n)\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n</pre> from copy import deepcopy from pprint import pprint  from pam.activity import Activity, Leg from pam.core import Household, Person, Population from pam.policy import (     ActivityPolicy,     ActivityProbability,     HouseholdPolicy,     HouseholdQuarantined,     MoveActivityTourToHomeLocation,     PersonAttributeFilter,     PersonPolicy,     PersonProbability,     ReduceSharedActivity,     RemoveActivity,     apply_policies, ) from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY In\u00a0[2]: Copied! <pre>def hhld_apply(household, policy):\n    new_hhld = deepcopy(household)\n    policy.apply_to(new_hhld)\n    return new_hhld\n\n\ndef print_attributes(hhld, attribs=None):\n    if attribs is not None:\n        print(f\"Household: {hhld}\")\n        for pid, person in hhld.people.items():\n            print(f\"Person: {pid}\")\n            print(\"Attributes:\")\n            for attrib in attribs:\n                print(f\"\\t{attrib}: {person.attributes[attrib]}\")\n    else:\n        print(f\"Household: {hhld}\")\n        for pid, person in hhld.people.items():\n            print(f\"Person: {pid}\")\n            print(\"Attributes:\")\n            pprint(person.attributes)\n\n\ndef instantiate_household_with(persons: list):\n    household = Household(1)\n    for person in persons:\n        household.add(person)\n    return household\n\n\ndef Steve():\n    Steve = Person(\"Steve\", attributes={\"age\": 50, \"job\": \"work\", \"gender\": \"male\"})\n    Steve.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(5 * 60)))\n    Steve.add(Leg(1, \"car\", \"a\", \"b\", start_time=mtdt(5 * 60), end_time=mtdt(6 * 60)))\n    Steve.add(Activity(2, \"work\", \"b\", start_time=mtdt(6 * 60), end_time=mtdt(12 * 60)))\n    Steve.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 10)))\n    Steve.add(\n        Activity(3, \"leisure\", \"c\", start_time=mtdt(12 * 60 + 10), end_time=mtdt(13 * 60 - 10))\n    )\n    Steve.add(Leg(3, \"walk\", \"c\", \"b\", start_time=mtdt(13 * 60 - 10), end_time=mtdt(13 * 60)))\n    Steve.add(Activity(4, \"work\", \"b\", start_time=mtdt(13 * 60), end_time=mtdt(18 * 60)))\n    Steve.add(Leg(4, \"car\", \"b\", \"a\", start_time=mtdt(18 * 60), end_time=mtdt(19 * 60)))\n    Steve.add(Activity(5, \"home\", \"a\", start_time=mtdt(19 * 60), end_time=mtdt(20 * 60)))\n    Steve.add(Leg(5, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Steve.add(\n        Activity(6, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))\n    )\n    Steve.add(Leg(6, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Steve.add(Activity(7, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Steve.add(Leg(7, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Steve.add(Activity(8, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Steve\n\n\ndef Hilda():\n    Hilda = Person(\"Hilda\", attributes={\"age\": 45, \"job\": \"influencer\", \"gender\": \"female\"})\n    Hilda.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\n    Hilda.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))\n    Hilda.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30)))\n    Hilda.add(Leg(1, \"pt\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))\n    Hilda.add(Activity(2, \"shop\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(14 * 60)))\n    Hilda.add(Leg(2, \"pt\", \"b\", \"c\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))\n    Hilda.add(\n        Activity(3, \"leisure\", \"c\", start_time=mtdt(14 * 60 + 20), end_time=mtdt(16 * 60 - 20))\n    )\n    Hilda.add(Leg(3, \"pt\", \"c\", \"b\", start_time=mtdt(16 * 60 - 20), end_time=mtdt(16 * 60)))\n    Hilda.add(Activity(4, \"escort\", \"b\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))\n    Hilda.add(Leg(4, \"walk\", \"a\", \"b\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(17 * 60)))\n    Hilda.add(Activity(5, \"home\", \"a\", start_time=mtdt(17 * 60), end_time=mtdt(20 * 60)))\n    Hilda.add(Leg(5, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Hilda.add(\n        Activity(6, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))\n    )\n    Hilda.add(Leg(6, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Hilda.add(Activity(7, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Hilda.add(Leg(7, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Hilda.add(Activity(8, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Hilda\n\n\ndef Timmy():\n    Timmy = Person(\"Timmy\", attributes={\"age\": 18, \"job\": \"education\", \"gender\": \"male\"})\n    Timmy.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\n    Timmy.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))\n    Timmy.add(Activity(2, \"sport\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 55)))\n    Timmy.add(Leg(2, \"walk\", \"b\", \"a\", start_time=mtdt(8 * 60 + 55), end_time=mtdt(9 * 60)))\n    Timmy.add(Activity(3, \"home\", \"a\", start_time=mtdt(9 * 60), end_time=mtdt(10 * 60)))\n    Timmy.add(Leg(3, \"bike\", \"a\", \"b\", start_time=mtdt(10 * 60), end_time=mtdt(11 * 60)))\n    Timmy.add(Activity(4, \"education\", \"b\", start_time=mtdt(11 * 60), end_time=mtdt(13 * 60)))\n    Timmy.add(Leg(4, \"bike\", \"b\", \"c\", start_time=mtdt(13 * 60), end_time=mtdt(13 * 60 + 5)))\n    Timmy.add(Activity(5, \"shop\", \"c\", start_time=mtdt(13 * 60 + 5), end_time=mtdt(13 * 60 + 30)))\n    Timmy.add(Leg(5, \"bike\", \"c\", \"b\", start_time=mtdt(13 * 60 + 30), end_time=mtdt(13 * 60 + 35)))\n    Timmy.add(Activity(6, \"education\", \"b\", start_time=mtdt(13 * 60 + 35), end_time=mtdt(15 * 60)))\n    Timmy.add(Leg(6, \"bike\", \"b\", \"d\", start_time=mtdt(15 * 60), end_time=mtdt(15 * 60 + 10)))\n    Timmy.add(Activity(7, \"leisure\", \"d\", start_time=mtdt(15 * 60 + 10), end_time=mtdt(18 * 60)))\n    Timmy.add(Leg(7, \"bike\", \"d\", \"a\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))\n    Timmy.add(Activity(8, \"home\", \"a\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(20 * 60)))\n    Timmy.add(Leg(8, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Timmy.add(\n        Activity(9, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))\n    )\n    Timmy.add(Leg(9, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Timmy.add(Activity(10, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Timmy.add(Leg(10, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Timmy.add(Activity(11, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Timmy\n\n\ndef Bobby():\n    Bobby = Person(\"Bobby\", attributes={\"age\": 6, \"job\": \"education\", \"gender\": \"female\"})\n    Bobby.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))\n    Bobby.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))\n    Bobby.add(Activity(2, \"education\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60)))\n    Bobby.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))\n    Bobby.add(Activity(3, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(20 * 60)))\n    Bobby.add(Leg(3, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Bobby.add(\n        Activity(4, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))\n    )\n    Bobby.add(Leg(4, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Bobby.add(Activity(5, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Bobby.add(Leg(5, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Bobby.add(Activity(6, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Bobby\n</pre> def hhld_apply(household, policy):     new_hhld = deepcopy(household)     policy.apply_to(new_hhld)     return new_hhld   def print_attributes(hhld, attribs=None):     if attribs is not None:         print(f\"Household: {hhld}\")         for pid, person in hhld.people.items():             print(f\"Person: {pid}\")             print(\"Attributes:\")             for attrib in attribs:                 print(f\"\\t{attrib}: {person.attributes[attrib]}\")     else:         print(f\"Household: {hhld}\")         for pid, person in hhld.people.items():             print(f\"Person: {pid}\")             print(\"Attributes:\")             pprint(person.attributes)   def instantiate_household_with(persons: list):     household = Household(1)     for person in persons:         household.add(person)     return household   def Steve():     Steve = Person(\"Steve\", attributes={\"age\": 50, \"job\": \"work\", \"gender\": \"male\"})     Steve.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(5 * 60)))     Steve.add(Leg(1, \"car\", \"a\", \"b\", start_time=mtdt(5 * 60), end_time=mtdt(6 * 60)))     Steve.add(Activity(2, \"work\", \"b\", start_time=mtdt(6 * 60), end_time=mtdt(12 * 60)))     Steve.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 10)))     Steve.add(         Activity(3, \"leisure\", \"c\", start_time=mtdt(12 * 60 + 10), end_time=mtdt(13 * 60 - 10))     )     Steve.add(Leg(3, \"walk\", \"c\", \"b\", start_time=mtdt(13 * 60 - 10), end_time=mtdt(13 * 60)))     Steve.add(Activity(4, \"work\", \"b\", start_time=mtdt(13 * 60), end_time=mtdt(18 * 60)))     Steve.add(Leg(4, \"car\", \"b\", \"a\", start_time=mtdt(18 * 60), end_time=mtdt(19 * 60)))     Steve.add(Activity(5, \"home\", \"a\", start_time=mtdt(19 * 60), end_time=mtdt(20 * 60)))     Steve.add(Leg(5, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Steve.add(         Activity(6, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))     )     Steve.add(Leg(6, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Steve.add(Activity(7, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Steve.add(Leg(7, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Steve.add(Activity(8, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Steve   def Hilda():     Hilda = Person(\"Hilda\", attributes={\"age\": 45, \"job\": \"influencer\", \"gender\": \"female\"})     Hilda.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))     Hilda.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))     Hilda.add(Activity(2, \"escort\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30)))     Hilda.add(Leg(1, \"pt\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))     Hilda.add(Activity(2, \"shop\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(14 * 60)))     Hilda.add(Leg(2, \"pt\", \"b\", \"c\", start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))     Hilda.add(         Activity(3, \"leisure\", \"c\", start_time=mtdt(14 * 60 + 20), end_time=mtdt(16 * 60 - 20))     )     Hilda.add(Leg(3, \"pt\", \"c\", \"b\", start_time=mtdt(16 * 60 - 20), end_time=mtdt(16 * 60)))     Hilda.add(Activity(4, \"escort\", \"b\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))     Hilda.add(Leg(4, \"walk\", \"a\", \"b\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(17 * 60)))     Hilda.add(Activity(5, \"home\", \"a\", start_time=mtdt(17 * 60), end_time=mtdt(20 * 60)))     Hilda.add(Leg(5, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Hilda.add(         Activity(6, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))     )     Hilda.add(Leg(6, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Hilda.add(Activity(7, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Hilda.add(Leg(7, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Hilda.add(Activity(8, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Hilda   def Timmy():     Timmy = Person(\"Timmy\", attributes={\"age\": 18, \"job\": \"education\", \"gender\": \"male\"})     Timmy.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))     Timmy.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))     Timmy.add(Activity(2, \"sport\", \"b\", start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 55)))     Timmy.add(Leg(2, \"walk\", \"b\", \"a\", start_time=mtdt(8 * 60 + 55), end_time=mtdt(9 * 60)))     Timmy.add(Activity(3, \"home\", \"a\", start_time=mtdt(9 * 60), end_time=mtdt(10 * 60)))     Timmy.add(Leg(3, \"bike\", \"a\", \"b\", start_time=mtdt(10 * 60), end_time=mtdt(11 * 60)))     Timmy.add(Activity(4, \"education\", \"b\", start_time=mtdt(11 * 60), end_time=mtdt(13 * 60)))     Timmy.add(Leg(4, \"bike\", \"b\", \"c\", start_time=mtdt(13 * 60), end_time=mtdt(13 * 60 + 5)))     Timmy.add(Activity(5, \"shop\", \"c\", start_time=mtdt(13 * 60 + 5), end_time=mtdt(13 * 60 + 30)))     Timmy.add(Leg(5, \"bike\", \"c\", \"b\", start_time=mtdt(13 * 60 + 30), end_time=mtdt(13 * 60 + 35)))     Timmy.add(Activity(6, \"education\", \"b\", start_time=mtdt(13 * 60 + 35), end_time=mtdt(15 * 60)))     Timmy.add(Leg(6, \"bike\", \"b\", \"d\", start_time=mtdt(15 * 60), end_time=mtdt(15 * 60 + 10)))     Timmy.add(Activity(7, \"leisure\", \"d\", start_time=mtdt(15 * 60 + 10), end_time=mtdt(18 * 60)))     Timmy.add(Leg(7, \"bike\", \"d\", \"a\", start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))     Timmy.add(Activity(8, \"home\", \"a\", start_time=mtdt(18 * 60 + 20), end_time=mtdt(20 * 60)))     Timmy.add(Leg(8, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Timmy.add(         Activity(9, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))     )     Timmy.add(Leg(9, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Timmy.add(Activity(10, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Timmy.add(Leg(10, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Timmy.add(Activity(11, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Timmy   def Bobby():     Bobby = Person(\"Bobby\", attributes={\"age\": 6, \"job\": \"education\", \"gender\": \"female\"})     Bobby.add(Activity(1, \"home\", \"a\", start_time=mtdt(0), end_time=mtdt(8 * 60)))     Bobby.add(Leg(1, \"walk\", \"a\", \"b\", start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))     Bobby.add(Activity(2, \"education\", \"b\", start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60)))     Bobby.add(Leg(2, \"walk\", \"b\", \"c\", start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))     Bobby.add(Activity(3, \"home\", \"a\", start_time=mtdt(16 * 60 + 30), end_time=mtdt(20 * 60)))     Bobby.add(Leg(3, \"car\", \"a\", \"b\", start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Bobby.add(         Activity(4, \"shop_1\", \"b\", start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50))     )     Bobby.add(Leg(4, \"walk\", \"b\", \"b\", start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Bobby.add(Activity(5, \"shop_2\", \"b\", start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Bobby.add(Leg(5, \"car\", \"b\", \"a\", start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Bobby.add(Activity(6, \"home\", \"a\", start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Bobby In\u00a0[3]: Copied! <pre>smiths = instantiate_household_with([Steve(), Hilda(), Timmy(), Bobby()])\n</pre> smiths = instantiate_household_with([Steve(), Hilda(), Timmy(), Bobby()]) In\u00a0[4]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() <p>$$P_{household} = 1 - (1-P_{person})^n$$</p> <p>If you have a probability that drives of any one person living in the household.</p> <p>The probability of the household being chosen is then $$1 - (1-P)^n$$ where $P$ is the probability any one person being chosen and $n$ is the number of people in the household; $(1-P)^n$ is the probability of no one being picked.</p> In\u00a0[5]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(RemoveActivity([\"education\"]), 1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(RemoveActivity([\"education\"]), 1)).plot() <p>If you have a probability that drives of any one activity a person does.</p> <p>The probability of the person being chosen is then $$1 - (1-P)^n$$ where $P$ is the probability any one (relevant) activity being chosen and $n$ is the number of (relevant) activities in the person's plan; $(1-P)^n$ is the probability of no relevant activities being picked.</p> In\u00a0[6]: Copied! <pre>hhld_apply(smiths, PersonPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 0.5)).plot()\n</pre> hhld_apply(smiths, PersonPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 0.5)).plot() <p>If you have a probability that drives of any one activity a person does and you want to affect particular activities with no consequence to the person or household.</p> <p>Notice that given a probability $P$ for an activity you can affect the whole household. The probability of the household being chosen is then $$1 - (1-P)^n$$ where $P$ is the probability any one (relevant) activity being chosen and $n$ is then the number of all (relevant) activities in all of the persons plans within a household; $(1-P)^n$ is the probability of no relevant activities being picked for the household.</p> In\u00a0[7]: Copied! <pre>hhld_apply(smiths, ActivityPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 0.5)).plot()\n</pre> hhld_apply(smiths, ActivityPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 0.5)).plot() <p>The Policies expect certain levels of probability. For example, performing a <code>HouseholdPolicy</code> is easy, you can affect a whole household using a probability at any level, <code>household</code>, <code>person</code> or <code>activity</code>. Performing an <code>ActivityPolicy</code> however means you need information at the level of the activities you want to affect.</p> HouseholdProbability PersonProbability ActivityProbability HouseholdPolicy Yes Yes Yes PersonPolicy --- Yes Yes ActivityPolicy --- --- Yes In\u00a0[8]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(RemoveActivity([\"education\"]), 1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(RemoveActivity([\"education\"]), 1)).plot() In\u00a0[9]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(ReduceSharedActivity([\"shop_1\"]), 1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(ReduceSharedActivity([\"shop_1\"]), 1)).plot() In\u00a0[10]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]), 1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]), 1)).plot() <p>The result of this modifier do not show up on the plot. Below are the details of Hilda's original plan.</p> In\u00a0[11]: Copied! <pre>smiths[\"Hilda\"].print()\n</pre> smiths[\"Hilda\"].print() <pre>Person: Hilda\n{'age': 45, 'job': 'influencer', 'gender': 'female'}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:escort, location:b, time:08:05:00 --&gt; 08:30:00, duration:0:25:00)\n3:\tLeg(mode:pt, area:a --&gt; b, time:08:00:00 --&gt; 08:30:00, duration:0:30:00)\n4:\tActivity(act:shop, location:b, time:08:30:00 --&gt; 14:00:00, duration:5:30:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:14:00:00 --&gt; 14:20:00, duration:0:20:00)\n6:\tActivity(act:leisure, location:c, time:14:20:00 --&gt; 15:40:00, duration:1:20:00)\n7:\tLeg(mode:pt, area:c --&gt; b, time:15:40:00 --&gt; 16:00:00, duration:0:20:00)\n8:\tActivity(act:escort, location:b, time:16:00:00 --&gt; 16:30:00, duration:0:30:00)\n9:\tLeg(mode:walk, area:a --&gt; b, time:16:30:00 --&gt; 17:00:00, duration:0:30:00)\n10:\tActivity(act:home, location:a, time:17:00:00 --&gt; 20:00:00, duration:3:00:00)\n11:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n12:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n13:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n14:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n15:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n16:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> <p>Here are details of Hilda's plan post application of.<code>MoveActivityTourToHomeLocation</code> to <code>'shop'</code> activities. Compare the location of Activities 6 and 7 with the ones above. At the moment only the Leg's destination and origin get updated, the mode choice and duration remains unchanged.</p> In\u00a0[12]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]), 1))[\n    \"Hilda\"\n].print()\n</pre> hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation([\"shop_1\", \"shop_2\"]), 1))[     \"Hilda\" ].print() <pre>Person: Hilda\n{'age': 45, 'job': 'influencer', 'gender': 'female'}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:escort, location:b, time:08:05:00 --&gt; 08:30:00, duration:0:25:00)\n3:\tLeg(mode:pt, area:a --&gt; b, time:08:00:00 --&gt; 08:30:00, duration:0:30:00)\n4:\tActivity(act:shop, location:b, time:08:30:00 --&gt; 14:00:00, duration:5:30:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:14:00:00 --&gt; 14:20:00, duration:0:20:00)\n6:\tActivity(act:leisure, location:c, time:14:20:00 --&gt; 15:40:00, duration:1:20:00)\n7:\tLeg(mode:pt, area:c --&gt; b, time:15:40:00 --&gt; 16:00:00, duration:0:20:00)\n8:\tActivity(act:escort, location:b, time:16:00:00 --&gt; 16:30:00, duration:0:30:00)\n9:\tLeg(mode:walk, area:a --&gt; b, time:16:30:00 --&gt; 17:00:00, duration:0:30:00)\n10:\tActivity(act:home, location:a, time:17:00:00 --&gt; 20:00:00, duration:3:00:00)\n11:\tLeg(mode:walk, area:a --&gt; a, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n12:\tActivity(act:shop_1, location:a, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n13:\tLeg(mode:walk, area:a --&gt; a, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n14:\tActivity(act:shop_2, location:a, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n15:\tLeg(mode:walk, area:a --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n16:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[13]: Copied! <pre>print_attributes(smiths, [\"gender\", \"age\", \"job\"])\n</pre> print_attributes(smiths, [\"gender\", \"age\", \"job\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\tgender: male\n\tage: 50\n\tjob: work\nPerson: Hilda\nAttributes:\n\tgender: female\n\tage: 45\n\tjob: influencer\nPerson: Timmy\nAttributes:\n\tgender: male\n\tage: 18\n\tjob: education\nPerson: Bobby\nAttributes:\n\tgender: female\n\tage: 6\n\tjob: education\n</pre> In\u00a0[14]: Copied! <pre>def is_male(attribute_value):\n    return attribute_value == \"male\"\n\n\ncondition = {\"gender\": is_male}\n\nhhld_apply(\n    smiths, PersonPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 1, PersonAttributeFilter(condition))\n).plot()\n</pre> def is_male(attribute_value):     return attribute_value == \"male\"   condition = {\"gender\": is_male}  hhld_apply(     smiths, PersonPolicy(RemoveActivity([\"shop_1\", \"shop_2\"]), 1, PersonAttributeFilter(condition)) ).plot() In\u00a0[15]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[16]: Copied! <pre>policy_household_quarantine_per_person = HouseholdQuarantined(PersonProbability(0.01))\n</pre> policy_household_quarantine_per_person = HouseholdQuarantined(PersonProbability(0.01)) In\u00a0[17]: Copied! <pre>hhld_apply(smiths, policy_household_quarantine_per_person).plot()\n</pre> hhld_apply(smiths, policy_household_quarantine_per_person).plot() In\u00a0[18]: Copied! <pre>hhld_apply(smiths, HouseholdQuarantined(1)).plot()\n</pre> hhld_apply(smiths, HouseholdQuarantined(1)).plot() In\u00a0[19]: Copied! <pre>print_attributes(smiths, [\"age\", \"job\"])\n</pre> print_attributes(smiths, [\"age\", \"job\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\tage: 50\n\tjob: work\nPerson: Hilda\nAttributes:\n\tage: 45\n\tjob: influencer\nPerson: Timmy\nAttributes:\n\tage: 18\n\tjob: education\nPerson: Bobby\nAttributes:\n\tage: 6\n\tjob: education\n</pre> In\u00a0[20]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[21]: Copied! <pre>def over_17(attribute_value):\n    return attribute_value &gt; 17\n\n\npolicy_remove_higher_education = PersonPolicy(\n    RemoveActivity([\"education\"]),\n    PersonProbability(1),\n    PersonAttributeFilter({\"age\": over_17}, how=\"all\"),\n)\n</pre> def over_17(attribute_value):     return attribute_value &gt; 17   policy_remove_higher_education = PersonPolicy(     RemoveActivity([\"education\"]),     PersonProbability(1),     PersonAttributeFilter({\"age\": over_17}, how=\"all\"), ) In\u00a0[22]: Copied! <pre>hhld_apply(smiths, policy_remove_higher_education).plot()\n</pre> hhld_apply(smiths, policy_remove_higher_education).plot() In\u00a0[23]: Copied! <pre>smiths[\"Steve\"].attributes[\"wfh\"] = True\nsmiths[\"Steve\"].attributes[\"care_constrained\"] = False\nsmiths[\"Hilda\"].attributes[\"wfh\"] = True\nsmiths[\"Hilda\"].attributes[\"care_constrained\"] = False\nsmiths[\"Timmy\"].attributes[\"wfh\"] = False\nsmiths[\"Timmy\"].attributes[\"care_constrained\"] = False\nsmiths[\"Bobby\"].attributes[\"wfh\"] = False\nsmiths[\"Bobby\"].attributes[\"care_constrained\"] = False\n</pre> smiths[\"Steve\"].attributes[\"wfh\"] = True smiths[\"Steve\"].attributes[\"care_constrained\"] = False smiths[\"Hilda\"].attributes[\"wfh\"] = True smiths[\"Hilda\"].attributes[\"care_constrained\"] = False smiths[\"Timmy\"].attributes[\"wfh\"] = False smiths[\"Timmy\"].attributes[\"care_constrained\"] = False smiths[\"Bobby\"].attributes[\"wfh\"] = False smiths[\"Bobby\"].attributes[\"care_constrained\"] = False In\u00a0[24]: Copied! <pre>print_attributes(smiths, [\"wfh\", \"care_constrained\"])\n</pre> print_attributes(smiths, [\"wfh\", \"care_constrained\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: True\n\tcare_constrained: False\nPerson: Hilda\nAttributes:\n\twfh: True\n\tcare_constrained: False\nPerson: Timmy\nAttributes:\n\twfh: False\n\tcare_constrained: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tcare_constrained: False\n</pre> In\u00a0[25]: Copied! <pre>def attribute_False(attribute_value):\n    return not bool(attribute_value)\n\n\ndef attribute_True(attribute_value):\n    return bool(attribute_value)\n\n\nconditions = {\"care_constrained\": attribute_False, \"wfh\": attribute_True}\n\n# notice that the probability of the household (`HouseholdPolicy`) being chosen is driven\n# by the presence of education activities (`ActivityProbability(['education'], 0.95)`)\n# in the end the policy removes both education and escort (`RemoveActivity(['education', 'escort'])`)\n# but the presence of escort doesn't affect the likelihood\npolicy_remove_any_education = HouseholdPolicy(\n    RemoveActivity([\"education\", \"escort\"]),\n    ActivityProbability([\"education\"], 0.95),\n    PersonAttributeFilter(conditions),\n)\n</pre> def attribute_False(attribute_value):     return not bool(attribute_value)   def attribute_True(attribute_value):     return bool(attribute_value)   conditions = {\"care_constrained\": attribute_False, \"wfh\": attribute_True}  # notice that the probability of the household (`HouseholdPolicy`) being chosen is driven # by the presence of education activities (`ActivityProbability(['education'], 0.95)`) # in the end the policy removes both education and escort (`RemoveActivity(['education', 'escort'])`) # but the presence of escort doesn't affect the likelihood policy_remove_any_education = HouseholdPolicy(     RemoveActivity([\"education\", \"escort\"]),     ActivityProbability([\"education\"], 0.95),     PersonAttributeFilter(conditions), ) In\u00a0[26]: Copied! <pre>hhld_apply(smiths, policy_remove_any_education).plot()\n</pre> hhld_apply(smiths, policy_remove_any_education).plot() In\u00a0[27]: Copied! <pre>smiths[\"Steve\"].attributes[\"wfh\"] = False\nsmiths[\"Steve\"].attributes[\"care_constrained\"] = True\nsmiths[\"Hilda\"].attributes[\"wfh\"] = False\nsmiths[\"Hilda\"].attributes[\"care_constrained\"] = True\nsmiths[\"Timmy\"].attributes[\"wfh\"] = False\nsmiths[\"Timmy\"].attributes[\"care_constrained\"] = False\nsmiths[\"Bobby\"].attributes[\"wfh\"] = False\nsmiths[\"Bobby\"].attributes[\"care_constrained\"] = False\n\nprint_attributes(smiths, [\"wfh\", \"care_constrained\"])\n</pre> smiths[\"Steve\"].attributes[\"wfh\"] = False smiths[\"Steve\"].attributes[\"care_constrained\"] = True smiths[\"Hilda\"].attributes[\"wfh\"] = False smiths[\"Hilda\"].attributes[\"care_constrained\"] = True smiths[\"Timmy\"].attributes[\"wfh\"] = False smiths[\"Timmy\"].attributes[\"care_constrained\"] = False smiths[\"Bobby\"].attributes[\"wfh\"] = False smiths[\"Bobby\"].attributes[\"care_constrained\"] = False  print_attributes(smiths, [\"wfh\", \"care_constrained\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: False\n\tcare_constrained: True\nPerson: Hilda\nAttributes:\n\twfh: False\n\tcare_constrained: True\nPerson: Timmy\nAttributes:\n\twfh: False\n\tcare_constrained: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tcare_constrained: False\n</pre> In\u00a0[28]: Copied! <pre>hhld_apply(smiths, policy_remove_any_education).plot()\n</pre> hhld_apply(smiths, policy_remove_any_education).plot() In\u00a0[29]: Copied! <pre>policy_remove_leisure = PersonPolicy(RemoveActivity([\"leisure\"]), PersonProbability(1))\n</pre> policy_remove_leisure = PersonPolicy(RemoveActivity([\"leisure\"]), PersonProbability(1)) In\u00a0[30]: Copied! <pre>hhld_apply(smiths, policy_remove_leisure).plot()\n</pre> hhld_apply(smiths, policy_remove_leisure).plot() In\u00a0[31]: Copied! <pre>smiths[\"Timmy\"].print()\n</pre> smiths[\"Timmy\"].print() <pre>Person: Timmy\n{'age': 18, 'job': 'education', 'gender': 'male', 'wfh': False, 'care_constrained': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:sport, location:b, time:08:05:00 --&gt; 08:55:00, duration:0:50:00)\n3:\tLeg(mode:walk, area:b --&gt; a, time:08:55:00 --&gt; 09:00:00, duration:0:05:00)\n4:\tActivity(act:home, location:a, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:a --&gt; b, time:10:00:00 --&gt; 11:00:00, duration:1:00:00)\n6:\tActivity(act:education, location:b, time:11:00:00 --&gt; 13:00:00, duration:2:00:00)\n7:\tLeg(mode:bike, area:b --&gt; c, time:13:00:00 --&gt; 13:05:00, duration:0:05:00)\n8:\tActivity(act:shop, location:c, time:13:05:00 --&gt; 13:30:00, duration:0:25:00)\n9:\tLeg(mode:bike, area:c --&gt; b, time:13:30:00 --&gt; 13:35:00, duration:0:05:00)\n10:\tActivity(act:education, location:b, time:13:35:00 --&gt; 15:00:00, duration:1:25:00)\n11:\tLeg(mode:bike, area:b --&gt; d, time:15:00:00 --&gt; 15:10:00, duration:0:10:00)\n12:\tActivity(act:leisure, location:d, time:15:10:00 --&gt; 18:00:00, duration:2:50:00)\n13:\tLeg(mode:bike, area:d --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:18:20:00 --&gt; 20:00:00, duration:1:40:00)\n15:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n19:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[32]: Copied! <pre>policy_move_sport = PersonPolicy(MoveActivityTourToHomeLocation([\"sport\"]), PersonProbability(1))\n</pre> policy_move_sport = PersonPolicy(MoveActivityTourToHomeLocation([\"sport\"]), PersonProbability(1)) In\u00a0[33]: Copied! <pre>hhld_apply(smiths, policy_move_sport)[\"Timmy\"].print()\n</pre> hhld_apply(smiths, policy_move_sport)[\"Timmy\"].print() <pre>Person: Timmy\n{'age': 18, 'job': 'education', 'gender': 'male', 'wfh': False, 'care_constrained': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; a, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:sport, location:a, time:08:05:00 --&gt; 08:55:00, duration:0:50:00)\n3:\tLeg(mode:walk, area:a --&gt; a, time:08:55:00 --&gt; 09:00:00, duration:0:05:00)\n4:\tActivity(act:home, location:a, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:a --&gt; b, time:10:00:00 --&gt; 11:00:00, duration:1:00:00)\n6:\tActivity(act:education, location:b, time:11:00:00 --&gt; 13:00:00, duration:2:00:00)\n7:\tLeg(mode:bike, area:b --&gt; c, time:13:00:00 --&gt; 13:05:00, duration:0:05:00)\n8:\tActivity(act:shop, location:c, time:13:05:00 --&gt; 13:30:00, duration:0:25:00)\n9:\tLeg(mode:bike, area:c --&gt; b, time:13:30:00 --&gt; 13:35:00, duration:0:05:00)\n10:\tActivity(act:education, location:b, time:13:35:00 --&gt; 15:00:00, duration:1:25:00)\n11:\tLeg(mode:bike, area:b --&gt; d, time:15:00:00 --&gt; 15:10:00, duration:0:10:00)\n12:\tActivity(act:leisure, location:d, time:15:10:00 --&gt; 18:00:00, duration:2:50:00)\n13:\tLeg(mode:bike, area:d --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:18:20:00 --&gt; 20:00:00, duration:1:40:00)\n15:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n19:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[34]: Copied! <pre>def discrete_joint_distribution_sampler(person, mapping, distribution):\n    p = distribution\n    for key in mapping:\n        value = person.attributes.get(key)\n        if value is None:\n            msg = f\"Cannot find mapping: {key} in sampling features: {person.attributes}\"\n            raise KeyError(msg)\n        p = p.get(value)\n        if p is None:\n            msg = f\"Cannot find feature for {key}: {value} in distribution: {p}\"\n            raise KeyError(msg)\n    return p\n</pre> def discrete_joint_distribution_sampler(person, mapping, distribution):     p = distribution     for key in mapping:         value = person.attributes.get(key)         if value is None:             msg = f\"Cannot find mapping: {key} in sampling features: {person.attributes}\"             raise KeyError(msg)         p = p.get(value)         if p is None:             msg = f\"Cannot find feature for {key}: {value} in distribution: {p}\"             raise KeyError(msg)     return p In\u00a0[35]: Copied! <pre>vulnerable_mapping = [\"age\", \"gender\"]\nvulnerable_distribution = dict(\n    zip(\n        list(range(101)),\n        [{\"male\": i / 100, \"female\": i / 100, \"other\": i / 100} for i in range(101)],\n    )\n)\n</pre> vulnerable_mapping = [\"age\", \"gender\"] vulnerable_distribution = dict(     zip(         list(range(101)),         [{\"male\": i / 100, \"female\": i / 100, \"other\": i / 100} for i in range(101)],     ) ) In\u00a0[36]: Copied! <pre>dict(list(vulnerable_distribution.items())[0:15])\n</pre> dict(list(vulnerable_distribution.items())[0:15]) Out[36]: <pre>{0: {'male': 0.0, 'female': 0.0, 'other': 0.0},\n 1: {'male': 0.01, 'female': 0.01, 'other': 0.01},\n 2: {'male': 0.02, 'female': 0.02, 'other': 0.02},\n 3: {'male': 0.03, 'female': 0.03, 'other': 0.03},\n 4: {'male': 0.04, 'female': 0.04, 'other': 0.04},\n 5: {'male': 0.05, 'female': 0.05, 'other': 0.05},\n 6: {'male': 0.06, 'female': 0.06, 'other': 0.06},\n 7: {'male': 0.07, 'female': 0.07, 'other': 0.07},\n 8: {'male': 0.08, 'female': 0.08, 'other': 0.08},\n 9: {'male': 0.09, 'female': 0.09, 'other': 0.09},\n 10: {'male': 0.1, 'female': 0.1, 'other': 0.1},\n 11: {'male': 0.11, 'female': 0.11, 'other': 0.11},\n 12: {'male': 0.12, 'female': 0.12, 'other': 0.12},\n 13: {'male': 0.13, 'female': 0.13, 'other': 0.13},\n 14: {'male': 0.14, 'female': 0.14, 'other': 0.14}}</pre> In\u00a0[37]: Copied! <pre>policy_remove_health = PersonPolicy(\n    RemoveActivity([\"medical\"]),\n    [\n        PersonProbability(\n            discrete_joint_distribution_sampler,\n            {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},\n        ),\n        ActivityProbability([\"medical\"], 0.5),\n    ],\n)\n</pre> policy_remove_health = PersonPolicy(     RemoveActivity([\"medical\"]),     [         PersonProbability(             discrete_joint_distribution_sampler,             {\"mapping\": vulnerable_mapping, \"distribution\": vulnerable_distribution},         ),         ActivityProbability([\"medical\"], 0.5),     ], ) In\u00a0[38]: Copied! <pre>print_attributes(smiths, [\"age\", \"gender\"])\n</pre> print_attributes(smiths, [\"age\", \"gender\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\tage: 50\n\tgender: male\nPerson: Hilda\nAttributes:\n\tage: 45\n\tgender: female\nPerson: Timmy\nAttributes:\n\tage: 18\n\tgender: male\nPerson: Bobby\nAttributes:\n\tage: 6\n\tgender: female\n</pre> In\u00a0[39]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[40]: Copied! <pre>hhld_apply(smiths, policy_remove_health).plot()\n</pre> hhld_apply(smiths, policy_remove_health).plot() In\u00a0[41]: Copied! <pre>policy_unemployment_and_furlough = PersonPolicy(RemoveActivity([\"work\"]), PersonProbability(0.1))\n</pre> policy_unemployment_and_furlough = PersonPolicy(RemoveActivity([\"work\"]), PersonProbability(0.1)) In\u00a0[42]: Copied! <pre>hhld_apply(smiths, PersonPolicy(RemoveActivity([\"work\"]), 1)).plot()\n</pre> hhld_apply(smiths, PersonPolicy(RemoveActivity([\"work\"]), 1)).plot() In\u00a0[43]: Copied! <pre>smiths[\"Steve\"].attributes[\"wfh\"] = True\nsmiths[\"Steve\"].attributes[\"key_worker\"] = False\nsmiths[\"Hilda\"].attributes[\"wfh\"] = False\nsmiths[\"Hilda\"].attributes[\"key_worker\"] = False\nsmiths[\"Timmy\"].attributes[\"wfh\"] = False\nsmiths[\"Timmy\"].attributes[\"key_worker\"] = False\nsmiths[\"Bobby\"].attributes[\"wfh\"] = False\nsmiths[\"Bobby\"].attributes[\"key_worker\"] = False\n\nprint_attributes(smiths, [\"wfh\", \"key_worker\"])\n</pre> smiths[\"Steve\"].attributes[\"wfh\"] = True smiths[\"Steve\"].attributes[\"key_worker\"] = False smiths[\"Hilda\"].attributes[\"wfh\"] = False smiths[\"Hilda\"].attributes[\"key_worker\"] = False smiths[\"Timmy\"].attributes[\"wfh\"] = False smiths[\"Timmy\"].attributes[\"key_worker\"] = False smiths[\"Bobby\"].attributes[\"wfh\"] = False smiths[\"Bobby\"].attributes[\"key_worker\"] = False  print_attributes(smiths, [\"wfh\", \"key_worker\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: True\n\tkey_worker: False\nPerson: Hilda\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Timmy\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tkey_worker: False\n</pre> In\u00a0[44]: Copied! <pre>conditions = {\"key_worker\": attribute_False, \"wfh\": attribute_True}\n</pre> conditions = {\"key_worker\": attribute_False, \"wfh\": attribute_True} In\u00a0[45]: Copied! <pre>policy_work_from_home = PersonPolicy(\n    RemoveActivity([\"work\"]), PersonProbability(0.5), PersonAttributeFilter(conditions)\n)\n</pre> policy_work_from_home = PersonPolicy(     RemoveActivity([\"work\"]), PersonProbability(0.5), PersonAttributeFilter(conditions) ) In\u00a0[46]: Copied! <pre>hhld_apply(\n    smiths, PersonPolicy(RemoveActivity([\"work\"]), 1, PersonAttributeFilter(conditions))\n).plot()\n</pre> hhld_apply(     smiths, PersonPolicy(RemoveActivity([\"work\"]), 1, PersonAttributeFilter(conditions)) ).plot() In\u00a0[47]: Copied! <pre>smiths[\"Steve\"].attributes[\"wfh\"] = False\nsmiths[\"Steve\"].attributes[\"key_worker\"] = True\nsmiths[\"Hilda\"].attributes[\"wfh\"] = False\nsmiths[\"Hilda\"].attributes[\"key_worker\"] = False\nsmiths[\"Timmy\"].attributes[\"wfh\"] = False\nsmiths[\"Timmy\"].attributes[\"key_worker\"] = False\nsmiths[\"Bobby\"].attributes[\"wfh\"] = False\nsmiths[\"Bobby\"].attributes[\"key_worker\"] = False\n\nprint_attributes(smiths, [\"wfh\", \"key_worker\"])\n</pre> smiths[\"Steve\"].attributes[\"wfh\"] = False smiths[\"Steve\"].attributes[\"key_worker\"] = True smiths[\"Hilda\"].attributes[\"wfh\"] = False smiths[\"Hilda\"].attributes[\"key_worker\"] = False smiths[\"Timmy\"].attributes[\"wfh\"] = False smiths[\"Timmy\"].attributes[\"key_worker\"] = False smiths[\"Bobby\"].attributes[\"wfh\"] = False smiths[\"Bobby\"].attributes[\"key_worker\"] = False  print_attributes(smiths, [\"wfh\", \"key_worker\"]) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: False\n\tkey_worker: True\nPerson: Hilda\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Timmy\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tkey_worker: False\n</pre> In\u00a0[48]: Copied! <pre>hhld_apply(\n    smiths, PersonPolicy(RemoveActivity([\"work\"]), 1, PersonAttributeFilter(conditions))\n).plot()\n</pre> hhld_apply(     smiths, PersonPolicy(RemoveActivity([\"work\"]), 1, PersonAttributeFilter(conditions)) ).plot() In\u00a0[49]: Copied! <pre>policy_reduced_work_activity = ActivityPolicy(\n    RemoveActivity([\"work\"]), ActivityProbability([\"work\"], 0.2)\n)\n</pre> policy_reduced_work_activity = ActivityPolicy(     RemoveActivity([\"work\"]), ActivityProbability([\"work\"], 0.2) ) In\u00a0[50]: Copied! <pre>hhld_apply(smiths, policy_reduced_work_activity).plot()\n</pre> hhld_apply(smiths, policy_reduced_work_activity).plot() In\u00a0[51]: Copied! <pre>policy_reduce_shopping_activities = HouseholdPolicy(\n    ReduceSharedActivity([\"shop\", \"shop_1\", \"shop_2\"]),\n    ActivityProbability([\"shop\", \"shop_1\", \"shop_2\"], 1),\n)\n</pre> policy_reduce_shopping_activities = HouseholdPolicy(     ReduceSharedActivity([\"shop\", \"shop_1\", \"shop_2\"]),     ActivityProbability([\"shop\", \"shop_1\", \"shop_2\"], 1), ) In\u00a0[52]: Copied! <pre>smiths_shop = hhld_apply(smiths, policy_reduce_shopping_activities)\n</pre> smiths_shop = hhld_apply(smiths, policy_reduce_shopping_activities) In\u00a0[53]: Copied! <pre>smiths_shop.plot()\n</pre> smiths_shop.plot() In\u00a0[54]: Copied! <pre>person_with_shopping = [\n    p for p in smiths_shop.people.values() if \"shop_1\" in [act.act for act in p.activities]\n][0].pid\n</pre> person_with_shopping = [     p for p in smiths_shop.people.values() if \"shop_1\" in [act.act for act in p.activities] ][0].pid In\u00a0[55]: Copied! <pre>smiths_shop.people[person_with_shopping].print()\n</pre> smiths_shop.people[person_with_shopping].print() <pre>Person: Bobby\n{'age': 6, 'job': 'education', 'gender': 'female', 'wfh': False, 'care_constrained': False, 'key_worker': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:30:00, duration:0:30:00)\n2:\tActivity(act:education, location:b, time:08:30:00 --&gt; 16:00:00, duration:7:30:00)\n3:\tLeg(mode:walk, area:b --&gt; c, time:16:00:00 --&gt; 16:30:00, duration:0:30:00)\n4:\tActivity(act:home, location:a, time:16:30:00 --&gt; 20:00:00, duration:3:30:00)\n5:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n6:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n7:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n8:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n9:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n10:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[56]: Copied! <pre>policy_move_shopping = PersonPolicy(\n    MoveActivityTourToHomeLocation([\"shop_1\", \"shop\", \"shop_2\"]),\n    ActivityProbability([\"shop_1\", \"shop\", \"shop_2\"], 1.0),\n)\n</pre> policy_move_shopping = PersonPolicy(     MoveActivityTourToHomeLocation([\"shop_1\", \"shop\", \"shop_2\"]),     ActivityProbability([\"shop_1\", \"shop\", \"shop_2\"], 1.0), ) In\u00a0[57]: Copied! <pre>smiths_shop = hhld_apply(smiths_shop, policy_move_shopping)\n</pre> smiths_shop = hhld_apply(smiths_shop, policy_move_shopping) In\u00a0[58]: Copied! <pre>smiths_shop.plot()\n</pre> smiths_shop.plot() In\u00a0[59]: Copied! <pre>smiths.people[person_with_shopping].print()\n</pre> smiths.people[person_with_shopping].print() <pre>Person: Bobby\n{'age': 6, 'job': 'education', 'gender': 'female', 'wfh': False, 'care_constrained': False, 'key_worker': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:30:00, duration:0:30:00)\n2:\tActivity(act:education, location:b, time:08:30:00 --&gt; 16:00:00, duration:7:30:00)\n3:\tLeg(mode:walk, area:b --&gt; c, time:16:00:00 --&gt; 16:30:00, duration:0:30:00)\n4:\tActivity(act:home, location:a, time:16:30:00 --&gt; 20:00:00, duration:3:30:00)\n5:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n6:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n7:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n8:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n9:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n10:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[60]: Copied! <pre>smiths_shop.people[person_with_shopping].print()\n</pre> smiths_shop.people[person_with_shopping].print() <pre>Person: Bobby\n{'age': 6, 'job': 'education', 'gender': 'female', 'wfh': False, 'care_constrained': False, 'key_worker': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:30:00, duration:0:30:00)\n2:\tActivity(act:education, location:b, time:08:30:00 --&gt; 16:00:00, duration:7:30:00)\n3:\tLeg(mode:walk, area:b --&gt; c, time:16:00:00 --&gt; 16:30:00, duration:0:30:00)\n4:\tActivity(act:home, location:a, time:16:30:00 --&gt; 20:00:00, duration:3:30:00)\n5:\tLeg(mode:walk, area:a --&gt; a, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n6:\tActivity(act:shop_1, location:a, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n7:\tLeg(mode:walk, area:a --&gt; a, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n8:\tActivity(act:shop_2, location:a, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n9:\tLeg(mode:walk, area:a --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n10:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[61]: Copied! <pre>population = Population(1)\npopulation.add(smiths)\n\nall_together_pop = apply_policies(\n    population,\n    [\n        policy_household_quarantine_per_person,\n        policy_remove_higher_education,\n        policy_remove_any_education,\n        policy_remove_leisure,\n        policy_move_sport,\n        policy_remove_health,\n        policy_unemployment_and_furlough,\n        policy_work_from_home,\n        policy_reduced_work_activity,\n        policy_reduce_shopping_activities,\n        policy_move_shopping,\n    ],\n)\n</pre> population = Population(1) population.add(smiths)  all_together_pop = apply_policies(     population,     [         policy_household_quarantine_per_person,         policy_remove_higher_education,         policy_remove_any_education,         policy_remove_leisure,         policy_move_sport,         policy_remove_health,         policy_unemployment_and_furlough,         policy_work_from_home,         policy_reduced_work_activity,         policy_reduce_shopping_activities,         policy_move_shopping,     ], ) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/05_policies_walk_through/#modifying-the-population-using-simple-policies","title":"Modifying the population using simple policies\u00b6","text":"<p>This notebook shows how simple policies can be applied to people, households, and entire populations.</p>"},{"location":"examples/05_policies_walk_through/#sampling-and-policy-levels","title":"Sampling and Policy Levels\u00b6","text":""},{"location":"examples/05_policies_walk_through/#household","title":"Household\u00b6","text":""},{"location":"examples/05_policies_walk_through/#person","title":"Person\u00b6","text":""},{"location":"examples/05_policies_walk_through/#activity","title":"Activity\u00b6","text":""},{"location":"examples/05_policies_walk_through/#joint-distributions","title":"Joint distributions\u00b6","text":"<p>You can give the <code>SamplingProbability</code> classes custom samplers with joint (or not) distributions. That changes the following table</p> HouseholdProbability PersonProbability ActivityProbability HouseholdPolicy $$p$$ $$1-(1-p)^{n_p}$$ $$1-(1-p)^{n_{a,h}}$$ PersonPolicy $$-$$ $$p$$ $$1-(1-p)^{n_{a,p}}$$ ActivityPolicy $$-$$ $$-$$ $$p$$ <p>where</p> <ul> <li>$n_p$ is the number of people in a household</li> <li>$n_{a,p}$ is the number of (relevant) activities in a person's plan</li> <li>$n_{a,h}$ is the number of (relevant) activities in a household</li> </ul> <p>to</p> HouseholdProbability PersonProbability ActivityProbability HouseholdPolicy $$p$$ $$1-\\prod_x (1-p_x)^{n_x}$$ $$1-\\prod_{x,a}(1-p_{x,a})^{n_{x,a}}$$ PersonPolicy $$-$$ $$p_x$$ $$1-\\prod_a (1-p_a)^{n_a}$$ ActivityPolicy $$-$$ $$-$$ $$p_a, p_{x,a}$$ <p>where</p> <ul> <li>$p_x$ is the probability for person $x$</li> <li>$n_x$ is the number of people with probability $p_x$</li> <li>$p_a$ is the probability for activity $a$</li> <li>$n_a$ is the number of activities $a$ in a person's plan</li> <li>$p_{x,a}$ is the probability for activity $a$ for person $x$</li> <li>$n_{x,a}$ is the number of activities $a$ in a person $x$ plan</li> </ul>"},{"location":"examples/05_policies_walk_through/#modifiers","title":"Modifiers\u00b6","text":"<p>Modifier perform the actions of removing or moving activities on the chosen Policy Level and sampled using the chosen Sampling Level.</p>"},{"location":"examples/05_policies_walk_through/#removeactivity","title":"<code>RemoveActivity</code>\u00b6","text":"<p>Takes a list of activities to be removed.</p>"},{"location":"examples/05_policies_walk_through/#reducesharedactivity","title":"<code>ReduceSharedActivity</code>\u00b6","text":"<p>This is a <code>HouseholdPolicy</code> level modifier which takes a list of activities, checks the household for those being shared (like going shopping together) and selects a person at random to still perform those activities. Those activities will be deleted for everyone else in the household.</p>"},{"location":"examples/05_policies_walk_through/#moveactivitytourtohomelocation","title":"<code>MoveActivityTourToHomeLocation</code>\u00b6","text":"<p>Takes a list of activities and moves those to the home location if they form a tour. A tour is a chain of activities sandwiched by two home activities (or boundary of persons plan e.g. if person's activities are: <code>'work', 'home', 'shop', 'work', 'home'</code> (in that order), their tours are: <code>['work'] </code>and <code>['shop', work']</code>).</p>"},{"location":"examples/05_policies_walk_through/#attribute-filters","title":"Attribute Filters\u00b6","text":"<p><code>PersonAttributeFilter</code> is a conveniece class to apply policies to selected people in the population which satisfy given attributes.</p>"},{"location":"examples/05_policies_walk_through/#policies","title":"Policies\u00b6","text":""},{"location":"examples/05_policies_walk_through/#person-based-household-quarantine","title":"Person-based Household Quarantine\u00b6","text":""},{"location":"examples/05_policies_walk_through/#remove-higher-education","title":"Remove Higher Education\u00b6","text":"<p>Remove all education activity for persons over age of 17</p>"},{"location":"examples/05_policies_walk_through/#remove-education","title":"Remove Education\u00b6","text":"<p>Probabilistically remove education activities from a person, and escort from people who share the household. Contraint based on the house not being care constrainted and people being able to work from home.</p>"},{"location":"examples/05_policies_walk_through/#example-of-non-care-constrained-household","title":"Example of non care constrained household\u00b6","text":"<p>Let's make the Smiths household a non care constrained household with at least one adult is able to work from home and the household is not care constrained.</p>"},{"location":"examples/05_policies_walk_through/#non-care-constrained-household-is-affected","title":"Non care constrained household is affected\u00b6","text":""},{"location":"examples/05_policies_walk_through/#example-of-care-constrained-household","title":"Example of care constrained household\u00b6","text":""},{"location":"examples/05_policies_walk_through/#care-constrained-household-is-not-affected","title":"Care constrained household is not affected\u00b6","text":""},{"location":"examples/05_policies_walk_through/#remove-leisure-activities","title":"Remove Leisure Activities\u00b6","text":"<p>Remove all leisure activities</p>"},{"location":"examples/05_policies_walk_through/#move-sport-activities","title":"Move Sport Activities\u00b6","text":"<p>Probabilistically move Sport activities to home location</p>"},{"location":"examples/05_policies_walk_through/#remove-health-activities","title":"Remove Health Activities\u00b6","text":"<p>Probabilistically remove individual health activities from a person. Make vulnerable people more likely to have their health activities removed.</p>"},{"location":"examples/05_policies_walk_through/#unemploymentfurlough","title":"Unemployment/Furlough\u00b6","text":"<p>Probabilistically remove all work activities from a person</p>"},{"location":"examples/05_policies_walk_through/#work-from-home","title":"Work from Home\u00b6","text":"<p>Probabilistically remove all work activities from a person</p>"},{"location":"examples/05_policies_walk_through/#reduced-work-activity","title":"Reduced Work Activity\u00b6","text":"<p>Probabilistically remove individual work activities from a person</p>"},{"location":"examples/05_policies_walk_through/#shopping","title":"Shopping\u00b6","text":""},{"location":"examples/05_policies_walk_through/#reduce-shared-shopping-activities","title":"Reduce Shared Shopping Activities\u00b6","text":""},{"location":"examples/05_policies_walk_through/#move-shopping-activities-closer-to-home","title":"Move Shopping Activities closer to home\u00b6","text":""},{"location":"examples/05_policies_walk_through/#all-together-now","title":"All together now!\u00b6","text":""},{"location":"examples/15_advanced_choice_modelling/","title":"Applying a location and mode choice model to populations","text":"In\u00a0[1]: Copied! <pre>import logging\nimport os\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom prettytable import PrettyTable\n\nfrom pam.operations.cropping import link_population\nfrom pam.planner import choice_location as choice\nfrom pam.planner.od import ODFactory, ODMatrix\nfrom pam.read import read_matsim\n\nlogging.basicConfig(level=logging.DEBUG)\nrandom.seed(0)\n</pre> import logging import os import random  import numpy as np import pandas as pd from prettytable import PrettyTable  from pam.operations.cropping import link_population from pam.planner import choice_location as choice from pam.planner.od import ODFactory, ODMatrix from pam.read import read_matsim  logging.basicConfig(level=logging.DEBUG) random.seed(0) <p>We read an example population, and set the location of all activities to zone <code>a</code>:</p> In\u00a0[2]: Copied! <pre>population = read_matsim(os.path.join(\"..\", \"tests\", \"test_data\", \"test_matsim_plansv12.xml\"))\nlink_population(population)\nfor _hid, _pid, person in population.people():\n    for act in person.activities:\n        act.location.area = \"a\"\n</pre> population = read_matsim(os.path.join(\"..\", \"tests\", \"test_data\", \"test_matsim_plansv12.xml\")) link_population(population) for _hid, _pid, person in population.people():     for act in person.activities:         act.location.area = \"a\" In\u00a0[3]: Copied! <pre>def print_activity_locs(population, act_scope=\"work\"):\n    summary = PrettyTable([\"pid\", \"seq\", \"location\", \"mode\"])\n    for _hid, pid, person in population.people():\n        for seq, act in enumerate(person.plan.activities):\n            if (act.act == act_scope) or (act_scope == \"all\"):\n                trmode = act.previous.mode if act.previous is not None else \"NA\"\n                summary.add_row([pid, seq, act.location.area, trmode])\n\n    print(summary)\n\n\nprint(\"Work locations and travel modes:\")\nprint_activity_locs(population, act_scope=\"work\")\n</pre> def print_activity_locs(population, act_scope=\"work\"):     summary = PrettyTable([\"pid\", \"seq\", \"location\", \"mode\"])     for _hid, pid, person in population.people():         for seq, act in enumerate(person.plan.activities):             if (act.act == act_scope) or (act_scope == \"all\"):                 trmode = act.previous.mode if act.previous is not None else \"NA\"                 summary.add_row([pid, seq, act.location.area, trmode])      print(summary)   print(\"Work locations and travel modes:\") print_activity_locs(population, act_scope=\"work\") <pre>Work locations and travel modes:\n+--------+-----+----------+------+\n|  pid   | seq | location | mode |\n+--------+-----+----------+------+\n| chris  |  1  |    a     | car  |\n| fatema |  1  |    a     | bike |\n|  fred  |  3  |    a     | walk |\n| gerry  |  3  |    a     | walk |\n|  nick  |  1  |    a     | car  |\n+--------+-----+----------+------+\n</pre> <p>Our <code>zones</code> dataset includes destination attraction data, for example the number of jobs or schools in each likely destination zone:</p> In\u00a0[4]: Copied! <pre>data_zones = pd.DataFrame({\"zone\": [\"a\", \"b\"], \"jobs\": [100, 200], \"schools\": [3, 1]}).set_index(\n    \"zone\"\n)\ndata_zones\n</pre> data_zones = pd.DataFrame({\"zone\": [\"a\", \"b\"], \"jobs\": [100, 200], \"schools\": [3, 1]}).set_index(     \"zone\" ) data_zones Out[4]: jobs schools zone a 100 3 b 200 1 <p>The <code>od</code> object holds origin-destination data, for example travel time and travel distance between each origin and destination, for each travel mode:</p> In\u00a0[5]: Copied! <pre>zone_labels = (\"a\", \"b\")\nod = ODFactory.from_matrices(\n    [\n        ODMatrix(\"time\", \"car\", zone_labels, zone_labels, np.array([[20, 40], [40, 20]])),\n        ODMatrix(\"time\", \"bus\", zone_labels, zone_labels, np.array([[30, 45], [45, 30]])),\n        ODMatrix(\"distance\", \"car\", zone_labels, zone_labels, np.array([[5, 8], [8, 5]])),\n        ODMatrix(\"distance\", \"bus\", zone_labels, zone_labels, np.array([[5, 9], [9, 5]])),\n    ]\n)\nod\n</pre> zone_labels = (\"a\", \"b\") od = ODFactory.from_matrices(     [         ODMatrix(\"time\", \"car\", zone_labels, zone_labels, np.array([[20, 40], [40, 20]])),         ODMatrix(\"time\", \"bus\", zone_labels, zone_labels, np.array([[30, 45], [45, 30]])),         ODMatrix(\"distance\", \"car\", zone_labels, zone_labels, np.array([[5, 8], [8, 5]])),         ODMatrix(\"distance\", \"bus\", zone_labels, zone_labels, np.array([[5, 9], [9, 5]])),     ] ) od Out[5]: <pre>Origin-destination dataset \n--------------------------------------------------\nLabels(vars=['time', 'distance'], origin_zones=('a', 'b'), destination_zones=('a', 'b'), mode=['car', 'bus'])\n--------------------------------------------------\ntime - car:\n[[20. 40.]\n [40. 20.]]\n--------------------------------------------------\ntime - bus:\n[[30. 45.]\n [45. 30.]]\n--------------------------------------------------\ndistance - car:\n[[5. 8.]\n [8. 5.]]\n--------------------------------------------------\ndistance - bus:\n[[5. 9.]\n [9. 5.]]\n--------------------------------------------------</pre> <p>The dimensions of the <code>od</code> object are always (in order): <code>variables</code>, <code>origin zone</code>, <code>destination zone</code>, and <code>mode</code>. It can be sliced using the respective labels under <code>od.labels</code>, for example:</p> In\u00a0[6]: Copied! <pre>od[\"time\", \"a\", \"b\", \"bus\"]\n</pre> od[\"time\", \"a\", \"b\", \"bus\"] Out[6]: <pre>45.0</pre> In\u00a0[7]: Copied! <pre>planner = choice.ChoiceMNL(population, od, data_zones)\n</pre> planner = choice.ChoiceMNL(population, od, data_zones) <pre>INFO:pam.planner.choice_location:Updated model configuration\nINFO:pam.planner.choice_location:ChoiceConfiguration(u=None, scope=None, func_probabilities=&lt;function calculate_mnl_probabilities at 0x1623db600&gt;, func_sampling=&lt;function sample_weighted at 0x1623e8400&gt;)\n</pre> <p>We configure the model by specifying:</p> <ul> <li>the scope of the model. For example, work activities.</li> <li>the utility formulation of each alternative.</li> </ul> <p>Both settings are defined as strings. The stings may comprise mathematical operators, coefficients, planner data objects (<code>od</code> / <code>zones</code>), and/or PAM population objects (<code>person</code>/ <code>act</code>).</p> <p>Coefficients can be passed either as a number, or as a list, with each element in the list corresponding to one of the modes in the <code>od</code> object.</p> In\u00a0[8]: Copied! <pre>scope = \"act.act=='work'\"\nasc = [0, -1]  # one value for each mode, 0-&gt;car, -1-&gt;\nasc_shift_poor = [0, 2]  # one value for each mode\nbeta_time = [-0.05, -0.07]  # one value for each mode\nbeta_zones = 0.4\nu = f\"\"\" \\\n{asc} + \\\n    (np.array({asc_shift_poor}) * (person.attributes['subpopulation']=='poor')) + \\\n    ({beta_time} * od['time', person.home.area]) + \\\n    ({beta_zones} * np.log(zones['jobs']))\n\"\"\"\n\nplanner.configure(u=u, scope=scope)\n</pre> scope = \"act.act=='work'\" asc = [0, -1]  # one value for each mode, 0-&gt;car, -1-&gt; asc_shift_poor = [0, 2]  # one value for each mode beta_time = [-0.05, -0.07]  # one value for each mode beta_zones = 0.4 u = f\"\"\" \\     {asc} + \\     (np.array({asc_shift_poor}) * (person.attributes['subpopulation']=='poor')) + \\     ({beta_time} * od['time', person.home.area]) + \\     ({beta_zones} * np.log(zones['jobs'])) \"\"\"  planner.configure(u=u, scope=scope) <pre>INFO:pam.planner.choice_location:Updated model configuration\nINFO:pam.planner.choice_location:ChoiceConfiguration(u=\"[0,-1]+(np.array([0,2])*(person.attributes['subpopulation']=='poor'))+([-0.05,-0.07]*od['time',person.home.area])+(0.4*np.log(zones['jobs']))\\n\", scope=\"act.act=='work'\", func_probabilities=&lt;function calculate_mnl_probabilities at 0x1623db600&gt;, func_sampling=&lt;function sample_weighted at 0x1623e8400&gt;)\n</pre> <p>The <code>.get_choice_set()</code> provides with with the utilities of each alternative, as perceived by each agent.</p> In\u00a0[9]: Copied! <pre>choice_set = planner.get_choice_set()\nprint(\"Activities in scope: \\n\", choice_set.idxs)\nprint(\"\\nAlternatives: \\n\", choice_set.choice_labels)\nprint(\"\\nChoice set utilities: \\n\", choice_set.u_choices)\n</pre> choice_set = planner.get_choice_set() print(\"Activities in scope: \\n\", choice_set.idxs) print(\"\\nAlternatives: \\n\", choice_set.choice_labels) print(\"\\nChoice set utilities: \\n\", choice_set.u_choices) <pre>Activities in scope: \n [ChoiceIdx(pid='chris', hid='chris', seq=1, act=&lt;pam.activity.Activity object at 0x16240ca90&gt;), ChoiceIdx(pid='fatema', hid='fatema', seq=1, act=&lt;pam.activity.Activity object at 0x16240d590&gt;), ChoiceIdx(pid='fred', hid='fred', seq=3, act=&lt;pam.activity.Activity object at 0x16240e990&gt;), ChoiceIdx(pid='gerry', hid='gerry', seq=3, act=&lt;pam.activity.Activity object at 0x1623fe4d0&gt;), ChoiceIdx(pid='nick', hid='nick', seq=1, act=&lt;pam.activity.Activity object at 0x16240eb50&gt;)]\n\nAlternatives: \n [ChoiceLabel(destination='a', mode='car'), ChoiceLabel(destination='a', mode='bus'), ChoiceLabel(destination='b', mode='car'), ChoiceLabel(destination='b', mode='bus')]\n\nChoice set utilities: \n [[ 0.84206807 -1.25793193  0.11932695 -2.03067305]\n [ 0.84206807  0.74206807  0.11932695 -0.03067305]\n [ 0.84206807  0.74206807  0.11932695 -0.03067305]\n [ 0.84206807  0.74206807  0.11932695 -0.03067305]\n [ 0.84206807 -1.25793193  0.11932695 -2.03067305]]\n</pre> <p>The <code>.apply()</code> method samples from the alternatives, and updates the location and mode of each activity accordingly:</p> In\u00a0[10]: Copied! <pre>planner.apply()\nprint(\"Sampled choices: \\n\", planner._selections.selections)\n</pre> planner.apply() print(\"Sampled choices: \\n\", planner._selections.selections) <pre>INFO:pam.planner.choice_location:Applying choice model...\nINFO:pam.planner.choice_location:Configuration: \nChoiceConfiguration(u=\"[0,-1]+(np.array([0,2])*(person.attributes['subpopulation']=='poor'))+([-0.05,-0.07]*od['time',person.home.area])+(0.4*np.log(zones['jobs']))\\n\", scope=\"act.act=='work'\", func_probabilities=&lt;function calculate_mnl_probabilities at 0x1623db600&gt;, func_sampling=&lt;function sample_weighted at 0x1623e8400&gt;)\nINFO:pam.planner.choice_location:Choice model application complete.\n</pre> <pre>Sampled choices: \n [ChoiceLabel(destination='b', mode='car'), ChoiceLabel(destination='b', mode='car'), ChoiceLabel(destination='a', mode='bus'), ChoiceLabel(destination='a', mode='car'), ChoiceLabel(destination='a', mode='car')]\n</pre> <p>The population's activity locations and travel modes have now been updated accordingly:</p> In\u00a0[11]: Copied! <pre>print_activity_locs(planner.population)\n</pre> print_activity_locs(planner.population) <pre>+--------+-----+----------+------+\n|  pid   | seq | location | mode |\n+--------+-----+----------+------+\n| chris  |  1  |    b     | car  |\n| fatema |  1  |    b     | car  |\n|  fred  |  3  |    a     | bus  |\n| gerry  |  3  |    a     | car  |\n|  nick  |  1  |    a     | car  |\n+--------+-----+----------+------+\n</pre>"},{"location":"examples/15_advanced_choice_modelling/#applying-a-location-and-mode-choice-model-to-populations","title":"Applying a location and mode choice model to populations\u00b6","text":"<p>This notebook applies a simple location and mode choice model to a PAM population.</p> <p>The <code>pam.planner.choice.ChoiceMNL</code> class allows the user to apply an MNL specification for selecting the location of activities and the mode for accessing them, given person characteristics, network conditions and/or zone attraction data.</p> <p>The typical workflow goes as follows:</p> <pre>choice_model = ChoiceMNL(population, od, zones) # initialize the model and point to the data objects \nchoice_model.configure(u, scope) # configure the model by specifying a utility function and the scope of application.\nchoice_model.apply() # apply the model and update the population with the results.\n</pre>"},{"location":"examples/15_advanced_choice_modelling/#data","title":"Data\u00b6","text":""},{"location":"examples/15_advanced_choice_modelling/#choice-model","title":"Choice model\u00b6","text":""},{"location":"examples/05_activity_plots/","title":"Plotting activity times","text":"In\u00a0[1]: Copied! <pre>import os\n\nimport pandas as pd\n\nfrom pam import read\nfrom pam.plot.stats import plot_activity_times, plot_leg_times\n</pre> import os  import pandas as pd  from pam import read from pam.plot.stats import plot_activity_times, plot_leg_times In\u00a0[2]: Copied! <pre>data_path = os.path.join(\"data\", \"example_data\")\ntrips = pd.read_csv(os.path.join(data_path, \"example_travel_diaries.csv\"))\nattributes = pd.read_csv(os.path.join(data_path, \"example_attributes.csv\"))\nattributes = attributes.set_index(\"pid\")\n</pre> data_path = os.path.join(\"data\", \"example_data\") trips = pd.read_csv(os.path.join(data_path, \"example_travel_diaries.csv\")) attributes = pd.read_csv(os.path.join(data_path, \"example_attributes.csv\")) attributes = attributes.set_index(\"pid\") In\u00a0[3]: Copied! <pre>population = read.load_travel_diary(trips, attributes)\n</pre> population = read.load_travel_diary(trips, attributes) <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all persons.\n</pre> In\u00a0[4]: Copied! <pre>population.random_household().plot()\n</pre> population.random_household().plot() In\u00a0[5]: Copied! <pre>fig1 = plot_activity_times(population)\n</pre> fig1 = plot_activity_times(population) In\u00a0[6]: Copied! <pre>fig2 = plot_leg_times(population)\n</pre> fig2 = plot_leg_times(population) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/05_activity_plots/#plotting-activity-times","title":"Plotting activity times\u00b6","text":"<p>In this example, we show how activity and trip times can be plotted.</p>"},{"location":"examples/08_toy_matsim_population/","title":"Demo - MATSim Population for West London","text":"<p>This notebook demonstrates an complex example workflow for creating a sample population for an area in West London. It creates agent plans for people and households using a random process.</p> <p>Steps:</p> <ol> <li>Import geographic data of Londinium;</li> <li>Facility sampling from OpenStreetMap data;</li> <li>Activity generation model with home based tours. Expand agents with different personal attributes, activities and trips;</li> <li>Perform Data Visualization and validation. Plot the activity plan, distance and duration of population;</li> <li>Export intermediate CSV tables of the population</li> </ol> In\u00a0[1]: Copied! <pre>import os\n\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nfrom pam.activity import Activity, Leg\nfrom pam.core import Household, Person, Population\nfrom pam.plot.stats import plot_activity_times\nfrom pam.read import load_travel_diary\nfrom pam.report.benchmarks import distance_counts, duration_counts\nfrom pam.samplers import facility\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\nfrom pam.write import to_csv, write_matsim, write_od_matrices\n\n%matplotlib inline\n</pre> import os  import geopandas as gp import matplotlib.pyplot as plt import numpy as np import pandas as pd  from pam.activity import Activity, Leg from pam.core import Household, Person, Population from pam.plot.stats import plot_activity_times from pam.read import load_travel_diary from pam.report.benchmarks import distance_counts, duration_counts from pam.samplers import facility from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY from pam.write import to_csv, write_matsim, write_od_matrices  %matplotlib inline In\u00a0[2]: Copied! <pre># Import geographic data of west london area\nnetwork_bb_path = os.path.join(\"data\", \"network_bounding_box.geojson\")\nlsoas_path = os.path.join(\"data\", \"lsoas\")  # lsoas: lower layer super output areas\n</pre> # Import geographic data of west london area network_bb_path = os.path.join(\"data\", \"network_bounding_box.geojson\") lsoas_path = os.path.join(\"data\", \"lsoas\")  # lsoas: lower layer super output areas <p>We will start by plotting Londinium boundary</p> In\u00a0[3]: Copied! <pre># Read the file and plot the boundary\nboundary = gp.read_file(network_bb_path)\n\n# Transform to epsg:27700\nboundary = boundary.to_crs(\"epsg:27700\")\nboundary.plot()\n</pre> # Read the file and plot the boundary boundary = gp.read_file(network_bb_path)  # Transform to epsg:27700 boundary = boundary.to_crs(\"epsg:27700\") boundary.plot() Out[3]: <pre>&lt;Axes: &gt;</pre> <p>Next we will plot Londinium outline shown above over a map of London to see where exactly it is located.</p> In\u00a0[4]: Copied! <pre># Plot boundary area in lsoas\nlsoas = gp.read_file(lsoas_path)\nlsoas.crs = \"EPSG:27700\"\nprint(lsoas.crs)\nlsoas = lsoas.set_index(\"LSOA_CODE\")\n\nfig, ax = plt.subplots(figsize=(10, 10))\nlsoas.plot(ax=ax)\nboundary.plot(ax=ax, color=\"red\")\n</pre> # Plot boundary area in lsoas lsoas = gp.read_file(lsoas_path) lsoas.crs = \"EPSG:27700\" print(lsoas.crs) lsoas = lsoas.set_index(\"LSOA_CODE\")  fig, ax = plt.subplots(figsize=(10, 10)) lsoas.plot(ax=ax) boundary.plot(ax=ax, color=\"red\") <pre>EPSG:27700\n</pre> Out[4]: <pre>&lt;Axes: &gt;</pre> <p>Finally, we will plot Londinium with LSOA boundaries included.</p> In\u00a0[5]: Copied! <pre># Overlay the area using geopandas package\nlsoas_clipped = gp.overlay(lsoas, boundary, how=\"intersection\")\nlsoas_clipped.plot()\n</pre> # Overlay the area using geopandas package lsoas_clipped = gp.overlay(lsoas, boundary, how=\"intersection\") lsoas_clipped.plot() Out[5]: <pre>&lt;Axes: &gt;</pre> In\u00a0[6]: Copied! <pre>lsoas_clipped.head()\n</pre> lsoas_clipped.head() Out[6]: LSOA_NAME MSOA_CODE MSOA_NAME STWARDCODE STWARDNAME LA_CODE LA_NAME geometry 0 Hammersmith and Fulham 010A E02000381 Hammersmith and Fulham 010 00ANGA Addison 00AN Hammersmith and Fulham POLYGON ((523932.247 179242.842, 523959.439 17... 1 Hammersmith and Fulham 010B E02000381 Hammersmith and Fulham 010 00ANGA Addison 00AN Hammersmith and Fulham POLYGON ((524171.272 179363.077, 524212.654 17... 2 Hammersmith and Fulham 012A E02000383 Hammersmith and Fulham 012 00ANGC Avonmore and Brook Green 00AN Hammersmith and Fulham POLYGON ((524167.660 178997.302, 524060.845 17... 3 Hammersmith and Fulham 012B E02000383 Hammersmith and Fulham 012 00ANGC Avonmore and Brook Green 00AN Hammersmith and Fulham POLYGON ((523774.000 178714.003, 523831.847 17... 4 Hammersmith and Fulham 012C E02000383 Hammersmith and Fulham 012 00ANGC Avonmore and Brook Green 00AN Hammersmith and Fulham MULTIPOLYGON (((524422.688 178825.081, 524379.... In\u00a0[7]: Copied! <pre>facilities_path = \"data/londinium_facilities_sample.geojson\"\nfacilities = gp.read_file(facilities_path)\nfacilities = facilities.rename({\"activities\": \"activity\"}, axis=1)\nfacilities.crs = \"EPSG:27700\"\nfacilities.head()\n</pre> facilities_path = \"data/londinium_facilities_sample.geojson\" facilities = gp.read_file(facilities_path) facilities = facilities.rename({\"activities\": \"activity\"}, axis=1) facilities.crs = \"EPSG:27700\" facilities.head() Out[7]: activity area distance_to_nearest_education distance_to_nearest_medical distance_to_nearest_shop distance_to_nearest_transit floor_area id levels units geometry 0 home 574 617.965594 516.743962 77.712882 466.059745 1148.0 1084822608 2.0 1.0 POINT (524877.659 179721.080) 1 home 66 143.055807 115.674294 125.537224 286.017738 198.0 368319574 3.0 1.0 POINT (527830.357 174758.729) 2 home 103 54.946075 214.532285 41.572871 93.975944 412.0 1640220880 4.0 1.0 POINT (526060.994 178970.515) 3 home 192 164.455318 216.217139 111.674214 180.452314 768.0 1741392588 4.0 1.0 POINT (526698.625 178513.841) 4 home 123 173.648285 249.190465 188.276309 139.258340 246.0 984446626 2.0 1.0 POINT (526369.238 179166.396) <p>Start by plotting different facility types, e.g. educational and medical facilities</p> In\u00a0[8]: Copied! <pre>education = facilities[facilities[\"activity\"] == \"education\"]\nmedical = facilities[facilities[\"activity\"] == \"medical\"]\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 12))\n\nboundary.plot(ax=ax1, color=\"steelblue\")\neducation.plot(ax=ax1, color=\"orange\", label=\"Educational facilities\")\nax1.legend()\n\nboundary.plot(ax=ax2, color=\"steelblue\")\nmedical.plot(ax=ax2, color=\"red\", label=\"Medical facilities\")\nax2.legend()\n</pre> education = facilities[facilities[\"activity\"] == \"education\"] medical = facilities[facilities[\"activity\"] == \"medical\"]  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 12))  boundary.plot(ax=ax1, color=\"steelblue\") education.plot(ax=ax1, color=\"orange\", label=\"Educational facilities\") ax1.legend()  boundary.plot(ax=ax2, color=\"steelblue\") medical.plot(ax=ax2, color=\"red\", label=\"Medical facilities\") ax2.legend() Out[8]: <pre>&lt;matplotlib.legend.Legend at 0x163b42f50&gt;</pre> In\u00a0[9]: Copied! <pre>lsoas_clipped.crs = \"EPSG:27700\"\nlen(lsoas_clipped)\n</pre> lsoas_clipped.crs = \"EPSG:27700\" len(lsoas_clipped) Out[9]: <pre>306</pre> In\u00a0[10]: Copied! <pre>lsoas_clipped = lsoas_clipped.set_index(\"LSOA_NAME\")\n</pre> lsoas_clipped = lsoas_clipped.set_index(\"LSOA_NAME\") In\u00a0[11]: Copied! <pre># build the sampler\nfacility_sampler = facility.FacilitySampler(\n    facilities=facilities, zones=lsoas_clipped, build_xml=True, fail=False, random_default=True\n)\n</pre> # build the sampler facility_sampler = facility.FacilitySampler(     facilities=facilities, zones=lsoas_clipped, build_xml=True, fail=False, random_default=True ) <pre>Joining facilities data to zones, this may take a while.\nBuilding sampler, this may take a while.\n</pre> In\u00a0[12]: Copied! <pre># Create random area sample\n\n\ndef random_area_sampler():\n    indexes = list(lsoas_clipped.index)\n    return np.random.choice(indexes)\n\n\nrandom_area_sampler()  # test\n</pre> # Create random area sample   def random_area_sampler():     indexes = list(lsoas_clipped.index)     return np.random.choice(indexes)   random_area_sampler()  # test Out[12]: <pre>'Kensington and Chelsea 011D'</pre> <ul> <li>It is a simple home based tours within 24 hours.</li> <li>We create different activity types: work, leisure, education, shopping, etc. Different transport model types: car, bus, subway, etc.</li> <li>Random number is assigned to the duration for each activity and transport mode</li> </ul> In\u00a0[13]: Copied! <pre># mapping the MSOA and LAD with index\nmapping_dict = dict(zip(lsoas_clipped.index, lsoas_clipped.MSOA_CODE))\nmapping_dict1 = dict(zip(lsoas_clipped.index, lsoas_clipped.LA_NAME))\n</pre> # mapping the MSOA and LAD with index mapping_dict = dict(zip(lsoas_clipped.index, lsoas_clipped.MSOA_CODE)) mapping_dict1 = dict(zip(lsoas_clipped.index, lsoas_clipped.LA_NAME)) In\u00a0[14]: Copied! <pre># Generate agents in west london area\n\n\ndef generate_agents(no_of_agents):\n\"\"\"\n    Randomly create agents with simple home-based tours.\n    The trip starts from home, has a random number of various acitivites, tranport modes would be added.\n    The trip finally ends at home.\n\n    \"\"\"\n    population = Population()  # Initialise an empty population\n\n    # Create simple personal attributes\n    income = [\"low\", \"medium\", \"high\"]\n    gender = [\"male\", \"female\"]\n    sort_age = [\n        \"0 to 4\",\n        \"5 to 10\",\n        \"11 to 15\",\n        \"16 to 20\",\n        \"21 to 25\",\n        \"26 to 29\",\n        \"30 to 39\",\n        \"40 to 49\",\n        \"50 to 59\",\n        \"60 to 64\",\n        \"65 to 69\",\n        \"70 to 74\",\n        \"75 to 79\",\n        \"80 to 84\",\n        \"85  and over\",\n    ]\n\n    # Create mode and activities\n    transport = [\"car\", \"bus\", \"ferry\", \"rail\", \"subway\", \"bike\", \"walk\"]\n    # Removed gym and park due to osmox problem\n    activity = [\n        \"leisure\",\n        \"work\",\n        \"shop\",\n        \"medical\",\n        \"education\",\n        \"park\",\n        \"pub\",\n        \"gym\",\n    ]  # Primary activity\n    sub_activity = [\n        \"shop\",\n        \"medical\",\n        \"pub\",\n        \"gym\",\n    ]  # People usually spend less time on sub activity\n\n    # Add activity plan for each person\n    for i in range(no_of_agents):\n        # Create different agents and household\n        agent_id = f\"agent_{i}\"\n        hh_id = f\"hh_{i}\"\n        hh = Household(hh_id, freq=1)\n\n        # Adding Activities and Legs alternately to different agents\n        # Activity 1 - home\n        leaves_home = (np.random.randint(6, 8) * 60) + np.random.randint(0, 100)  # minutes\n        location1 = random_area_sampler()\n        location1_loc = facility_sampler.sample(location1, \"home\")\n        lsoa_name = mapping_dict.get(location1)\n        lad_name = mapping_dict1.get(location1)\n\n        agent = Person(\n            agent_id,\n            freq=1,\n            attributes={\n                \"subpopulation\": np.random.choice(income) + \" income\",\n                \"gender\": np.random.choice(gender),\n                \"age\": np.random.choice(sort_age),\n                \"household_zone\": location1,\n                \"household_LSOA\": lsoa_name,\n                \"household_LAD\": lad_name,\n            },\n        )\n\n        hh.add(agent)\n        population.add(hh)\n\n        # Trip duration\n        trip_duration_main_activity = np.random.randint(3, 6) * 60\n        trip_duration_sub_activity = np.random.randint(1, 3) * 60\n\n        agent.add(\n            Activity(\n                seq=1,\n                act=\"home\",\n                area=location1,\n                loc=location1_loc,\n                start_time=mtdt(0),\n                end_time=mtdt(leaves_home),\n            )\n        )\n\n        # Initiated parameters\n        location_prev = location1\n        location_prev_loc = location1_loc\n        leave_time = leaves_home\n\n        # Add random numbers of activities\n        no_of_activities = np.random.randint(1, 5)\n\n        for i in range(no_of_activities):\n            arrives_primary = leave_time + np.random.randint(10, 90)  # minutes\n\n            # Activity 2.\n            if i &lt; 2:  # Start with main activity\n                random_act = np.random.choice(activity)\n            else:\n                random_act = np.random.choice(sub_activity)\n\n            if random_act == (\"work\"):\n                leaves_primary = arrives_primary + trip_duration_main_activity\n            else:\n                leaves_primary = arrives_primary + trip_duration_sub_activity\n\n            # Outbound leg\n            location_next = random_area_sampler()\n            location_next_loc = facility_sampler.sample(location_next, random_act)\n\n            agent.add(\n                Leg(\n                    seq=i + 1,\n                    mode=np.random.choice(transport),\n                    start_area=location_prev,\n                    start_loc=location_prev_loc,\n                    end_area=location_next,\n                    end_loc=location_next_loc,\n                    start_time=mtdt(leave_time),\n                    end_time=mtdt(arrives_primary),\n                )\n            )\n\n            agent.add(\n                Activity(\n                    seq=i + 2,\n                    act=random_act,\n                    area=location_next,\n                    loc=location_next_loc,\n                    start_time=mtdt(arrives_primary),\n                    end_time=mtdt(leaves_primary),\n                )\n            )\n\n            # Update parameters\n            leave_time = leaves_primary\n            location_prev = location_next\n            location_prev_loc = location_next_loc\n\n        # Inbound leg\n        arrives_home = leave_time + np.random.randint(10, 90)  # minutes\n        agent.add(\n            Leg(\n                seq=no_of_activities + 1,\n                mode=np.random.choice(transport),\n                start_area=location_next,\n                start_loc=location_next_loc,\n                end_area=location1,\n                end_loc=location1_loc,\n                start_time=mtdt(leave_time),\n                end_time=mtdt(arrives_home),\n            )\n        )\n\n        # Activity\n        agent.add(\n            Activity(\n                seq=no_of_activities + 2,\n                act=\"home\",\n                area=location1,\n                loc=location1_loc,\n                start_time=mtdt(arrives_home),\n                end_time=END_OF_DAY,\n            )\n        )\n\n    return population\n</pre> # Generate agents in west london area   def generate_agents(no_of_agents):     \"\"\"     Randomly create agents with simple home-based tours.     The trip starts from home, has a random number of various acitivites, tranport modes would be added.     The trip finally ends at home.      \"\"\"     population = Population()  # Initialise an empty population      # Create simple personal attributes     income = [\"low\", \"medium\", \"high\"]     gender = [\"male\", \"female\"]     sort_age = [         \"0 to 4\",         \"5 to 10\",         \"11 to 15\",         \"16 to 20\",         \"21 to 25\",         \"26 to 29\",         \"30 to 39\",         \"40 to 49\",         \"50 to 59\",         \"60 to 64\",         \"65 to 69\",         \"70 to 74\",         \"75 to 79\",         \"80 to 84\",         \"85  and over\",     ]      # Create mode and activities     transport = [\"car\", \"bus\", \"ferry\", \"rail\", \"subway\", \"bike\", \"walk\"]     # Removed gym and park due to osmox problem     activity = [         \"leisure\",         \"work\",         \"shop\",         \"medical\",         \"education\",         \"park\",         \"pub\",         \"gym\",     ]  # Primary activity     sub_activity = [         \"shop\",         \"medical\",         \"pub\",         \"gym\",     ]  # People usually spend less time on sub activity      # Add activity plan for each person     for i in range(no_of_agents):         # Create different agents and household         agent_id = f\"agent_{i}\"         hh_id = f\"hh_{i}\"         hh = Household(hh_id, freq=1)          # Adding Activities and Legs alternately to different agents         # Activity 1 - home         leaves_home = (np.random.randint(6, 8) * 60) + np.random.randint(0, 100)  # minutes         location1 = random_area_sampler()         location1_loc = facility_sampler.sample(location1, \"home\")         lsoa_name = mapping_dict.get(location1)         lad_name = mapping_dict1.get(location1)          agent = Person(             agent_id,             freq=1,             attributes={                 \"subpopulation\": np.random.choice(income) + \" income\",                 \"gender\": np.random.choice(gender),                 \"age\": np.random.choice(sort_age),                 \"household_zone\": location1,                 \"household_LSOA\": lsoa_name,                 \"household_LAD\": lad_name,             },         )          hh.add(agent)         population.add(hh)          # Trip duration         trip_duration_main_activity = np.random.randint(3, 6) * 60         trip_duration_sub_activity = np.random.randint(1, 3) * 60          agent.add(             Activity(                 seq=1,                 act=\"home\",                 area=location1,                 loc=location1_loc,                 start_time=mtdt(0),                 end_time=mtdt(leaves_home),             )         )          # Initiated parameters         location_prev = location1         location_prev_loc = location1_loc         leave_time = leaves_home          # Add random numbers of activities         no_of_activities = np.random.randint(1, 5)          for i in range(no_of_activities):             arrives_primary = leave_time + np.random.randint(10, 90)  # minutes              # Activity 2.             if i &lt; 2:  # Start with main activity                 random_act = np.random.choice(activity)             else:                 random_act = np.random.choice(sub_activity)              if random_act == (\"work\"):                 leaves_primary = arrives_primary + trip_duration_main_activity             else:                 leaves_primary = arrives_primary + trip_duration_sub_activity              # Outbound leg             location_next = random_area_sampler()             location_next_loc = facility_sampler.sample(location_next, random_act)              agent.add(                 Leg(                     seq=i + 1,                     mode=np.random.choice(transport),                     start_area=location_prev,                     start_loc=location_prev_loc,                     end_area=location_next,                     end_loc=location_next_loc,                     start_time=mtdt(leave_time),                     end_time=mtdt(arrives_primary),                 )             )              agent.add(                 Activity(                     seq=i + 2,                     act=random_act,                     area=location_next,                     loc=location_next_loc,                     start_time=mtdt(arrives_primary),                     end_time=mtdt(leaves_primary),                 )             )              # Update parameters             leave_time = leaves_primary             location_prev = location_next             location_prev_loc = location_next_loc          # Inbound leg         arrives_home = leave_time + np.random.randint(10, 90)  # minutes         agent.add(             Leg(                 seq=no_of_activities + 1,                 mode=np.random.choice(transport),                 start_area=location_next,                 start_loc=location_next_loc,                 end_area=location1,                 end_loc=location1_loc,                 start_time=mtdt(leave_time),                 end_time=mtdt(arrives_home),             )         )          # Activity         agent.add(             Activity(                 seq=no_of_activities + 2,                 act=\"home\",                 area=location1,                 loc=location1_loc,                 start_time=mtdt(arrives_home),                 end_time=END_OF_DAY,             )         )      return population In\u00a0[15]: Copied! <pre># Create 100 agents and check the population statistics\npopulation = generate_agents(20)\nprint(population.stats)\n</pre> # Create 100 agents and check the population statistics population = generate_agents(20) print(population.stats) <pre>Using random sample for zone:Westminster 021A:park\nUsing random sample for zone:Lambeth 006D:education\nUsing random sample for zone:Lambeth 005C:park\nUsing random sample for zone:Lambeth 011D:pub\nUsing random sample for zone:Lambeth 004B:pub\nUsing random sample for zone:Richmond upon Thames 001E:shop\nUsing random sample for zone:Kensington and Chelsea 008B:work\nUsing random sample for zone:Lambeth 007A:work\nUsing random sample for zone:Wandsworth 018C:leisure\nUsing random sample for zone:Wandsworth 012B:gym\nUsing random sample for zone:Hammersmith and Fulham 025B:leisure\nUsing random sample for zone:Hammersmith and Fulham 012F:education\nUsing random sample for zone:Wandsworth 008A:education\nUsing random sample for zone:Hammersmith and Fulham 024B:pub\nUsing random sample for zone:Lambeth 013B:gym\nUsing random sample for zone:Lambeth 012D:shop\nUsing random sample for zone:Lambeth 019E:work\nUsing random sample for zone:Wandsworth 010C:gym\nUsing random sample for zone:Wandsworth 006A:home\nUsing random sample for zone:Lambeth 004C:pub\nUsing random sample for zone:Kensington and Chelsea 010D:shop\nUsing random sample for zone:Lambeth 017B:medical\nUsing random sample for zone:Lambeth 012E:pub\nUsing random sample for zone:Kensington and Chelsea 010B:park\nUsing random sample for zone:Westminster 024E:park\nUsing random sample for zone:Hammersmith and Fulham 015A:shop\nUsing random sample for zone:Wandsworth 008A:shop\nUsing random sample for zone:Hammersmith and Fulham 012C:shop\nUsing random sample for zone:Lambeth 006C:shop\nUsing random sample for zone:Lambeth 015D:gym\nUsing random sample for zone:Lambeth 006C:work\nUsing random sample for zone:Wandsworth 004B:gym\nUsing random sample for zone:Wandsworth 001C:park\nUsing random sample for zone:Hammersmith and Fulham 020D:gym\nUsing random sample for zone:Hammersmith and Fulham 018A:gym\nUsing random sample for zone:Hammersmith and Fulham 022A:pub\nUsing random sample for zone:Wandsworth 020B:gym\nUsing random sample for zone:Wandsworth 009B:park\n</pre> <pre>{'num_households': 20, 'num_people': 20, 'num_activities': 90, 'num_legs': 70}\n</pre> In\u00a0[16]: Copied! <pre>population.random_person().print()\n</pre> population.random_person().print() <pre>Person: agent_14\n{'subpopulation': 'medium income', 'gender': 'male', 'age': '85  and over', 'household_zone': 'Westminster 023A', 'household_LSOA': 'E02000982', 'household_LAD': 'Westminster'}\n0:\tActivity(act:home, location:POINT (528674.754749049 178085.52007832748), time:00:00:00 --&gt; 06:46:00, duration:6:46:00)\n1:\tLeg(mode:bike, area:POINT (528674.754749049 178085.52007832748) --&gt; POINT (527669.4798617783 176140.01100021007), time:06:46:00 --&gt; 07:23:00, duration:0:37:00)\n2:\tActivity(act:shop, location:POINT (527669.4798617783 176140.01100021007), time:07:23:00 --&gt; 08:23:00, duration:1:00:00)\n3:\tLeg(mode:bus, area:POINT (527669.4798617783 176140.01100021007) --&gt; POINT (524664.1853007445 178570.79156875174), time:08:23:00 --&gt; 09:22:00, duration:0:59:00)\n4:\tActivity(act:shop, location:POINT (524664.1853007445 178570.79156875174), time:09:22:00 --&gt; 10:22:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:POINT (524664.1853007445 178570.79156875174) --&gt; POINT (529828.9013367804 178996.6055492614), time:10:22:00 --&gt; 10:42:00, duration:0:20:00)\n6:\tActivity(act:shop, location:POINT (529828.9013367804 178996.6055492614), time:10:42:00 --&gt; 11:42:00, duration:1:00:00)\n7:\tLeg(mode:rail, area:POINT (529828.9013367804 178996.6055492614) --&gt; POINT (529894.6079999349 176743.832467726), time:11:42:00 --&gt; 12:41:00, duration:0:59:00)\n8:\tActivity(act:shop, location:POINT (529894.6079999349 176743.832467726), time:12:41:00 --&gt; 13:41:00, duration:1:00:00)\n9:\tLeg(mode:subway, area:POINT (529894.6079999349 176743.832467726) --&gt; POINT (528674.754749049 178085.52007832748), time:13:41:00 --&gt; 14:19:00, duration:0:38:00)\n10:\tActivity(act:home, location:POINT (528674.754749049 178085.52007832748), time:14:19:00 --&gt; 00:00:00, duration:9:41:00)\n</pre> In\u00a0[17]: Copied! <pre>population.random_person().attributes\n</pre> population.random_person().attributes Out[17]: <pre>{'subpopulation': 'low income',\n 'gender': 'female',\n 'age': '85  and over',\n 'household_zone': 'Hammersmith and Fulham 025A',\n 'household_LSOA': 'E02000396',\n 'household_LAD': 'Hammersmith and Fulham'}</pre> In\u00a0[18]: Copied! <pre># Validation if it works\npopulation.validate()\n</pre> # Validation if it works population.validate() In\u00a0[19]: Copied! <pre># Print random person activity plan\npopulation.random_person().print()\n</pre> # Print random person activity plan population.random_person().print() <pre>Person: agent_15\n{'subpopulation': 'low income', 'gender': 'female', 'age': '21 to 25', 'household_zone': 'Kensington and Chelsea 020E', 'household_LSOA': 'E02000596', 'household_LAD': 'Kensington and Chelsea'}\n0:\tActivity(act:home, location:POINT (526176.2513220281 177402.39918771468), time:00:00:00 --&gt; 08:33:00, duration:8:33:00)\n1:\tLeg(mode:rail, area:POINT (526176.2513220281 177402.39918771468) --&gt; POINT (530336.8184657237 175444.9354955124), time:08:33:00 --&gt; 09:36:00, duration:1:03:00)\n2:\tActivity(act:gym, location:POINT (530336.8184657237 175444.9354955124), time:09:36:00 --&gt; 10:36:00, duration:1:00:00)\n3:\tLeg(mode:rail, area:POINT (530336.8184657237 175444.9354955124) --&gt; POINT (530142.3180487572 177052.09677222857), time:10:36:00 --&gt; 11:43:00, duration:1:07:00)\n4:\tActivity(act:work, location:POINT (530142.3180487572 177052.09677222857), time:11:43:00 --&gt; 14:43:00, duration:3:00:00)\n5:\tLeg(mode:subway, area:POINT (530142.3180487572 177052.09677222857) --&gt; POINT (527369.8588878576 176645.98928565838), time:14:43:00 --&gt; 16:01:00, duration:1:18:00)\n6:\tActivity(act:gym, location:POINT (527369.8588878576 176645.98928565838), time:16:01:00 --&gt; 17:01:00, duration:1:00:00)\n7:\tLeg(mode:subway, area:POINT (527369.8588878576 176645.98928565838) --&gt; POINT (526176.2513220281 177402.39918771468), time:17:01:00 --&gt; 17:20:00, duration:0:19:00)\n8:\tActivity(act:home, location:POINT (526176.2513220281 177402.39918771468), time:17:20:00 --&gt; 00:00:00, duration:6:40:00)\n</pre> <p>Plot the activities as a 24-hour diary schedules for 5 randomly chosen agents</p> In\u00a0[20]: Copied! <pre>for _i in range(5):\n    p = population.random_person()\n    p.plot()\n</pre> for _i in range(5):     p = population.random_person()     p.plot() <p>Plot the frequency with which each of the activity types happens throughout the 24-hour period.</p> In\u00a0[21]: Copied! <pre>fig = plot_activity_times(population)\n</pre> fig = plot_activity_times(population) In\u00a0[22]: Copied! <pre># Check the duration of trips\ndurations = duration_counts(population)\ndurations\n</pre> # Check the duration of trips durations = duration_counts(population) durations Out[22]: duration trips 0 0 to 5 min 0 1 5 to 10 min 2 2 10 to 15 min 5 3 15 to 30 min 15 4 30 to 45 min 8 5 45 to 60 min 9 6 60 to 90 min 31 7 90 to 120 min 0 8 120+ min 0 <p>Now plot a histogram for duration of the trips.</p> In\u00a0[23]: Copied! <pre>plt.barh(durations[\"duration\"], durations[\"trips\"])\nplt.xlabel(\"Counts\")\nplt.ylabel(\"Duration for trips\")\nplt.title(\"Duration for different trips\")\nplt.ylim(ymax=\"90 to 120 min\")\n</pre> plt.barh(durations[\"duration\"], durations[\"trips\"]) plt.xlabel(\"Counts\") plt.ylabel(\"Duration for trips\") plt.title(\"Duration for different trips\") plt.ylim(ymax=\"90 to 120 min\") Out[23]: <pre>(-0.8400000000000001, 7.0)</pre> In\u00a0[24]: Copied! <pre># Check the distance of trips\ndistances = distance_counts(population)\ndistances\n</pre> # Check the distance of trips distances = distance_counts(population) distances Out[24]: distance trips 0 0 to 1 km 2 1 1 to 5 km 49 2 5 to 10 km 19 3 10 to 25 km 0 4 25 to 50 km 0 5 50 to 100 km 0 6 100 to 200 km 0 7 200+ km 0 <p>Next we plot the distribution of trip distances.</p> In\u00a0[25]: Copied! <pre>plt.barh(distances[\"distance\"], distances[\"trips\"])\nplt.xlabel(\"Counts\")\nplt.ylabel(\"distance, km\")\nplt.title(\"distance for different trips\")\nplt.ylim(ymax=\"25 to 50 km\")\n</pre> plt.barh(distances[\"distance\"], distances[\"trips\"]) plt.xlabel(\"Counts\") plt.ylabel(\"distance, km\") plt.title(\"distance for different trips\") plt.ylim(ymax=\"25 to 50 km\") Out[25]: <pre>(-0.79, 4.0)</pre> In\u00a0[26]: Copied! <pre>to_csv(population, dir=\"outputs\", crs=\"epsg:27700\")\n</pre> to_csv(population, dir=\"outputs\", crs=\"epsg:27700\") <p>Plot the distribution of activities by type</p> In\u00a0[27]: Copied! <pre>df_activity = pd.read_csv(os.path.join(\"outputs\", \"activities.csv\"))\ntotals = df_activity.activity.value_counts()\nplt.barh(totals.index, totals)\nplt.title(\"activities count\")\n</pre> df_activity = pd.read_csv(os.path.join(\"outputs\", \"activities.csv\")) totals = df_activity.activity.value_counts() plt.barh(totals.index, totals) plt.title(\"activities count\") Out[27]: <pre>Text(0.5, 1.0, 'activities count')</pre> In\u00a0[28]: Copied! <pre>write_od_matrices(population, path=\"outputs\")\nod_matrices = pd.read_csv(\n    os.path.join(\"outputs\", \"total_od.csv\")\n)  # we should change this method to be consistent with other - ie return a dataframe\nod_matrices[\"total origins\"] = od_matrices.drop(\"Origin\", axis=1).sum(axis=1)\nod_matrices\n</pre> write_od_matrices(population, path=\"outputs\") od_matrices = pd.read_csv(     os.path.join(\"outputs\", \"total_od.csv\") )  # we should change this method to be consistent with other - ie return a dataframe od_matrices[\"total origins\"] = od_matrices.drop(\"Origin\", axis=1).sum(axis=1) od_matrices Out[28]: Origin Hammersmith and Fulham 010E Hammersmith and Fulham 012C Hammersmith and Fulham 012F Hammersmith and Fulham 015A Hammersmith and Fulham 016B Hammersmith and Fulham 016C Hammersmith and Fulham 017B Hammersmith and Fulham 018A Hammersmith and Fulham 020D ... Westminster 020C Westminster 020D Westminster 021A Westminster 021C Westminster 022C Westminster 023A Westminster 023C Westminster 024B Westminster 024E total origins 0 Hammersmith and Fulham 010E 0 0 0 0 0 0 0 0 0 ... 0 0 1 0 0 0 0 0 0 1 1 Hammersmith and Fulham 012C 0 0 0 0 0 0 0 0 0 ... 1 0 0 0 0 0 0 0 0 1 2 Hammersmith and Fulham 012F 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 3 Hammersmith and Fulham 015A 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 4 Hammersmith and Fulham 016B 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 62 Westminster 022C 1 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 63 Westminster 023A 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 64 Westminster 023C 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 65 Westminster 024B 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 66 Westminster 024E 0 0 0 1 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 <p>67 rows \u00d7 69 columns</p> <p>Plot the number of trips originating from each LSOA</p> In\u00a0[29]: Copied! <pre>lsoas_clipped = lsoas_clipped.reset_index()\norigins_heat_map = lsoas_clipped.join(od_matrices[\"total origins\"])\n\nfig, ax = plt.subplots(figsize=(18, 10))\norigins_heat_map.plot(\"total origins\", legend=True, ax=ax)\nax.set_title(\"Total Origins\")\n</pre> lsoas_clipped = lsoas_clipped.reset_index() origins_heat_map = lsoas_clipped.join(od_matrices[\"total origins\"])  fig, ax = plt.subplots(figsize=(18, 10)) origins_heat_map.plot(\"total origins\", legend=True, ax=ax) ax.set_title(\"Total Origins\") Out[29]: <pre>Text(0.5, 1.0, 'Total Origins')</pre> In\u00a0[30]: Copied! <pre>people = pd.read_csv(os.path.join(\"outputs\", \"people.csv\")).set_index(\"pid\")\nhhs = pd.read_csv(os.path.join(\"outputs\", \"households.csv\")).set_index(\"hid\")\ntrips = pd.read_csv(os.path.join(\"outputs\", \"legs.csv\")).drop([\"Unnamed: 0\"], axis=1)\n\ntrips = trips.rename(columns={\"origin activity\": \"oact\", \"destination activity\": \"dact\"})\ntrips.head()\n</pre> people = pd.read_csv(os.path.join(\"outputs\", \"people.csv\")).set_index(\"pid\") hhs = pd.read_csv(os.path.join(\"outputs\", \"households.csv\")).set_index(\"hid\") trips = pd.read_csv(os.path.join(\"outputs\", \"legs.csv\")).drop([\"Unnamed: 0\"], axis=1)  trips = trips.rename(columns={\"origin activity\": \"oact\", \"destination activity\": \"dact\"}) trips.head() Out[30]: pid hid freq ozone dzone purp oact dact mode seq tst tet duration 0 agent_0 hh_0 NaN Westminster 022C Hammersmith and Fulham 010E NaN home shop bus 1 1900-01-01 07:23:00 1900-01-01 08:18:00 0:55:00 1 agent_0 hh_0 NaN Hammersmith and Fulham 010E Westminster 021A NaN shop park car 2 1900-01-01 09:18:00 1900-01-01 10:18:00 1:00:00 2 agent_0 hh_0 NaN Westminster 021A Westminster 022C NaN park home bike 3 1900-01-01 11:18:00 1900-01-01 11:31:00 0:13:00 3 agent_1 hh_1 NaN Hammersmith and Fulham 025A Lambeth 006D NaN home education ferry 1 1900-01-01 07:32:00 1900-01-01 08:53:00 1:21:00 4 agent_1 hh_1 NaN Lambeth 006D Lambeth 005C NaN education park car 2 1900-01-01 10:53:00 1900-01-01 11:10:00 0:17:00 In\u00a0[31]: Copied! <pre>population_reloaded = load_travel_diary(trips=trips, persons_attributes=people, hhs_attributes=hhs)\n</pre> population_reloaded = load_travel_diary(trips=trips, persons_attributes=people, hhs_attributes=hhs) <pre>Using from-to activity parser using 'oact' and 'dact' columns\n</pre> <p>Plot the activities as a 24-hour diary schedules</p> In\u00a0[32]: Copied! <pre>population[\"hh_0\"][\"agent_0\"].plot()\n</pre> population[\"hh_0\"][\"agent_0\"].plot() In\u00a0[33]: Copied! <pre>population_reloaded[\"hh_0\"][\"agent_0\"].plot()\n</pre> population_reloaded[\"hh_0\"][\"agent_0\"].plot() In\u00a0[34]: Copied! <pre>population == population_reloaded\n</pre> population == population_reloaded Out[34]: <pre>False</pre> <p>The populations are not the same because the csv files did not preserve the coordinates that we previously sampled, so we will sample them again. But the reloaded population will be different as for each location a new coordinate is sampled.</p> In\u00a0[35]: Copied! <pre>write_matsim(population=population, plans_path=os.path.join(\"outputs\", \"population.xml\"))\n</pre> write_matsim(population=population, plans_path=os.path.join(\"outputs\", \"population.xml\"))"},{"location":"examples/08_toy_matsim_population/#demo-matsim-population-for-west-london","title":"Demo - MATSim Population for West London\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#aim","title":"Aim\u00b6","text":"<p>Create a bigger and more realistic sample population automatically for the West London area called Londinium. The sample population includes various activities, personal attributes and modes; the population would be used as input for MATSim transport simulation.</p>"},{"location":"examples/08_toy_matsim_population/#import-geographic-data-of-londinium","title":"Import geographic data of Londinium\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#facility-sampler","title":"Facility sampler\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#activity-generation-model","title":"Activity generation model\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#data-visulazation-and-validation","title":"Data Visulazation and validation\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#readwrite-data","title":"Read/write data\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#export-intermediate-csv-tables-of-population","title":"Export intermediate CSV tables of population\u00b6","text":""},{"location":"examples/08_toy_matsim_population/#reload-tabular-data","title":"Reload Tabular Data\u00b6","text":"<p>We load in the csv files we previously wrote to disk. This replicates a simple synthesis process we might typically use for travel diary survey data.</p>"},{"location":"examples/08_toy_matsim_population/#write-output-to-matsim-xml","title":"Write output to MATSim xml\u00b6","text":""},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Fix for cropping as per issue #241 (#240).</li> <li>optimise.grid.grid_search fixed (#239).</li> <li><code>TourPlanner</code> prevents sampling of duplicate destinations, and prevents origin being sampled as a destination (#231).</li> <li>Fix for #221, improved \"pt simplification\" (#222)</li> </ul>"},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>MATSim warm starting example (#239).</li> <li>Support for MATSim vehicles files (#215).</li> <li>Anaconda package of PAM, available on the <code>city-modelling-lab</code> channel (#211).</li> <li>Python versions 3.9 to 3.11 support (#192, #210).</li> <li>Documentation, now available at https://arup-group.github.io/pam (#197).</li> <li>internal Codecov and pre-commit CI bots (#202).</li> <li>internal Github action job to build PAM and run tests on a Windows machine (#192).</li> <li>internal Contribution guidelines and issue/pull request templates (#207).</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Documentation and examples improved (#239).</li> <li><code>ActivityDuration</code> class name changed to <code>DurationEstimator</code> (#231).</li> <li><code>TourPlanner</code> class sequences stops using GreedyTSP algorithm, rather than previous method sorting by distance from depot (#231).</li> <li>Minor changes to docs for zsh users (eg <code>pip install '.[dev]'</code>)(#219).</li> <li>Recommended installation instructions, to use mamba instead of pip (#192, #211).</li> <li>internal Source code and example notebook code layout to align with pep8 guidelines and to remove unused dependency imports (#196, #201).</li> <li>internal development toolkit, moving from internal scripts to pytest plugins (#193).</li> <li>internal CI actions link to reusable ones from <code>arup-group/actions-city-modelling-lab/</code>, including new memory profiling and multi-OS / python version tests (#243).</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Example data files not accessed by any example notebook (#196).</li> <li>internal Unused scripts that were outside the source code directory (#199).</li> </ul>"},{"location":"CHANGELOG/#v024-2023-06-08","title":"v0.2.4 - 2023-06-08","text":"<p>This version is a pre-release</p>"},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Option to skip existing facility locations during facility sampling, by adding the <code>location_override</code> argument to the <code>population.sample_locs</code> method (#190).</li> </ul>"},{"location":"CHANGELOG/#v023-2023-06-07","title":"v0.2.3 - 2023-06-07","text":"<p>This version is a pre-release</p>"},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>A bug when creating origin-destination (OD) matrices within the <code>ODFactory</code> class (#191).</li> </ul>"},{"location":"CHANGELOG/#v022-2023-05-30","title":"v0.2.2 - 2023-05-30","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Abstract mode and location choice modules, available within the <code>pam.planner.choice_location</code> module (#189).</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>internal Docker base image to ensure successful CodeBuild CD pipeline builds (#188).</li> </ul>"},{"location":"CHANGELOG/#v021-2023-05-11","title":"v0.2.1 - 2023-05-11","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>internal initialisation files, such that PAM submodules can be accessed after installing the repository as a package with pip (#187).</li> </ul>"},{"location":"CHANGELOG/#v020-2023-05-10","title":"v0.2.0 - 2023-05-10","text":"<p>This is the first version of PAM which follows semantic versioning and can be considered the first official release of the package.</p>"},{"location":"api/activity/","title":"pam.activity","text":""},{"location":"api/activity/#pam.activity.Activity","title":"<code>Activity(seq=None, act=None, area=None, link=None, loc=None, start_time=None, end_time=None, freq=None)</code>","text":"<p>             Bases: <code>PlanComponent</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(\nself,\nseq=None,\nact=None,\narea=None,\nlink=None,\nloc=None,\nstart_time=None,\nend_time=None,\nfreq=None,\n):\nself.seq = seq\nself.act = act\nself.location = Location(loc=loc, link=link, area=area)\nself.start_time = start_time\nself.end_time = end_time\nself.freq = freq\n</code></pre>"},{"location":"api/activity/#pam.activity.Activity.act","title":"<code>act = act</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.end_time","title":"<code>end_time = end_time</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.freq","title":"<code>freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.location","title":"<code>location = Location(loc=loc, link=link, area=area)</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.seq","title":"<code>seq = seq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.start_time","title":"<code>start_time = start_time</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.is_exact","title":"<code>is_exact(other)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def is_exact(self, other):\nreturn (\n(self.location == other.location)\nand (self.act == other.act)\nand (self.start_time == other.start_time)\nand (self.end_time == other.end_time)\n)\n</code></pre>"},{"location":"api/activity/#pam.activity.Activity.isin_exact","title":"<code>isin_exact(activities)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def isin_exact(self, activities: list):\nfor other in activities:\nif self.is_exact(other):\nreturn True\nreturn False\n</code></pre>"},{"location":"api/activity/#pam.activity.Activity.validate_matsim","title":"<code>validate_matsim()</code>","text":"<p>Checks if activity has required fields for a valid matsim plan.</p> Source code in <code>pam/activity.py</code> <pre><code>def validate_matsim(self) -&gt; None:\n\"\"\"Checks if activity has required fields for a valid matsim plan.\"\"\"\nif self.act is None:\nraise InvalidMATSimError(\"Activity requires a type.\")\nif self.start_time is None and self.end_time is None:\nraise InvalidMATSimError(\"Activity requires either start time or end_time.\")\nif self.location.loc is None and self.location.link is None:\nraise InvalidMATSimError(\"Activity requires link id or x,y coordinates.\")\n</code></pre>"},{"location":"api/activity/#pam.activity.Leg","title":"<code>Leg(seq=None, mode=None, start_area=None, end_area=None, start_link=None, end_link=None, start_loc=None, end_loc=None, start_time=None, end_time=None, distance=None, purp=None, freq=None, attributes={}, route=None)</code>","text":"<p>             Bases: <code>PlanComponent</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(\nself,\nseq=None,\nmode=None,\nstart_area=None,\nend_area=None,\nstart_link=None,\nend_link=None,\nstart_loc=None,\nend_loc=None,\nstart_time=None,\nend_time=None,\ndistance=None,\npurp=None,\nfreq=None,\nattributes={},\nroute=None,\n):\nself.seq = seq\nself.purp = purp\nself.mode = mode\nself.start_location = Location(loc=start_loc, link=start_link, area=start_area)\nself.end_location = Location(loc=end_loc, link=end_link, area=end_area)\nself.start_time = start_time\nself.end_time = end_time\nself.freq = freq\nself._distance = distance\n# relevant for simulated plans\nself.attributes = attributes\nif route is not None:\nself.route = route\nelse:\nself.route = Route()\n</code></pre>"},{"location":"api/activity/#pam.activity.Leg.act","title":"<code>act = 'travel'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.attributes","title":"<code>attributes = attributes</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.boarding_time","title":"<code>boarding_time</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.d_stop","title":"<code>d_stop</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.distance","title":"<code>distance</code>  <code>property</code>","text":"<p>Distance, assumed to be in m in either case.</p>"},{"location":"api/activity/#pam.activity.Leg.end_location","title":"<code>end_location = Location(loc=end_loc, link=end_link, area=end_area)</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.end_time","title":"<code>end_time = end_time</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.euclidean_distance","title":"<code>euclidean_distance</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.freq","title":"<code>freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.mode","title":"<code>mode = mode</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.network_route","title":"<code>network_route</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.o_stop","title":"<code>o_stop</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.purp","title":"<code>purp = purp</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.route","title":"<code>route = route</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.route_id","title":"<code>route_id</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.seq","title":"<code>seq = seq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.service_id","title":"<code>service_id</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.start_location","title":"<code>start_location = Location(loc=start_loc, link=start_link, area=start_area)</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.start_time","title":"<code>start_time = start_time</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan","title":"<code>Plan(home_area=None, home_location=None, home_loc=None, freq=None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def __init__(\nself, home_area=None, home_location: Optional[Location] = None, home_loc=None, freq=None\n):\nself.day = []\nif home_location:\nself.home_location = home_location\nelse:\nself.home_location = Location()\nif home_area:\nself.home_location.area = home_area\nif home_loc:\nself.home_location.loc = home_loc\nself.logger = logging.getLogger(__name__)\nself.plan_freq = freq\nself.score = None\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.activities","title":"<code>activities</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.activity_classes","title":"<code>activity_classes: set</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.closed","title":"<code>closed: bool</code>  <code>property</code>","text":"<p>Check if plan starts and stops at the same facility (based on activity and location).</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"api/activity/#pam.activity.Plan.day","title":"<code>day = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.first","title":"<code>first</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.home","title":"<code>home</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.home_based","title":"<code>home_based</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.home_location","title":"<code>home_location = home_location</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.is_valid","title":"<code>is_valid: bool</code>  <code>property</code>","text":"<p>Check for sequence, time and location structure and consistency. Note that this also checks that plan ends at END_OF_DAY.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"api/activity/#pam.activity.Plan.last","title":"<code>last</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.legs","title":"<code>legs</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.length","title":"<code>length</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.mode_classes","title":"<code>mode_classes: set</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.plan_freq","title":"<code>plan_freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.score","title":"<code>score = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.valid_end_of_day_time","title":"<code>valid_end_of_day_time: bool</code>  <code>property</code>","text":"<p>Check that start and end time of Activities and Legs are consistent.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"api/activity/#pam.activity.Plan.valid_locations","title":"<code>valid_locations: bool</code>  <code>property</code>","text":"<p>Check that locations are consistent across Activities and Legs.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"api/activity/#pam.activity.Plan.valid_sequence","title":"<code>valid_sequence: bool</code>  <code>property</code>","text":"<p>Check sequence of Activities and Legs.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"api/activity/#pam.activity.Plan.valid_start_of_day_time","title":"<code>valid_start_of_day_time: bool</code>  <code>property</code>","text":"<p>Check that start and end time of Activities and Legs are consistent.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"api/activity/#pam.activity.Plan.valid_time_sequence","title":"<code>valid_time_sequence: bool</code>  <code>property</code>","text":"<p>Check that start and end time of Activities and Legs are consistent.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"api/activity/#pam.activity.Plan.activity_tours","title":"<code>activity_tours()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def activity_tours(self):\ntours = []\ntour = []\nfor act in self.activities:\nif act.act == \"home\":\nif tour:\ntours.append(tour)\ntour = []\nelse:\ntour.append(act)\nif tour:\ntours.append(tour)\nreturn tours\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.add","title":"<code>add(p)</code>","text":"<p>Safely add a new component to the plan.</p> PARAMETER  DESCRIPTION <code>p</code> <p>component to add.</p> <p> TYPE: <code>Union[Activity, Leg, Trip, list[Activity, Leg, Trip]]</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def add(self, p: Union[Activity, Leg, Trip, list[Activity, Leg, Trip]]) -&gt; None:\n\"\"\"Safely add a new component to the plan.\n    Args:\n      p (Union[Activity, Leg, Trip, list[Activity, Leg, Trip]]): component to add.\n    \"\"\"\nif isinstance(p, list):\nfor c in p:\nself.add(c)\nelif isinstance(p, Activity):\nif self.day and isinstance(self.day[-1], Activity):  # enforce act-leg-act seq\nraise PAMSequenceValidationError(\n\"Failed to add to plan, next component must be a Trip or Leg.\"\n)\nself.day.append(p)\nelif isinstance(p, Leg) or isinstance(p, Trip):\nif not self.day:\nraise PAMSequenceValidationError(\n\"Failed to add to plan, first component must be Activity instance.\"\n)\nif not isinstance(self.day[-1], Activity):  # enforce act-leg-act seq\nraise PAMSequenceValidationError(\n\"Failed to add to plan, next component must be Activity instance.\"\n)\nself.day.append(p)\nelse:\nraise UserWarning(f\"Cannot add type: {type(p)} to plan.\")\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.autocomplete_matsim","title":"<code>autocomplete_matsim()</code>","text":"<p>Complete leg start and end locations.</p> Source code in <code>pam/activity.py</code> <pre><code>def autocomplete_matsim(self):\n\"\"\"Complete leg start and end locations.\"\"\"\nfor seq, component in enumerate(self):\nif isinstance(component, Leg):\nself.day[seq].start_location = self.day[seq - 1].location\nself.day[seq].end_location = self.day[seq + 1].location\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.change_duration","title":"<code>change_duration(seq, shift_duration)</code>","text":"<p>Change the duration of a leg and shift subsequent activities/legs forward.</p> PARAMETER  DESCRIPTION <code>seq</code> <p>leg index in self.day.</p> <p> TYPE: <code>int</code> </p> <code>shift_duration</code> <p>the number of seconds to change the leg duration by.</p> <p> TYPE: <code>timedelta</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def change_duration(self, seq: int, shift_duration: timedelta) -&gt; None:\n\"\"\"Change the duration of a leg and shift subsequent activities/legs forward.\n    Args:\n        seq (int): leg index in self.day.\n        shift_duration (timedelta): the number of seconds to change the leg duration by.\n    \"\"\"\n# change leg duration\nself.day[seq].end_time = self.day[seq].end_time + shift_duration\n# shift all subsequent legs and activities\nfor idx in range(seq + 1, len(self.day)):\nstart_time = self.day[idx].start_time\nself.day[idx].shift_start_time(start_time + shift_duration)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.clear","title":"<code>clear()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def clear(self):\nself.day = []\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.closed_duration","title":"<code>closed_duration(idx)</code>","text":"<p>Check duration of plan component at idx, if closed plan, combine first and last durations.</p> PARAMETER  DESCRIPTION <code>idx</code> <p>index along plan component to check.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def closed_duration(self, idx: int) -&gt; datetime64:\n\"\"\"Check duration of plan component at idx, if closed plan, combine first and last durations.\n    Args:\n      idx (int): index along plan component to check.\n    Returns:\n        datetime64:\n    \"\"\"\nif self.closed and (idx == 0 or idx == self.length - 1):\nreturn self.day[0].duration + self.day[-1].duration\nreturn self.day[idx].duration\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.combine_matching_activities","title":"<code>combine_matching_activities(idx_start, idx_end)</code>","text":"<p>Combine two given activities into same activity, remove surplus Legs</p> PARAMETER  DESCRIPTION <code>idx_start</code> <p> TYPE: <code>int</code> </p> <code>idx_end</code> <p> TYPE: <code>int</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def combine_matching_activities(self, idx_start: int, idx_end: int) -&gt; None:\n\"\"\"Combine two given activities into same activity, remove surplus Legs\n    Args:\n      idx_start (int):\n      idx_end (int):\n    \"\"\"\nself.day[idx_start].end_time = self.day[idx_end].end_time  # extend proceeding act\nself.day.pop(idx_end)  # remove subsequent activity\nself.day.pop(idx_end - 1)  # remove subsequent leg\nself.day.pop(idx_start + 1)  # remove proceeding leg\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.combine_wrapped_activities","title":"<code>combine_wrapped_activities(idx_start, idx_end)</code>","text":"<p>Combine two given activities that will wrap around day, remove surplus Legs</p> PARAMETER  DESCRIPTION <code>idx_start</code> <p> TYPE: <code>int</code> </p> <code>idx_end</code> <p> TYPE: <code>int</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def combine_wrapped_activities(self, idx_start: int, idx_end: int) -&gt; None:\n\"\"\"Combine two given activities that will wrap around day, remove surplus Legs\n    Args:\n      idx_start (int):\n      idx_end (int):\n    \"\"\"\n# extend proceeding act to end of day\nself.day[idx_start].end_time = pam.variables.END_OF_DAY\n# extend subsequent act to start of day\nself.day[idx_end].start_time = pam.utils.minutes_to_datetime(0)\nself.day.pop(idx_start + 1)  # remove proceeding leg\nself.day.pop(idx_end - 1)  # remove subsequent leg\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.crop","title":"<code>crop()</code>","text":"<p>Crop a plan to end of day (END_OF_DAY). Plan components that start after this time are removed. Activities that end after this time are trimmed. If the last component is a Leg, this leg is removed and the previous activity extended.</p> Source code in <code>pam/activity.py</code> <pre><code>def crop(self):\n\"\"\"Crop a plan to end of day (END_OF_DAY). Plan components that start after this\n    time are removed. Activities that end after this time are trimmed. If the last component\n    is a Leg, this leg is removed and the previous activity extended.\n    \"\"\"\n# crop plan beyond end of day\nfor idx, component in list(self.reversed()):\nif component.start_time &gt; pam.variables.END_OF_DAY:\nself.logger.debug(\"Cropping plan components\")\nself.day = self.day[:idx]\nelse:\nbreak\n# crop plan that is out of sequence\nfor idx in range(1, self.length):\nif self[idx].start_time &lt; self[idx - 1].end_time:\nself.logger.debug(\"Cropping plan components\")\nself.day = self.day[:idx]\nbreak\nif self[idx].start_time &gt; self[idx].end_time:\nself.logger.debug(\"Cropping plan components\")\nself.day = self.day[: idx + 1]\nbreak\n# deal with last component\nif isinstance(self.day[-1], Activity):\nself.day[-1].end_time = pam.variables.END_OF_DAY\nelse:\nself.logger.debug(\"Cropping plan ending in Leg\")\nself.day.pop(-1)\nself.day[-1].end_time = pam.variables.END_OF_DAY\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.expand","title":"<code>expand(pivot_idx)</code>","text":"<p>Fill plan by expanding a pivot activity.</p> PARAMETER  DESCRIPTION <code>pivot_idx</code> <p> TYPE: <code>int</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def expand(self, pivot_idx: int) -&gt; None:\n\"\"\"Fill plan by expanding a pivot activity.\n    Args:\n      pivot_idx (int):\n    \"\"\"\n# todo this isn't great - just pushes other activities to edges of day\nnew_time = pam.utils.minutes_to_datetime(0)\nfor seq in range(pivot_idx + 1):  # push forward pivot and all proceeding components\nnew_time = self.day[seq].shift_start_time(new_time)\nnew_time = pam.variables.END_OF_DAY\nfor seq in range(self.length - 1, pivot_idx, -1):  # push back all subsequent components\nnew_time = self.day[seq].shift_end_time(new_time)\nself.day[pivot_idx].end_time = new_time  # expand pivot\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.fill_plan","title":"<code>fill_plan(idx_start, idx_end, default='home')</code>","text":"<p>Fill a plan after Activity has been removed.</p> <p>Plan is filled between given remaining activity locations (idx_start and idx_end). Note that the plan will also have legs that need to be removed.</p> PARAMETER  DESCRIPTION <code>idx_start</code> <p>location of previous Activity.</p> <p> TYPE: <code>Union[int, None]</code> </p> <code>idx_end</code> <p>location of subsequent Activity.</p> <p> TYPE: <code>Union[int, None]</code> </p> <code>default</code> <p>Not Used. Defaults to \"home\".</p> <p> TYPE: <code>Any</code> DEFAULT: <code>'home'</code> </p> RETURNS DESCRIPTION <code>True</code> <p> TYPE: <code>True</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def fill_plan(\nself, idx_start: Union[int, None], idx_end: Union[int, None], default: Any = \"home\"\n) -&gt; True:\n\"\"\"Fill a plan after Activity has been removed.\n    Plan is filled between given remaining\n    activity locations (idx_start and idx_end). Note that the plan will also have legs that\n    need to be removed.\n    Args:\n      idx_start (Union[int, None]): location of previous Activity.\n      idx_end (Union[int, None]): location of subsequent Activity.\n      default (Any, optional): Not Used. Defaults to \"home\".\n    Returns:\n      True:\n    \"\"\"\nself.logger.debug(f\" fill_plan, {idx_start}-&gt;{idx_end}\")\nif idx_start is None and idx_end is None:  # Assume stay at home\nself.stay_at_home()\nreturn True\nif idx_start is None:  # start of day non wrapping\nself.day.pop(0)\nself.expand(idx_end - 1)  # shifted because we popped index 0\nreturn True\nif idx_end is None:  # end of day non wrapping\nself.day.pop(-1)\nself.expand(idx_start)\nreturn True\nif idx_start == idx_end:  # this is a single remaining activity -&gt; stay at home\nif self.position_of(target=\"home\") is None:\nraise ValueError(\"Require home activity\")\nself.stay_at_home()\nreturn True\nif self.day[idx_start] == self.day[idx_end]:  # combine activities\n\"\"\"\n        These activities are the same (based on type and location), so can be combined,\n        but there are 2 sub cases:\n        i) idx_start &lt; idx_end -&gt; wrapped combine\n        ii) else -&gt; regular combine can ignore wrapping\n        \"\"\"\nif idx_end &lt; idx_start:  # this is a wrapped activity --&gt; close it\n# todo probably don't need to pass the idx - know that it must be first and last\nself.combine_wrapped_activities(idx_start, idx_end)\nreturn True\n# this is a regular non wrapped mid plan activity -&gt; combine acts\nself.combine_matching_activities(idx_start, idx_end)\nreturn True\n\"\"\"\n    Remaining are plans where the activities are different so fill not be combined, instread\n    we will use 'expand' to refill the plan. There are 2 sub cases:\n    i) idx_start &lt; idx_end -&gt; wrapped combine\n    ii) else -&gt; regular combine can ignore wrapping\n    \"\"\"\nif idx_end &lt; idx_start:  # this is a wrapped activity --&gt; close it\nself.day.pop(0)  # remove start leg\nself.day.pop(-1)  # remove end leg\npivot_idx = self.position_of(target=\"home\")\nif pivot_idx is None:\nself.logger.warning(\"Unable to find home activity, changing plan to stay at home\")\nself.stay_at_home()\nreturn True\nself.expand(pivot_idx)\nreturn True\n# need to change first leg for new destination\nself.join_activities(idx_start, idx_end)\nreturn True\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.finalise_activity_end_times","title":"<code>finalise_activity_end_times()</code>","text":"<p>Add activity end times based on start time of next activity.</p> Source code in <code>pam/activity.py</code> <pre><code>def finalise_activity_end_times(self):\n\"\"\"Add activity end times based on start time of next activity.\"\"\"\nif len(self.day) &gt; 1:\nfor seq in range(0, len(self.day) - 1, 2):  # activities excluding last one\nself.day[seq].end_time = self.day[seq + 1].start_time\nself.day[-1].end_time = pam.variables.END_OF_DAY\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.fix","title":"<code>fix(crop=True, times=True, locations=True)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def fix(self, crop=True, times=True, locations=True):\nif crop:\nself.crop()\nif times:\nself.fix_time_consistency()\nif locations:\nself.fix_location_consistency()\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.fix_location_consistency","title":"<code>fix_location_consistency()</code>","text":"<p>Force plan locations consistency by adjusting leg locations.</p> Source code in <code>pam/activity.py</code> <pre><code>def fix_location_consistency(self):\n\"\"\"Force plan locations consistency by adjusting leg locations.\"\"\"\nfor i in range(1, self.length - 1):\ncomponent = self.day[i]\nif isinstance(component, Leg):\ncomponent.start_location = copy(self.day[i - 1].location)\ncomponent.end_location = copy(self.day[i + 1].location)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.fix_time_consistency","title":"<code>fix_time_consistency()</code>","text":"<p>Force plan component time consistency.</p> Source code in <code>pam/activity.py</code> <pre><code>def fix_time_consistency(self):\n\"\"\"Force plan component time consistency.\"\"\"\nfor i in range(self.length - 1):\nself.day[i + 1].start_time = self.day[i].end_time\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.get","title":"<code>get(idx, default=None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def get(self, idx, default=None):\nif -self.length &lt;= idx &lt; self.length:\nreturn self.day[idx]\nreturn default\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.get_home_duration","title":"<code>get_home_duration()</code>","text":"<p>Get the total duration of home activities.</p> Source code in <code>pam/activity.py</code> <pre><code>def get_home_duration(self):\n\"\"\"Get the total duration of home activities.\"\"\"\n# total time spent at home\nhome_duration = timedelta(0)\nfor plan in self.day:\nif plan.act == \"home\":\nhome_duration += plan.duration\nreturn home_duration\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.get_leg_tour","title":"<code>get_leg_tour(seq)</code>","text":"<p>Get the tour of a leg</p> PARAMETER  DESCRIPTION <code>seq</code> <p>plan sequence. Must be a leg sequence.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list</code> <p>activities in a tour.</p> <p> TYPE: <code>list</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def get_leg_tour(self, seq: int) -&gt; list:\n\"\"\"Get the tour of a leg\n    Args:\n      seq (int): plan sequence. Must be a leg sequence.\n    Returns:\n      list: activities in a tour.\n    \"\"\"\nassert isinstance(self.day[seq], Leg)\nact_from = self.day[seq - 1]\nact_to = self.day[seq + 1]\nfor tour in self.activity_tours():\nfor tour_act in tour:\nif act_from.is_exact(tour_act) or act_to.is_exact(tour_act):\nreturn tour\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.infer_activities_from_tour_purpose","title":"<code>infer_activities_from_tour_purpose()</code>","text":"<p>Infer and set activity types based on trip purpose.</p> <p>Algorithm works like breadth first search, initiated from inferred home locations. Search takes place in two stages, first pass forward, the backward. The next activity type is set based on the trip purpose. Pass forward is exhausted first, because it's assumed that this is how the diary is originally filled in.</p> Source code in <code>pam/activity.py</code> <pre><code>def infer_activities_from_tour_purpose(self) -&gt; None:\n\"\"\"Infer and set activity types based on trip purpose.\n    Algorithm works like breadth first search,\n    initiated from inferred home locations. Search takes place in two stages, first pass forward,\n    the backward. The next activity type is set based on the trip purpose. Pass forward is exhausted\n    first, because it's assumed that this is how the diary is originally filled in.\n    \"\"\"\n# find home activities\nhome_idxs = self.infer_activity_idxs(target=self.home)\nfor idx in home_idxs:\nself.day[idx].act = \"home\"\narea_map = {}\nremaining = set(range(0, self.length, 2)) - set(home_idxs)\n# forward traverse\nqueue = [\nidx + 2 for idx in home_idxs if idx + 2 &lt; self.length\n]  # add next act idxs to queue\\\nlast_act = None\nwhile queue:  # traverse from home\nidx = queue.pop()\nif self.day[idx].act is None:\nact = self.day[idx - 1].purp.lower()\nlocation = str(self.day[idx].location.min)\nif act == last_act and location in area_map:\nact = area_map[location]\nself.day[idx].act = act\nremaining -= {idx}\nlast_act = act\narea_map[location] = act\nif idx + 2 in remaining:\nqueue.append(idx + 2)\nqueue = []\nfor location, activity in area_map.items():\ncandidates = self.infer_activity_idxs(target=Location(area=location), default=False)\nfor idx in candidates:\nif idx in remaining:\nself.day[idx].act = activity\nremaining -= {idx}\nif idx + 2 in remaining:\nqueue.append(idx + 2)\nwhile queue:\nidx = queue.pop()\nif self.day[idx].act is None:\nact = self.day[idx - 1].purp.lower()\nlocation = self.day[idx].location.min\nif act == last_act and location in area_map:\nact = area_map[location]\nself.day[idx].act = act\nremaining -= {idx}\nlast_act = act\narea_map[location] = act\nif idx + 2 &lt; self.length:\nqueue.append(idx + 2)\n# backward traverse\nqueue = list(remaining)  # add next act idxs to queue\nwhile queue:  # traverse from home\nidx = queue.pop()\nif self.day[idx].act is None:\nact = self.day[idx + 1].purp.lower()\nlocation = self.day[idx].location.min\nif act == last_act and location in area_map:\nact = area_map[location]\nself.day[idx].act = act\nremaining -= {idx}\nlast_act = act\narea_map[location] = act\nif idx - 2 &gt;= 0:\nqueue.append(idx - 2)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.infer_activity_idxs","title":"<code>infer_activity_idxs(target, default=True)</code>","text":"<p>Infer idxs of home activity based on location.</p> <p>First pass looks to exclude other acts at home location, second pass adds home idxs. If a leg is found to start and end at the home location then the one with maximum duration is included.</p> PARAMETER  DESCRIPTION <code>target</code> <p> TYPE: <code>Location</code> </p> <code>default</code> <p>Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>set</code> <p> TYPE: <code>set</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def infer_activity_idxs(self, target: Location, default: bool = True) -&gt; set:\n\"\"\"Infer idxs of home activity based on location.\n    First pass looks to exclude other acts at home location, second pass adds home idxs.\n    If a leg is found to start and end at the home location then the one with maximum duration is included.\n    Args:\n      target (Location):\n      default (bool, optional): Defaults to True.\n    Returns:\n        set:\n    \"\"\"\n# todo untested for more than three possible home activities in a row.\ncandidates = set()\nexclude = set()\nfor idx, leg in enumerate(self.legs):\nprev_act_idx = 2 * idx\nnext_act_idx = prev_act_idx + 2\nif leg.start_location == leg.end_location == target:  # check for larger duration\nif self.closed_duration(prev_act_idx) &gt; self.closed_duration(next_act_idx):\nexclude.add(next_act_idx)\nelse:\nexclude.add(prev_act_idx)\nfor idx, act in enumerate(self.activities):\nif act.location == target and (idx * 2) not in exclude:\ncandidates.add(idx * 2)\nif default and not candidates:  # assume first activity (and last if closed)\nif self.closed:\nreturn set([0, self.length - 1])\nreturn set([0])\nreturn candidates\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.join_activities","title":"<code>join_activities(idx_start, idx_end)</code>","text":"<p>Join together two Activities with new Leg, expand last home activity.</p> PARAMETER  DESCRIPTION <code>idx_start</code> <p> TYPE: <code>int</code> </p> <code>idx_end</code> <p> TYPE: <code>int</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def join_activities(self, idx_start: int, idx_end: int) -&gt; None:\n\"\"\"Join together two Activities with new Leg, expand last home activity.\n    Args:\n      idx_start (int):\n      idx_end (int):\n    \"\"\"\nself.day[idx_start + 1].end_location = self.day[idx_end - 1].end_location\nself.day[idx_start + 1].purp = self.day[idx_end - 1].purp\nself.day.pop(idx_end - 1)  # remove second leg\n# todo add logic to change mode and time of leg\n# press plans away from pivoting activity\npivot_idx = self.position_of(target=\"home\")\nif pivot_idx is None:\nself.logger.warning(\"Unable to find home activity, changing plan to stay at home\")\nself.stay_at_home()\nreturn None\nself.expand(pivot_idx)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.mode_shift","title":"<code>mode_shift(seq, new_mode='walk', mode_speed={'car': 37, 'bus': 10, 'walk': 4, 'cycle': 14, 'pt': 23, 'rail': 37}, update_duration=False)</code>","text":"<p>Changes mode for a leg, along with any legs in the same tour.</p> <p>Leg durations are adjusted to mode speed, and home activity durations revisited to fit within the 24-hr plan. Default speed values are from National Travel Survey data (NTS0303).</p> PARAMETER  DESCRIPTION <code>seq</code> <p>leg index in self.day</p> <p> TYPE: <code>int</code> </p> <code>new_mode</code> <p>default mode shift. Defaults to \"walk\".</p> <p> TYPE: <code>string</code> DEFAULT: <code>'walk'</code> </p> <code>mode_speed</code> <p>a dictionary of average mode speeds (kph). Defaults to {\"car\": 37, \"bus\": 10, \"walk\": 4, \"cycle\": 14, \"pt\": 23, \"rail\": 37}.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{'car': 37, 'bus': 10, 'walk': 4, 'cycle': 14, 'pt': 23, 'rail': 37}</code> </p> <code>update_duration</code> <p>whether to update leg durations based on mode speed. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def mode_shift(\nself,\nseq: int,\nnew_mode=\"walk\",\nmode_speed={\"car\": 37, \"bus\": 10, \"walk\": 4, \"cycle\": 14, \"pt\": 23, \"rail\": 37},\nupdate_duration=False,\n) -&gt; None:\n\"\"\"Changes mode for a leg, along with any legs in the same tour.\n    Leg durations are adjusted to mode speed, and home activity durations revisited to fit within the 24-hr plan.\n    Default speed values are from National Travel Survey data (NTS0303).\n    Args:\n      seq (int): leg index in self.day\n      new_mode (string, optional): default mode shift. Defaults to \"walk\".\n      mode_speed (dict, optional): a dictionary of average mode speeds (kph). Defaults to {\"car\": 37, \"bus\": 10, \"walk\": 4, \"cycle\": 14, \"pt\": 23, \"rail\": 37}.\n      update_duration (bool, optional): whether to update leg durations based on mode speed. Defaults to False.\n    \"\"\"\nassert isinstance(self.day[seq], Leg)\ntour = self.get_leg_tour(seq)\nfor seq, plan in enumerate(self.day):\nif isinstance(plan, Leg):\nact_from = self.day[seq - 1]\nact_to = self.day[seq + 1]\nfor other_act in tour:\n# if any of the trip ends belongs in the tour change the mode\nif act_from.is_exact(other_act) or act_to.is_exact(other_act):\nif update_duration:\nshift_duration = (\n(mode_speed[plan.mode] / mode_speed[new_mode]) * plan.duration\n) - plan.duration  # calculate any trip duration changes due to mode shift\nplan.mode = new_mode  # change mode\nif update_duration:\nself.change_duration(\nseq=seq, shift_duration=shift_duration\n)  # change the duration of the trip\nif update_duration:\n# adjust home activities time in order fit revised legs/activities within a 24hr day\nhome_duration = self.get_home_duration()\nhome_duration_factor = (\nself.day[-1].end_time - END_OF_DAY\n) / home_duration  # factor to adjust home activity time by\nfor seq, plan in enumerate(self.day):\nif plan.act == \"home\":\nshift_duration = -home_duration_factor * plan.duration\nshift_duration = timedelta(\nseconds=round(shift_duration / timedelta(seconds=1))\n)  # round to second\nself.change_duration(seq=seq, shift_duration=shift_duration)\n# make sure the last activity ends in the end of day (ie remove potential rounding errors)\nif self.day[-1].end_time != END_OF_DAY:\nself.day[-1].end_time = END_OF_DAY\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.move_activity","title":"<code>move_activity(seq, default='home', new_mode='walk')</code>","text":"<p>Changes Activity location and associated journeys</p> PARAMETER  DESCRIPTION <code>seq</code> <p> TYPE: <code>int</code> </p> <code>default</code> <p>Defaults to \"home\".</p> <p> TYPE: <code>Union[Literal['home'], Location]</code> DEFAULT: <code>'home'</code> </p> <code>new_mode</code> <p>access/egress journey switching to this mode. Ie 'walk'. Defaults to \"walk\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'walk'</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def move_activity(\nself, seq: int, default: Union[Literal[\"home\"], Location] = \"home\", new_mode: str = \"walk\"\n) -&gt; None:\n\"\"\"Changes Activity location and associated journeys\n    Args:\n      seq (int):\n      default (Union[Literal[\"home\"], Location], optional): Defaults to \"home\".\n      new_mode (str, optional): access/egress journey switching to this mode. Ie 'walk'. Defaults to \"walk\".\n    \"\"\"\nassert isinstance(self.day[seq], Activity)\n# decide on the new location\nif default == \"home\":\nnew_location = self.home\nelse:\nassert isinstance(default, Location)\nnew_location = default\n# actually update the location\nself.day[seq].location = new_location\nif seq != 0:\n# if it's not the first activity of plan\n# update leg that leads to activity at seq\nself.day[seq - 1].end_location = new_location\nself.mode_shift(seq - 1, new_mode)\nif seq != len(self.day) - 1:\n# if it's not the last activity of plan\n# update leg that leads to activity at seq\nself.day[seq + 1].start_location = new_location\nself.mode_shift(seq + 1, new_mode)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.plot","title":"<code>plot(kwargs=None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def plot(self, kwargs=None):\nplot.plot_plan(self, kwargs)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.position_of","title":"<code>position_of(target='home', search='last')</code>","text":"<p>Return position of target activity type (either first or last depending on search).</p> PARAMETER  DESCRIPTION <code>target</code> <p>Defaults to \"home\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'home'</code> </p> <code>search</code> <p>Defaults to \"last\".</p> <p> TYPE: <code>Literal['first', 'last']</code> DEFAULT: <code>'last'</code> </p> RETURNS DESCRIPTION <code>Union[int, None]</code> <p>Union[int, None]: None if target activity type is not found.</p> Source code in <code>pam/activity.py</code> <pre><code>def position_of(\nself, target: str = \"home\", search: Literal[\"first\", \"last\"] = \"last\"\n) -&gt; Union[int, None]:\n\"\"\"Return position of target activity type (either first or last depending on search).\n    Args:\n        target (str, optional): Defaults to \"home\".\n        search (Literal['first', 'last'], optional): Defaults to \"last\".\n    Returns:\n        Union[int, None]: None if target activity type is not found.\n    \"\"\"\nif search == \"last\":\nlast = None\nfor seq, act in enumerate(self.day):\nif act.act.lower() == target:\nlast = seq\nreturn last\nif search == \"first\":\nfor seq, act in enumerate(self.day):\nif act.act.lower() == target:\nreturn seq\nraise UserWarning(\"Method only supports search types 'first' or 'last'.\")\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.print","title":"<code>print()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def print(self):\nfor seq, component in enumerate(self):\nprint(f\"{seq}:\\t{component}\")\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.remove_activity","title":"<code>remove_activity(seq)</code>","text":"<p>Remove an activity from plan at given seq.</p> <p>Does not remove adjacent legs. Will also check if an activity is wrapped and remove accordingly. Returns</p> PARAMETER  DESCRIPTION <code>seq</code> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>tuple[Union[int, None], Union[int, None]]</code> <p>tuple[Union[int, None], Union[int, None]]: (adjusted) idx of previous (p_idx) and subsequent (s_idx) activities as a tuple. If there is no previous or subsequent activity, ie a removed activity is at the start or end of an open plan, then None can be returned. If all activities are removed then None, None is returned.</p> Source code in <code>pam/activity.py</code> <pre><code>def remove_activity(self, seq: int) -&gt; tuple[Union[int, None], Union[int, None]]:\n\"\"\"Remove an activity from plan at given seq.\n    Does not remove adjacent legs.\n    Will also check if an activity is wrapped and remove accordingly. Returns\n    Args:\n      seq (int):\n    Returns:\n      tuple[Union[int, None], Union[int, None]]:\n        (adjusted) idx of previous (p_idx) and subsequent (s_idx) activities as a tuple.\n        If there is no previous or subsequent activity, ie a removed activity is at the start or end of an open plan, then None can be returned.\n        If all activities are removed then None, None is returned.\n    \"\"\"\nassert isinstance(self.day[seq], Activity)\nif seq == 0 and seq == self.length - 1:  # remove activity that is entire plan\nself.logger.debug(\nf\" remove_activity, idx:{seq} type:{self.day[seq].act}, plan now empty\"\n)\nself.day.pop(0)\nreturn None, None\nif (seq == 0 or seq == self.length - 1) and self.closed:  # remove activity that wraps\nself.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}, wraps\")\nself.day.pop(0)\nself.day.pop(self.length - 1)\nif self.length == 1:  # all activities have been removed\nself.logger.debug(\nf\" remove_activity, idx:{seq} type:{self.day[seq].act}, now empty\"\n)\nreturn None, None\nreturn self.length - 2, 1\nif seq == 0:  # remove first activity\nself.logger.debug(\nf\" remove_activity, idx:{seq} type:{self.day[seq].act}, first activity\"\n)\nself.day.pop(seq)\nreturn None, 1\nif seq == self.length - 1:  # remove last activity\nself.logger.debug(\nf\" remove_activity, idx:{seq} type:{self.day[seq].act}, last activity\"\n)\nself.day.pop(seq)\nreturn self.length - 2, None\nelse:  # remove activity somewhere in middle of plan\nself.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}\")\nself.day.pop(seq)\nreturn seq - 2, seq + 1\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.reversed","title":"<code>reversed()</code>","text":"<p>Reverse iterate through plan, yield idx and component.</p> Source code in <code>pam/activity.py</code> <pre><code>def reversed(self):\n\"\"\"Reverse iterate through plan, yield idx and component.\"\"\"\nfor i in range(self.length - 1, -1, -1):\nyield i, self[i]\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.set_leg_purposes","title":"<code>set_leg_purposes()</code>","text":"<p>Set leg purposes to destination activity.</p> <p>Skip 'pt interaction' activities.</p> Source code in <code>pam/activity.py</code> <pre><code>def set_leg_purposes(self) -&gt; None:\n\"\"\"Set leg purposes to destination activity.\n    Skip 'pt interaction' activities.\n    \"\"\"\nfor seq, component in enumerate(self):\nif isinstance(component, Leg):\nfor j in range(seq + 1, len(self.day) - 1, 2):\nact = self.day[j].act\nif not act == \"pt interaction\":\nself.day[seq].purp = act\nbreak\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.simplify_pt_trips","title":"<code>simplify_pt_trips(ignore=['pt interaction', 'pt_interaction'])</code>","text":"<p>Remove public transit (pt) interaction events and simplify associated legs to single legs with dominant mode. Dominant mode is based on max (total) distance by each mode.</p> <p>For example, given the following trip:</p> <pre><code>home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n</code></pre> <p>Is simplified to:</p> <pre><code>home =bus=&gt; work\n</code></pre> <p>(In this example we are assuming that bus was used to travel further than the two walk legs). The final bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.</p> PARAMETER  DESCRIPTION <code>ignore</code> <p>activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>['pt interaction', 'pt_interaction']</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def simplify_pt_trips(self, ignore=[\"pt interaction\", \"pt_interaction\"]) -&gt; None:\n\"\"\"Remove public transit (pt) interaction events and simplify associated legs to single legs with\n    dominant mode. Dominant mode is based on max (total) distance by each mode.\n    For example, given the following trip:\n        home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n    Is simplified to:\n        home =bus=&gt; work\n    (In this example we are assuming that bus was used to travel further than the two walk legs). The final\n    bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.\n    Args:\n      ignore (list[str], optional): activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].\n    \"\"\"\nif set(ignore).intersection(self.activity_classes):\nself.day = list(self.tripify(ignore=ignore))\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.stay_at_home","title":"<code>stay_at_home()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def stay_at_home(self):\nself.logger.debug(f\" stay_at_home, location:{self.home}\")\nself.day = [\nActivity(\nseq=1,\nact=\"home\",\narea=self.home.area,\nstart_time=pam.utils.minutes_to_datetime(0),\nend_time=pam.variables.END_OF_DAY,\n)\n]\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.trip_legs","title":"<code>trip_legs(ignore=['pt interaction', 'pt_interaction'])</code>","text":"<p>Yield plan trips as lists of legs. Trips are based on sequences of activity types used to separate legs within the same trip. The logic is based on the removal of public transit interaction activities.</p> PARAMETER  DESCRIPTION <code>ignore</code> <p>activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>['pt interaction', 'pt_interaction']</code> </p> YIELDS DESCRIPTION <code>str</code> <p>Iterator[str]</p> Source code in <code>pam/activity.py</code> <pre><code>def trip_legs(self, ignore: list[str] = [\"pt interaction\", \"pt_interaction\"]) -&gt; Iterator[str]:\n\"\"\"Yield plan trips as lists of legs. Trips are based on sequences of activity types used to separate\n    legs within the same trip. The logic is based on the removal of public transit interaction activities.\n    Args:\n      ignore (list[str], optional): activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].\n    Yields:\n        Iterator[str]\n    \"\"\"\nif self.day:\nlegs = []\nfor component in self[1:]:\nif isinstance(component, Leg):\nlegs.append(component)\nelif component.act not in ignore:\nyield legs\nlegs = []\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.tripify","title":"<code>tripify(ignore=['pt interaction', 'pt_interaction'])</code>","text":"<p>Iterate through plan components removing public transit (pt) interaction events and simplifying associated legs to single leg with dominant mode. Where dominant mode is based on max (total) distance by each mode for that trip.</p> <p>For example, given the following trip:</p> <pre><code>home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n</code></pre> <p>Is \"tripified\" to:</p> <pre><code>home =bus=&gt; work\n</code></pre> <p>(In this example we are assuming that bus was used to travel further than the two walk legs). The final bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.</p> PARAMETER  DESCRIPTION <code>ignore</code> <p>activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>['pt interaction', 'pt_interaction']</code> </p> RETURNS DESCRIPTION <code>Iterator[PlanComponent]</code> <p>Iterator[PlanComponent]</p> Source code in <code>pam/activity.py</code> <pre><code>def tripify(\nself, ignore: list[str] = [\"pt interaction\", \"pt_interaction\"]\n) -&gt; Iterator[PlanComponent]:\n\"\"\"Iterate through plan components removing public transit (pt) interaction events and simplifying\n    associated legs to single leg with dominant mode. Where dominant mode is based on max (total) distance\n    by each mode for that trip.\n    For example, given the following trip:\n        home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n    Is \"tripified\" to:\n        home =bus=&gt; work\n    (In this example we are assuming that bus was used to travel further than the two walk legs). The final\n    bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.\n    Args:\n      ignore (list[str], optional): activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].\n    Returns:\n        Iterator[PlanComponent]\n    \"\"\"\nif self.day:\nseq = 0\nmodes = {}\nstart_location = self.day[0].location\nstart_time = self.day[0].end_time\ndistance = 0\nfor component in self:\nif isinstance(component, Leg):\nmodes[component.mode] = modes.get(component.mode, 0) + component.distance\ndistance += component.distance\nattributes = component.attributes  # trips collect attributes from last leg\nif isinstance(component, Activity):\nif component.act not in ignore:\nwhile True:\nif modes:\nyield Leg(\nseq=seq,\nmode=max(modes, key=modes.get),\nstart_area=start_location.area,\nend_area=component.location.area,\nstart_link=start_location.link,\nend_link=component.location.link,\nstart_loc=start_location.loc,\nend_loc=component.location.loc,\nstart_time=start_time,\nend_time=component.start_time,\ndistance=distance,\npurp=component.act,\nattributes=attributes,\n)\nyield component\nbreak\nmodes = {}\nstart_location = component.location\nstart_time = component.end_time\ndistance = 0\nseq += 1\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.trips","title":"<code>trips(ignore=['pt interaction', 'pt_interaction'])</code>","text":"<p>Iterate through plan trips. Multi-modal leg trips are simplified to single trip with dominant mode. Where dominant mode is based on max (total) distance by each mode for that trip. The logic is based on the removal of public transit interaction activities.</p> <p>For example, given the following legs:</p> <pre><code>home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n</code></pre> <p>Is simplified to:</p> <pre><code>home =bus=&gt; work\n</code></pre> <p>(In this example we are assuming that bus was used to travel further than the two walk legs). The final bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.</p> PARAMETER  DESCRIPTION <code>ignore</code> <p>activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>['pt interaction', 'pt_interaction']</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Iterator[Trip]</p> Source code in <code>pam/activity.py</code> <pre><code>def trips(self, ignore: list[str] = [\"pt interaction\", \"pt_interaction\"]) -&gt; str:\n\"\"\"Iterate through plan trips. Multi-modal leg trips are simplified to single trip with dominant mode.\n    Where dominant mode is based on max (total) distance by each mode for that trip. The logic is based on\n    the removal of public transit interaction activities.\n    For example, given the following legs:\n        home =walk=&gt; pt interaction =bus=&gt; pt interaction =walk=&gt; work\n    Is simplified to:\n        home =bus=&gt; work\n    (In this example we are assuming that bus was used to travel further than the two walk legs). The final\n    bus leg duration and distance are taken from the accumulated walk and bus leg durations and distances.\n    Args:\n      ignore (list[str], optional): activities to remove. Defaults to [\"pt interaction\", \"pt_interaction\"].\n    Returns:\n        Iterator[Trip]\n    \"\"\"\nif self.day:\nseq = 0\nmodes = {}\nstart_location = self.day[0].location\nstart_time = self.day[0].end_time\ndistance = 0\nfor component in self[1:]:\nif isinstance(component, Leg):\nmodes[component.mode] = modes.get(component.mode, 0) + component.distance\ndistance += component.distance\nattributes = component.attributes\nelif component.act not in ignore:\nyield Trip(\nseq=seq,\nmode=max(modes, key=modes.get),\nstart_area=start_location.area,\nend_area=component.location.area,\nstart_link=start_location.link,\nend_link=component.location.link,\nstart_loc=start_location.loc,\nend_loc=component.location.loc,\nstart_time=start_time,\nend_time=component.start_time,\ndistance=distance,\npurp=component.act,\nattributes=attributes,\n)\nmodes = {}\nstart_location = component.location\nstart_time = component.end_time\ndistance = 0\nseq += 1\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.validate","title":"<code>validate()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate(self):\nself.validate_sequence()\nself.validate_times()\nself.validate_locations()\nreturn True\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.validate_locations","title":"<code>validate_locations()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate_locations(self):\nif not self.valid_locations:\nraise PAMValidationLocationsError()\nreturn True\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.validate_sequence","title":"<code>validate_sequence()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate_sequence(self):\nif not self.valid_sequence:\nraise PAMSequenceValidationError()\nreturn True\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.validate_times","title":"<code>validate_times()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate_times(self):\nif not self.valid_time_sequence:\nraise PAMInvalidTimeSequenceError(\"Plan activity and trips times are not consistent\")\nreturn True\n</code></pre>"},{"location":"api/activity/#pam.activity.PlanComponent","title":"<code>PlanComponent</code>","text":""},{"location":"api/activity/#pam.activity.PlanComponent.duration","title":"<code>duration</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.PlanComponent.hours","title":"<code>hours</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.PlanComponent.shift_duration","title":"<code>shift_duration(new_duration, new_start_time=None)</code>","text":"<p>Given a new duration and optionally start time, set start time &amp; set end time based on duration.</p> PARAMETER  DESCRIPTION <code>new_duration</code> <p> TYPE: <code>timedelta</code> </p> <code>new_start_time</code> <p>Defaults to None.</p> <p> TYPE: <code>datetime64</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new end time.</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_duration(\nself, new_duration: timedelta, new_start_time: Optional[datetime64] = None\n) -&gt; datetime64:\n\"\"\"Given a new duration and optionally start time, set start time &amp; set end time based on duration.\n    Args:\n      new_duration (timedelta):\n      new_start_time (datetime64, optional): Defaults to None.\n    Returns:\n      datetime64: new end time.\n    \"\"\"\nif new_start_time is not None:\nself.start_time = new_start_time\nself.end_time = self.start_time + new_duration\nreturn self.end_time\n</code></pre>"},{"location":"api/activity/#pam.activity.PlanComponent.shift_end_time","title":"<code>shift_end_time(new_end_time)</code>","text":"<p>Given a new end time, set end time &amp; start time based on previous duration.</p> PARAMETER  DESCRIPTION <code>new_end_time</code> <p> TYPE: <code>datetime64</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new start time.</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_end_time(self, new_end_time: datetime64) -&gt; datetime64:\n\"\"\"Given a new end time, set end time &amp; start time based on previous duration.\n    Args:\n      new_end_time (datetime64):\n    Returns:\n      datetime64: new start time.\n    \"\"\"\nduration = self.duration\nself.end_time = new_end_time\nself.start_time = new_end_time - duration\nreturn self.start_time\n</code></pre>"},{"location":"api/activity/#pam.activity.PlanComponent.shift_start_time","title":"<code>shift_start_time(new_start_time)</code>","text":"<p>Given a new start time, set start time &amp; end time based on previous duration.</p> PARAMETER  DESCRIPTION <code>new_start_time</code> <p> TYPE: <code>datetime64</code> </p> RETURNS DESCRIPTION <code>datetime64</code> <p>new end time</p> <p> TYPE: <code>datetime64</code> </p> Source code in <code>pam/activity.py</code> <pre><code>def shift_start_time(self, new_start_time: datetime64) -&gt; datetime64:\n\"\"\"Given a new start time, set start time &amp; end time based on previous duration.\n    Args:\n        new_start_time (datetime64):\n    Returns:\n        datetime64: new end time\n    \"\"\"\nduration = self.duration\nself.start_time = new_start_time\nself.end_time = new_start_time + duration\nreturn self.end_time\n</code></pre>"},{"location":"api/activity/#pam.activity.Route","title":"<code>Route(xml_elem=None)</code>","text":"<p>xml element wrapper for leg routes, in the simplest case of a leg with no route, this will behave as an empty dictionary. For routed legs this provides some convenience properties such as is_transit, and transit_route.</p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(self, xml_elem=None) -&gt; None:\nif xml_elem:\nself.xml = xml_elem[0]\nelse:\nself.xml = {}  # this allows an empty route to behave as an empty dict\n</code></pre>"},{"location":"api/activity/#pam.activity.Route.distance","title":"<code>distance: float</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.exists","title":"<code>exists: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.is_routed","title":"<code>is_routed: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.is_teleported","title":"<code>is_teleported: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.is_transit","title":"<code>is_transit: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.network_route","title":"<code>network_route: list</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.transit","title":"<code>transit: dict</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.type","title":"<code>type</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.xml","title":"<code>xml = xml_elem[0]</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Route.get","title":"<code>get(key, default=None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def get(self, key, default=None) -&gt; str:\nreturn self.xml.get(key, default)\n</code></pre>"},{"location":"api/activity/#pam.activity.RouteV11","title":"<code>RouteV11(xml_elem)</code>","text":"<p>             Bases: <code>Route</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(self, xml_elem) -&gt; None:\nsuper().__init__(xml_elem)\n</code></pre>"},{"location":"api/activity/#pam.activity.RouteV11.is_transit","title":"<code>is_transit: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.RouteV11.transit","title":"<code>transit: dict</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Trip","title":"<code>Trip</code>","text":"<p>             Bases: <code>Leg</code></p>"},{"location":"api/array/decode/","title":"pam.array.decode","text":""},{"location":"api/array/decode/#pam.array.decode.add_end_times","title":"<code>add_end_times(plan, end_of_day=END_OF_DAY)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def add_end_times(plan: list, end_of_day=END_OF_DAY):\n# add end_times\nfor i in range(len(plan) - 1):\nplan[i].end_time = plan[i + 1].start_time\nplan[-1].end_time = end_of_day\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.fix_missing_components","title":"<code>fix_missing_components(plan, bin_size=3600, default_leg_mode='car', default_activity='other')</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def fix_missing_components(\nplan: list, bin_size=3600, default_leg_mode=\"car\", default_activity=\"other\"\n):\nfor i in range(len(plan) - 1):\nif isinstance(plan[i], type(plan[i + 1])):\nstart_time = plan[i].end_time - timedelta(seconds=int(bin_size / 4))\nend_time = plan[i].end_time + timedelta(seconds=int(bin_size / 4))\nif isinstance(plan[i], Activity):  # add missing Leg\nplan.insert(\ni + 1, Leg(mode=default_leg_mode, start_time=start_time, end_time=end_time)\n)\nplan[i].end_time = start_time\nplan[i + 2].start_time = end_time\nif isinstance(plan[i], Leg):  # add missing Activity\nplan.insert(\ni + 1, Activity(act=default_activity, start_time=start_time, end_time=end_time)\n)\nplan[i].end_time = start_time\nplan[i + 2].start_time = end_time\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.fix_missing_end_activity","title":"<code>fix_missing_end_activity(plan, end_of_day=END_OF_DAY, bin_size=3600)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def fix_missing_end_activity(plan: list, end_of_day=END_OF_DAY, bin_size=3600):\nif not isinstance(plan[-1], Activity):\nstart_time = end_of_day - timedelta(seconds=int(bin_size / 2))  # expected duration\nplan.append(\nActivity(act=\"home\", start_time=start_time, end_time=end_of_day)\n)  # sensible assumption\nplan[-2].end_time = start_time\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.fix_missing_start_activity","title":"<code>fix_missing_start_activity(plan, start_of_day=START_OF_DAY, bin_size=3600)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def fix_missing_start_activity(plan: list, start_of_day=START_OF_DAY, bin_size=3600):\nif not isinstance(plan[0], Activity):\nend_time = start_of_day + timedelta(seconds=int(bin_size / 2))  # expected duration\nplan.insert(\n0, Activity(act=\"home\", start_time=start_of_day, end_time=end_time)\n)  # sensible assumption\nplan[1].start_time = end_time\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.iter_array","title":"<code>iter_array(array, mapping, start_of_day=START_OF_DAY, bin_size=3600)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def iter_array(array, mapping, start_of_day=START_OF_DAY, bin_size=3600):\nprev = None\nfor i, time_bin in enumerate(array):\nif (prev is None) or (not np.array_equal(time_bin, prev)):  # new component class\ncomponent_class = mapping.get(np.argmax(time_bin))\nif component_class is None:\nraise UserWarning(\nf\"Not found index of {np.argmax(time_bin)} in supplied mapping: {mapping}.\"\n)\nyield component_class, start_of_day + timedelta(seconds=(i * bin_size))\nprev = time_bin\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.one_hot_to_plan","title":"<code>one_hot_to_plan(array, mapping, bin_size=3600, duration=86400, start_of_day=START_OF_DAY, end_of_day=END_OF_DAY, leg_encoding='travel', default_leg_mode='car', default_activity='other')</code>","text":"<p>Decode a one-hot encoded plan array for a given mapping. Attempts to create a valid plan sequence by assuming obviously missing components. Does not support locations, these must be created manually.</p> PARAMETER  DESCRIPTION <code>array</code> <p>input one-hot encoded plan.</p> <p> TYPE: <code>array</code> </p> <code>mapping</code> <p>encoding index to activity, eg {0: 'home', 1:'travel'}.</p> <p> TYPE: <code>dict</code> </p> <code>bin_size</code> <p>in seconds. Defaults to 3600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3600</code> </p> <code>duration</code> <p>in seconds. Defaults to 86400.</p> <p> TYPE: <code>int</code> DEFAULT: <code>86400</code> </p> <code>start_of_day</code> <p>start datetime of first activity. Defaults to START_OF_DAY.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>START_OF_DAY</code> </p> <code>end_of_day</code> <p>end time of last activity. Defaults to END_OF_DAY.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>END_OF_DAY</code> </p> <code>leg_encoding</code> <p>activity encoding for travel components. Defaults to \"travel\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'travel'</code> </p> <code>default_leg_mode</code> <p>assumed leg mode when unknown. Defaults to \"car\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'car'</code> </p> <code>default_activity</code> <p>assumed activity when unknown. Defaults to \"other\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'other'</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>may raise a UserWarning if bin_size and duration are not consistent with array size.</p> RETURNS DESCRIPTION <code>Plan</code> <p>pam.activity.Plan</p> <p> TYPE: <code>Plan</code> </p> Source code in <code>pam/array/decode.py</code> <pre><code>def one_hot_to_plan(\narray: np.array,\nmapping: dict,\nbin_size: int = 3600,\nduration: int = 86400,\nstart_of_day: datetime = START_OF_DAY,\nend_of_day: datetime = END_OF_DAY,\nleg_encoding: str = \"travel\",\ndefault_leg_mode: str = \"car\",\ndefault_activity: str = \"other\",\n) -&gt; Plan:\n\"\"\"Decode a one-hot encoded plan array for a given mapping. Attempts to create a valid plan sequence\n    by assuming obviously missing components. Does not support locations, these must be created\n    manually.\n    Args:\n        array (np.array): input one-hot encoded plan.\n        mapping (dict): encoding index to activity, eg {0: 'home', 1:'travel'}.\n        bin_size (int, optional): in seconds. Defaults to 3600.\n        duration (int, optional): in seconds. Defaults to 86400.\n        start_of_day (datetime, optional): start datetime of first activity. Defaults to START_OF_DAY.\n        end_of_day (datetime, optional): end time of last activity. Defaults to END_OF_DAY.\n        leg_encoding (str, optional): activity encoding for travel components. Defaults to \"travel\".\n        default_leg_mode (str, optional): assumed leg mode when unknown. Defaults to \"car\".\n        default_activity (str, optional): assumed activity when unknown. Defaults to \"other\".\n    Raises:\n        UserWarning: may raise a UserWarning if bin_size and duration are not consistent with array size.\n    Returns:\n        Plan: pam.activity.Plan\n    \"\"\"\nbins = int(duration / bin_size)\nif not len(array) == bins:\nraise UserWarning(\n\"Specified plan duration and bin lengths do not match given array length.\"\n)\nproposed_plan = []\nfor act, start_time in iter_array(\narray=array, mapping=mapping, start_of_day=start_of_day, bin_size=bin_size\n):\nif act == leg_encoding:  # add leg\nproposed_plan.append(Leg(mode=default_leg_mode, start_time=start_time))\nelse:\nproposed_plan.append(Activity(act=act, start_time=start_time))\nadd_end_times(proposed_plan, end_of_day)\nfix_missing_start_activity(proposed_plan, start_of_day, bin_size)\nfix_missing_end_activity(proposed_plan, end_of_day, bin_size)\nfix_missing_components(proposed_plan, default_leg_mode, default_activity)\nplan = Plan()\nplan.day = proposed_plan\nreturn plan\n</code></pre>"},{"location":"api/array/distance/","title":"pam.array.distance","text":""},{"location":"api/array/distance/#pam.array.distance.accuracy","title":"<code>accuracy(actual, predicted)</code>","text":"Source code in <code>pam/array/distance.py</code> <pre><code>def accuracy(actual: np.array, predicted: np.array) -&gt; float:\nassert actual.shape == predicted.shape\ncorrect = 0\nfor ia, ib in zip(actual, predicted):\nif np.argmax(ia) == np.argmax(ib):\ncorrect += 1\nreturn correct / len(predicted)\n</code></pre>"},{"location":"api/array/distance/#pam.array.distance.cross_entropy","title":"<code>cross_entropy(actual, predicted)</code>","text":"Source code in <code>pam/array/distance.py</code> <pre><code>def cross_entropy(actual: np.array, predicted: np.array) -&gt; float:\nassert actual.shape == predicted.shape\nepsilon = 1e-12\npredicted = np.clip(predicted, epsilon, 1.0 - epsilon)\nreturn -np.sum(actual * np.log(predicted)) / actual.shape[0]\n</code></pre>"},{"location":"api/array/encode/","title":"pam.array.encode","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical","title":"<code>PlansToCategorical(bin_size=3600, duration=86400)</code>","text":"<p>Tool for converting pam.core.plans to integer arrays.</p> PARAMETER  DESCRIPTION <code>bin_size</code> <p>Defaults to 3600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3600</code> </p> <code>duration</code> <p>Defaults to 86400.</p> <p> TYPE: <code>int</code> DEFAULT: <code>86400</code> </p> Example <p>|&lt;----A----&gt;||&lt;----B----&gt;||||&lt;----A----&gt;| =&gt; [0,0,0,1,1,1,2,0,0,0] Where 0 represents a time bin of activity A, 1 of B and so on. The axis represents time, binnned according to bin_size and total duration, both given in seconds. A mapping between the array values (indexes) and plan activities can be accessed via self.index_to_act and self.act_to_index. Note <ul> <li>Leg components will have the encoding \"travel\" which will be included in the mapping.</li> <li>Location and mode information is lost.</li> <li>Some plan components may be lost if their durations are less than the chosen bin six.</li> <li>Plan components beyond 24 hours are cropped.</li> </ul> Source code in <code>pam/array/encode.py</code> <pre><code>def __init__(self, bin_size: int = 3600, duration: int = 86400) -&gt; None:\n\"\"\"Tool for converting pam.core.plans to integer arrays.\n    Args:\n        bin_size (int, optional): Defaults to 3600.\n        duration (int, optional): Defaults to 86400.\n    Example:\n        |&lt;----A----&gt;||&lt;----B----&gt;||&lt;C&gt;||&lt;----A----&gt;| =&gt; [0,0,0,1,1,1,2,0,0,0]\n        Where 0 represents a time bin of activity A, 1 of B and so on.\n        The axis represents time, binnned according to bin_size and total duration, both given in seconds.\n        A mapping between the array values (indexes) and plan activities can be accessed\n        via self.index_to_act and self.act_to_index.\n    Note:\n        - Leg components will have the encoding \"travel\" which will be included in the mapping.\n        - Location and mode information is lost.\n        - Some plan components may be lost if their durations are less than the chosen bin six.\n        - Plan components beyond 24 hours are cropped.\n    \"\"\"\nself.bin_size = bin_size\nself.duration = duration\nself.bins = int(self.duration / self.bin_size)\nself.index_to_act = {}\nself.act_to_index = {}\n</code></pre>"},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.act_to_index","title":"<code>act_to_index = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.bin_size","title":"<code>bin_size = bin_size</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.bins","title":"<code>bins = int(self.duration / self.bin_size)</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.duration","title":"<code>duration = duration</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.index_to_act","title":"<code>index_to_act = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.encode","title":"<code>encode(plan)</code>","text":"<p>Transform a pam.activity.Plan into a categorical integer array.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>input Plan object to be encoded as one-hot.</p> <p> TYPE: <code>Plan</code> </p> RETURNS DESCRIPTION <code>array</code> <p>np.array: encoded plan</p> Source code in <code>pam/array/encode.py</code> <pre><code>def encode(self, plan: Plan) -&gt; np.array:\n\"\"\"Transform a pam.activity.Plan into a categorical integer array.\n    Args:\n      plan (Plan): input Plan object to be encoded as one-hot.\n    Returns:\n      np.array: encoded plan\n    \"\"\"\nencoded = np.zeros((self.bins))\nstart_bin = 0\nreference_time = plan.day[0].start_time\nfor component in plan.day:\nact = component.act\nif act not in self.act_to_index:\nindex = len(self.act_to_index)\nself.act_to_index[act] = index\nself.index_to_act[index] = act\nindex = self.act_to_index[act]\nend_bin = round(td_to_s(component.end_time - reference_time) / self.bin_size)\nif end_bin &gt;= self.duration:  # deal with last component\nend_bin = self.duration\nencoded[start_bin:end_bin] = index\nbreak\nencoded[start_bin:end_bin] = index\nstart_bin = end_bin\nreturn encoded\n</code></pre>"},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.get_act","title":"<code>get_act(index)</code>","text":"Source code in <code>pam/array/encode.py</code> <pre><code>def get_act(self, index):\nreturn self.index_to_act.get(index)\n</code></pre>"},{"location":"api/array/encode/#pam.array.encode.plan_to_one_hot","title":"<code>plan_to_one_hot(plan, mapping, bin_size=3600, duration=86400)</code>","text":"<p>Transform a pam.activity.Plan into a one-hot encoded array. Output array is two dimensional. First axis represents time, binnned according to bin_size given in seconds. Seconds axis is a one-hot endcoding of activity type based on the given mapping. Note that Leg components will have the encoding \"travel\" which should be included in the mapping. Location and mode information is lost. Some plan components may be lost if their durations are less than the chosen bin six. Plan components beyond 24 hours are cropped.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>input Plan object to be encoded as one-hot</p> <p> TYPE: <code>Plan</code> </p> <code>mapping</code> <p>dictionary mapping of activity types to one-hot index, eg {\"home\":0, \"travel\":1}</p> <p> TYPE: <code>dict</code> </p> <code>bin_size</code> <p>time bin size (in seconds). Defaults to 3600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3600</code> </p> <code>duration</code> <p>day_duration (in seconds). Defaults to 86400.</p> <p> TYPE: <code>int</code> DEFAULT: <code>86400</code> </p> RETURNS DESCRIPTION <code>array</code> <p>np.array: one-hot encoded plan</p> Source code in <code>pam/array/encode.py</code> <pre><code>def plan_to_one_hot(\nplan: Plan, mapping: dict, bin_size: int = 3600, duration: int = 86400\n) -&gt; np.array:\n\"\"\"Transform a pam.activity.Plan into a one-hot encoded array. Output array is two dimensional.\n    First axis represents time, binnned according to bin_size given in seconds.\n    Seconds axis is a one-hot endcoding of activity type based on the given mapping. Note that Leg\n    components will have the encoding \"travel\" which should be included in the mapping. Location and\n    mode information is lost. Some plan components may be lost if their durations are less than\n    the chosen bin six. Plan components beyond 24 hours are cropped.\n    Args:\n        plan (Plan): input Plan object to be encoded as one-hot\n        mapping (dict): dictionary mapping of activity types to one-hot index, eg {\"home\":0, \"travel\":1}\n        bin_size (int, optional): time bin size (in seconds). Defaults to 3600.\n        duration (int, optional): day_duration (in seconds). Defaults to 86400.\n    Returns:\n        np.array: one-hot encoded plan\n    \"\"\"\nbins = int(duration / bin_size)\nencoded = np.zeros((bins, len(mapping)))\nstart_bin = 0\nreference_time = plan.day[0].start_time\nfor component in plan.day:\nindex = mapping.get(component.act, None)\nend_bin = round(td_to_s(component.end_time - reference_time) / bin_size)\nif end_bin &gt;= duration:  # deal with last component\nend_bin = duration\nencoded[start_bin:end_bin, index] = 1.0\nbreak\nencoded[start_bin:end_bin, index] = 1.0\nstart_bin = end_bin\nreturn encoded\n</code></pre>"},{"location":"api/core/","title":"pam.core","text":""},{"location":"api/core/#pam.core.Household","title":"<code>Household(hid, attributes={}, freq=None, location=None, area=None, loc=None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def __init__(\nself,\nhid,\nattributes={},\nfreq=None,\nlocation: Optional[Location] = None,\narea=None,\nloc=None,\n):\nself.hid = hid\nself.people = {}\nself.attributes = attributes\nself.hh_freq = freq\nif location:\nself._location = location\nelse:\nself._location = Location()\nif area:  # potential overwrite\nself._location.area = area\nif loc:  # potential overwrite\nself._location.loc = loc\n</code></pre>"},{"location":"api/core/#pam.core.Household.activities","title":"<code>activities</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.attributes","title":"<code>attributes = attributes</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.av_person_freq","title":"<code>av_person_freq</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.freq","title":"<code>freq</code>  <code>property</code>","text":"<p>Return hh_freq, else if None, return the average frequency of household members.</p> <p>TODO: note this assumes we are basing hh freq on person freq. TODO: replace this with something better.</p>"},{"location":"api/core/#pam.core.Household.hh_freq","title":"<code>hh_freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.hid","title":"<code>hid = hid</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.legs","title":"<code>legs</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.location","title":"<code>location</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.people","title":"<code>people = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.subpopulation","title":"<code>subpopulation</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.add","title":"<code>add(person)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def add(self, person):\nif isinstance(person, list):\nfor p in person:\nself.add(p)\nelif isinstance(person, Person):\nself.people[person.pid] = person\nelse:\nraise UserWarning(f\"Expected instance of Person, not: {type(person)}\")\n</code></pre>"},{"location":"api/core/#pam.core.Household.build_travel_geodataframe","title":"<code>build_travel_geodataframe(**kwargs)</code>","text":"<p>Builds geopandas.GeoDataFrame for travel Legs found for persons within a Household.</p> KEYWORD ARGUMENTS FOR PLOT.PLANS.BUILD_PERSON_TRAVEL_GEODATAFRAME DESCRIPTION <code>from_epsg</code> <p>coordinate system the plans are currently in</p> <p> TYPE: <code>str</code> </p> <code>to_epsg</code> <p>coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid).</p> Source code in <code>pam/core.py</code> <pre><code>def build_travel_geodataframe(self, **kwargs) -&gt; gpd.GeoDataFrame:\n\"\"\"Builds geopandas.GeoDataFrame for travel Legs found for persons within a Household.\n    Keyword Args: Keyword arguments for plot.plans.build_person_travel_geodataframe\n        from_epsg (str): coordinate system the plans are currently in\n        to_epsg (str): coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.\n    Returns:\n        geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid).\n    \"\"\"\ngdf = None\nfor _, person in self:\n_gdf = person.build_travel_geodataframe(**kwargs)\n_gdf[\"hid\"] = self.hid\nif gdf is None:\ngdf = _gdf\nelse:\ngdf = pd.concat([gdf, _gdf])\ngdf = gdf.sort_values([\"pid\", \"seq\"]).reset_index(drop=True)\nreturn gdf\n</code></pre>"},{"location":"api/core/#pam.core.Household.fix_plans","title":"<code>fix_plans(crop=True, times=True, locations=True)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def fix_plans(self, crop=True, times=True, locations=True):\nfor _, person in self:\nif crop:\nperson.plan.crop()\nif times:\nperson.plan.fix_time_consistency()\nif locations:\nperson.plan.fix_location_consistency()\n</code></pre>"},{"location":"api/core/#pam.core.Household.get","title":"<code>get(pid, default=None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def get(self, pid, default=None):\nreturn self.people.get(pid, default)\n</code></pre>"},{"location":"api/core/#pam.core.Household.get_attribute","title":"<code>get_attribute(key)</code>","text":"<p>Get set of attribute values for given key, First searches hh attributes then occupants.</p> Source code in <code>pam/core.py</code> <pre><code>def get_attribute(self, key) -&gt; set:\n\"\"\"Get set of attribute values for given key, First searches hh attributes then occupants.\"\"\"\nif key in self.attributes:\nreturn {self.attributes[key]}\nattributes = set()\nfor _, person in self:\nattributes.add(person.attributes.get(key))\nreturn attributes\n</code></pre>"},{"location":"api/core/#pam.core.Household.pickle","title":"<code>pickle(path)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def pickle(self, path):\nwith open(path, \"wb\") as file:\npickle.dump(self, file)\n</code></pre>"},{"location":"api/core/#pam.core.Household.plot","title":"<code>plot(**kwargs)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def plot(self, **kwargs):\nplot.plot_household(self, **kwargs)\n</code></pre>"},{"location":"api/core/#pam.core.Household.plot_travel_plotly","title":"<code>plot_travel_plotly(epsg='epsg:4326', **kwargs)</code>","text":"<p>Uses plotly's Scattermapbox to plot persons' travel.</p> PARAMETER  DESCRIPTION <code>epsg</code> <p>coordinate system the plans spatial information is in, e.g. 'epsg:27700'</p> <p> TYPE: <code>str</code> DEFAULT: <code>'epsg:4326'</code> </p> <p>Keyword Args: Keyword arguments for plot.plot_travel_plans     gdf (geopandas.GeoDataFrame): generated by build_person_travel_geodataframe     groupby (list): optional argument for splitting traces in the plot     colour_by (str): argument for specifying what the colour should correspond to in the plot, travel mode by default     cmap (dict): optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent     mapbox_access_token (str): required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).</p> Source code in <code>pam/core.py</code> <pre><code>def plot_travel_plotly(self, epsg: str = \"epsg:4326\", **kwargs) -&gt; None:\n\"\"\"Uses plotly's Scattermapbox to plot persons' travel.\n    Args:\n        epsg (str): coordinate system the plans spatial information is in, e.g. 'epsg:27700'\n    Keyword Args: Keyword arguments for plot.plot_travel_plans\n        gdf (geopandas.GeoDataFrame): generated by build_person_travel_geodataframe\n        groupby (list): optional argument for splitting traces in the plot\n        colour_by (str): argument for specifying what the colour should correspond to in the plot, travel mode by default\n        cmap (dict): optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent\n        mapbox_access_token (str): required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).\n    \"\"\"\nreturn plot.plot_travel_plans(\ngdf=self.build_travel_geodataframe(from_epsg=epsg, to_epsg=\"epsg:4326\"), **kwargs\n)\n</code></pre>"},{"location":"api/core/#pam.core.Household.print","title":"<code>print()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def print(self):\nprint(self)\nprint(self.attributes)\nfor _, person in self:\nperson.print()\n</code></pre>"},{"location":"api/core/#pam.core.Household.random_person","title":"<code>random_person()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def random_person(self):\nreturn self.people[random.choice(list(self.people))]\n</code></pre>"},{"location":"api/core/#pam.core.Household.reindex","title":"<code>reindex(prefix)</code>","text":"<p>Safely reindex all person identifiers in household using a prefix.</p> PARAMETER  DESCRIPTION <code>prefix</code> <p>Prefix to add.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/core.py</code> <pre><code>def reindex(self, prefix: str):\n\"\"\"Safely reindex all person identifiers in household using a prefix.\n    Args:\n        prefix (str): Prefix to add.\n    \"\"\"\nself.hid = prefix + self.hid\nfor pid in list(self.people):\nperson = self.people[pid]\nnew_pid = prefix + pid\nif new_pid in self.people:\nraise KeyError(f\"Duplicate person identifier (pid): {new_pid}\")\nperson.reindex(prefix)\nself.people[new_pid] = person\ndel self.people[pid]\n</code></pre>"},{"location":"api/core/#pam.core.Household.set_area","title":"<code>set_area(area)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_area(self, area):\nself._location.area = area\nfor _, person in self:\nperson.set_area(area)\n</code></pre>"},{"location":"api/core/#pam.core.Household.set_freq","title":"<code>set_freq(freq)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_freq(self, freq):\nself.hh_freq = freq\n</code></pre>"},{"location":"api/core/#pam.core.Household.set_loc","title":"<code>set_loc(loc)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_loc(self, loc):\nself._location.loc = loc\nfor _, person in self:\nperson.set_loc(loc)\n</code></pre>"},{"location":"api/core/#pam.core.Household.set_location","title":"<code>set_location(location)</code>","text":"<p>Set both hh and person home_location, but note that hhs and their persons do not share location object.</p> Source code in <code>pam/core.py</code> <pre><code>def set_location(self, location: Location):\n\"\"\"Set both hh and person home_location, but note that hhs and their persons do not share location object.\"\"\"\nself._location = location\nfor _, person in self:\nperson.set_location(location.copy())\n</code></pre>"},{"location":"api/core/#pam.core.Household.shared_activities","title":"<code>shared_activities()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def shared_activities(self):\nshared_activities = []\nhousehold_activities = []\nfor pid, person in self.people.items():\nfor activity_ in person.activities:\nif activity_.isin_exact(household_activities):\nshared_activities.append(activity_)\nif not activity_.isin_exact(household_activities):\nhousehold_activities.append(activity_)\nreturn shared_activities\n</code></pre>"},{"location":"api/core/#pam.core.Household.size","title":"<code>size()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def size(self):\nreturn len(self.people)\n</code></pre>"},{"location":"api/core/#pam.core.Household.vehicles","title":"<code>vehicles()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def vehicles(self):\nfor pid, p in self.people.items():\nfor mode, veh in p.vehicles.items():\nyield pid, mode, veh\n</code></pre>"},{"location":"api/core/#pam.core.Person","title":"<code>Person(pid, freq=None, attributes={}, vehicles=None, home_location=None, home_area=None, home_loc=None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def __init__(\nself,\npid,\nfreq=None,\nattributes: dict = {},\nvehicles: Optional[dict[str, Vehicle]] = None,\nhome_location: Optional[Location] = None,\nhome_area=None,\nhome_loc=None,\n):\nself.pid = pid\nself.person_freq = freq\nself.attributes = attributes\nif vehicles is not None:\nself.vehicles = vehicles\nelse:\nself.vehicles = {}\nif home_location is not None:\nself.home_location = home_location\nelse:\nself.home_location = Location()\nif home_area:\nself.home_location.area = home_area\nif home_loc:\nself.home_location.loc = home_loc\n# person and their plan share Location\nself.plan = activity.Plan(home_location=self.home_location)\nself.plans_non_selected = []\n</code></pre>"},{"location":"api/core/#pam.core.Person.activities","title":"<code>activities</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.acts","title":"<code>acts</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.attributes","title":"<code>attributes = attributes</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.av_activity_freq","title":"<code>av_activity_freq</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.av_trip_freq","title":"<code>av_trip_freq</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.closed_plan","title":"<code>closed_plan: bool</code>  <code>property</code>","text":"<p>Check if plan starts and stops at the same facility (based on activity and location).</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"api/core/#pam.core.Person.first_activity","title":"<code>first_activity</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.freq","title":"<code>freq</code>  <code>property</code>","text":"<p>Return person_freq, else if None, return the average frequency of legs.</p> <p>TODO consider passing parent hh on creation so that we can retrieve hh freq if required.</p>"},{"location":"api/core/#pam.core.Person.has_valid_plan","title":"<code>has_valid_plan: bool</code>  <code>property</code>","text":"<p>Check sequence of Activities and Legs.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p>"},{"location":"api/core/#pam.core.Person.home","title":"<code>home</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.home_based","title":"<code>home_based</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.home_location","title":"<code>home_location = home_location</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.last_activity","title":"<code>last_activity</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.last_component","title":"<code>last_component</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.last_leg","title":"<code>last_leg</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.legs","title":"<code>legs</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.length","title":"<code>length</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.num_activities","title":"<code>num_activities</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.num_legs","title":"<code>num_legs</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.person_freq","title":"<code>person_freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.pid","title":"<code>pid = pid</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.plan","title":"<code>plan = activity.Plan(home_location=self.home_location)</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.plans_non_selected","title":"<code>plans_non_selected = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.subpopulation","title":"<code>subpopulation</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.vehicles","title":"<code>vehicles = vehicles</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.add","title":"<code>add(p)</code>","text":"<p>Safely add a new component to the plan.</p> PARAMETER  DESCRIPTION <code>p</code> <p>component to add.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>pam/core.py</code> <pre><code>def add(self, p: Any) -&gt; None:\n\"\"\"Safely add a new component to the plan.\n    Args:\n        p (Any): component to add.\n    \"\"\"\nself.plan.add(p)\n</code></pre>"},{"location":"api/core/#pam.core.Person.assign_vehicles_from_manager","title":"<code>assign_vehicles_from_manager(manager)</code>","text":"<p>Assign vehicles to person from vehicles manager. This method removes the vehicles attribute from the agent and uses it to populate Person.vehicles variable. This method is used by read.matsim to transfer regular vehicles and electric vehicles from MATSim xml formats to each Person.</p> PARAMETER  DESCRIPTION <code>manager</code> <p>Population vehicles.</p> <p> TYPE: <code>VehicleManager</code> </p> Source code in <code>pam/core.py</code> <pre><code>def assign_vehicles_from_manager(self, manager: VehicleManager):\n\"\"\"Assign vehicles to person from vehicles manager.\n    This method removes the vehicles attribute from the agent and uses it to populate\n    Person.vehicles variable. This method is used by read.matsim to transfer regular vehicles\n    and electric vehicles from MATSim xml formats to each Person.\n    Args:\n        manager (VehicleManager): Population vehicles.\n    \"\"\"\nself.vehicles = {\nmode: manager.pop(vid) for mode, vid in self.attributes.pop(\"vehicles\", {}).items()\n}\n</code></pre>"},{"location":"api/core/#pam.core.Person.build_travel_geodataframe","title":"<code>build_travel_geodataframe(**kwargs)</code>","text":"<p>Builds geopandas.GeoDataFrame for Person's Legs.</p> KEYWORD ARGUMENTS FOR PLOT.BUILD_PERSON_TRAVEL_GEODATAFRAME, DESCRIPTION <code>from_epsg</code> <p>coordinate system the plans are currently in</p> <p> TYPE: <code>str</code> </p> <code>to_epsg</code> <p>coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>geopandas.GeoDataFrame: columns for person id (pid).</p> Source code in <code>pam/core.py</code> <pre><code>def build_travel_geodataframe(self, **kwargs) -&gt; gpd.GeoDataFrame:\n\"\"\"Builds geopandas.GeoDataFrame for Person's Legs.\n    Keyword Args: Keyword arguments for plot.build_person_travel_geodataframe,\n        from_epsg (str): coordinate system the plans are currently in\n        to_epsg (str): coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.\n    Returns:\n        geopandas.GeoDataFrame: columns for person id (pid).\n    \"\"\"\nreturn plot.build_person_travel_geodataframe(self, **kwargs)\n</code></pre>"},{"location":"api/core/#pam.core.Person.clear_plan","title":"<code>clear_plan()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def clear_plan(self):\nself.plan.clear()\n</code></pre>"},{"location":"api/core/#pam.core.Person.evs","title":"<code>evs()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def evs(self):\nfor mode, veh in self.vehicles.items():\nif isinstance(veh, ElectricVehicle):\nyield mode, veh\n</code></pre>"},{"location":"api/core/#pam.core.Person.fill_plan","title":"<code>fill_plan(p_idx, s_idx, default='home')</code>","text":"<p>Fill a plan after Activity has been removed.</p> PARAMETER  DESCRIPTION <code>p_idx</code> <p>location of previous Activity</p> <p> TYPE: <code>Any</code> </p> <code>s_idx</code> <p>location of subsequent Activity</p> <p> TYPE: <code>Any</code> </p> <code>default</code> <p>Defaults to \"home\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'home'</code> </p> <p>Returns:     bool:</p> Source code in <code>pam/core.py</code> <pre><code>def fill_plan(self, p_idx: Any, s_idx: Any, default: str = \"home\") -&gt; bool:\n\"\"\"Fill a plan after Activity has been removed.\n    Args:\n        p_idx (Any): location of previous Activity\n        s_idx (Any): location of subsequent Activity\n        default (str, optional): Defaults to \"home\"\n    Returns:\n        bool:\n    \"\"\"\nreturn self.plan.fill_plan(p_idx, s_idx, default=default)\n</code></pre>"},{"location":"api/core/#pam.core.Person.finalise","title":"<code>finalise()</code>","text":"<p>Add activity end times based on start time of next activity.</p> Source code in <code>pam/core.py</code> <pre><code>def finalise(self):\n\"\"\"Add activity end times based on start time of next activity.\"\"\"\nself.plan.finalise_activity_end_times()\n</code></pre>"},{"location":"api/core/#pam.core.Person.fix_plan","title":"<code>fix_plan(crop=True, times=True, locations=True)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def fix_plan(self, crop=True, times=True, locations=True):\nif crop:\nself.plan.crop()\nif times:\nself.plan.fix_time_consistency()\nif locations:\nself.plan.fix_location_consistency()\n</code></pre>"},{"location":"api/core/#pam.core.Person.iter_vehicles","title":"<code>iter_vehicles()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def iter_vehicles(self):\nfor mode, veh in self.vehicles.items():\nyield mode, veh\n</code></pre>"},{"location":"api/core/#pam.core.Person.move_activity","title":"<code>move_activity(seq, default='home', new_mode='walk')</code>","text":"<p>Move an activity from plan at given seq to default location.</p> PARAMETER  DESCRIPTION <code>seq</code> <p> TYPE: <code>Any</code> </p> <code>default</code> <p>'home' or pam.activity.Location. Defaults to \"home\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'home'</code> </p> <code>new_mode</code> <p>access/egress journey switching to this mode. Ie 'walk'. Defaults to \"walk\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'walk'</code> </p> Source code in <code>pam/core.py</code> <pre><code>def move_activity(self, seq: Any, default: str = \"home\", new_mode: str = \"walk\") -&gt; None:\n\"\"\"Move an activity from plan at given seq to default location.\n    Args:\n        seq (Any):\n        default (str, optional):\n            'home' or pam.activity.Location.\n            Defaults to \"home\".\n        new_mode (str, optional):\n            access/egress journey switching to this mode. Ie 'walk'.\n            Defaults to \"walk\".\n    \"\"\"\nreturn self.plan.move_activity(seq, default, new_mode)\n</code></pre>"},{"location":"api/core/#pam.core.Person.pickle","title":"<code>pickle(path)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def pickle(self, path):\nwith open(path, \"wb\") as file:\npickle.dump(self, file)\n</code></pre>"},{"location":"api/core/#pam.core.Person.plot","title":"<code>plot(**kwargs)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def plot(self, **kwargs):\nplot.plot_person(self, **kwargs)\n</code></pre>"},{"location":"api/core/#pam.core.Person.plot_travel_plotly","title":"<code>plot_travel_plotly(epsg='epsg:4326', **kwargs)</code>","text":"<p>Uses plotly's Scattermapbox to plot persons' travel.</p> PARAMETER  DESCRIPTION <code>epsg</code> <p>coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'epsg:4326'</code> </p> <p>Keyword Args: Keyword arguments for plot.plot_travel_plans     gdf (geopandas.GeoDataFrame): generated by build_person_travel_geodataframe     groupby (list): optional argument for splitting traces in the plot     colour_by (str): argument for specifying what the colour should correspond to in the plot, travel mode by default     cmap (dict): optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent     mapbox_access_token (str): required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/)</p> RETURNS DESCRIPTION <code>Figure</code> <p>go.Figure: Plotly figure object</p> Source code in <code>pam/core.py</code> <pre><code>def plot_travel_plotly(self, epsg: str = \"epsg:4326\", **kwargs) -&gt; go.Figure:\n\"\"\"Uses plotly's Scattermapbox to plot persons' travel.\n    Args:\n        epsg (str, optional): coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".\n    Keyword Args: Keyword arguments for plot.plot_travel_plans\n        gdf (geopandas.GeoDataFrame): generated by build_person_travel_geodataframe\n        groupby (list): optional argument for splitting traces in the plot\n        colour_by (str): argument for specifying what the colour should correspond to in the plot, travel mode by default\n        cmap (dict): optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent\n        mapbox_access_token (str): required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/)\n    Returns:\n        go.Figure: Plotly figure object\n    \"\"\"\nreturn plot.plot_travel_plans(\ngdf=self.build_travel_geodataframe(from_epsg=epsg, to_epsg=\"epsg:4326\"), **kwargs\n)\n</code></pre>"},{"location":"api/core/#pam.core.Person.print","title":"<code>print()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def print(self):\nprint(self)\nprint(self.attributes)\nself.plan.print()\n</code></pre>"},{"location":"api/core/#pam.core.Person.reindex","title":"<code>reindex(prefix)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def reindex(self, prefix: str):\nself.pid = prefix + self.pid\n</code></pre>"},{"location":"api/core/#pam.core.Person.remove_activity","title":"<code>remove_activity(seq)</code>","text":"<p>Remove an activity from plan at given seq. Check for wrapped removal.</p> PARAMETER  DESCRIPTION <code>seq</code> <p> TYPE: <code>int</code> </p> <p>Returns:     tuple: (adjusted) idx of previous and subsequent activities as a tuple</p> Source code in <code>pam/core.py</code> <pre><code>def remove_activity(self, seq: int) -&gt; tuple:\n\"\"\"Remove an activity from plan at given seq. Check for wrapped removal.\n    Args:\n        seq (int):\n    Returns:\n        tuple: (adjusted) idx of previous and subsequent activities as a tuple\n    \"\"\"\nreturn self.plan.remove_activity(seq)\n</code></pre>"},{"location":"api/core/#pam.core.Person.set_area","title":"<code>set_area(area)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_area(self, area):\nself.home_location.area = area\nself.plan.home_location.area = area\n</code></pre>"},{"location":"api/core/#pam.core.Person.set_freq","title":"<code>set_freq(freq)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_freq(self, freq):\nself.person_freq = freq\n</code></pre>"},{"location":"api/core/#pam.core.Person.set_loc","title":"<code>set_loc(loc)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_loc(self, loc):\nself.home_location.loc = loc\nself.plan.home_location.loc = loc\n</code></pre>"},{"location":"api/core/#pam.core.Person.set_location","title":"<code>set_location(location)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_location(self, location: Location):\nself.home_location = location\nself.plan.home_location = location\n</code></pre>"},{"location":"api/core/#pam.core.Person.stay_at_home","title":"<code>stay_at_home()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def stay_at_home(self):\nself.plan.stay_at_home()\n</code></pre>"},{"location":"api/core/#pam.core.Person.validate","title":"<code>validate()</code>","text":"<p>Validate plan.</p> Source code in <code>pam/core.py</code> <pre><code>def validate(self):\n\"\"\"Validate plan.\"\"\"\nself.plan.validate()\nreturn True\n</code></pre>"},{"location":"api/core/#pam.core.Person.validate_locations","title":"<code>validate_locations()</code>","text":"<p>Check sequence of Activity and Leg locations.</p> RETURNS DESCRIPTION <code>True</code> <p> TYPE: <code>True</code> </p> Source code in <code>pam/core.py</code> <pre><code>def validate_locations(self) -&gt; True:\n\"\"\"Check sequence of Activity and Leg locations.\n    Returns:\n        True:\n    \"\"\"\nif not self.plan.valid_locations:\nraise PAMValidationLocationsError(f\"Person {self.pid} has invalid plan locations\")\nreturn True\n</code></pre>"},{"location":"api/core/#pam.core.Person.validate_sequence","title":"<code>validate_sequence()</code>","text":"<p>Check sequence of Activities and Legs.</p> RETURNS DESCRIPTION <code>True</code> <p> TYPE: <code>True</code> </p> Source code in <code>pam/core.py</code> <pre><code>def validate_sequence(self) -&gt; True:\n\"\"\"Check sequence of Activities and Legs.\n    Returns:\n        True:\n    \"\"\"\nif not self.plan.valid_sequence:\nraise PAMSequenceValidationError(f\"Person {self.pid} has invalid plan sequence\")\nreturn True\n</code></pre>"},{"location":"api/core/#pam.core.Person.validate_times","title":"<code>validate_times()</code>","text":"<p>Check sequence of Activity and Leg times.</p> RETURNS DESCRIPTION <code>True</code> <p> TYPE: <code>True</code> </p> Source code in <code>pam/core.py</code> <pre><code>def validate_times(self) -&gt; True:\n\"\"\"Check sequence of Activity and Leg times.\n    Returns:\n        True:\n    \"\"\"\nif not self.plan.valid_time_sequence:\nraise PAMInvalidTimeSequenceError(f\"Person {self.pid} has invalid plan times\")\nreturn True\n</code></pre>"},{"location":"api/core/#pam.core.Population","title":"<code>Population(name=None)</code>","text":"<p>Class to define a population.</p> PARAMETER  DESCRIPTION <code>name</code> <p>Name of population. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/core.py</code> <pre><code>def __init__(self, name: str = None) -&gt; None:\n\"\"\"Class to define a population.\n    Args:\n        name (str, optional): Name of population. Defaults to None.\n    \"\"\"\nself.name = name\nself.logger = logging.getLogger(__name__)\nself.households = {}\nself._vehicles_manager = VehicleManager()\n</code></pre>"},{"location":"api/core/#pam.core.Population.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.attributes","title":"<code>attributes: dict</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.freq","title":"<code>freq</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.has_electric_vehicles","title":"<code>has_electric_vehicles</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.has_vehicles","title":"<code>has_vehicles: bool</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.households","title":"<code>households = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Population.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Population.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Population.num_households","title":"<code>num_households</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.population","title":"<code>population</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.size","title":"<code>size</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.stats","title":"<code>stats</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.subpopulations","title":"<code>subpopulations</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.vehicle_types","title":"<code>vehicle_types: dict[str, VehicleType]</code>  <code>property</code>","text":"RETURNS DESCRIPTION <code>dict[str, VehicleType]</code> <p>dist[str, VehicleType]: Mapping of vehicle type id to vehicle type data.</p>"},{"location":"api/core/#pam.core.Population.add","title":"<code>add(target)</code>","text":"<p>Add houeshold/person, or a list of households/persons to the population.</p> PARAMETER  DESCRIPTION <code>target</code> <p>Can be any arbitrary nesting of lists, as long as the deepest nesting includes only Houeshold and Person objects</p> <p> TYPE: <code>list[Union[Household, Person, list]]</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Only Household and Person objects allowed</p> Source code in <code>pam/core.py</code> <pre><code>def add(self, target: list[Union[Household, Person, list]]) -&gt; None:\n\"\"\"Add houeshold/person, or a list of households/persons to the population.\n    Args:\n        target (list[Union[Household, Person, list]]):\n            Can be any arbitrary nesting of lists, as long as the deepest nesting includes only Houeshold and Person objects\n    Raises:\n        UserWarning: Only Household and Person objects allowed\n    \"\"\"\nif isinstance(target, list):\nfor hh in target:\nself.add(hh)\nelif isinstance(target, Household):\nself.households[target.hid] = target\nelif isinstance(target, Person):\nself.logger.debug(\n(\n\"Directly adding a Person to a Population requires a Household.\",\nf\"Auto creating a household {target.pid} for person {target.pid}, check this is intended.\",\n)\n)\nself.add(Household(hid=target.pid))\nself.households[target.pid].add(target)\nelse:\nraise UserWarning(\nf\"Expected instance of Household, list or Person, not: {type(target)}\"\n)\n</code></pre>"},{"location":"api/core/#pam.core.Population.add_fields","title":"<code>add_fields(df)</code>  <code>staticmethod</code>","text":"<p>Add extra fields used for benchmarking in place.</p> PARAMETER  DESCRIPTION <code>df</code> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>pam/core.py</code> <pre><code>@staticmethod\ndef add_fields(df: pd.DataFrame) -&gt; None:\n\"\"\"Add extra fields used for benchmarking in place.\n    Args:\n        df (pd.DataFrame):\n    \"\"\"\ndf[\"personhrs\"] = df[\"freq\"] * df[\"duration\"] / 60\ndf[\"departure_hour\"] = df.tst.apply(lambda x: x.hour)\ndf[\"arrival_hour\"] = df.tet.apply(lambda x: x.hour)\ndf[\"euclidean_distance_category\"] = pd.cut(\ndf.euclidean_distance,\nbins=[0, 1, 5, 10, 25, 50, 100, 200, 999999],\nlabels=[\n\"0 to 1 km\",\n\"1 to 5 km\",\n\"5 to 10 km\",\n\"10 to 25 km\",\n\"25 to 50 km\",\n\"50 to 100 km\",\n\"100 to 200 km\",\n\"200+ km\",\n],\n)\ndf[\"duration_category\"] = pd.cut(\ndf.duration,\nbins=[0, 5, 10, 15, 30, 45, 60, 90, 120, 999999],\nlabels=[\n\"0 to 5 min\",\n\"5 to 10 min\",\n\"10 to 15 min\",\n\"15 to 30 min\",\n\"30 to 45 min\",\n\"45 to 60 min\",\n\"60 to 90 min\",\n\"90 to 120 min\",\n\"120+ min\",\n],\n)\n</code></pre>"},{"location":"api/core/#pam.core.Population.add_veh","title":"<code>add_veh(hid, pid, mode, vehicle)</code>","text":"<p>Add vehicle of given mode to person, based on hid and pid. Method checks that id is unique and vehicle type is available, otherwise raises UserWarning.</p> PARAMETER  DESCRIPTION <code>hid</code> <p>Household id</p> <p> TYPE: <code>str</code> </p> <code>pid</code> <p>Person id</p> <p> TYPE: <code>str</code> </p> <code>mode</code> <p>Mode of vehicle</p> <p> TYPE: <code>str</code> </p> <code>vehicle</code> <p>Vehicle to add</p> <p> TYPE: <code>Vehicle</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Duplicate id.</p> <code>UserWarning</code> <p>Unknown vehicle type.</p> Source code in <code>pam/core.py</code> <pre><code>def add_veh(self, hid: str, pid: str, mode: str, vehicle: Vehicle):\n\"\"\"Add vehicle of given mode to person, based on hid and pid. Method checks that id is unique and vehicle type is available, otherwise raises UserWarning.\n    Args:\n        hid (str): Household id\n        pid (str): Person id\n        mode (str): Mode of vehicle\n        vehicle (Vehicle): Vehicle to add\n    Raises:\n        UserWarning: Duplicate id.\n        UserWarning: Unknown vehicle type.\n    \"\"\"\nif vehicle.type_id not in self._vehicles_manager._veh_types:\nraise UserWarning(f\"Unable to add vehicle with unknown type: '{vehicle.type_id}'.\")\nperson_vehicles = self.households[hid][pid].vehicles\nif not (\nperson_vehicles.get(mode) and person_vehicles[mode].vid == vehicle.vid\n):  # assume not replacing existing\n# so check for duplicates\nif vehicle.vid in set([v.vid for _, _, _, v in self.vehicles()]):\nraise UserWarning(\nf\"Unable to add vehicle with duplicate vehicle id (vid): {vehicle.vid}\"\n)\nperson_vehicles[mode] = vehicle\n</code></pre>"},{"location":"api/core/#pam.core.Population.add_veh_type","title":"<code>add_veh_type(vehicle_type)</code>","text":"<p>Add a vehicle type to the population vehicles manager.</p> PARAMETER  DESCRIPTION <code>vehicle_type</code> <p>Vehicle type to be added.</p> <p> TYPE: <code>VehicleType</code> </p> Source code in <code>pam/core.py</code> <pre><code>def add_veh_type(self, vehicle_type: VehicleType):\n\"\"\"Add a vehicle type to the population vehicles manager.\n    Args:\n        vehicle_type (VehicleType): Vehicle type to be added.\n    \"\"\"\nself._vehicles_manager.add_type(vehicle_type)\n</code></pre>"},{"location":"api/core/#pam.core.Population.build_travel_geodataframe","title":"<code>build_travel_geodataframe(**kwargs)</code>","text":"<p>Builds geopandas.GeoDataFrame for travel Legs found for all persons in the Population.</p> KEYWORD ARGUMENTS FOR PLOT.BUILD_PERSON_TRAVEL_GEODATAFRAME. DESCRIPTION <code>from_epsg</code> <p>coordinate system the plans are currently in</p> <p> TYPE: <code>str</code> </p> <code>to_epsg</code> <p>coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid)</p> Source code in <code>pam/core.py</code> <pre><code>def build_travel_geodataframe(self, **kwargs) -&gt; gpd.GeoDataFrame:\n\"\"\"Builds geopandas.GeoDataFrame for travel Legs found for all persons in the Population.\n    Keyword Args: Keyword arguments for plot.build_person_travel_geodataframe.\n        from_epsg (str): coordinate system the plans are currently in\n        to_epsg (str): coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.\n    Returns:\n        geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid)\n    \"\"\"\ngdf = None\nfor hid, household in self.households.items():\n_gdf = household.build_travel_geodataframe(**kwargs)\nif gdf is None:\ngdf = _gdf\nelse:\ngdf = pd.concat([gdf, _gdf])\ngdf = gdf.sort_values([\"hid\", \"pid\", \"seq\"]).reset_index(drop=True)\nreturn gdf\n</code></pre>"},{"location":"api/core/#pam.core.Population.check_vehicles","title":"<code>check_vehicles()</code>","text":"<p>Checks that all person vehicles have types defined by vehicles manager.</p> RAISES DESCRIPTION <code>PAMVehicleIdError</code> <p>Undefined vehicle type in population.</p> RETURNS DESCRIPTION <code>bool</code> <p>Return true if all vehicle types are defined.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/core.py</code> <pre><code>def check_vehicles(self) -&gt; bool:\n\"\"\"Checks that all person vehicles have types defined by vehicles manager.\n    Raises:\n        PAMVehicleIdError: Undefined vehicle type in population.\n    Returns:\n        bool: Return true if all vehicle types are defined.\n    \"\"\"\nveh_types = set(self._vehicles_manager._veh_types.keys())\nfor _, _, _, veh in self.vehicles():\nif veh.type_id not in veh_types:\nraise PAMVehicleIdError(\nf\"Failed to find veh type of id '{veh.type_id}', specified for veh id '{veh.vid}'.\"\n)\nreturn True\n</code></pre>"},{"location":"api/core/#pam.core.Population.combine","title":"<code>combine(other, prefix='')</code>","text":"<p>Safe addition with assignment by adding a prefix to create unique pids and hids.</p> Source code in <code>pam/core.py</code> <pre><code>def combine(self, other, prefix=\"\"):\n\"\"\"Safe addition with assignment by adding a prefix to create unique pids and hids.\"\"\"\nprefix = str(prefix)\nif isinstance(other, Population):\nother.reindex(prefix)\nself += other\nreturn None\nif isinstance(other, Household):\nother.reindex(prefix)\nself += other\nreturn None\nif isinstance(other, Person):\nhh = Household(other.pid)  # we create a new hh for single person\nhh.add(other)\nhh.reindex(prefix)\nself += hh\nreturn None\nraise TypeError(\nf\"Object for addition must be a Population Household or Person object, not {type(other)}\"\n)\n</code></pre>"},{"location":"api/core/#pam.core.Population.evs","title":"<code>evs()</code>","text":"<p>Return iterator of all electric vehicles in population, prepended with household id, person id and mode.</p> YIELDS DESCRIPTION <p>Iterator[str, str, str, ElectricVehicle]: Iterator of (hid, pid, mode, vehicle)</p> Source code in <code>pam/core.py</code> <pre><code>def evs(self):\n\"\"\"Return iterator of all electric vehicles in population, prepended with household id,\n    person id and mode.\n    Yields:\n        Iterator[str, str, str, ElectricVehicle]: Iterator of (hid, pid, mode, vehicle)\n    \"\"\"\nfor hid, pid, p in self.people():\nfor mode, veh in p.evs():\nyield hid, pid, mode, veh\n</code></pre>"},{"location":"api/core/#pam.core.Population.fix_plans","title":"<code>fix_plans(crop=True, times=True, locations=True)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def fix_plans(self, crop: bool = True, times=True, locations=True):\nfor _, _, person in self.people():\nif crop:\nperson.plan.crop()\nif times:\nperson.plan.fix_time_consistency()\nif locations:\nperson.plan.fix_location_consistency()\n</code></pre>"},{"location":"api/core/#pam.core.Population.get","title":"<code>get(hid, default=None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def get(self, hid, default=None):\nreturn self.households.get(hid, default)\n</code></pre>"},{"location":"api/core/#pam.core.Population.legs_df","title":"<code>legs_df()</code>","text":"<p>Extract tabular record of population legs.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: record of legs</p> Source code in <code>pam/core.py</code> <pre><code>def legs_df(self) -&gt; pd.DataFrame:\n\"\"\"Extract tabular record of population legs.\n    Returns:\n        pd.DataFrame: record of legs\n    \"\"\"\ndf = []\nfor hid, pid, person in self.people():\nfor seq, leg in enumerate(person.legs):\nrecord = {\n\"pid\": pid,\n\"hid\": hid,\n\"hzone\": person.home,\n\"ozone\": leg.start_location.area,\n\"dzone\": leg.end_location.area,\n\"oloc\": leg.start_location,\n\"dloc\": leg.end_location,\n\"seq\": seq,\n\"purp\": leg.purp,\n\"mode\": leg.mode,\n\"tst\": leg.start_time.time(),\n\"tet\": leg.end_time.time(),\n# duration in minutes\n\"duration\": leg.duration / pd.Timedelta(minutes=1),\n\"euclidean_distance\": leg.euclidean_distance,\n\"freq\": person.freq,\n}\n# add person attributes\nrecord = {**record, **dict(person.attributes)}\ndf.append(record)\ndf = pd.DataFrame(df)\nself.add_fields(df)\nreturn df\n</code></pre>"},{"location":"api/core/#pam.core.Population.people","title":"<code>people()</code>","text":"<p>Iterator for people in poulation, returns hid, pid and Person.</p> Source code in <code>pam/core.py</code> <pre><code>def people(self):\n\"\"\"Iterator for people in poulation, returns hid, pid and Person.\"\"\"\nfor hid, household in self.households.items():\nfor pid, person in household.people.items():\nyield hid, pid, person\n</code></pre>"},{"location":"api/core/#pam.core.Population.pickle","title":"<code>pickle(path)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def pickle(self, path: str):\nwith open(path, \"wb\") as file:\npickle.dump(self, file)\n</code></pre>"},{"location":"api/core/#pam.core.Population.plans","title":"<code>plans()</code>","text":"<p>Iterator for plans in poulation.</p> Source code in <code>pam/core.py</code> <pre><code>def plans(self) -&gt; Iterator[activity.Plan]:\n\"\"\"Iterator for plans in poulation.\"\"\"\nfor hid, household in self.households.items():\nfor pid, person in household.people.items():\nyield person.plan\n</code></pre>"},{"location":"api/core/#pam.core.Population.plot_travel_plotly","title":"<code>plot_travel_plotly(epsg='epsg:4326', **kwargs)</code>","text":"<p>Plot travel plans.</p> PARAMETER  DESCRIPTION <code>epsg</code> <p>coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'epsg:4326'</code> </p> <p>Keyword Args: Keyword arguments for plot.plot_travel_plans     gdf (geopandas.GeoDataFrame): geopandas.GeoDataFrame generated by build_person_travel_geodataframe     groupby (list): optional argument for splitting traces in the plot     colour_by (str): argument for specifying what the colour should correspond to in the plot, travel mode by default     cmap (dict): optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent     mapbox_access_token (str): required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).</p> RETURNS DESCRIPTION <code>Figure</code> <p>go.Figure: Plotly figure object.</p> Source code in <code>pam/core.py</code> <pre><code>def plot_travel_plotly(self, epsg: str = \"epsg:4326\", **kwargs) -&gt; go.Figure:\n\"\"\"Plot travel plans.\n    Args:\n        epsg (str, optional): coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".\n    Keyword Args: Keyword arguments for plot.plot_travel_plans\n        gdf (geopandas.GeoDataFrame): geopandas.GeoDataFrame generated by build_person_travel_geodataframe\n        groupby (list): optional argument for splitting traces in the plot\n        colour_by (str): argument for specifying what the colour should correspond to in the plot, travel mode by default\n        cmap (dict): optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent\n        mapbox_access_token (str): required to generate the plot (see https://docs.mapbox.com/help/how-mapbox-works/access-tokens/).\n    Returns:\n        go.Figure: Plotly figure object.\n    \"\"\"\nreturn plot.plot_travel_plans(\ngdf=self.build_travel_geodataframe(from_epsg=epsg, to_epsg=\"epsg:4326\"), **kwargs\n)\n</code></pre>"},{"location":"api/core/#pam.core.Population.print","title":"<code>print()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def print(self):\nprint(self)\nfor _, household in self:\nhousehold.print()\n</code></pre>"},{"location":"api/core/#pam.core.Population.random_household","title":"<code>random_household()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def random_household(self):\nreturn self.households[random.choice(list(self.households))]\n</code></pre>"},{"location":"api/core/#pam.core.Population.random_person","title":"<code>random_person()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def random_person(self):\nhh = self.random_household()\nreturn hh.random_person()\n</code></pre>"},{"location":"api/core/#pam.core.Population.rebuild_vehicles_manager","title":"<code>rebuild_vehicles_manager()</code>","text":"<p>(Re)build vehicle population from persons. This method adds all Population vehicles from each Person and adds them to the Population.vehicles_manager. This method is used by write.matsim to write regular vehicles and electric vehicles to MATSim xml formats.</p> Source code in <code>pam/core.py</code> <pre><code>def rebuild_vehicles_manager(self):\n\"\"\"\n    (Re)build vehicle population from persons. This method adds all Population vehicles from each\n    Person and adds them to the Population.vehicles_manager. This method is used by write.matsim\n    to write regular vehicles and electric vehicles to MATSim xml formats.\n    \"\"\"\nself._vehicles_manager.clear_vehs()\nself.update_vehicles_manager()\n</code></pre>"},{"location":"api/core/#pam.core.Population.reindex","title":"<code>reindex(prefix)</code>","text":"<p>Safely reindex all household and person identifiers in population using a prefix.</p> Source code in <code>pam/core.py</code> <pre><code>def reindex(self, prefix: str):\n\"\"\"Safely reindex all household and person identifiers in population using a prefix.\"\"\"\nfor hid in list(self.households):\nhh = self.households[hid]\nnew_hid = prefix + str(hid)\nif new_hid in self.households:\nraise KeyError(f\"Duplicate household identifier (hid): {new_hid}\")\nhh.reindex(prefix)\nself.households[new_hid] = hh\ndel self.households[hid]\n</code></pre>"},{"location":"api/core/#pam.core.Population.remove_vehicle_type","title":"<code>remove_vehicle_type(tid)</code>","text":"<p>Remove vehicle type from vehicles manager.</p> PARAMETER  DESCRIPTION <code>tid</code> <p>Vehicle type id.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/core.py</code> <pre><code>def remove_vehicle_type(self, tid: str):\n\"\"\"Remove vehicle type from vehicles manager.\n    Args:\n        tid (str): Vehicle type id.\n    \"\"\"\nself._vehicles_manager.remove_type(tid)\n</code></pre>"},{"location":"api/core/#pam.core.Population.sample_locs","title":"<code>sample_locs(sampler, long_term_activities=None, joint_trips_prefix='escort_', location_override=True)</code>","text":"<p>WIP Sample household plan locs using a sampler.</p> <p>Sampler uses activity types and areas to sample locations. Note that households share locations for activities of the same type within the same area. Trivially this includes household location. But also, for example, shopping activities if they are in the same area.</p> <p>We treat escort activities (ie those prefixed by \"escort_\") as the escorted activity. For example, the sampler treats \"escort_education\" and \"education\" equally. Note that this shared activity sampling of location models shared facilities, but does not explicitly infer or model shared transport. For example there is no consideration of if trips to shared locations take place at the same time or from the same locations.</p> <p>After sampling Location objects are shared between shared activity locations and corresponding trips start and end locations. These objects are mutable, so care must be taken if making changes as these will impact all other persons shared locations in the household. Often this behaviour might be expected. For example if we change the location of the household home activity, all persons and home activities are impacted.</p> PARAMETER  DESCRIPTION <code>long_term_activities</code> <p>a list of activities for which location is only assigned once (per zone). Defaults to None</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>joint_trips_prefix</code> <p>a purpose prefix used to identify escort/joint trips. Defaults to \"escort_\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'escort_'</code> </p> <code>location_override</code> <p>if False, the facility sampler will retain any already-existing locations in the population.. Defaults to True</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>pam/core.py</code> <pre><code>def sample_locs(\nself,\nsampler,\nlong_term_activities: list = None,\njoint_trips_prefix: str = \"escort_\",\nlocation_override: bool = True,\n):\n\"\"\"WIP Sample household plan locs using a sampler.\n    Sampler uses activity types and areas to sample locations. Note that households share\n    locations for activities of the same type within the same area. Trivially this includes\n    household location. But also, for example, shopping activities if they are in the same area.\n    We treat escort activities (ie those prefixed by \"escort_\") as the escorted activity. For\n    example, the sampler treats \"escort_education\" and \"education\" equally. Note that this shared\n    activity sampling of location models shared facilities, but does not explicitly infer or\n    model shared transport. For example there is no consideration of if trips to shared locations\n    take place at the same time or from the same locations.\n    After sampling Location objects are shared between shared activity locations and corresponding\n    trips start and end locations. These objects are mutable, so care must be taken if making changes\n    as these will impact all other persons shared locations in the household. Often this behaviour\n    might be expected. For example if we change the location of the household home activity, all\n    persons and home activities are impacted.\n    Args:\n        long_term_activities (list, optional): a list of activities for which location is only assigned once (per zone). Defaults to None\n        joint_trips_prefix (str, optional): a purpose prefix used to identify escort/joint trips. Defaults to \"escort_\"\n        location_override (bool, optional): if False, the facility sampler will retain any already-existing locations in the population.. Defaults to True\n    \"\"\"\nif long_term_activities is None:\nlong_term_activities = variables.LONG_TERM_ACTIVITIES\nfor _, household in self.households.items():\nhome_loc = activity.Location(\narea=household.location.area, loc=sampler.sample(household.location.area, \"home\")\n)\nunique_locations = {(household.location.area, \"home\"): home_loc}\nfor __, person in household.people.items():\nfor act in person.activities:\n# remove escort prefix from activity types.\nif act.act[: len(joint_trips_prefix)] == joint_trips_prefix:\ntarget_act = act.act[(len(joint_trips_prefix)) :]\nelse:\ntarget_act = act.act\n# assign any unique locations\nif (act.location.area, target_act) in unique_locations:\nlocation = unique_locations[(act.location.area, target_act)]\nact.location = location\n# sample facility\nelif location_override or act.location.loc is None:\nlocation = activity.Location(\narea=act.location.area,\nloc=sampler.sample(act.location.area, target_act),\n)\nif target_act in long_term_activities:\n# one location per zone for long-term choices (only)\n# short-term activities, such as shopping can visit multiple locations in the same zone\nunique_locations[(act.location.area, target_act)] = location\nact.location = location\n# complete the alotting activity locations to the trip starts and ends.\nfor idx in range(person.plan.length):\ncomponent = person.plan[idx]\nif isinstance(component, activity.Leg):\ncomponent.start_location = person.plan[idx - 1].location\ncomponent.end_location = person.plan[idx + 1].location\n</code></pre>"},{"location":"api/core/#pam.core.Population.sample_locs_complex","title":"<code>sample_locs_complex(sampler, long_term_activities=None, joint_trips_prefix='escort_')</code>","text":"<p>Extends sample_locs method to enable more complex and rules-based sampling.</p> <p>Keeps track of the last location and transport mode, to apply distance- and mode-based sampling rules. It is generally slower than sample_locs, as it loops through both activities and legs.</p> PARAMETER  DESCRIPTION <code>long_term_activities</code> <p>a list of activities for which location is only assigned once (per zone). Defaults to None.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>joint_trips_prefix</code> <p>a purpose prefix used to identify escort/joint trips. Defaults to \"escort_\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'escort_'</code> </p> Source code in <code>pam/core.py</code> <pre><code>def sample_locs_complex(\nself, sampler, long_term_activities: list = None, joint_trips_prefix: str = \"escort_\"\n):\n\"\"\"Extends sample_locs method to enable more complex and rules-based sampling.\n    Keeps track of the last location and transport mode, to apply distance- and mode-based sampling rules.\n    It is generally slower than sample_locs, as it loops through both activities and legs.\n    Args:\n        long_term_activities (list, optional):\n            a list of activities for which location is only assigned once (per zone).\n            Defaults to None.\n        joint_trips_prefix (str, optional):\n            a purpose prefix used to identify escort/joint trips.\n            Defaults to \"escort_\".\n    \"\"\"\nif long_term_activities is None:\nlong_term_activities = variables.LONG_TERM_ACTIVITIES\nfor _, household in self.households.items():\nhome_loc = activity.Location(\narea=household.location.area,\nloc=sampler.sample(\nhousehold.location.area,\n\"home\",\nmode=None,\nprevious_duration=None,\nprevious_loc=None,\n),\n)\nmode = None\nunique_locations = {(household.location.area, \"home\"): home_loc}\nfor _, person in household.people.items():\nmode = None\nprevious_duration = None\nprevious_loc = None\nfor idx, component in enumerate(person.plan):\n# loop through all plan elements\nif isinstance(component, activity.Leg):\nmode = component.mode  # keep track of last mode\nprevious_duration = component.duration\nelif isinstance(component, activity.Activity):\nact = component\n# remove \"escort_\" from activity types.\n# TODO: model joint trips\nif act.act[: len(joint_trips_prefix)] == joint_trips_prefix:\ntarget_act = act.act[(len(joint_trips_prefix)) :]\nelse:\ntarget_act = act.act\nif (act.location.area, target_act) in unique_locations:\nlocation = unique_locations[(act.location.area, target_act)]\nact.location = location\nelse:\nlocation = activity.Location(\narea=act.location.area,\nloc=sampler.sample(\nact.location.area,\ntarget_act,\nmode=mode,\nprevious_duration=previous_duration,\nprevious_loc=previous_loc,\n),\n)\nif target_act in long_term_activities:\nunique_locations[(act.location.area, target_act)] = location\nact.location = location\nprevious_loc = location.loc  # keep track of previous location\n# complete the alotting activity locations to the trip starts and ends.\nfor idx in range(person.plan.length):\ncomponent = person.plan[idx]\nif isinstance(component, activity.Leg):\ncomponent.start_location = person.plan[idx - 1].location\ncomponent.end_location = person.plan[idx + 1].location\n</code></pre>"},{"location":"api/core/#pam.core.Population.to_csv","title":"<code>to_csv(dir, crs=None, to_crs='EPSG:4326')</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def to_csv(self, dir: str, crs=None, to_crs: str = \"EPSG:4326\"):\nwrite.to_csv(self, dir, crs, to_crs)\n</code></pre>"},{"location":"api/core/#pam.core.Population.trips_df","title":"<code>trips_df()</code>","text":"<p>Extract tabular record of population legs.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: record of legs</p> Source code in <code>pam/core.py</code> <pre><code>def trips_df(self) -&gt; pd.DataFrame:\n\"\"\"Extract tabular record of population legs.\n    Returns:\n        pd.DataFrame: record of legs\n    \"\"\"\ndf = []\nfor hid, pid, person in self.people():\nfor seq, trip in enumerate(person.plan.trips()):\nrecord = {\n\"pid\": pid,\n\"hid\": hid,\n\"hzone\": person.home,\n\"ozone\": trip.start_location.area,\n\"dzone\": trip.end_location.area,\n\"oloc\": trip.start_location,\n\"dloc\": trip.end_location,\n\"seq\": seq,\n\"purp\": trip.purp,\n\"mode\": trip.mode,\n\"tst\": trip.start_time.time(),\n\"tet\": trip.end_time.time(),\n# duration in minutes\n\"duration\": trip.duration / pd.Timedelta(minutes=1),\n\"euclidean_distance\": trip.euclidean_distance,\n\"freq\": person.freq,\n}\n# add person attributes\nrecord = {**record, **dict(person.attributes)}\ndf.append(record)\ndf = pd.DataFrame(df)\nself.add_fields(df)\nreturn df\n</code></pre>"},{"location":"api/core/#pam.core.Population.update_vehicles_manager","title":"<code>update_vehicles_manager()</code>","text":"<p>Update vehicle population from persons.</p> Source code in <code>pam/core.py</code> <pre><code>def update_vehicles_manager(self):\n\"\"\"\n    Update vehicle population from persons.\n    \"\"\"\nvehs = {}\nfor _, _, _, veh in self.vehicles():\nif veh.vid in vehs:\nraise PAMVehicleIdError(\"Failed to build due to duplicate vehicle id: {veh.vid}\")\nvehs[veh.vid] = veh\nself._vehicles_manager._vehicles.update(vehs)\nif not self._vehicles_manager.is_consistent():\nraise UserWarning(\"Failed consistency check refer to logs.\")\n</code></pre>"},{"location":"api/core/#pam.core.Population.validate","title":"<code>validate()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def validate(self):\nfor hid, pid, person in self.people():\nperson.validate()\n</code></pre>"},{"location":"api/core/#pam.core.Population.vehicles","title":"<code>vehicles()</code>","text":"<p>Return iterator of all vehicles in population, prepended with household id, person id and mode.</p> YIELDS DESCRIPTION <code>str, str, str, Vehicle</code> <p>Iterator[str, str, str, Vehicle]: Iterator of (hid, pid, mode, vehicle)</p> Source code in <code>pam/core.py</code> <pre><code>def vehicles(self) -&gt; Iterator[str, str, str, Vehicle]:\n\"\"\"Return iterator of all vehicles in population, prepended with household id, person id\n    and mode.\n    Yields:\n        Iterator[str, str, str, Vehicle]: Iterator of (hid, pid, mode, vehicle)\n    \"\"\"\nfor hid, pid, p in self.people():\nfor mode, veh in p.vehicles.items():\nyield hid, pid, mode, veh\n</code></pre>"},{"location":"api/location/","title":"pam.location","text":""},{"location":"api/location/#pam.location.Location","title":"<code>Location(loc=None, link=None, area=None)</code>","text":"Source code in <code>pam/location.py</code> <pre><code>def __init__(self, loc=None, link=None, area=None):\nself.loc = loc\nself.link = link\nself.area = area\n</code></pre>"},{"location":"api/location/#pam.location.Location.area","title":"<code>area = area</code>  <code>instance-attribute</code>","text":""},{"location":"api/location/#pam.location.Location.exists","title":"<code>exists</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.link","title":"<code>link = link</code>  <code>instance-attribute</code>","text":""},{"location":"api/location/#pam.location.Location.loc","title":"<code>loc = loc</code>  <code>instance-attribute</code>","text":""},{"location":"api/location/#pam.location.Location.max","title":"<code>max</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.min","title":"<code>min</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.x","title":"<code>x</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.y","title":"<code>y</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.copy","title":"<code>copy()</code>","text":"Source code in <code>pam/location.py</code> <pre><code>def copy(self):\nreturn Location(loc=self.loc, link=self.link, area=self.area)\n</code></pre>"},{"location":"api/operations/combine/","title":"pam.operations.combine","text":""},{"location":"api/operations/combine/#pam.operations.combine.pop_combine","title":"<code>pop_combine(inpaths, matsim_version, household_key='hid', simplify_pt_trips=False, autocomplete=True, crop=False, leg_attributes=True, leg_route=True, keep_non_selected=True)</code>","text":"<p>Combine two or more populations (e.g. household, freight... etc).</p> Source code in <code>pam/operations/combine.py</code> <pre><code>def pop_combine(\ninpaths: str,\nmatsim_version: int,\nhousehold_key: str = \"hid\",\nsimplify_pt_trips: bool = False,\nautocomplete: bool = True,\ncrop: bool = False,\nleg_attributes: bool = True,\nleg_route: bool = True,\nkeep_non_selected=True,\n):\n\"\"\"Combine two or more populations (e.g. household, freight... etc).\"\"\"\nprint(\"==================================================\")\nprint(\"Combining input populations\")\ncombined_population = core.Population()\nfor inpath in inpaths:\npopulation = read.read_matsim(\ninpath,\nweight=1,\nversion=matsim_version,\nhousehold_key=household_key,\nsimplify_pt_trips=simplify_pt_trips,\nautocomplete=autocomplete,\ncrop=crop,\nleg_attributes=leg_attributes,\nleg_route=leg_route,\nkeep_non_selected=keep_non_selected,\n)\nprint(f\"population: {population.stats}\")\ncombined_population += population\nreturn combined_population\n</code></pre>"},{"location":"api/operations/cropping/","title":"pam.operations.cropping","text":"<p>Methods for cropping plans outside core areas.</p>"},{"location":"api/operations/cropping/#pam.operations.cropping.create_leg","title":"<code>create_leg(previous_act, next_act, travel_mode='car')</code>","text":"<p>Create a leg between two activities.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def create_leg(previous_act: Activity, next_act: Activity, travel_mode: str = \"car\") -&gt; Leg:\n\"\"\"Create a leg between two activities.\"\"\"\nleg = Leg(\nstart_time=previous_act.end_time,\nend_time=next_act.start_time,\nmode=travel_mode,\npurp=next_act.act,\n)\nleg.start_location = previous_act.location\nleg.end_location = next_act.location\n# link\nleg.previous = previous_act\nleg.next = next_act\nreturn leg\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.crop_leg","title":"<code>crop_leg(leg, boundary)</code>","text":"<p>Crop a leg to a boundary.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def crop_leg(leg: Leg, boundary: Polygon) -&gt; None:\n\"\"\"Crop a leg to a boundary.\"\"\"\npath = get_leg_path(leg)\npath_cropped = path.intersection(boundary)\nstart_location, end_location = path_cropped.boundary.geoms\nleg.start_location.loc = start_location\nleg.previous.location.loc = start_location\nleg.end_location.loc = end_location\nleg.next.location.loc = end_location\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.crop_plan","title":"<code>crop_plan(plan, kept_activities)</code>","text":"<p>Crop a plan in a way that exludes any external-external movement (and the corresponding activities). If no plan components are left in scope, the plan will have a single \"external\" activity.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def crop_plan(plan: Plan, kept_activities: List[Activity]) -&gt; None:\n\"\"\"Crop a plan in a way that exludes any external-external movement (and the corresponding activities).\n    If no plan components are left in scope, the plan will have a single \"external\" activity.\n    \"\"\"\nif kept_activities:\nday = list(filter(lambda x: filter_component(x, kept_activities), plan.day))\nelse:\nday = empty_day()\nplan.day = day\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.empty_day","title":"<code>empty_day()</code>","text":"Source code in <code>pam/operations/cropping.py</code> <pre><code>def empty_day() -&gt; list:\nday = [\nActivity(\nseq=1,\nact=\"external\",\narea=\"external\",\nstart_time=pam.utils.minutes_to_datetime(0),\nend_time=pam.variables.END_OF_DAY,\n)\n]\nreturn day\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.filter_component","title":"<code>filter_component(component, kept_activities)</code>","text":"<p>Check if an activity/leg should be kept.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def filter_component(component, kept_activities: List[Activity]) -&gt; bool:\n\"\"\"Check if an activity/leg should be kept.\"\"\"\nif isinstance(component, Activity):\nreturn component in kept_activities\nelif isinstance(component, Leg):\nreturn (component.previous in kept_activities) and (component.next in kept_activities)\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.get_kept_activities","title":"<code>get_kept_activities(plan, boundary)</code>","text":"<p>Get a list of the activities to keep after cropping external-external movements.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def get_kept_activities(plan: Plan, boundary: Polygon) -&gt; list:\n\"\"\"Get a list of the activities to keep after cropping external-external movements.\"\"\"\nkept_activities = list()\nfor leg in plan.legs:\nif leg_intersects(leg, boundary):\nfor act in [leg.previous, leg.next]:\nif act not in kept_activities:\nkept_activities.append(act)\nreturn kept_activities\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.get_leg_path","title":"<code>get_leg_path(leg)</code>","text":"<p>Get the (euclidean) geometry of a leg.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def get_leg_path(leg: Leg) -&gt; LineString:\n\"\"\"Get the (euclidean) geometry of a leg.\"\"\"\npath = LineString([leg.start_location.loc, leg.end_location.loc])\nreturn path\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.infill_legs","title":"<code>infill_legs(plan)</code>","text":"<p>Infill missing legs. If there is no leg between two activities, a new one is created linking them.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def infill_legs(plan: Plan) -&gt; None:\n\"\"\"Infill missing legs.\n    If there is no leg between two activities, a new one is created linking them.\n    \"\"\"\ni = 0\nwhile i &lt; len(plan.day) - 1:\ncomponent1 = plan.day[i]\ncomponent2 = plan.day[i + 1]\nif isinstance(component1, Activity) and isinstance(component2, Activity):\nleg = create_leg(component1, component2)\nplan.day.insert(i + 1, leg)\ni += 1\ni += 1\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.leg_intersects","title":"<code>leg_intersects(leg, boundary)</code>","text":"<p>Check whether a leg touches an area defined by a boundary.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def leg_intersects(leg: Leg, boundary: Polygon) -&gt; bool:\n\"\"\"Check whether a leg touches an area defined by a boundary.\"\"\"\npath = get_leg_path(leg)\nreturn path.intersects(boundary)\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.link_plan","title":"<code>link_plan(plan)</code>","text":"<p>Link a plan: each activity/leg gets a pointer to the previous/next plan component.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def link_plan(plan: Plan) -&gt; None:\n\"\"\"Link a plan: each activity/leg gets a pointer to the previous/next plan component.\"\"\"\nplan_list = list(plan)\nact_list = list(plan.activities)\nleg_list = list(plan.legs)\nfor i, p in enumerate(plan_list):\np.next = list_get(plan_list, i + 1)\np.previous = list_get(plan_list, i - 1)\nfor i, p in enumerate(act_list):\np.next_act = list_get(act_list, i + 1)\np.previous_act = list_get(act_list, i - 1)\nfor i, p in enumerate(leg_list):\np.start_hour = p.start_time.hour\np.next_leg = list_get(leg_list, i + 1)\np.previous_leg = list_get(leg_list, i - 1)\np.start_location = p.previous.location\np.end_location = p.next.location\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.link_population","title":"<code>link_population(population)</code>","text":"<p>Link the plan components of every agent in the population.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def link_population(population: Population) -&gt; None:\n\"\"\"Link the plan components of every agent in the population.\"\"\"\nfor hid, pid, person in population.people():\nlink_plan(person.plan)\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.list_get","title":"<code>list_get(list_to_access, idx)</code>","text":"Source code in <code>pam/operations/cropping.py</code> <pre><code>def list_get(list_to_access, idx):\nif idx &lt; len(list_to_access) and idx &gt;= 0:\nreturn list_to_access[idx]\nelse:\nreturn None\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.rename_external","title":"<code>rename_external(plan, boundary)</code>","text":"<p>Rename all external-area activities as \"external\".</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def rename_external(plan: Plan, boundary: Polygon) -&gt; None:\n\"\"\"Rename all external-area activities as \"external\".\"\"\"\nfor act in plan.activities:\nif not boundary.contains(act.location.loc):\nact.act = \"external\"\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.simplify_external_plans","title":"<code>simplify_external_plans(plan, boundary, snap_to_boundary=False, rename_external_activities=False)</code>","text":"<p>Simplify any activities happening outside the boundary area.</p> Method <ol> <li>Identify which legs touch the boundary area</li> <li>Keep the relevant legs/activities and drop the remaining components</li> <li>Infill: create any new legs between external activities as necessary</li> <li>Ensure plan consistency: start/end times, sequences, etc</li> <li>optional Rename activities to \"external\"</li> <li>optional Crop the leg geometries to start/stop at the core area boundaries</li> </ol> PARAMETER  DESCRIPTION <code>plan</code> <p>a PAM plan</p> <p> TYPE: <code>Plan</code> </p> <code>boundary</code> <p>the geometry of the core modelled area</p> <p> TYPE: <code>Polygon</code> </p> <code>snap_to_boundary</code> <p>whether to crop legs to stop at the core area boundary. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rename_external_activities</code> <p>whether to rename all external-area activities as \"external\" Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def simplify_external_plans(\nplan: Plan,\nboundary: Polygon,\nsnap_to_boundary: bool = False,\nrename_external_activities: bool = False,\n) -&gt; None:\n\"\"\"Simplify any activities happening outside the boundary area.\n    Method:\n     1. Identify which legs touch the boundary area\n     2. Keep the relevant legs/activities and drop the remaining components\n     3. Infill: create any new legs between external activities as necessary\n     4. Ensure plan consistency: start/end times, sequences, etc\n     5. **optional** Rename activities to \"external\"\n     6. **optional** Crop the leg geometries to start/stop at the core area boundaries\n    Args:\n      plan (Plan): a PAM plan\n      boundary (Polygon): the geometry of the core modelled area\n      snap_to_boundary (bool, optional): whether to crop legs to stop at the core area boundary. Defaults to False.\n      rename_external_activities (bool, optional): whether to rename all external-area activities as \"external\" Defaults to False.\n    \"\"\"\nlink_plan(plan)\nkept_activities = get_kept_activities(plan, boundary)  # activities to keep\ncrop_plan(plan, kept_activities)  # drop external plan components\ninfill_legs(plan)  # infill with any new legs if required\nstretch_times(plan)  # fix plan time boundaries\nlink_plan(plan)  # re-link plan components\nif rename_external_activities:\nrename_external(plan, boundary)  # rename activities to \"external\"\nif snap_to_boundary:\nfor leg in plan.legs:\ncrop_leg(leg, boundary)  # crop leg geometry\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.simplify_population","title":"<code>simplify_population(population, boundary, snap_to_boundary=False, rename_external_activities=False)</code>","text":"<p>Simplify external plans across a population.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def simplify_population(\npopulation: str,\nboundary: str,\nsnap_to_boundary: bool = False,\nrename_external_activities: bool = False,\n) -&gt; None:\n\"\"\"Simplify external plans across a population.\"\"\"\n# simplify plans\nfor hid, pid, person in population.people():\nsimplify_external_plans(person.plan, boundary, snap_to_boundary, rename_external_activities)\n# remove empty person-plans and households\nremove_persons = []\nfor hid, pid, person in population.people():\nif len(person.plan) == 1 and person.plan.day[0].act == \"external\":\nremove_persons.append((hid, pid))\nfor hid, pid in remove_persons:\ndel population[hid].people[pid]\nremove_hhs = [\nhid for hid in population.households if len(population.households[hid].people) == 0\n]\nfor hid in remove_hhs:\ndel population.households[hid]\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.stretch_times","title":"<code>stretch_times(plan)</code>","text":"<p>Extend start/end activity times to the start/end of day.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def stretch_times(plan: Plan) -&gt; None:\n\"\"\"Extend start/end activity times to the start/end of day.\"\"\"\nplan.day[0].start_time = START_OF_DAY\nplan.day[-1].end_time = END_OF_DAY\n</code></pre>"},{"location":"api/optimise/grid/","title":"pam.optimise.grid","text":""},{"location":"api/optimise/grid/#pam.optimise.grid.Recorder","title":"<code>Recorder(initial_score, initial_plan)</code>","text":"<p>Mechanism for recording grid optimiser progress.</p> PARAMETER  DESCRIPTION <code>initial_score</code> <p>Initial plan score.</p> <p> TYPE: <code>float</code> </p> <code>initial_plan</code> <p>Initial plan.</p> <p> TYPE: <code>Plan</code> </p> Source code in <code>pam/optimise/grid.py</code> <pre><code>def __init__(self, initial_score: float, initial_plan: Plan) -&gt; None:\n\"\"\"Mechanism for recording grid optimiser progress.\n    Args:\n        initial_score (float): Initial plan score.\n        initial_plan (Plan): Initial plan.\n    \"\"\"\nself.best_plan = initial_plan\nself.best_score = initial_score\n</code></pre>"},{"location":"api/optimise/grid/#pam.optimise.grid.Recorder.best_plan","title":"<code>best_plan = initial_plan</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/grid/#pam.optimise.grid.Recorder.best_score","title":"<code>best_score = initial_score</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/grid/#pam.optimise.grid.Recorder.update","title":"<code>update(score, plan)</code>","text":"<p>Update with new score and plan.</p> PARAMETER  DESCRIPTION <code>score</code> <p>Latest plan score.</p> <p> TYPE: <code>float</code> </p> <code>plan</code> <p>Latest plan.</p> <p> TYPE: <code>Plan</code> </p> Source code in <code>pam/optimise/grid.py</code> <pre><code>def update(self, score: float, plan: Plan):\n\"\"\"Update with new score and plan.\n    Args:\n        score (float): Latest plan score.\n        plan (Plan): Latest plan.\n    \"\"\"\nif score &gt;= self.best_score:\nself.best_score = score\nself.best_plan = deepcopy(plan)\n</code></pre>"},{"location":"api/optimise/grid/#pam.optimise.grid.grid_search","title":"<code>grid_search(plan, plans_scorer, config, step=900, copy=True)</code>","text":"<p>Grid search for optimum plan schedule.</p> <p>Checks all permutations of a plan's activity start times and durations, finds plan that has maximum score, based on the given scorer. The precision and size of the grid is based on the given step (seconds). Smaller steps increase the grid size.</p> <p>Trip durations are assumed fixed and activity sequence is not changed.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>Input plan.</p> <p> TYPE: <code>Plan</code> </p> <code>plans_scorer</code> <p>Plans scorer object.</p> <p> TYPE: <code>PlanScorer</code> </p> <code>config</code> <p>PlansScorer config.</p> <p> TYPE: <code>Dict</code> </p> <code>step</code> <p>Grid size in seconds. Defaults to 900.</p> <p> TYPE: <code>int</code> DEFAULT: <code>900</code> </p> <code>copy</code> <p>Create a copy of the input plan. Defaults to True.</p> <p> TYPE: <code>Bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>(Plan, float)</code> <p>Best plan found and score of best plan.</p> Source code in <code>pam/optimise/grid.py</code> <pre><code>def grid_search(\nplan: Plan, plans_scorer: PlanScorer, config: dict, step: int = 900, copy=True\n) -&gt; (float, Plan):\n\"\"\"Grid search for optimum plan schedule.\n    Checks all permutations of a plan's activity start times and durations, finds plan\n    that has maximum score, based on the given scorer. The precision and size of the grid is based\n    on the given step (seconds). Smaller steps increase the grid size.\n    Trip durations are assumed fixed and activity sequence is not changed.\n    Args:\n        plan (Plan): Input plan.\n        plans_scorer (PlanScorer): Plans scorer object.\n        config (Dict): PlansScorer config.\n        step (int): Grid size in seconds. Defaults to 900.\n        copy (Bool): Create a copy of the input plan. Defaults to True.\n    Returns:\n        (Plan, float): Best plan found and score of best plan.\n    \"\"\"\nif copy:\nplan = deepcopy(plan)\ninitial_score = plans_scorer.score_plan(plan, config)\nrecorder = Recorder(initial_score, plan)\ntraverse(\nscorer=plans_scorer,\nconfig=config,\nplan=plan,\nearliest=0,\nstep=step,\nleg_index=0,\nrecorder=recorder,\n)\nprint_report(initial_score, recorder.best_score, step)\nreturn recorder.best_plan, recorder.best_score\n</code></pre>"},{"location":"api/optimise/grid/#pam.optimise.grid.latest_start_time","title":"<code>latest_start_time(plan, leg_index)</code>","text":"Source code in <code>pam/optimise/grid.py</code> <pre><code>def latest_start_time(plan: Plan, leg_index: int):\nallowance = 24 * 60 * 60\nfor c in plan[(leg_index * 2) + 1 :: 2]:\nallowance -= c.duration.seconds\nreturn allowance\n</code></pre>"},{"location":"api/optimise/grid/#pam.optimise.grid.print_report","title":"<code>print_report(initial_score, best_score, n)</code>","text":"Source code in <code>pam/optimise/grid.py</code> <pre><code>def print_report(initial_score: float, best_score: float, n: int):\nif best_score &gt; initial_score:\nprint(f\"Score improved from {initial_score} to {best_score} using step size {n}s.\")\nelse:\nprint(f\"Failed to improve score from initial {initial_score} using step size {n}s.\")\n</code></pre>"},{"location":"api/optimise/grid/#pam.optimise.grid.traverse","title":"<code>traverse(scorer, config, plan, step, earliest, leg_index, recorder)</code>","text":"<p>Traverse all possible grid permutations by enumerating all trip start times of first trip and recursively all following trips in sequence.</p> Source code in <code>pam/optimise/grid.py</code> <pre><code>def traverse(\nscorer: PlanScorer,\nconfig: dict,\nplan: Plan,\nstep: int,\nearliest: int,\nleg_index: int,\nrecorder: Recorder,\n):\n\"\"\"Traverse all possible grid permutations by enumerating all trip start times of first trip\n    and recursively all following trips in sequence.\n    \"\"\"\n## exit condition\nif leg_index * 2 + 2 &gt;= len(plan):\nrecorder.update(scorer.score_plan(plan, cnfg=config), plan)\nreturn None\nlatest_start = latest_start_time(plan, leg_index)\nfor earliest in range(earliest, latest_start + step, step):\nactivity = plan[leg_index * 2]\nleg = plan[leg_index * 2 + 1]\nnext_activity = plan[leg_index * 2 + 2]\nactivity.end_time = START_OF_DAY + timedelta(seconds=earliest)\nleg.end_time = leg.shift_start_time(activity.end_time)\nnext_activity.start_time = leg.end_time\ntraverse(\nscorer=scorer,\nconfig=config,\nplan=deepcopy(plan),\nearliest=earliest + step,  # + plan[leg_index * 2 + 1].duration.seconds,\nleg_index=leg_index + 1,\nstep=step,\nrecorder=recorder,\n)\n</code></pre>"},{"location":"api/optimise/random/","title":"pam.optimise.random","text":""},{"location":"api/optimise/random/#pam.optimise.random.Stopper","title":"<code>Stopper(horizon=5, sensitivity=0.01)</code>","text":"<p>Early stopping mechanism. Maintains last n scores, where n is equal to \"horizon\". Triggers an early stop if change across horizon is less than given sensitivity.</p> PARAMETER  DESCRIPTION <code>horizon</code> <p>length of stored history. Defaults to 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>sensitivity</code> <p>stopping tolerance. Defaults to 0.01.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.01</code> </p> Source code in <code>pam/optimise/random.py</code> <pre><code>def __init__(self, horizon=5, sensitivity=0.01) -&gt; None:\n\"\"\"Early stopping mechanism. Maintains last n scores, where n is equal to \"horizon\".\n    Triggers an early stop if change across horizon is less than given sensitivity.\n    Args:\n        horizon (int, optional): length of stored history. Defaults to 5.\n        sensitivity (float, optional): stopping tolerance. Defaults to 0.01.\n    \"\"\"\nself.record = []\nself.horizon = horizon\nself.sensitivity = sensitivity\n</code></pre>"},{"location":"api/optimise/random/#pam.optimise.random.Stopper.horizon","title":"<code>horizon = horizon</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/random/#pam.optimise.random.Stopper.record","title":"<code>record = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/random/#pam.optimise.random.Stopper.sensitivity","title":"<code>sensitivity = sensitivity</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/random/#pam.optimise.random.Stopper.stop","title":"<code>stop(score)</code>","text":"Source code in <code>pam/optimise/random.py</code> <pre><code>def stop(self, score):\nself.record.append(score)\nif len(self.record) &gt; self.horizon:\nself.record.pop(0)\nif abs(self.record[-1] - self.record[0]) &lt; self.sensitivity:\nreturn True\nreturn False\n</code></pre>"},{"location":"api/optimise/random/#pam.optimise.random.print_report","title":"<code>print_report(initial_score, best_score, n)</code>","text":"Source code in <code>pam/optimise/random.py</code> <pre><code>def print_report(initial_score, best_score, n):\nif best_score &gt; initial_score:\nprint(f\"Score improved from {initial_score} to {best_score} in {n} steps.\")\nelse:\nprint(f\"Failed to improve score from initial {initial_score} in {n} steps.\")\n</code></pre>"},{"location":"api/optimise/random/#pam.optimise.random.random_mutate_activity_durations","title":"<code>random_mutate_activity_durations(plan, copy=True)</code>","text":"<p>Rearrange input plan into random new plan, maintaining activity sequence and trip durations.</p> Source code in <code>pam/optimise/random.py</code> <pre><code>def random_mutate_activity_durations(plan: Plan, copy=True):\n\"\"\"Rearrange input plan into random new plan, maintaining activity sequence and trip durations.\"\"\"\nallowance = 24 * 60 * 60  # seconds\nfor leg in plan.legs:\nallowance -= leg.duration.total_seconds()\nn_activities = len(list(plan.activities))\nactivity_durations = [\ntimedelta(seconds=int(random.random() * allowance / n_activities))\nfor n in range(n_activities)\n]\nif copy:\nplan = deepcopy(plan)\ntime = plan.day[0].shift_duration(new_duration=activity_durations.pop(0))\nidx = 1\nfor activity_duration, leg_duration in zip(\nactivity_durations, [leg.duration for leg in plan.legs]\n):\ntime = plan.day[idx].shift_duration(new_start_time=time, new_duration=leg_duration)\ntime = plan.day[idx + 1].shift_duration(new_start_time=time, new_duration=activity_duration)\nidx += 2\nplan.day[-1].end_time = END_OF_DAY\nreturn plan\n</code></pre>"},{"location":"api/optimise/random/#pam.optimise.random.reschedule","title":"<code>reschedule(plan, plans_scorer, config={}, horizon=5, sensitivity=0.01, patience=1000)</code>","text":"<p>Randomly search for an improved plan sequence based on given plans_scorer.</p> <p>This is not seriously suggested as a sensible approach, it is supplied for example only.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>Input plan.</p> <p> TYPE: <code>Plan</code> </p> <code>plans_scorer</code> <p>Plans scorer.</p> <p> TYPE: <code>PlanScorer</code> </p> <code>config</code> <p>plans_scorer configuration. Defaults to {}.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>horizon</code> <p>Early stopper horizon. Defaults to 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>sensitivity</code> <p>Early stopper sensitivity. Defaults to 0.01.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.01</code> </p> <code>patience</code> <p>Defaults to 1000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RETURNS DESCRIPTION <code>(Plan, float)</code> <p>best plan found and best score.</p> Source code in <code>pam/optimise/random.py</code> <pre><code>def reschedule(\nplan: Plan,\nplans_scorer: PlanScorer,\nconfig: dict = {},\nhorizon: int = 5,\nsensitivity: float = 0.01,\npatience: int = 1000,\n) -&gt; (Plan, float):\n\"\"\"Randomly search for an improved plan sequence based on given plans_scorer.\n    This is not seriously suggested as a sensible approach, it is supplied for example only.\n    Args:\n        plan (Plan): Input plan.\n        plans_scorer (PlanScorer): Plans scorer.\n        config (dict): plans_scorer configuration. Defaults to {}.\n        horizon (int): Early stopper horizon. Defaults to 5.\n        sensitivity (float): Early stopper sensitivity. Defaults to 0.01.\n        patience (int): Defaults to 1000.\n    Returns:\n        (Plan, float): best plan found and best score.\n    \"\"\"\nbest_score = plans_scorer.score_plan(plan, config)\ninitial_score = best_score\nbest_scores = {0: best_score}\nstopper = Stopper(horizon=horizon, sensitivity=sensitivity)\nfor n in range(patience + 1):\nproposed_plan = random_mutate_activity_durations(plan, copy=True)\nscore = plans_scorer.score_plan(proposed_plan, config)\nif score &gt; best_score:\nbest_scores[n] = score\nbest_score = score\nplan = proposed_plan\nif stopper.stop(score):\nprint_report(initial_score, best_score, n)\nreturn plan, best_scores\nprint_report(initial_score, best_score, n)\nreturn plan, best_scores\n</code></pre>"},{"location":"api/planner/choice_location/","title":"pam.planner.choice_location","text":"<p>Location and mode choice models for activity modelling.</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration","title":"<code>ChoiceConfiguration</code>  <code>dataclass</code>","text":"ATTRIBUTE DESCRIPTION <code>u</code> <p>The utility function specification. The string may point to household, person, act, leg, od, or zone data. It can also include values and/or mathematical operations. Parameters may be passed as single values, or as lists (with each element in the list corresponding to one of the modes in the OD object). For example: u='-[0,1] - (2 * od['time']) - (od['time'] * person.attributes['age']&gt;60). Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>scope</code> <p>The scope of the function (for example, work activities). Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>func_probabilities</code> <p>The function for calculating the probability of each alternative. Defaults to None.</p> <p> TYPE: <code>Callable</code> </p> <code>func_sampling</code> <p>The function for sampling across alternatives, ie softmax. Defaults to None.</p> <p> TYPE: <code>Callable</code> </p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.func_probabilities","title":"<code>func_probabilities: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.func_sampling","title":"<code>func_sampling: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.scope","title":"<code>scope: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.u","title":"<code>u: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.validate","title":"<code>validate(vars)</code>","text":"PARAMETER  DESCRIPTION <code>vars</code> <p> TYPE: <code>list[str]</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def validate(self, vars: list[str]) -&gt; None:\n\"\"\"\n    Args:\n      vars (list[str]):\n    \"\"\"\nfor var in vars:\nif getattr(self, var) is None:\nraise ValueError(f\"Setting {var} has not been set yet\")\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx","title":"<code>ChoiceIdx</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Choice set index.</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.act","title":"<code>act: Activity</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.hid","title":"<code>hid: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.pid","title":"<code>pid: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.seq","title":"<code>seq: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceLabel","title":"<code>ChoiceLabel</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Destination and mode choice labels of a selected option.</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceLabel.destination","title":"<code>destination: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceLabel.mode","title":"<code>mode: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceMNL","title":"<code>ChoiceMNL(population, od, zones)</code>","text":"<p>             Bases: <code>ChoiceModel</code></p> <p>Applies a Multinomial Logit Choice model.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(self, population: Population, od: OD, zones: pd.DataFrame) -&gt; None:\nsuper().__init__(population, od, zones)\nself.configure(\nfunc_probabilities=calculate_mnl_probabilities, func_sampling=sample_weighted\n)\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel","title":"<code>ChoiceModel(population, od, zones)</code>","text":"<p>Choice model interface.</p> PARAMETER  DESCRIPTION <code>population</code> <p>A PAM population.</p> <p> TYPE: <code>Population</code> </p> <code>od</code> <p>An object holding origin-destination.</p> <p> TYPE: <code>OD</code> </p> <code>zones</code> <p>Zone-level data.</p> <p> TYPE: <code>Union[DataFrame, Zones]</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(self, population: Population, od: OD, zones: Union[pd.DataFrame, Zones]) -&gt; None:\n\"\"\"Choice model interface.\n    Args:\n        population (Population): A PAM population.\n        od (OD): An object holding origin-destination.\n        zones (Union[pd.DataFrame, Zones]): Zone-level data.\n    \"\"\"\nself.logger = logging.getLogger(__name__)\nself.population = population\nlink_population(self.population)\nself.od = od\nself.zones = self.parse_zone_data(zones)\nself.zones.data = self.zones.data.loc[list(od.labels.destination_zones)]\nself.configuration = ChoiceConfiguration()\nself._selections = None\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.configuration","title":"<code>configuration = ChoiceConfiguration()</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.od","title":"<code>od = od</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.population","title":"<code>population = population</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.selections","title":"<code>selections: SelectionSet</code>  <code>property</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.zones","title":"<code>zones = self.parse_zone_data(zones)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.apply","title":"<code>apply(apply_location=True, apply_mode=True, once_per_agent=True, apply_mode_to='chain')</code>","text":"<p>Apply the choice model to the PAM population,     updating the activity locations and mode choices in scope.</p> PARAMETER  DESCRIPTION <code>apply_location</code> <p>Whether to update activities' location. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>apply_mode</code> <p>Whether to update travel modes. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>once_per_agent</code> <p>If True, the same selected option is applied to all activities within scope of an agent. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>apply_mode_to</code> <p>Whether to apply the mode to the entire trip chain that contains the activity, or the leg preceding the activity. Defaults to \"chain\".</p> <p> TYPE: <code>Literal['chain', 'previous_leg']</code> DEFAULT: <code>'chain'</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def apply(\nself,\napply_location: bool = True,\napply_mode: bool = True,\nonce_per_agent: bool = True,\napply_mode_to: Literal[\"chain\", \"previous_leg\"] = \"chain\",\n) -&gt; None:\n\"\"\"Apply the choice model to the PAM population,\n        updating the activity locations and mode choices in scope.\n    Args:\n      apply_location (bool, optional): Whether to update activities' location. Defaults to True.\n      apply_mode (bool, optional): Whether to update travel modes. Defaults to True.\n      once_per_agent (bool, optional): If True, the same selected option is applied to all activities within scope of an agent. Defaults to True.\n      apply_mode_to (Literal[\"chain\", \"previous_leg\"]):\n        Whether to apply the mode to the entire trip chain that contains the activity, or the leg preceding the activity.\n        Defaults to \"chain\".\n    \"\"\"\nself.logger.info(\"Applying choice model...\")\nself.logger.info(f\"Configuration: \\n{self.configuration}\")\npid = None\ndestination = None\ntrmode = None\n# update location and mode\nfor idx, selection in zip(self.selections.choice_set.idxs, self.selections.selections):\nif not (once_per_agent and (pid == idx.pid)):\ndestination = selection.destination\ntrmode = selection.mode\npid = idx.pid\nact = idx.act\nif apply_location:\nact.location.area = destination\nif apply_mode and (act.previous is not None):\nif apply_mode_to == \"chain\":\napply_mode_to_home_chain(act, trmode)\nelif apply_mode_to == \"previous_leg\":\nact.previous.mode = trmode\nelse:\nraise ValueError(f\"Invalid option {apply_mode_to}\")\nself.logger.info(\"Choice model application complete.\")\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.configure","title":"<code>configure(**kwargs)</code>","text":"<p>Specify the model.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Parameters of the ChoiceConfiguration class.</p> <p> TYPE: <code>Optional[Union[str, Callable]]</code> DEFAULT: <code>{}</code> </p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def configure(self, **kwargs: Optional[Union[str, Callable]]) -&gt; None:\n\"\"\"Specify the model.\n    Args:\n      **kwargs (Optional[Union[str, Callable]]): Parameters of the ChoiceConfiguration class.\n    \"\"\"\nfor k, v in kwargs.items():\nif type(v) == str:\nv = v.replace(\" \", \"\")\nsetattr(self.configuration, k, v)\nself.logger.info(\"Updated model configuration\")\nself.logger.info(self.configuration)\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.get_choice_set","title":"<code>get_choice_set()</code>","text":"<p>Construct an agent's choice set for each activity/leg within scope.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def get_choice_set(self) -&gt; ChoiceSet:\n\"\"\"Construct an agent's choice set for each activity/leg within scope.\"\"\"\nself.configuration.validate([\"u\", \"scope\"])\nod = self.od\nu = self.configuration.u\nscope = self.configuration.scope\n# zones might be defined in `u` and so be required on calling `eval(u)`\nzones = self.zones  # noqa: F841\nidxs = []\nu_choices = []\nchoice_labels = list(itertools.product(od.labels.destination_zones, od.labels.mode))\nchoice_labels = [ChoiceLabel(*x) for x in choice_labels]\n# iterate across activities\nfor hid, hh in self.population:\nfor pid, person in hh:\nfor i, act in enumerate(person.activities):\nif eval(scope):\nidx_act = ChoiceIdx(pid=pid, hid=hid, seq=i, act=act)\n# calculate utilities for each alternative\nu_act = eval(u)\n# flatten location-mode combinations\nu_act = u_act.flatten()\nu_choices.append(u_act)\nidxs.append(idx_act)\nu_choices = np.array(u_choices)\n# check dimensions\nassert u_choices.shape[1] == len(choice_labels)\nassert u_choices.shape[0] == len(idxs)\nreturn ChoiceSet(idxs=idxs, u_choices=u_choices, choice_labels=choice_labels)\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.parse_zone_data","title":"<code>parse_zone_data(zones)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/choice_location.py</code> <pre><code>@staticmethod\ndef parse_zone_data(zones: Union[pd.DataFrame, Zones]) -&gt; Zones:\nif isinstance(zones, Zones):\nreturn deepcopy(zones)\nelif isinstance(zones, pd.DataFrame):\nreturn Zones(data=zones.copy())\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceSet","title":"<code>ChoiceSet</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>MNL Choice set.</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceSet.choice_labels","title":"<code>choice_labels: list[ChoiceLabel]</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceSet.idxs","title":"<code>idxs: list[ChoiceIdx]</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceSet.u_choices","title":"<code>u_choices: np.array</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet","title":"<code>SelectionSet</code>  <code>dataclass</code>","text":"<p>Calculate probabilities and select alternative.</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.choice_set","title":"<code>choice_set: ChoiceSet</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.func_probabilities","title":"<code>func_probabilities: Callable</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.func_sampling","title":"<code>func_sampling: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.probabilities","title":"<code>probabilities: np.array</code>  <code>property</code>","text":"<p>Probabilities for each alternative.</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.selections","title":"<code>selections: list[ChoiceLabel]</code>  <code>property</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.sample","title":"<code>sample()</code>","text":"<p>Sample from a set of alternative options.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def sample(self) -&gt; list:\n\"\"\"Sample from a set of alternative options.\"\"\"\nsampled = np.apply_along_axis(func1d=self.func_sampling, axis=1, arr=self.probabilities)\nsampled_labels = [self.choice_set.choice_labels[x] for x in sampled]\nself._selections = sampled_labels\nreturn sampled_labels\n</code></pre>"},{"location":"api/planner/clustering/","title":"pam.planner.clustering","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters","title":"<code>PlanClusters(population, n_cores=1)</code>","text":"<p>Groups activity plans into clusters. Plan similarity is defined using the edit distance     of character-encoded plan sequences.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def __init__(self, population: Population, n_cores: int = 1) -&gt; None:\nself.population = population\nself.plans = list(population.plans())\nself.n_cores = n_cores\nself._distances = None\nself.model = None\n# encodings\nself.activity_classes = sorted(list(population.activity_classes) + [\"travel\"])\nself.plans_encoder = PlansCharacterEncoder(activity_classes=self.activity_classes)\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.activity_classes","title":"<code>activity_classes = sorted(list(population.activity_classes) + ['travel'])</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.distances","title":"<code>distances: np.array</code>  <code>property</code>","text":"<p>Levenshtein distances between activity plans.</p>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.distances_no_diagonal","title":"<code>distances_no_diagonal: np.array</code>  <code>property</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.model","title":"<code>model = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.n_cores","title":"<code>n_cores = n_cores</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plans","title":"<code>plans = list(population.plans())</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plans_encoded","title":"<code>plans_encoded: list[str]</code>  <code>cached</code> <code>property</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plans_encoder","title":"<code>plans_encoder = PlansCharacterEncoder(activity_classes=self.activity_classes)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.population","title":"<code>population = population</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.fit","title":"<code>fit(n_clusters, clustering_method='agglomerative', linkage='complete')</code>","text":"<p>Fit an agglomerative clustering model.</p> PARAMETER  DESCRIPTION <code>n_clusters</code> <p>The number of clusters to use.</p> <p> TYPE: <code>int</code> </p> <code>clustering_method</code> <p>The clustering method to use. Defaults to \"agglomerative\".</p> <p> TYPE: <code>Literal['agglomerative', 'spectral']</code> DEFAULT: <code>'agglomerative'</code> </p> <code>linkage</code> <p>Linkage criterion. Defaults to \"complete\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'complete'</code> </p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def fit(\nself,\nn_clusters: int,\nclustering_method: Literal[\"agglomerative\", \"spectral\"] = \"agglomerative\",\nlinkage: Optional[str] = \"complete\",\n) -&gt; None:\n\"\"\"Fit an agglomerative clustering model.\n    Args:\n      n_clusters (int): The number of clusters to use.\n      clustering_method (Literal['agglomerative', 'spectral']): The clustering method to use. Defaults to \"agglomerative\".\n      linkage (str, optional): Linkage criterion. Defaults to \"complete\".\n    \"\"\"\nif clustering_method == \"agglomerative\":\nmodel = AgglomerativeClustering(\nn_clusters=n_clusters, linkage=linkage, metric=\"precomputed\"\n)\nmodel.fit((self.distances))\nelif clustering_method == \"spectral\":\nmodel = SpectralClustering(n_clusters=n_clusters, affinity=\"precomputed\")\nmodel.fit((1 - self.distances))\nelse:\nraise ValueError(\n\"Please select a valid clustering_method ('agglomerative' or 'spectral')\"\n)\nself.model = model\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.get_closest_matches","title":"<code>get_closest_matches(plan, n)</code>","text":"<p>Get the n closest matches of a PAM activity schedule.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_closest_matches(self, plan, n) -&gt; list[Plan]:\n\"\"\"Get the n closest matches of a PAM activity schedule.\"\"\"\nidx = self.plans.index(plan)\nidx_closest = np.argsort(self.distances_no_diagonal[idx])[:n]\nreturn [self.plans[x] for x in idx_closest]\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.get_cluster_membership","title":"<code>get_cluster_membership()</code>","text":"<p>Get the cluster membership of each person in the population. Returns a dictionary where the index values are (hid, pid) tuples,     and the values are the correponding agents' clusters.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_cluster_membership(self) -&gt; dict:\n\"\"\"Get the cluster membership of each person in the population.\n    Returns a dictionary where the index values are (hid, pid) tuples,\n        and the values are the correponding agents' clusters.\n    \"\"\"\nids = [(hid, pid) for hid, pid, person in self.population.people()]\nreturn dict(zip(ids, self.model.labels_))\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.get_cluster_plans","title":"<code>get_cluster_plans(cluster)</code>","text":"<p>Get the plans that belong in a specific cluster.</p> PARAMETER  DESCRIPTION <code>cluster</code> <p>The cluster index.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_cluster_plans(self, cluster: int) -&gt; list:\n\"\"\"Get the plans that belong in a specific cluster.\n    Args:\n        cluster (int): The cluster index.\n    \"\"\"\nreturn list(itertools.compress(self.plans, self.model.labels_ == cluster))\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.get_cluster_sizes","title":"<code>get_cluster_sizes()</code>","text":"<p>Get the number of plans in each cluster.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_cluster_sizes(self) -&gt; pd.Series:\n\"\"\"Get the number of plans in each cluster.\"\"\"\nreturn pd.Series(self.model.labels_).value_counts()\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plot_plan_breakdowns","title":"<code>plot_plan_breakdowns(ax=None, cluster=None, activity_classes=None, **kwargs)</code>","text":"<p>Area plot of the breakdown of activities taking place every minute for a specific cluster.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def plot_plan_breakdowns(\nself, ax=None, cluster=None, activity_classes: Optional[list[str]] = None, **kwargs\n):\n\"\"\"Area plot of the breakdown of activities taking place every minute\n    for a specific cluster.\n    \"\"\"\nif cluster is not None:\nplans = self.get_cluster_plans(cluster)\nelse:\nplans = self.plans\nif activity_classes is None:\nactivity_classes = self.activity_classes\nreturn plot_activity_breakdown_area(\nplans=plans, activity_classes=self.activity_classes, ax=ax, **kwargs\n)\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plot_plan_breakdowns_tiles","title":"<code>plot_plan_breakdowns_tiles(n=None, **kwargs)</code>","text":"<p>Tiled area plot of the breakdown of activities taking place every minute, for the clusters with the top n number of plans.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def plot_plan_breakdowns_tiles(self, n: Optional[int] = None, **kwargs):\n\"\"\"Tiled area plot of the breakdown of activities taking place every minute,\n    for the clusters with the top n number of plans.\n    \"\"\"\nif n is None:\nn = len(set(self.model.labels_))\nclusters = self.get_cluster_sizes().head(n).index\nplans = {cluster: self.get_cluster_plans(cluster) for cluster in clusters}\nreturn plot_activity_breakdown_area_tiles(\nplans=plans, activity_classes=self.activity_classes, **kwargs\n)\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.calc_levenshtein_matrix","title":"<code>calc_levenshtein_matrix(x, y, n_cores=1)</code>","text":"<p>Create a levenshtein distance matrix from two lists of strings.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def calc_levenshtein_matrix(x: list[str], y: list[str], n_cores=1) -&gt; np.array:\n\"\"\"Create a levenshtein distance matrix from two lists of strings.\"\"\"\nlevenshtein_distance = np.vectorize(_levenshtein_distance)\nif n_cores == 1:\ndistances = levenshtein_distance(np.array(x).reshape(-1, 1), np.array(y))\nelse:\nxs = np.array_split(x, n_cores)\nxs = [x.reshape(-1, 1) for x in xs]\ncalc_levenshtein_matrix_partial = partial(levenshtein_distance, b=y)\nwith Pool(n_cores) as p:\ndistances = np.concatenate(p.map(calc_levenshtein_matrix_partial, xs))\nreturn distances\n</code></pre>"},{"location":"api/planner/encoder/","title":"pam.planner.encoder","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder","title":"<code>Encoder(labels, travel_act='travel')</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, labels: List[str], travel_act=\"travel\") -&gt; None:\nself.labels = set(labels)\nif travel_act not in self.labels:\nself.labels.add(travel_act)\nself.label_code = self.get_mapping(self.labels)\nself.code_label = {v: k for k, v in self.label_code.items()}\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.code_label","title":"<code>code_label = {v: kfor (k, v) in self.label_code.items()}</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.label_code","title":"<code>label_code = self.get_mapping(self.labels)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.labels","title":"<code>labels = set(labels)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.decode","title":"<code>decode(code)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, code: Union[int, str]) -&gt; str:\nreturn self.code_label[code]\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.encode","title":"<code>encode(label)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, label: str) -&gt; Union[int, str]:\nreturn self.label_code[label]\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.get_mapping","title":"<code>get_mapping(labels)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_mapping(labels: List[str]):\nraise NotImplementedError\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder","title":"<code>PlanCharacterEncoder</code>","text":"<p>             Bases: <code>PlanEncoder</code></p>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.activity_encoder_class","title":"<code>activity_encoder_class = StringCharacterEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.encode","title":"<code>encode(plan)</code>","text":"<p>Convert a pam plan to a character sequence.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plan: Plan) -&gt; np.array:\n\"\"\"Convert a pam plan to a character sequence.\"\"\"\nencoded = \"\"\nfor act in plan.day:\nduration = int(act.duration / td(minutes=1))\nencoded = encoded + (self.activity_encoder.encode(act.act) * duration)\nreturn encoded\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.get_seq","title":"<code>get_seq(x)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_seq(x):\nreturn x\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder","title":"<code>PlanEncoder(activity_encoder=None, labels=None)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(\nself,\nactivity_encoder: Optional[StringCharacterEncoder] = None,\nlabels: Optional[List[str]] = None,\n) -&gt; None:\nif activity_encoder is not None:\nself.activity_encoder = activity_encoder\nelif labels is not None:\nself.activity_encoder = self.activity_encoder_class(labels)\nelse:\nraise ValueError(\"Please provide appropriate activity labels or encodings\")\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.activity_encoder","title":"<code>activity_encoder = activity_encoder</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.activity_encoder_class","title":"<code>activity_encoder_class = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.add_plan_component","title":"<code>add_plan_component(plan, seq, act, start_time, duration)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef add_plan_component(plan: Plan, seq, act, start_time, duration) -&gt; None:\nif act == \"travel\":\nplan.add(activity.Leg(seq=seq, start_time=start_time, end_time=start_time + duration))\nelse:\nplan.add(\nactivity.Activity(\nseq=seq, act=act, start_time=start_time, end_time=start_time + duration\n)\n)\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.decode","title":"<code>decode(encoded_plan)</code>","text":"<p>Decode a sequence to a new PAM plan.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, encoded_plan: np.array) -&gt; Plan:\n\"\"\"Decode a sequence to a new PAM plan.\"\"\"\nstart_time = START_OF_DAY\nplan = activity.Plan()\n# for every activity/leg:\nfor seq, (k, g) in enumerate(groupby(self.get_seq(encoded_plan))):\nduration = td(minutes=len(list(g)))\nact = self.activity_encoder.decode(k)\n# add to the plan and advance start time\nself.add_plan_component(\nplan=plan, seq=seq, act=act, start_time=start_time, duration=duration\n)\nstart_time += duration\nreturn plan\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.encode","title":"<code>encode()</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self):\nraise NotImplementedError\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.get_seq","title":"<code>get_seq(x)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_seq(x):\nraise NotImplementedError\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder","title":"<code>PlanOneHotEncoder</code>","text":"<p>             Bases: <code>PlanEncoder</code></p>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.activity_encoder_class","title":"<code>activity_encoder_class = StringIntEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.encode","title":"<code>encode(plan)</code>","text":"<p>Encode a PAM plan into a 2D numpy boolean array, where the row indicates the activity and the column indicates the minute of the day.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plan: Plan) -&gt; np.array:\n\"\"\"Encode a PAM plan into a 2D numpy boolean array,\n    where the row indicates the activity\n    and the column indicates the minute of the day.\n    \"\"\"\nduration = int((plan.day[-1].end_time - START_OF_DAY) / td(minutes=1))\nencoded = np.zeros(shape=(len(self.activity_encoder.labels), duration), dtype=bool)\nfor act in plan.day:\nstart_minute = int((act.start_time - START_OF_DAY) / td(minutes=1))\nend_minute = int((act.end_time - START_OF_DAY) / td(minutes=1))\nidx = self.activity_encoder.encode(act.act)\nencoded[idx, start_minute:end_minute] = True\nreturn encoded\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.get_seq","title":"<code>get_seq(x)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_seq(x):\nreturn x.argmax(axis=0)\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansCharacterEncoder","title":"<code>PlansCharacterEncoder</code>","text":"<p>             Bases: <code>PlansEncoder</code></p>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansCharacterEncoder.plans_encoder_class","title":"<code>plans_encoder_class = PlanCharacterEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder","title":"<code>PlansEncoder(activity_classes)</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, activity_classes: set) -&gt; None:\nself.plan_encoder = self.plans_encoder_class(labels=activity_classes)\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder.dtype","title":"<code>dtype = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder.plan_encoder","title":"<code>plan_encoder = self.plans_encoder_class(labels=activity_classes)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder.plans_encoder_class","title":"<code>plans_encoder_class = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder.encode","title":"<code>encode(plans)</code>","text":"<p>Encode all plans to a stacked numpy array.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plans: List[Plan]) -&gt; np.ndarray:\n\"\"\"Encode all plans to a stacked numpy array.\"\"\"\nplans_encoded = np.stack([self.plan_encoder.encode(x) for x in plans])\nreturn plans_encoded\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansOneHotEncoder","title":"<code>PlansOneHotEncoder</code>","text":"<p>             Bases: <code>PlansEncoder</code></p> <p>Encode plans to a 3D numpy array, where the first axis indicates the person, the second indicates the activity, and the third indicates the minute of the day.</p>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansOneHotEncoder.plans_encoder_class","title":"<code>plans_encoder_class = PlanOneHotEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.StringCharacterEncoder","title":"<code>StringCharacterEncoder</code>","text":"<p>             Bases: <code>Encoder</code></p> <p>Encodes strings as single characters.</p>"},{"location":"api/planner/encoder/#pam.planner.encoder.StringCharacterEncoder.get_mapping","title":"<code>get_mapping(labels)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_mapping(labels: List[str]) -&gt; dict:\nencoded = {}\nfor i, act in enumerate(labels):\nencoded[act] = chr(i + 65)\nreturn encoded\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.StringIntEncoder","title":"<code>StringIntEncoder</code>","text":"<p>             Bases: <code>Encoder</code></p> <p>Encodes strings as integers.</p>"},{"location":"api/planner/encoder/#pam.planner.encoder.StringIntEncoder.get_mapping","title":"<code>get_mapping(labels)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_mapping(labels: List[str]) -&gt; dict:\nencoded = {label: i for i, label in enumerate(labels)}\nreturn encoded\n</code></pre>"},{"location":"api/planner/od/","title":"pam.planner.od","text":"<p>Manages origin-destination data required by the planner module.</p>"},{"location":"api/planner/od/#pam.planner.od.Labels","title":"<code>Labels</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Data labels for the origin-destination dataset.</p>"},{"location":"api/planner/od/#pam.planner.od.Labels.destination_zones","title":"<code>destination_zones: list</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.Labels.mode","title":"<code>mode: list</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.Labels.origin_zones","title":"<code>origin_zones: list</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.Labels.vars","title":"<code>vars: list</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.OD","title":"<code>OD(data, labels)</code>","text":"<p>Holds origin-destination matrices for a number of modes and variables.</p> PARAMETER  DESCRIPTION <code>data</code> <p>A multi-dimensional numpy array of the origin-destination data. - First dimension: variable (ie travel time, distance, etc) - Second dimension: origin zone - Third dimension: destination zone - Fourth dimension: mode (ie car, bus, etc)</p> <p> TYPE: <code>ndarray</code> </p> <code>labels</code> <p> TYPE: <code>Union[Labels, list, dict]</code> </p> Source code in <code>pam/planner/od.py</code> <pre><code>def __init__(self, data: np.ndarray, labels: Union[Labels, list, dict]) -&gt; None:\n\"\"\"\n    Args:\n        data (np.ndarray):\n            A multi-dimensional numpy array of the origin-destination data.\n            - First dimension: variable (ie travel time, distance, etc)\n            - Second dimension: origin zone\n            - Third dimension: destination zone\n            - Fourth dimension: mode (ie car, bus, etc)\n        labels (Union[Labels, list, dict]):\n    \"\"\"\nself.data = data\nself.labels = self.parse_labels(labels)\nself.data_checks()\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.OD.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.OD.labels","title":"<code>labels = self.parse_labels(labels)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.OD.data_checks","title":"<code>data_checks()</code>","text":"<p>Check the integrity of input data and labels.</p> Source code in <code>pam/planner/od.py</code> <pre><code>def data_checks(self):\n\"\"\"Check the integrity of input data and labels.\"\"\"\nassert (\nself.data.ndim == 4\n), \"The number of matrix dimensions should be 4 (mode, variable, origin, destination)\"\nfor i, (key, labels) in enumerate(zip(self.labels._fields, self.labels)):\nassert len(labels) == self.data.shape[i], (\nf\"The number of {key} labels should match the number of elements\"\nf\"in dimension {i} of the OD dataset\"\n)\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.OD.parse_labels","title":"<code>parse_labels(labels)</code>  <code>staticmethod</code>","text":"<p>Parse labels as a named tuple.</p> Source code in <code>pam/planner/od.py</code> <pre><code>@staticmethod\ndef parse_labels(labels: Union[Labels, list, dict]) -&gt; Labels:\n\"\"\"Parse labels as a named tuple.\"\"\"\nif not isinstance(labels, Labels):\nif isinstance(labels, list):\nreturn Labels(*labels)\nelif isinstance(labels, dict):\nreturn Labels(**labels)\nelse:\nraise ValueError(\"Please provide a valid label type\")\nreturn labels\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.ODFactory","title":"<code>ODFactory</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODFactory.check","title":"<code>check(matrices, labels)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/od.py</code> <pre><code>@staticmethod\ndef check(matrices: list[ODMatrix], labels: Labels) -&gt; None:\n# all matrices follow the same zoning system and are equal size\nfor mat in matrices:\nassert mat.origin_zones == labels.origin_zones, \"Please check zone labels\"\nassert mat.destination_zones == labels.destination_zones, \"Please check zone labels\"\nassert mat.matrix.shape == matrices[0].matrix.shape, \"Please check matrix dimensions\"\n# all possible combinations are provided\ncombinations_matrices = [(var, trmode) for (var, trmode, *others) in matrices]\ncombinations_labels = list(itertools.product(labels.vars, labels.mode))\nfor combination in combinations_labels:\nassert (\ncombination in combinations_matrices\n), f\"Combination {combination} missing from the input matrices\"\n# no duplicate combinations\nassert len(combinations_matrices) == len(\nset(combinations_matrices)\n), \"No duplicate keys are allowed\"\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.ODFactory.from_matrices","title":"<code>from_matrices(matrices)</code>  <code>classmethod</code>","text":"<p>Creates an OD instance from a list of ODMatrices.</p> Source code in <code>pam/planner/od.py</code> <pre><code>@classmethod\ndef from_matrices(cls, matrices: list[ODMatrix]) -&gt; OD:\n\"\"\"Creates an OD instance from a list of ODMatrices.\"\"\"\n# collect dimensions\nlabels = cls.prepare_labels(matrices)\ncls.check(matrices, labels)\n# create ndarray\nod = np.zeros(shape=[len(x) for x in labels])\nfor mat in matrices:\nod[labels.vars.index(mat.var), :, :, labels.mode.index(mat.mode)] = mat.matrix\nreturn OD(data=od, labels=labels)\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.ODFactory.prepare_labels","title":"<code>prepare_labels(matrices)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/od.py</code> <pre><code>@staticmethod\ndef prepare_labels(matrices: list[ODMatrix]) -&gt; Labels:\nlabels = Labels(\nvars=list(pd.unique([mat.var for mat in matrices])),\norigin_zones=matrices[0].origin_zones,\ndestination_zones=matrices[0].destination_zones,\nmode=list(pd.unique([mat.mode for mat in matrices])),\n)\nreturn labels\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.ODMatrix","title":"<code>ODMatrix</code>","text":"<p>             Bases: <code>NamedTuple</code></p>"},{"location":"api/planner/od/#pam.planner.od.ODMatrix.destination_zones","title":"<code>destination_zones: tuple</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODMatrix.matrix","title":"<code>matrix: np.array</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODMatrix.mode","title":"<code>mode: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODMatrix.origin_zones","title":"<code>origin_zones: tuple</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODMatrix.var","title":"<code>var: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/utils_planner/","title":"pam.planner.utils_planner","text":""},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.apply_mode_to_home_chain","title":"<code>apply_mode_to_home_chain(act, trmode)</code>","text":"<p>Apply a transport mode across a home-based trip chain, which comprises the specified activity.</p> PARAMETER  DESCRIPTION <code>act</code> <p>The activity that is part of the trip chain.</p> <p> TYPE: <code>Activity</code> </p> <code>trmode</code> <p>The mode to apply to each leg of the chain.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def apply_mode_to_home_chain(act: Activity, trmode: str) -&gt; None:\n\"\"\"Apply a transport mode across a home-based trip chain,\n    which comprises the specified activity.\n    Args:\n        act (Activity): The activity that is part of the trip chain.\n        trmode (str): The mode to apply to each leg of the chain.\n    \"\"\"\nif \"next\" not in act.__dict__:\nraise KeyError(\n\"Plan is not linked. Please use `pam.operations.cropping.link_plan` to link activities and legs.\"\n)\n# apply forwards\nelem = act.next\nwhile (elem is not None) and (elem.act != \"home\"):\nif isinstance(elem, Leg):\nelem.mode = trmode\nelem = elem.next\n# apply backwards\nelem = act.previous\nwhile (elem is not None) and (elem.act != \"home\"):\nif isinstance(elem, Leg):\nelem.mode = trmode\nelem = elem.previous\n</code></pre>"},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.calculate_mnl_probabilities","title":"<code>calculate_mnl_probabilities(x)</code>","text":"<p>Calculates MNL probabilities from a set of alternatives.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def calculate_mnl_probabilities(x: Union[np.array, List]) -&gt; np.array:\n\"\"\"Calculates MNL probabilities from a set of alternatives.\"\"\"\nreturn np.exp(x) / np.exp(x).sum()\n</code></pre>"},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.get_trip_chains","title":"<code>get_trip_chains(plan, act='home')</code>","text":"<p>Get trip chains starting and/or ending at a long-term activity.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def get_trip_chains(plan: Plan, act: str = \"home\") -&gt; List[List[Union[Activity, Leg]]]:\n\"\"\"Get trip chains starting and/or ending at a long-term activity.\"\"\"\nchains = []\nchain = []\nfor elem in plan.day:\nif isinstance(elem, Activity) and elem.act == act:\nif len(chain) &gt; 0:\nchains.append(chain + [elem])\nchain = []\nchain.append(elem)\nif len(chain) &gt; 1:\nchains += [chain]  # add any remaining trips until the end of the day\nreturn chains\n</code></pre>"},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.get_validate","title":"<code>get_validate(obj, name)</code>","text":"<p>Get an object's attribute, or raise an error if its value is None.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def get_validate(obj, name: str):\n\"\"\"Get an object's attribute, or raise an error if its value is None.\"\"\"\nattr = getattr(obj, name)\nif attr is None:\nraise ValueError(f\"Attribute {name} has not been set yet\")\nreturn attr\n</code></pre>"},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.sample_weighted","title":"<code>sample_weighted(weights)</code>","text":"<p>Weighted sampling. Returns the index of the selection.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def sample_weighted(weights: np.array) -&gt; int:\n\"\"\"Weighted sampling.\n    Returns the index of the selection.\n    \"\"\"\nreturn random.choices(range(len(weights)), weights=weights, k=1)[0]\n</code></pre>"},{"location":"api/planner/zones/","title":"pam.planner.zones","text":"<p>Manages zone-level data required by the planner module.</p>"},{"location":"api/planner/zones/#pam.planner.zones.Zones","title":"<code>Zones(data)</code>","text":"PARAMETER  DESCRIPTION <code>data</code> <p>A dataframe with variables as columns and the zone as index</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>pam/planner/zones.py</code> <pre><code>def __init__(self, data: pd.DataFrame) -&gt; None:\n\"\"\"\n    Args:\n        data (pd.DataFrame): A dataframe with variables as columns and the zone as index\n    \"\"\"\nself.data = data\n</code></pre>"},{"location":"api/planner/zones/#pam.planner.zones.Zones.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"api/plot/plans/","title":"pam.plot.plans","text":""},{"location":"api/plot/plans/#pam.plot.plans.build_cmap","title":"<code>build_cmap(df)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def build_cmap(df):\ncolors = plt.cm.Set3.colors[::-1]\nactivities_unique = df[\"act\"].unique()\n# repeat colours if unique items &gt; 1\nlen_factor = (len(activities_unique) // len(colors)) + 1\nd_color = dict(zip(activities_unique, colors * len_factor))\nd_color[\"Travel\"] = (0.3, 0.3, 0.3)\nreturn d_color\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.build_person_df","title":"<code>build_person_df(person)</code>","text":"<p>Loop through a persons plan, creating a pandas dataframe defining activities for plotting.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def build_person_df(person):\n\"\"\"Loop through a persons plan, creating a pandas dataframe defining activities for plotting.\"\"\"\ndata = {\"act\": [], \"modes\": [], \"start_time\": [], \"end_time\": [], \"dur\": []}\nfor component in person.plan.day:\ndata[\"act\"].append(component.act.lower().title())\nif isinstance(component, activity.Leg):\ndata[\"modes\"].append(component.mode.lower().title())\nelse:\ndata[\"modes\"].append(None)\ndata[\"start_time\"].append(component.start_time.hour + component.start_time.minute / 60)\ndata[\"end_time\"].append(component.end_time.hour + component.end_time.minute / 60)\ndata[\"dur\"].append(component.duration.total_seconds() / 3600)\ndf = pd.DataFrame(data)\ndf[\"pid\"] = person.pid\nreturn df\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.build_person_travel_geodataframe","title":"<code>build_person_travel_geodataframe(person, from_epsg=None, to_epsg=None)</code>","text":"<p>Loop through a persons legs, creating a geopandas GeoDataFrame defining travel for plotting.</p> PARAMETER  DESCRIPTION <code>person</code> <p> TYPE: <code>Person</code> </p> <code>from_epsg</code> <p>coordinate system the plans are currently in. You need to specify <code>from_epsg</code> as well to use this. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>to_epsg</code> <p>coordinate system you want the geo dataframe to be projected to. You need to specify <code>from_epsg</code> as well to use this. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>geographically pinpointed travel legs for given <code>person</code>.</p> <p> TYPE: <code>GeoDataFrame</code> </p> Source code in <code>pam/plot/plans.py</code> <pre><code>def build_person_travel_geodataframe(\nperson: Person, from_epsg: Optional[str] = None, to_epsg: Optional[str] = None\n) -&gt; GeoDataFrame:\n\"\"\"Loop through a persons legs, creating a geopandas GeoDataFrame defining travel for plotting.\n    Args:\n      person (pam.core.Person):\n      from_epsg (str, optional):\n        coordinate system the plans are currently in.\n        You need to specify `from_epsg` as well to use this. Defaults to None.\n      to_epsg (str, optional):\n        coordinate system you want the geo dataframe to be projected to.\n        You need to specify `from_epsg` as well to use this. Defaults to None.\n    Returns:\n        GeoDataFrame: geographically pinpointed travel legs for given `person`.\n    \"\"\"\ndf = pd.DataFrame()\nfor leg in person.legs:\nif (leg.start_location.loc is None) or (leg.end_location.loc is None):\nraise AttributeError(\n\"\"\"\nTo create a geopandas.DataFrame you need specific locations. Make sure Legs have\nloc attribute defined with a shapely.Point or s2sphere.CellId.\n\"\"\"\n)\ngeometry = utils.get_linestring(leg.start_location.loc, leg.end_location.loc)\n_leg_dict = {\n\"mode\": leg.mode,\n\"purp\": leg.purp,\n\"seq\": leg.seq,\n\"freq\": leg.freq,\n\"start_time\": leg.start_time,\n\"end_time\": leg.end_time,\n\"start_location\": geometry.coords[0],\n\"end_location\": geometry.coords[-1],\n\"geometry\": geometry,\n\"distance\": leg.distance,\n\"service_id\": leg.route.transit.get(\"transitLineId\"),\n\"route_id\": leg.route.transit.get(\"transitRouteId\"),\n\"o_stop\": leg.route.transit.get(\"accessFacilityId\"),\n\"d_stop\": leg.route.transit.get(\"egressFacilityId\"),\n\"network_route\": leg.route.network_route,\n}\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\"ignore\", category=ShapelyDeprecationWarning)\ndf = pd.concat([df, pd.Series(_leg_dict)], ignore_index=True, axis=1)\ndf = df.T\ndf[\"pid\"] = person.pid\ndf = GeoDataFrame(df, geometry=\"geometry\")\nif from_epsg:\ndf.crs = from_epsg\nif to_epsg:\ndf = df.to_crs(to_epsg)\nreturn df\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.build_plan_df","title":"<code>build_plan_df(plan, pid='sample')</code>","text":"<p>Loop through a plan, creating a pandas dataframe defining activities for plotting.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def build_plan_df(plan, pid=\"sample\"):\n\"\"\"Loop through a plan, creating a pandas dataframe defining activities for plotting.\"\"\"\ndata = {\"act\": [], \"modes\": [], \"start_time\": [], \"end_time\": [], \"dur\": []}\nfor component in plan.day:\ndata[\"act\"].append(component.act.lower().title())\nif isinstance(component, activity.Leg) and component.mode is not None:\ndata[\"modes\"].append(component.mode.lower().title())\nelse:\ndata[\"modes\"].append(None)\ndata[\"start_time\"].append(component.start_time.hour + component.start_time.minute / 60)\ndata[\"end_time\"].append(component.end_time.hour + component.end_time.minute / 60)\ndata[\"dur\"].append(component.duration.total_seconds() / 3600)\ndf = pd.DataFrame(data)\ndf[\"pid\"] = pid\nreturn df\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.build_rgb_travel_cmap","title":"<code>build_rgb_travel_cmap(df, colour_by)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def build_rgb_travel_cmap(df, colour_by):\ncolors = [\n(int(tup[0] * 255), int(tup[1] * 255), int(tup[2] * 255))\nfor tup in plt.cm.Set3.colors[::-1]\n]\ncolour_by_unique = df[colour_by].unique()\n# repeat colours if unique items &gt; 12\nlen_factor = (len(colour_by_unique) // len(colors)) + 1\nd_color = dict(zip(colour_by_unique, colors * len_factor))\nreturn d_color\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_activities","title":"<code>plot_activities(df, **kwargs)</code>","text":"<p>Plot activity plans from pandas dataframe.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_activities(df, **kwargs):\n\"\"\"Plot activity plans from pandas dataframe.\"\"\"\nif \"cmap\" not in kwargs:\ncmap = build_cmap(df)\nelse:\ncmap = kwargs[\"cmap\"]\ndf[\"color\"] = df[\"act\"].map(cmap)\npids = df[\"pid\"].unique()\nfig, axs = plt.subplots(\nlen(pids),\n1,\nfigsize=(16, 3 + (1 * (len(pids) - 1))),\nsharex=True,  # fudge to keep proportions about right\n)\nfor idx, pid in enumerate(pids):\nperson_data = df.loc[df.pid == pid]\nlabel_x, label_y, labels = [], [], []\nif len(pids) == 1:\nax = axs\nelse:\nax = axs[idx]\nfor i in range(len(person_data)):\ny = 1\ndata = person_data.iloc[i]\nax.barh(\ny,\nwidth=\"dur\",\ndata=data,\nleft=\"start_time\",\nlabel=\"act\",\ncolor=\"color\",\nedgecolor=\"black\",\nlinewidth=2,\n)\n# Populate Labelling Params\nlabel_x.append(data[\"start_time\"] + data[\"dur\"] / 2)\nlabel_y.append(y)\nlabels.append(data.act)\n# Labels\nrects = ax.patches\nfor x, y, rect, label in zip(label_x, label_y, rects, labels):\nif label == \"Travel\":\ncolor = \"white\"\nelse:\ncolor = \"black\"\nif rect.get_width() &gt;= 2:\nax.text(\nx,\ny,\nlabel,\nha=\"center\",\nva=\"center\",\nfontdict={\"color\": color, \"size\": 10, \"weight\": \"regular\"},\n)\ncontinue\nif rect.get_width() &gt;= 0.5:\nax.text(\nx,\ny,\nlabel,\nha=\"center\",\nva=\"center\",\nfontdict={\"color\": color, \"size\": 10, \"weight\": \"regular\", \"rotation\": 90},\n)\nax.set_title(f\"Person ID: {pid}\")\nax.get_yaxis().set_visible(False)\nfor side in [\"top\", \"right\", \"bottom\", \"left\"]:\nax.spines[side].set_visible(False)\nif kwargs.get(\"legend\", True) is True:\nlegend_elements = []\nfor act, color in cmap.items():\nlegend_elements.append(Patch(facecolor=color, edgecolor=\"black\", label=act))\nplt.legend(\nhandles=legend_elements,\nncol=len(legend_elements),\nprop={\"size\": 12},\nframeon=False,\nbbox_to_anchor=(0.5, -0.5),\nloc=\"upper center\",\nborderaxespad=0.0,\n)\nplt.xticks(range(25))\nplt.xlim(right=24)\nplt.tight_layout()\nif kwargs.get(\"path\") is not None:\nplt.savefig(kwargs[\"path\"])\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_activity_breakdown_area","title":"<code>plot_activity_breakdown_area(plans, activity_classes=None, plans_encoder=None, normalize=False, legend=True, ax=None, colormap='tab20')</code>","text":"<p>Area plot of the breakdown of activities taking place every minute.</p> PARAMETER  DESCRIPTION <code>plans</code> <p>A list of PAM plans.</p> <p> TYPE: <code>List[Plan]</code> </p> <code>activity_classes</code> <p>A list of the activity labels to encode a plan from. Defaults to None.</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>plans_encoder</code> <p>A pre-encoded plan; alternative to passing <code>activity_classes</code>. Defaults to None.</p> <p> TYPE: <code>Optional[type[PlanEncoder]]</code> DEFAULT: <code>None</code> </p> <code>normalize</code> <p>Whether to convert the y-axis to percentages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>legend</code> <p>Whether to include the legend of activities in the plot. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>ax</code> <p>A matplotlib axis; if not given, a new one will be generated. Defaults to None.</p> <p> TYPE: <code>Optional[Axes]</code> DEFAULT: <code>None</code> </p> <code>colormap</code> <p>The colormap to use in the plot. Defaults to \"tab20\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'tab20'</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>One of <code>activity_classes</code> or <code>plans_encoder</code> must be defined.</p> RETURNS DESCRIPTION <code>Axes</code> <p>plt.Axes: plot object.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_activity_breakdown_area(\nplans: List[Plan],\nactivity_classes: Optional[List[str]] = None,\nplans_encoder: Optional[type[encoder.PlanEncoder]] = None,\nnormalize: bool = False,\nlegend: bool = True,\nax: Optional[plt.Axes] = None,\ncolormap: str = \"tab20\",\n) -&gt; plt.Axes:\n\"\"\"\n    Area plot of the breakdown of activities taking place every minute.\n    Args:\n        plans (List[Plan]): A list of PAM plans.\n        activity_classes (Optional[List[str]], optional): A list of the activity labels to encode a plan from. Defaults to None.\n        plans_encoder (Optional[type[encoder.PlanEncoder]], optional): A pre-encoded plan; alternative to passing `activity_classes`. Defaults to None.\n        normalize (bool, optional): Whether to convert the y-axis to percentages. Defaults to False.\n        legend (bool, optional): Whether to include the legend of activities in the plot. Defaults to True.\n        ax (Optional[plt.Axes], optional): A matplotlib axis; if not given, a new one will be generated. Defaults to None.\n        colormap (str, optional): The colormap to use in the plot. Defaults to \"tab20\".\n    Raises:\n        ValueError: One of `activity_classes` or `plans_encoder` must be defined.\n    Returns:\n        plt.Axes: plot object.\n    \"\"\"\nif activity_classes is not None:\nplans_encoder = encoder.PlansOneHotEncoder(activity_classes=activity_classes)\nelif plans_encoder is None:\nraise ValueError(\"Please provide a list of activity classes or a plans encoder.\")\nlabels = plans_encoder.plan_encoder.activity_encoder.labels\nfreqs = plans_encoder.encode(plans).sum(axis=0)\nif normalize:\nfreqs = freqs.astype(float) / freqs.sum(0)\nif ax is None:\nfig, ax = plt.subplots(1, 1)\nn_labels = len(labels)\ncmap = matplotlib.colormaps[colormap]\ncolors = [cmap(x) for x in range(n_labels)]\nax.stackplot(range(freqs.shape[1]), *freqs, colors=colors)\nif legend:\nax.legend(labels, loc=\"lower left\", bbox_to_anchor=(1.0, 0), frameon=False)\nif normalize:\nax.yaxis.set_major_formatter(mtick.FuncFormatter(lambda x, _: \"{:.0%}\".format(x)))\nax.set_xlim(0, freqs.shape[1])\nax.set_ylim(0, freqs.sum(0).max())\nreturn ax\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_activity_breakdown_area_tiles","title":"<code>plot_activity_breakdown_area_tiles(plans, activity_classes, figsize=(10, 8), **kwargs)</code>","text":"<p>Tiled area plot of the breakdown of activities taking place every minute.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_activity_breakdown_area_tiles(\nplans: Dict[List[Plan]], activity_classes: List[str], figsize=(10, 8), **kwargs\n):\n\"\"\"Tiled area plot of the breakdown of activities taking place every minute.\"\"\"\nplans_encoder = encoder.PlansOneHotEncoder(activity_classes=activity_classes)\nlabels = plans_encoder.plan_encoder.activity_encoder.labels\nnrows = int(np.ceil(len(plans) / 2))\nirow = 0\nicol = 0\nfig, axs = plt.subplots(nrows, 2, figsize=figsize, sharex=True, sharey=True)\nfig.tight_layout(pad=2)\nfor k, v in plans.items():\nn = len(v)\nif nrows &gt; 1:\nax = axs[irow, icol]\nelse:\nax = axs[icol]\nprint(ax)\nplot_activity_breakdown_area(\nplans=v, ax=ax, legend=False, normalize=True, plans_encoder=plans_encoder, **kwargs\n)\nax.set_title(f\"Cluster {k} - {n} plans\")\nirow += icol\nicol = (icol + 1) % 2\nax.legend(labels, loc=\"lower left\", bbox_to_anchor=(1.0, 0), frameon=False)\nreturn axs\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_household","title":"<code>plot_household(household, **kwargs)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_household(household, **kwargs):\ndf = pd.concat([build_person_df(person) for person in household.people.values()])\nplot_activities(df, **kwargs)\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_person","title":"<code>plot_person(person, **kwargs)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_person(person, **kwargs):\ndf = build_person_df(person)\nplot_activities(df, **kwargs)\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_persons","title":"<code>plot_persons(persons, kwargs=None)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_persons(persons, kwargs=None):\ndf = pd.concat([build_person_df(person) for person in persons])\nplot_activities(df, **kwargs)\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_plan","title":"<code>plot_plan(plan, kwargs=None)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_plan(plan, kwargs=None):\ndf = build_plan_df(plan)\nif kwargs is not None:\nplot_activities(df, **kwargs)\nelse:\nplot_activities(df)\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_travel_plans","title":"<code>plot_travel_plans(gdf, groupby=None, colour_by='mode', cmap=None, mapbox_access_token='')</code>","text":"<p>Uses plotly's Scattermapbox to plot travel GeoDataFrame.</p> PARAMETER  DESCRIPTION <code>gdf</code> <p>Ouptut of <code>build_person_travel_geodataframe</code>.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>groupby</code> <p>List of column names to group together into different plotly <code>traces</code>. Defaults to None.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>colour_by</code> <p>The <code>gdf</code> column that should be used to define colours in the plot. Defaults to \"mode\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'mode'</code> </p> <code>cmap</code> <p>Useful to pass if generating a number of plots and want to keep colour scheme. Defaults to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>mapbox_access_token</code> <p>required to generate the plot. See https://docs.mapbox.com/help/how-mapbox-works/access-tokens/ Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <p>Returns:     go.Figure: plotly figure object</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_travel_plans(\ngdf: GeoDataFrame,\ngroupby: Optional[list] = None,\ncolour_by: str = \"mode\",\ncmap: Optional[dict] = None,\nmapbox_access_token: str = \"\",\n) -&gt; go.Figure:\n\"\"\"Uses plotly's Scattermapbox to plot travel GeoDataFrame.\n    Args:\n      gdf (GeoDataFrame): Ouptut of `build_person_travel_geodataframe`.\n      groupby (list, optional): List of column names to group together into different plotly `traces`. Defaults to None.\n      colour_by (str, optional): The `gdf` column that should be used to define colours in the plot. Defaults to \"mode\".\n      cmap (dict, optional): Useful to pass if generating a number of plots and want to keep colour scheme. Defaults to None.\n      mapbox_access_token (str, optional):\n        required to generate the plot. See https://docs.mapbox.com/help/how-mapbox-works/access-tokens/\n        Defaults to \"\".\n    Returns:\n        go.Figure: plotly figure object\n    \"\"\"\nif not mapbox_access_token:\nraise Warning(\"You need to pass `mapbox_access_token` for the plot to appear.\")\n_gdf = gdf.copy()\n_gdf[\"start_time\"] = _gdf[\"start_time\"].dt.strftime(\"%H:%M:%S\")\n_gdf[\"end_time\"] = _gdf[\"end_time\"].dt.strftime(\"%H:%M:%S\")\n_gdf[\"seq\"] = _gdf[\"seq\"].astype(int)\nif cmap is None:\ncmap = build_rgb_travel_cmap(gdf, colour_by)\ndata = []\nall_coords = []\nif groupby is None:\ngroupby = []\nto_group = colour_by\nelse:\nto_group = [colour_by] + groupby\nfor name, group in _gdf.groupby(to_group):\nif len(groupby) &gt; 0:\ncolour_by_item = name[0]\nelse:\ncolour_by_item = name\ncolour = \"rgb({},{},{})\".format(\ncmap[colour_by_item][0], cmap[colour_by_item][1], cmap[colour_by_item][2]\n)\nlat = []\nlon = []\nhovertext = []\nfor idx in group.index:\ncoords = group.loc[idx, \"geometry\"].coords\nall_coords.extend(coords)\nlat = lat + [point[1] for point in coords] + [float(\"nan\")]\nlon = lon + [point[0] for point in coords] + [float(\"nan\")]\n_hovertext = [\"\"] * (len(coords) + 1)\n_hovertext[0] = \"pid: {}&lt;br&gt;start time: {}&lt;br&gt;trip seq: {}&lt;br&gt;mode: {}\".format(\ngroup.loc[idx, \"pid\"],\ngroup.loc[idx, \"start_time\"],\ngroup.loc[idx, \"seq\"],\ngroup.loc[idx, \"mode\"],\n)\n_hovertext[-2] = \"pid: {}&lt;br&gt;end time: {}&lt;br&gt;trip seq: {}&lt;br&gt;mode: {}\".format(\ngroup.loc[idx, \"pid\"],\ngroup.loc[idx, \"end_time\"],\ngroup.loc[idx, \"seq\"],\ngroup.loc[idx, \"mode\"],\n)\nhovertext = hovertext + _hovertext\ndata.append(\ngo.Scattermapbox(\nlat=lat,\nlon=lon,\nhovertext=hovertext,\nhoverinfo=\"text\",\nmode=\"lines+markers\",\nmarker=dict(size=10, color=colour, opacity=0.75),\nline=dict(color=colour),\nname=\"{}\".format(name),\n)\n)\nif all_coords:\nc_lat = sum([point[1] for point in all_coords]) / len(all_coords)\nc_lon = sum([point[0] for point in all_coords]) / len(all_coords)\nelse:\nc_lat = 0\nc_lon = 0\nlayout = go.Layout(\ntitle=\"\",\nautosize=True,\nhovermode=\"closest\",\nmapbox=go.layout.Mapbox(\naccesstoken=mapbox_access_token,\nbearing=0,\ncenter=go.layout.mapbox.Center(lat=c_lat, lon=c_lon),\npitch=0,\nzoom=10,\nstyle=\"dark\",\n),\n)\nfig = go.Figure(data=data, layout=layout)\nreturn fig\n</code></pre>"},{"location":"api/plot/stats/","title":"pam.plot.stats","text":""},{"location":"api/plot/stats/#pam.plot.stats.calculate_activity_duration_by_act","title":"<code>calculate_activity_duration_by_act(population, exclude=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_activity_duration_by_act(population, exclude=None):\nall_activities = []\nfor hid, pid, person in population.people():\nfor seq, activity in enumerate(person.activities):\nall_activities.append(\n{\n\"act\": activity.act,\n\"duration_hours\": activity.duration.days * 24\n+ activity.duration.seconds / 3600,\n}\n)\nall_activities_df = pd.DataFrame(all_activities)\noutputs_df = all_activities_df.groupby(\"act\", as_index=False).agg({\"duration_hours\": \"sum\"})\noutputs_df.insert(0, \"scenario\", population.name, True)\nif exclude is not None:\noutputs_df = outputs_df[outputs_df.act != exclude]\nreturn outputs_df\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.calculate_leg_duration_by_mode","title":"<code>calculate_leg_duration_by_mode(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_leg_duration_by_mode(population):\nall_legs = []\nfor hid, pid, person in population.people():\nfor seq, leg in enumerate(person.legs):\nall_legs.append(\n{\n\"leg mode\": leg.mode,\n\"duration_hours\": leg.duration.days * 24 + leg.duration.seconds / 3600,\n}\n)\nall_legs_df = pd.DataFrame(all_legs)\noutputs_df = all_legs_df.groupby(\"leg mode\", as_index=False).agg({\"duration_hours\": \"sum\"})\noutputs_df.insert(0, \"scenario\", population.name, True)\nreturn outputs_df\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.calculate_total_activity_duration","title":"<code>calculate_total_activity_duration(population, exclude=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_total_activity_duration(population, exclude=None):\ntotal_activity_duration = timedelta(minutes=0)\nfor hid, pid, person in population.people():\nfor seq, activity in enumerate(person.activities):\nif activity.act != exclude:\ntotal_activity_duration = total_activity_duration + activity.duration\ntotal_activity_duration_hours = (\ntotal_activity_duration.days * 24 + total_activity_duration.seconds / 3600\n)\nreturn total_activity_duration_hours\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.calculate_total_leg_duration","title":"<code>calculate_total_leg_duration(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_total_leg_duration(population):\ntotal_leg_duration = timedelta(minutes=0)\nfor hid, pid, person in population.people():\nfor seq, leg in enumerate(person.legs):\ntotal_leg_duration = total_leg_duration + leg.duration\ntotal_leg_duration_hours = total_leg_duration.days * 24 + total_leg_duration.seconds / 3600\nreturn total_leg_duration_hours\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.extract_activity_log","title":"<code>extract_activity_log(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def extract_activity_log(population):\nlog = []\nfor hid, pid, person in population.people():\nfor activity in person.activities:\nlog.append(\n{\n\"act\": activity.act,\n\"start\": dt_to_s(activity.start_time),\n\"end\": dt_to_s(activity.end_time),\n\"duration\": td_to_s(activity.duration),\n}\n)\nreturn pd.DataFrame(log)\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.extract_leg_log","title":"<code>extract_leg_log(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def extract_leg_log(population):\nlog = []\nfor hid, pid, person in population.people():\nfor leg in person.legs:\nlog.append(\n{\n\"mode\": leg.mode,\n\"start\": dt_to_s(leg.start_time),\n\"end\": dt_to_s(leg.end_time),\n\"duration\": td_to_s(leg.duration),\n}\n)\nreturn pd.DataFrame(log)\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_activity_duration","title":"<code>plot_activity_duration(list_of_populations, exclude=None, axis=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_activity_duration(list_of_populations, exclude=None, axis=None):\nx = []\ny = []\nfor idx, population in enumerate(list_of_populations):\nx.append(population.name)\ny.append(calculate_total_activity_duration(population, exclude))\noutputs_df = pd.DataFrame({\"scenario\": x, \"activity duration (hours)\": y})\nx_label_rotation = 90\nif exclude is not None:\ntitle = \"activities (excl \" + exclude + \")\"\nelse:\ntitle = \"activities\"\nif axis is None:\nplt.bar(x, y)\nplt.xticks(rotation=x_label_rotation)\nplt.ylabel(\"duration (hours)\")\nplt.title(title)\nplt.show\nelse:\naxis.bar(x, y)\naxis.plot()\naxis.set_title(title)\naxis.xaxis.set_label(\"\")\naxis.xaxis.set_ticks(x)\naxis.xaxis.set_ticklabels(x, rotation=x_label_rotation)\nreturn outputs_df\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_activity_duration_by_act","title":"<code>plot_activity_duration_by_act(list_of_populations, exclude=None, axis=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_activity_duration_by_act(list_of_populations, exclude=None, axis=None):\npopulation_act_df = pd.DataFrame()\nfor idx, population in enumerate(list_of_populations):\npopulation_act_df = pd.concat(\n[population_act_df, calculate_activity_duration_by_act(population, exclude)],\nignore_index=True,\n)\npivot_for_chart = population_act_df.pivot(\nindex=\"scenario\", columns=\"act\", values=\"duration_hours\"\n)\nif exclude is not None:\ntitle = \"activities by type (excl \" + exclude + \")\"\nelse:\ntitle = \"activities by type\"\nif axis is None:\npivot_for_chart.plot.bar(stacked=True)\nplt.ylabel(\"duration (hours)\")\nplt.title(title)\nplt.show\nelse:\npivot_for_chart.plot.bar(stacked=True, ax=axis)\naxis.set_xlabel(\"\")\naxis.set_title(title)\nreturn pivot_for_chart\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_activity_times","title":"<code>plot_activity_times(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_activity_times(population):\nacts = extract_activity_log(population)\nfig = plot_time_bins(acts, sub_col=\"act\")\nreturn fig\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_leg_duration","title":"<code>plot_leg_duration(list_of_populations, axis=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_leg_duration(list_of_populations, axis=None):\nx = []\ny = []\nfor idx, population in enumerate(list_of_populations):\nx.append(population.name)\ny.append(calculate_total_leg_duration(population))\noutputs_df = pd.DataFrame({\"scenario\": x, \"leg duration (hours)\": y})\ntitle = \"legs\"\nx_label_rotation = 90\nif axis is None:\nplt.bar(x, y)\nplt.xticks(rotation=x_label_rotation)\nplt.ylabel(\"duration (hours)\")\nplt.title(title)\nelse:\naxis.bar(x, y)\naxis.plot()\naxis.set_title(title)\naxis.xaxis.set_label(\"\")\naxis.xaxis.set_ticks(x)\naxis.xaxis.set_ticklabels(x, rotation=x_label_rotation)\nreturn outputs_df\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_leg_duration_by_mode","title":"<code>plot_leg_duration_by_mode(list_of_populations, axis=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_leg_duration_by_mode(list_of_populations, axis=None):\npopulation_mode_df = pd.DataFrame()\nfor idx, population in enumerate(list_of_populations):\npopulation_mode_df = pd.concat(\n[population_mode_df, calculate_leg_duration_by_mode(population)], ignore_index=True\n)\npivot_for_chart = population_mode_df.pivot(\nindex=\"scenario\", columns=\"leg mode\", values=\"duration_hours\"\n)\ntitle = \"legs by mode\"\nif axis is None:\npivot_for_chart.plot.bar(stacked=True)\nplt.title(title)\nplt.ylabel(\"duration (hours)\")\nelse:\npivot_for_chart.plot.bar(stacked=True, ax=axis)\naxis.set_xlabel(\"\")\naxis.set_title(title)\nreturn pivot_for_chart\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_leg_times","title":"<code>plot_leg_times(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_leg_times(population):\nlegs = extract_leg_log(population)\nfig = plot_time_bins(legs, sub_col=\"mode\")\nreturn fig\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_population_comparisons","title":"<code>plot_population_comparisons(list_of_populations, activity_to_exclude=None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_population_comparisons(list_of_populations, activity_to_exclude=None):\nfig1, ax = plt.subplots(nrows=1, ncols=2, tight_layout=True, sharey=True)\nplot_leg_duration(list_of_populations, ax[0])\nleg_modes = plot_leg_duration_by_mode(list_of_populations, ax[1])\nax[0].set_ylabel(\"duration (hours)\")\nfig2, ax2 = plt.subplots(nrows=1, ncols=2, tight_layout=True, sharey=True)\nplot_activity_duration(list_of_populations, activity_to_exclude, ax2[0])\nactivity_types = plot_activity_duration_by_act(list_of_populations, activity_to_exclude, ax2[1])\nax2[0].set_ylabel(\"duration (hours)\")\nleg_modes[\"TOTAL\"] = leg_modes.sum(axis=1)\nactivity_types[\"TOTAL\"] = activity_types.sum(axis=1)\nprint(leg_modes, \"\\n\", activity_types)\nreturn fig1, fig2, leg_modes, activity_types\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_time_bins","title":"<code>plot_time_bins(data, sub_col, width=12, height_factor=1.2)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_time_bins(data, sub_col, width=12, height_factor=1.2):\nsubs = set(data[sub_col])\nfig, axs = plt.subplots(len(subs), figsize=(width, 1.2 * len(subs)), sharex=False)\nif not isinstance(axs, np.ndarray):\naxs = [axs]\nfor ax, sub in zip(axs, subs):\nbinned = time_binner(data.loc[data[sub_col] == sub])\nax.pcolormesh(binned.T, cmap=\"cool\", edgecolors=\"white\", linewidth=1)\nax.xaxis.set_ticks([i for i in range(0, 97, 8)])\nax.xaxis.set_ticklabels([f\"{h:02}:00\" for h in range(0, 25, 2)])\nax.yaxis.set_ticks([0.5, 1.5, 2.5])\nax.yaxis.set_ticklabels([\"Duration\", \"End time\", \"Start time\"])\nax.grid(which=\"minor\", color=\"w\", linestyle=\"-\", linewidth=2)\nfor pos in [\"right\", \"top\", \"bottom\", \"left\"]:\nax.spines[pos].set_visible(False)\nax.set_title(sub.title(), fontsize=\"medium\", rotation=0)\nfig.tight_layout()\nreturn fig\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.time_binner","title":"<code>time_binner(data)</code>","text":"<p>Bin start and end times and durations, return freq table for 24 hour period, 15min intervals.</p> Source code in <code>pam/plot/stats.py</code> <pre><code>def time_binner(data):\n\"\"\"Bin start and end times and durations, return freq table for 24 hour period, 15min intervals.\"\"\"\nbins = list(range(0, 24 * 60 * 60 + 1, 15 * 60))\nbins[-1] = 100 * 60 * 60\nlabels = pd.timedelta_range(start=\"00:00:00\", periods=96, freq=\"15min\")\nbinned = pd.DataFrame(index=pd.timedelta_range(start=\"00:00:00\", periods=96, freq=\"15min\"))\nbinned[\"duration\"] = pd.cut(data.duration, bins, labels=labels, right=False).value_counts()\nbinned[\"end\"] = pd.cut(data.end, bins, labels=labels, right=False).value_counts()\nbinned[\"start\"] = pd.cut(data.start, bins, labels=labels, right=False).value_counts()\nbinned = binned / binned.max()\nreturn binned\n</code></pre>"},{"location":"api/policy/filters/","title":"pam.policy.filters","text":""},{"location":"api/policy/filters/#pam.policy.filters.Filter","title":"<code>Filter()</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for attribute-based filters.</p> Source code in <code>pam/policy/filters.py</code> <pre><code>def __init__(self):\npass\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.Filter.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def print(self):\nprint(self.__str__())\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.Filter.satisfies_conditions","title":"<code>satisfies_conditions(x)</code>  <code>abstractmethod</code>","text":"<p>Check if object satisfies conditions to be filtered</p> Source code in <code>pam/policy/filters.py</code> <pre><code>@abstractmethod\ndef satisfies_conditions(self, x):\n\"Check if object satisfies conditions to be filtered\"\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter","title":"<code>PersonAttributeFilter(conditions, how='all')</code>","text":"<p>             Bases: <code>Filter</code></p> <p>Helps filtering Person on specified attributes.</p> PARAMETER  DESCRIPTION <code>conditions</code> <p>Dictionary of key = person.attribute, value = function that returns a boolean given the value at person.attribute[key]</p> <p> TYPE: <code>dict[str, Callable[[str], bool]]</code> </p> <code>how</code> <p>The level of rigour used to match conditions. <code>all</code> means all conditions for a person need to be met. <code>any</code> means at least one condition needs to be met</p> <p> TYPE: <code>Literal['all', 'any']</code> DEFAULT: <code>'all'</code> </p> Source code in <code>pam/policy/filters.py</code> <pre><code>def __init__(\nself, conditions: dict[str, Callable[[str], bool]], how: Literal[\"all\", \"any\"] = \"all\"\n) -&gt; None:\n\"\"\"Helps filtering Person on specified attributes.\n    Args:\n        conditions (dict[str, Callable[[str], bool]]):\n            Dictionary of key = person.attribute, value = function that returns a boolean given the value at person.attribute[key]\n        how (Literal[\"all\", \"any\"]):\n            The level of rigour used to match conditions.\n            `all` means all conditions for a person need to be met. `any` means at least one condition needs to be met\n    \"\"\"\nsuper().__init__()\nself.conditions = conditions\nself.how = how\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.conditions","title":"<code>conditions = conditions</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.how","title":"<code>how = how</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.household_satisfies_conditions","title":"<code>household_satisfies_conditions(household)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def household_satisfies_conditions(self, household):\nif not self.conditions:\nreturn True\nfor pid, person in household.people.items():\nif self.person_satisfies_conditions(person):\nreturn True\nreturn False\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.person_satisfies_conditions","title":"<code>person_satisfies_conditions(person)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def person_satisfies_conditions(self, person):\nif not self.conditions:\nreturn True\nelif self.how == \"all\":\nsatisfies_attribute_conditions = True\nfor attribute_key, attribute_condition in self.conditions.items():\nsatisfies_attribute_conditions &amp;= attribute_condition(\nperson.attributes[attribute_key]\n)\nreturn satisfies_attribute_conditions\nelif self.how == \"any\":\nsatisfies_attribute_conditions = False\nfor attribute_key, attribute_condition in self.conditions.items():\nsatisfies_attribute_conditions |= attribute_condition(\nperson.attributes[attribute_key]\n)\nreturn satisfies_attribute_conditions\nelse:\nraise NotImplementedError(\n\"{} not implemented, use only `all` or `any`\".format(self.how)\n)\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.satisfies_conditions","title":"<code>satisfies_conditions(x)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def satisfies_conditions(self, x):\nif isinstance(x, pam.core.Household):\n# household satisfies conditions if one person satisfies conditions according to self.how\nreturn self.household_satisfies_conditions(x)\nelif isinstance(x, pam.core.Person):\nreturn self.person_satisfies_conditions(x)\nelif isinstance(x, pam.activity.Activity):\nraise NotImplementedError\nelse:\nraise NotImplementedError\n</code></pre>"},{"location":"api/policy/modifiers/","title":"pam.policy.modifiers","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.AddActivity","title":"<code>AddActivity(activities)</code>","text":"<p>             Bases: <code>Modifier</code></p> <p>Adds specified activities.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be added.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: list[str]):\n\"\"\"Adds specified activities.\n    Args:\n        activities (list[str]): List of activities to be added.\n    \"\"\"\nsuper().__init__()\nself.activities = activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.AddActivity.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.AddActivity.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(\nself,\nhousehold: pam.core.Household,\nperson: Optional[pam.core.Person] = None,\nactivities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\nraise NotImplementedError(\"Watch this space\")\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.Modifier","title":"<code>Modifier()</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for modifiers - these are classes which change activities in a person's plan.</p> <p>In general a modifer should be able to be applied on three levels Household - apply change to all activities in all person's plans in household Person - apply change to all activities in a person's plan Activity - apply change to individual activity in a person's plan</p> <p>Not all modifiers will satisfy this of course, e.g. ReduceSharedActivity only works on a household level as the activites for removal need to be shared within a household.</p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self):\nsuper().__init__()\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.Modifier.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>  <code>abstractmethod</code>","text":"<p>Uses self.probability to decide if household/person/activity should be selected.</p> PARAMETER  DESCRIPTION <code>household</code> <p> TYPE: <code>Household</code> </p> <code>person</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[Person]</code> DEFAULT: <code>None</code> </p> <code>activities</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[list[Activity]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>@abstractmethod\ndef apply_to(\nself,\nhousehold: pam.core.Household,\nperson: Optional[pam.core.Person] = None,\nactivities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\n\"\"\"Uses self.probability to decide if household/person/activity should be selected.\n    Args:\n        household (Household):\n        person (Optional[Person], optional): Defaults to None.\n        activities (Optional[list[Activity]], optional): Defaults to None.\n    \"\"\"\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.Modifier.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def print(self):\nprint(self.__str__())\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation","title":"<code>MoveActivityTourToHomeLocation(activities, location='home', new_mode='walk')</code>","text":"<p>             Bases: <code>Modifier</code></p> <p>Moves a tour of activities to home location.</p> <p>A tour is defined as a list of activities sandwiched between two home activities.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be considered in a tour. Any combination of activities in activities sandwiched by home activities will be selected Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.</p> <p> TYPE: <code>list[str]</code> </p> <code>location</code> <p>Location to which the tour should be moved. Defaults to \"home\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'home'</code> </p> <code>new_mode</code> <p>Mode used in the legs to/from the activity when we relocate the activity. Defaults to \"walk\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'walk'</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: list[str], location: str = \"home\", new_mode: str = \"walk\"):\n\"\"\"Moves a tour of activities to home location.\n    A tour is defined as a list of activities sandwiched between two home activities.\n    Args:\n        activities:\n            List of activities to be considered in a tour.\n            Any combination of activities in activities sandwiched by home activities will be selected\n            Does not require an exact match.\n            E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.\n        location (str): Location to which the tour should be moved. Defaults to \"home\".\n        new_mode (str): Mode used in the legs to/from the activity when we relocate the activity. Defaults to \"walk\".\n    \"\"\"\nsuper().__init__()\nself.activities = activities\nself.default = location\nself.new_mode = new_mode\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.default","title":"<code>default = location</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.new_mode","title":"<code>new_mode = new_mode</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(\nself,\nhousehold: pam.core.Household,\nperson: Optional[pam.core.Person] = None,\nactivities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\nnew_mode = self.new_mode\nif activities and person:\nself.move_individual_activities(person, activities, new_mode)\nelif person:\nself.move_person_activities(person, new_mode)\nelif household and isinstance(household, pam.core.Household):\nself.move_household_activities(household, new_mode)\nelse:\nraise NotImplementedError(\n\"Types passed incorrectly: {}, {}, {}. You need {} at the very least.\"\n\"\".format(type(household), type(person), type(activities), type(pam.core.Household))\n)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.is_part_of_tour","title":"<code>is_part_of_tour(act, tours)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def is_part_of_tour(self, act, tours: list):\nfor tour in tours:\n# more rigorous check if activity in activities; Activity.__eq__ is not sufficient here\nif act.isin_exact(tour):\nreturn True\nreturn False\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.matching_activity_tours","title":"<code>matching_activity_tours(plan, p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def matching_activity_tours(self, plan, p):\ntours = plan.activity_tours()\nmatching_tours = []\nfor tour in tours:\nif self.tour_matches_activities(tour, p):\nmatching_tours.append(tour)\nreturn matching_tours\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_activities","title":"<code>move_activities(person, p, new_mode='walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_activities(self, person, p, new_mode=\"walk\"):\ntours = self.matching_activity_tours(person.plan, p)\nif tours:\nfor seq in range(len(person.plan)):\nif isinstance(person.plan[seq], pam.activity.Activity):\nact = person.plan[seq]\nif self.is_part_of_tour(act, tours):\nperson.move_activity(seq, default=self.default, new_mode=new_mode)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_household_activities","title":"<code>move_household_activities(household, new_mode='walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_household_activities(self, household, new_mode=\"walk\"):\nfor pid, person in household.people.items():\nself.move_person_activities(person, new_mode=new_mode)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_individual_activities","title":"<code>move_individual_activities(person, activities, new_mode='walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_individual_activities(self, person, activities, new_mode=\"walk\"):\ndef is_a_selected_activity(act):\n# more rigorous check if activity in activities; Activity.__eq__ is not sufficient here\nreturn act.isin_exact(activities)\nself.move_activities(person, p=is_a_selected_activity, new_mode=new_mode)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_person_activities","title":"<code>move_person_activities(person, new_mode='walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_person_activities(self, person, new_mode=\"walk\"):\ndef return_true(act):\nreturn True\nself.move_activities(person, p=return_true, new_mode=new_mode)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.tour_matches_activities","title":"<code>tour_matches_activities(tour, p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def tour_matches_activities(self, tour, p):\nif set([act.act for act in tour]) - set(self.activities) == set():\nfor act in tour:\nif p(act):\nreturn True\nreturn False\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity","title":"<code>ReduceSharedActivity(activities)</code>","text":"<p>             Bases: <code>Modifier</code></p> <p>Policy that needs to be applied on a household level. For activities shared within a household (Activity.act (type of activity), start/end times and locations match). Randomly assigns a person whose activities will be retained and deletes the shared activities from other persons in household.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities that should be considered for sharing. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: list[str]) -&gt; None:\n\"\"\"Policy that needs to be applied on a household level. For activities\n    shared within a household (Activity.act (type of activity), start/end\n    times and locations match). Randomly assigns a person whose activities\n    will be retained and deletes the shared activities from other persons\n    in household.\n    Args:\n        activities (list[str]):\n            List of activities that should be considered for sharing.\n            Does not require an exact match.\n            E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.\n    \"\"\"\nsuper().__init__()\nself.activities = activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(\nself,\nhousehold: pam.core.Household,\nperson: Optional[pam.core.Person] = None,\nactivities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\nif household and isinstance(household, pam.core.Household):\nself.remove_household_activities(household)\nelse:\nraise NotImplementedError(\n\"Types passed incorrectly: {}, {}, {}. This modifier exists only for Households\"\n\"you need to pass {}.\"\n\"\".format(type(household), type(person), type(activities), type(pam.core.Household))\n)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.is_activity_for_removal","title":"<code>is_activity_for_removal(p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def is_activity_for_removal(self, p):\nreturn p.act.lower() in self.activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.people_who_share_activities_for_removal","title":"<code>people_who_share_activities_for_removal(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def people_who_share_activities_for_removal(self, household):\nshared_activities_for_removal = self.shared_activities_for_removal(household)\npeople_with_shared_acts_for_removal = []\nfor pid, person in household.people.items():\nfor activity in person.activities:\nif activity.isin_exact(shared_activities_for_removal):\npeople_with_shared_acts_for_removal.append(person)\nreturn people_with_shared_acts_for_removal\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.remove_activities","title":"<code>remove_activities(person, shared_activities_for_removal)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_activities(self, person, shared_activities_for_removal):\nseq = 0\nwhile seq &lt; len(person.plan):\nact = person.plan[seq]\n# TODO there is a bug here `act in shared_activities_for_removal` should really be\n# act.in_list_exact(shared_activities_for_removal), but if tthere is more than one\n# activity in shared_activities_for_removal and  the  activities adjoin the\n# activities morph and change time, making them not satisfy self.is_exact(other) anymore\n# in this implementation however, you risk deleting isolated activities that have the\n# same name and location but aren't shared\nif isinstance(act, pam.activity.Activity) and act in shared_activities_for_removal:\nprevious_idx, subsequent_idx = person.remove_activity(seq)\nperson.fill_plan(previous_idx, subsequent_idx, default=\"home\")\nelse:\nseq += 1\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.remove_household_activities","title":"<code>remove_household_activities(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_household_activities(self, household):\nacts_for_removal = self.shared_activities_for_removal(household)\nif acts_for_removal:\n# pick the person that retains activities\nppl_sharing_activities = self.people_who_share_activities_for_removal(household)\nif ppl_sharing_activities:\nperson_retaining_activities = random.choice(\nself.people_who_share_activities_for_removal(household)\n)\nfor pid, person in household.people.items():\nif person != person_retaining_activities:\nself.remove_activities(person, acts_for_removal)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.shared_activities_for_removal","title":"<code>shared_activities_for_removal(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def shared_activities_for_removal(self, household):\nshared_activities = household.shared_activities()\nreturn [act for act in shared_activities if self.is_activity_for_removal(act)]\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity","title":"<code>RemoveActivity(activities)</code>","text":"<p>             Bases: <code>Modifier</code></p> <p>Removes specified activities.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be removed.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: list[str]):\n\"\"\"Removes specified activities.\n    Args:\n        activities (list[str]): List of activities to be removed.\n    \"\"\"\nsuper().__init__()\nself.activities = activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(\nself,\nhousehold: pam.core.Household,\nperson: Optional[pam.core.Person] = None,\nactivities: Optional[list[pam.activity.Activity]] = None,\n) -&gt; None:\nif activities and person:\nself.remove_individual_activities(person, activities)\nelif person:\nself.remove_person_activities(person)\nelif household and isinstance(household, pam.core.Household):\nself.remove_household_activities(household)\nelse:\nraise TypeError(\n\"Types passed incorrectly: {}, {}, {}. You need {} at the very least.\"\n\"\".format(type(household), type(person), type(activities), type(pam.core.Household))\n)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.is_activity_for_removal","title":"<code>is_activity_for_removal(p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def is_activity_for_removal(self, p):\nreturn p.act.lower() in self.activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_activities","title":"<code>remove_activities(person, p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_activities(self, person, p):\nseq = 0\nwhile seq &lt; len(person.plan):\nact = person.plan[seq]\nif self.is_activity_for_removal(act) and p(act):\nprevious_idx, subsequent_idx = person.remove_activity(seq)\nperson.fill_plan(previous_idx, subsequent_idx, default=\"home\")\nelse:\nseq += 1\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_household_activities","title":"<code>remove_household_activities(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_household_activities(self, household):\nfor pid, person in household.people.items():\nself.remove_person_activities(person)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_individual_activities","title":"<code>remove_individual_activities(person, activities)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_individual_activities(self, person, activities):\ndef is_a_selected_activity(act):\n# more rigorous check if activity in activities; Activity.__eq__ is not sufficient here\nreturn act.isin_exact(activities)\nself.remove_activities(person, p=is_a_selected_activity)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_person_activities","title":"<code>remove_person_activities(person)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_person_activities(self, person):\ndef return_true(act):\nreturn True\nself.remove_activities(person, p=return_true)\n</code></pre>"},{"location":"api/policy/policies/","title":"pam.policy.policies","text":""},{"location":"api/policy/policies/#pam.policy.policies.ActivityPolicy","title":"<code>ActivityPolicy(modifier, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PolicyLevel</code></p> <p>Policy that is to be applied on an individual activity level.</p> PARAMETER  DESCRIPTION <code>modifier</code> <p>the class which governs the change to be performed to the activities in a person's plan.</p> <p> TYPE: <code>Modifier</code> </p> <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select activity for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself,\nmodifier: modifiers.Modifier,\nprobability: Union[float, int, probability_samplers.SamplingProbability],\nattribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n\"\"\"Policy that is to be applied on an individual activity level.\n    Args:\n        modifier (modifiers.Modifier): the class which governs the change to be performed to the activities in a person's plan.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select activity for policy application based on object attributes. Defaults to None.\n    \"\"\"\nsuper().__init__(modifier, attribute_filter)\nself.probability = probability_samplers.verify_probability(\nprobability,\n(probability_samplers.HouseholdProbability, probability_samplers.PersonProbability),\n)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.ActivityPolicy.probability","title":"<code>probability = probability_samplers.verify_probability(probability, (probability_samplers.HouseholdProbability, probability_samplers.PersonProbability))</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.ActivityPolicy.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\nself,\nhousehold: Household,\nperson: Optional[Person] = None,\nactivities: Optional[list[Activity]] = None,\n) -&gt; None:\nfor pid, person in household.people.items():\nif self.attribute_filter.satisfies_conditions(person):\nactivities_to_purge = []\nfor activity in person.activities:\nif isinstance(self.probability, list):\np = 1\nfor prob in self.probability:\np *= prob.p(activity)\nif random.random() &lt; p:\nactivities_to_purge.append(activity)\nelif self.probability.sample(activity):\nactivities_to_purge.append(activity)\nif activities_to_purge:\nself.modifier.apply_to(household, person, activities_to_purge)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdPolicy","title":"<code>HouseholdPolicy(modifier, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PolicyLevel</code></p> <p>Policy that is to be applied on a household level.</p> PARAMETER  DESCRIPTION <code>modifier</code> <p>The class which governs the change to be performed to the activities in a person's plan.</p> <p> TYPE: <code>Modifier</code> </p> <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. The household policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself,\nmodifier: modifiers.Modifier,\nprobability: Union[float, int, probability_samplers.SamplingProbability],\nattribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n\"\"\"Policy that is to be applied on a household level.\n    Args:\n        modifier (modifiers.Modifier): The class which governs the change to be performed to the activities in a person's plan.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            The household policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select household for policy application based on object attributes. Defaults to None.\n    \"\"\"\nsuper().__init__(modifier, attribute_filter)\nself.probability = probability_samplers.verify_probability(probability)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdPolicy.probability","title":"<code>probability = probability_samplers.verify_probability(probability)</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.HouseholdPolicy.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\nself,\nhousehold: Household,\nperson: Optional[Person] = None,\nactivities: Optional[list[Activity]] = None,\n) -&gt; None:\nif self.attribute_filter.satisfies_conditions(household):\nif isinstance(self.probability, list):\np = 1\nfor prob in self.probability:\np *= prob.p(household)\nif random.random() &lt; p:\nself.modifier.apply_to(household)\nelif self.probability.sample(household):\nself.modifier.apply_to(household)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdQuarantined","title":"<code>HouseholdQuarantined(probability)</code>","text":"<p>             Bases: <code>Policy</code></p> <p>Household level Policy which removes all non-home activities for all persons in a household.</p> PARAMETER  DESCRIPTION <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. This policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself, probability: Union[float, int, probability_samplers.SamplingProbability]\n) -&gt; None:\n\"\"\"Household level Policy which removes all non-home activities for all persons in a household.\n    Args:\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            This policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.\n    \"\"\"\nsuper().__init__()\nself.probability = probability_samplers.verify_probability(probability)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdQuarantined.probability","title":"<code>probability = probability_samplers.verify_probability(probability)</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.HouseholdQuarantined.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\nself,\nhousehold: Household,\nperson: Optional[Person] = None,\nactivities: Optional[list[Activity]] = None,\n) -&gt; None:\np = self.probability.p(household)\nif random.random() &lt; p:\nfor pid, person in household.people.items():\nperson.stay_at_home()\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.MovePersonActivitiesToHome","title":"<code>MovePersonActivitiesToHome(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PersonPolicy</code></p> <p>Pre-packaged person-level policy which moves a tour of activities to home location.</p> <p>A tour is defined as a list of activities sandwiched between two home activities.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be considered in a tour. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The activity policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes.. Defaults to None.</p> <p> TYPE: <code>Optional[Filter]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself,\nactivities: list,\nprobability: Union[float, int, probability_samplers.SamplingProbability],\nattribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n\"\"\"Pre-packaged person-level policy which moves a tour of activities to home location.\n    A tour is defined as a list of activities sandwiched between two home activities.\n    Args:\n        activities (list):\n            List of activities to be considered in a tour.\n            Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The activity policy accepts all but 'HouseholdProbability' level of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n        attribute_filter (Optional[filters.Filter], optional):\n            If given, helps filter/select household for policy application based on object attributes.. Defaults to None.\n    \"\"\"\nsuper().__init__(\nmodifiers.MoveActivityTourToHomeLocation(activities), probability, attribute_filter\n)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PersonPolicy","title":"<code>PersonPolicy(modifier, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PolicyLevel</code></p> <p>Policy that is to be applied on a person level.</p> PARAMETER  DESCRIPTION <code>modifier</code> <p>the class which governs the change to be performed to the activities in a person's plan.</p> <p> TYPE: <code>Modifier</code> </p> <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select person for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself,\nmodifier: modifiers.Modifier,\nprobability: Union[float, int, probability_samplers.SamplingProbability],\nattribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n\"\"\"Policy that is to be applied on a person level.\n    Args:\n        modifier (modifiers.Modifier): the class which governs the change to be performed to the activities in a person's plan.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select person for policy application based on object attributes. Defaults to None.\n    \"\"\"\nsuper().__init__(modifier, attribute_filter)\nself.probability = probability_samplers.verify_probability(\nprobability, (probability_samplers.HouseholdProbability)\n)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PersonPolicy.probability","title":"<code>probability = probability_samplers.verify_probability(probability, probability_samplers.HouseholdProbability)</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.PersonPolicy.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\nself,\nhousehold: Household,\nperson: Optional[Person] = None,\nactivities: Optional[list[Activity]] = None,\n) -&gt; None:\nfor pid, person in household.people.items():\nif self.attribute_filter.satisfies_conditions(person):\nif isinstance(self.probability, list):\np = 1\nfor prob in self.probability:\np *= prob.p(person)\nif random.random() &lt; p:\nself.modifier.apply_to(household, person)\nelif self.probability.sample(person):\nself.modifier.apply_to(household, person)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PersonStayAtHome","title":"<code>PersonStayAtHome(probability)</code>","text":"<p>             Bases: <code>Policy</code></p> <p>Person level Policy which removes all non-home activities for a person.</p> PARAMETER  DESCRIPTION <code>probability</code> <p>A number or a subclass of the 'SamplingProbability' base class. The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself, probability: Union[float, int, probability_samplers.SamplingProbability]\n) -&gt; None:\n\"\"\"Person level Policy which removes all non-home activities for a person.\n    Args:\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            A number or a subclass of the 'SamplingProbability' base class.\n            The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n    \"\"\"\nsuper().__init__()\nself.probability = probability_samplers.verify_probability(\nprobability, (probability_samplers.HouseholdProbability)\n)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PersonStayAtHome.probability","title":"<code>probability = probability_samplers.verify_probability(probability, probability_samplers.HouseholdProbability)</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.PersonStayAtHome.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\nself,\nhousehold: Household,\nperson: Optional[Person] = None,\nactivities: Optional[list[Activity]] = None,\n) -&gt; None:\nfor pid, person in household.people.items():\nif random.random() &lt; self.probability.p(person):\nperson.stay_at_home()\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.Policy","title":"<code>Policy()</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for policies.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self):\npass\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.Policy.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>  <code>abstractmethod</code>","text":"<p>Uses self.probability to decide if household/person/activity should be selected.</p> PARAMETER  DESCRIPTION <code>household</code> <p> TYPE: <code>Household</code> </p> <code>person</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[Person]</code> DEFAULT: <code>None</code> </p> <code>activities</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[list[Activity]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>@abstractmethod\ndef apply_to(\nself,\nhousehold: Household,\nperson: Optional[Person] = None,\nactivities: Optional[list[Activity]] = None,\n) -&gt; None:\n\"\"\"Uses self.probability to decide if household/person/activity should be selected.\n    Args:\n        household (Household):\n        person (Optional[Person], optional): Defaults to None.\n        activities (Optional[list[Activity]], optional): Defaults to None.\n    \"\"\"\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.Policy.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\nprint(self.__str__())\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PolicyLevel","title":"<code>PolicyLevel(modifier, attribute_filter=None)</code>","text":"<p>             Bases: <code>Policy</code></p> <p>Base class to formalise the hierarchy of levels at which a policy should applied at.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself, modifier: modifiers.Modifier, attribute_filter: Optional[filters.Filter] = None\n):\nsuper().__init__()\nassert isinstance(\nmodifier, modifiers.Modifier\n), \"modifier needs to be subclass of {}\".format(type(modifiers.Modifier))\nself.modifier = modifier\nif attribute_filter is None:\nself.attribute_filter = filters.PersonAttributeFilter({})\nelse:\nself.attribute_filter = attribute_filter\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PolicyLevel.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.PolicyLevel.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.PolicyLevel.apply_to","title":"<code>apply_to(household, person=None, activities=None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(\nself,\nhousehold: Household,\nperson: Optional[Person] = None,\nactivities: Optional[list[Activity]] = None,\n) -&gt; None:\nsuper().apply_to(household, person, activities)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.ReduceSharedHouseholdActivities","title":"<code>ReduceSharedHouseholdActivities(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>HouseholdPolicy</code></p> <p>Pre-packaged household-level policy which reduces the number of activities shared within a household.</p> <p>Activity.act (type of activity), start/end times and locations match. Randomly assigns a person whose activities will be retained and deletes the shared activities from other persons in household.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities that should be considered for sharing. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The activity policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Optional[Filter]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself,\nactivities: list,\nprobability: Union[float, int, probability_samplers.SamplingProbability],\nattribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n\"\"\"Pre-packaged household-level policy which reduces the number of activities shared within a household.\n    Activity.act (type of activity), start/end times and locations match.\n    Randomly assigns a person whose activities will be retained and deletes the shared activities from other persons in household.\n    Args:\n        activities (list):\n            List of activities that should be considered for sharing.\n            Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The activity policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n        attribute_filter (Optional[filters.Filter], optional):\n            If given, helps filter/select household for policy application based on object attributes. Defaults to None.\n    \"\"\"\nsuper().__init__(modifiers.ReduceSharedActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.RemoveHouseholdActivities","title":"<code>RemoveHouseholdActivities(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>HouseholdPolicy</code></p> <p>Pre-packaged household-level policy which removes specified activities from all person's plans within selected households.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be removed.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The household policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself,\nactivities: list,\nprobability: Union[float, int, probability_samplers.SamplingProbability],\nattribute_filter: Optional[filters.Filter] = None,\n):\n\"\"\"Pre-packaged household-level policy which removes specified activities from all person's plans within selected households.\n    Args:\n        activities (list): List of activities to be removed.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The household policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select household for policy application based on object attributes. Defaults to None.\n    \"\"\"\nsuper().__init__(modifiers.RemoveActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.RemoveIndividualActivities","title":"<code>RemoveIndividualActivities(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>ActivityPolicy</code></p> <p>Pre-packaged activity-level policy which removes specified activities from all person's plans within selected households.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be removed.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select household for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Optional[Filter]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself,\nactivities: list,\nprobability: Union[float, int, probability_samplers.SamplingProbability],\nattribute_filter: Optional[filters.Filter] = None,\n) -&gt; None:\n\"\"\"Pre-packaged activity-level policy which removes specified activities from all person's plans within selected households.\n    Args:\n        activities (list):  List of activities to be removed.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.\n        attribute_filter (Optional[filters.Filter], optional):\n            If given, helps filter/select household for policy application based on object attributes. Defaults to None.\n    \"\"\"\nsuper().__init__(modifiers.RemoveActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.RemovePersonActivities","title":"<code>RemovePersonActivities(activities, probability, attribute_filter=None)</code>","text":"<p>             Bases: <code>PersonPolicy</code></p> <p>Pre-packaged person-level policy which removes specified activities from all person's plans within selected households.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities to be removed.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>The person policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p> TYPE: <code>Union[float, int, SamplingProbability]</code> </p> <code>attribute_filter</code> <p>If given, helps filter/select person for policy application based on object attributes. Defaults to None.</p> <p> TYPE: <code>Filter</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(\nself,\nactivities: list,\nprobability: Union[float, int, probability_samplers.SamplingProbability],\nattribute_filter: Optional[filters.Filter] = None,\n):\n\"\"\"Pre-packaged person-level policy which removes specified activities from all person's plans within selected households.\n    Args:\n        activities (list):  List of activities to be removed.\n        probability (Union[float, int, probability_samplers.SamplingProbability]):\n            The person policy accepts all levels of Sampling Probabilities.\n            If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.\n        attribute_filter (filters.Filter, optional):\n            If given, helps filter/select person for policy application based on object attributes. Defaults to None.\n    \"\"\"\nsuper().__init__(modifiers.RemoveActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.apply_policies","title":"<code>apply_policies(population, policies, in_place=False)</code>","text":"<p>Method which applies policies to population.</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> <code>policies</code> <p>Policies to be applied to the population.</p> <p> TYPE: <code>Union[list[Policy], Policy]</code> </p> <code>in_place</code> <p>Whether to apply policies to current Population (True) object or return a copy (False). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[Population]</code> <p>pam.core.Population, optional: if <code>in_place</code> is False.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_policies(\npopulation: Population, policies: Union[list[Policy], Policy], in_place: bool = False\n) -&gt; Optional[Population]:\n\"\"\"Method which applies policies to population.\n    Args:\n      population (pam.core.Population):\n      policies (Union[list[Policy], Policy]): Policies to be applied to the population.\n      in_place (bool): Whether to apply policies to current Population (True) object or return a copy (False). Defaults to False.\n    Returns:\n      pam.core.Population, optional: if `in_place` is False.\n    \"\"\"\nif not in_place:\npop = deepcopy(population)\nelse:\npop = population\nif isinstance(policies, Policy):\npolicies = [policies]\nfor i in range(len(policies)):\npolicy = policies[i]\nassert isinstance(\npolicy, Policy\n), \"Policies need to be of type {}, not {}. Failed for policy {} at list index {}\".format(\ntype(Policy), type(policy), policy, i\n)\nfor hid, household in pop.households.items():\nfor policy in policies:\npolicy.apply_to(household)\nif not in_place:\nreturn pop\n</code></pre>"},{"location":"api/policy/probability_samplers/","title":"pam.policy.probability_samplers","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability","title":"<code>ActivityProbability(activities, probability, kwargs=None)</code>","text":"<p>             Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which evaluates value of probability at household, person and activity level based on probability for an activity.</p> PARAMETER  DESCRIPTION <code>activities</code> <p>List of activities.</p> <p> TYPE: <code>list</code> </p> <code>probability</code> <p>A float/int: 0&lt;probability&lt;=1 or a function which given input of pam.core.Activity returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the activity being sampled.</p> <p> TYPE: <code>Union[float, int, Callable[[Activity]]]</code> </p> <code>kwargs</code> <p>Keyword arguments to add when calling <code>probability</code>, if it is a Callable. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(\nself,\nactivities: list,\nprobability: Union[float, int, Callable[[pam.activity.Activity], float]],\nkwargs: Optional[dict] = None,\n) -&gt; None:\n\"\"\"A probabilistic sampler which evaluates value of probability at household, person and activity level based on probability for an activity.\n    Args:\n        activities (list): List of activities.\n        probability (Union[float, int, Callable[[pam.activity.Activity]]]):\n            A float/int: 0&lt;probability&lt;=1 or a function which given input of pam.core.Activity returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the activity being sampled.\n        kwargs (Optional[dict], optional): Keyword arguments to add when calling `probability`, if it is a Callable. Defaults to None.\n    \"\"\"\nsuper().__init__(probability)\nself.activities = activities\nassert isinstance(self.probability, float) or callable(self.probability)\nif kwargs is None:\nself.kwargs = {}\nelse:\nself.kwargs = kwargs\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.kwargs","title":"<code>kwargs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.compute_probability_for_activity","title":"<code>compute_probability_for_activity(activity)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def compute_probability_for_activity(self, activity):\nif isinstance(self.probability, float):\nreturn self.probability\nelif callable(self.probability):\nreturn self.probability(activity, **self.kwargs)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.is_relevant_activity","title":"<code>is_relevant_activity(act)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def is_relevant_activity(self, act):\nreturn act.act.lower() in self.activities\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\nif isinstance(x, pam.core.Household):\np = 1\nfor pid, person in x.people.items():\nfor act in person.activities:\nif self.is_relevant_activity(act):\np *= 1 - self.compute_probability_for_activity(act)\nreturn 1 - p\nelif isinstance(x, pam.core.Person):\np = 1\nfor act in x.activities:\nif self.is_relevant_activity(act):\np *= 1 - self.compute_probability_for_activity(act)\nreturn 1 - p\nelif isinstance(x, pam.activity.Activity):\nif self.is_relevant_activity(x):\nreturn self.compute_probability_for_activity(x)\nreturn 0\nelse:\nraise NotImplementedError\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability","title":"<code>HouseholdProbability(probability, kwargs=None)</code>","text":"<p>             Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which evaluates value of probability at household level based on probability for a household.</p> PARAMETER  DESCRIPTION <code>probability</code> <p>0&lt;probability&lt;=1, or a function which given input of pam.core.Household returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the household being sampled.</p> <p> TYPE: <code>Union[float, int, Callable[[Household], float]]</code> </p> <code>kwargs</code> <p>Keyword arguments to add when calling <code>probability</code>, if it is a Callable. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(\nself,\nprobability: Union[float, int, Callable[[pam.core.Household], float]],\nkwargs: Optional[dict] = None,\n) -&gt; None:\n\"\"\"A probabilistic sampler which evaluates value of probability at household level based on probability for a household.\n    Args:\n        probability (Union[float, int, Callable[[pam.core.Household], float]]):\n            0&lt;probability&lt;=1, or a function which given input of pam.core.Household returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the household being sampled.\n        kwargs (Optional[dict], optional): Keyword arguments to add when calling `probability`, if it is a Callable. Defaults to None.\n    \"\"\"\nsuper().__init__(probability)\nassert isinstance(self.probability, float) or callable(self.probability)\nif kwargs is None:\nself.kwargs = {}\nelse:\nself.kwargs = kwargs\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.kwargs","title":"<code>kwargs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.compute_probability_for_household","title":"<code>compute_probability_for_household(household)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def compute_probability_for_household(self, household):\nif isinstance(self.probability, float):\nreturn self.probability\nelif callable(self.probability):\nreturn self.probability(household, **self.kwargs)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\nif isinstance(x, pam.core.Household):\nreturn self.compute_probability_for_household(x)\nelif isinstance(x, pam.core.Person):\nraise NotImplementedError\nelif isinstance(x, pam.activity.Activity):\nraise NotImplementedError\nelse:\nraise TypeError\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability","title":"<code>PersonProbability(probability, kwargs=None)</code>","text":"<p>             Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which evaluates value of probability at household and person level based on probability for a person.</p> PARAMETER  DESCRIPTION <code>probability</code> <p>0&lt;probability&lt;=1 or a function which given input of pam.core.Person returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the person being sampled.</p> <p> TYPE: <code>Union[float, int, Callable[[Person], float]]</code> </p> <code>kwargs</code> <p>Keyword arguments to add when calling <code>probability</code>, if it is a Callable. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(\nself,\nprobability: Union[float, int, Callable[[pam.core.Person], float]],\nkwargs: Optional[dict] = None,\n) -&gt; None:\n\"\"\"A probabilistic sampler which evaluates value of probability at household and person level based on probability for a person.\n    Args:\n        probability (Union[float, int, Callable[[pam.core.Person], float]]):\n            0&lt;probability&lt;=1 or a function which given input of pam.core.Person returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the person being sampled.\n        kwargs (Optional[dict], optional): Keyword arguments to add when calling `probability`, if it is a Callable. Defaults to None.\n    \"\"\"\nsuper().__init__(probability)\nassert isinstance(self.probability, float) or callable(self.probability)\nif kwargs is None:\nself.kwargs = {}\nelse:\nself.kwargs = kwargs\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.kwargs","title":"<code>kwargs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.compute_probability_for_person","title":"<code>compute_probability_for_person(person)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def compute_probability_for_person(self, person):\nif isinstance(self.probability, float):\nreturn self.probability\nelif callable(self.probability):\nreturn self.probability(person, **self.kwargs)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\nif isinstance(x, pam.core.Household):\np = 1\nfor pid, person in x.people.items():\np *= 1 - self.compute_probability_for_person(person)\nreturn 1 - p\nelif isinstance(x, pam.core.Person):\nreturn self.compute_probability_for_person(x)\nelif isinstance(x, pam.activity.Activity):\nraise NotImplementedError\nelse:\nraise NotImplementedError\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability","title":"<code>SamplingProbability(probability)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for probabilistic samplers.</p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(self, probability: Union[float, int]):\nif isinstance(probability, int):\nprobability = float(probability)\nif isinstance(probability, float):\nassert 0 &lt; probability &lt;= 1\nself.probability = probability\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.probability","title":"<code>probability = probability</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.p","title":"<code>p(x)</code>  <code>abstractmethod</code>","text":"<p>Compute probability</p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>@abstractmethod\ndef p(self, x):\n\"Compute probability\"\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def print(self):\nprint(self.__str__())\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.sample","title":"<code>sample(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def sample(self, x):\nreturn random.random() &lt; self.p(x)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability","title":"<code>SimpleProbability(probability)</code>","text":"<p>             Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which returns value of probability at the same level as the input (household/person/activity).</p> PARAMETER  DESCRIPTION <code>probability</code> <p>0&lt;probability&lt;=1.</p> <p> TYPE: <code>Union[float, int]</code> </p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(self, probability: Union[float, int]) -&gt; None:\n\"\"\"A probabilistic sampler which returns value of probability at the same level as the input (household/person/activity).\n    Args:\n        probability (Union[float, int]): 0&lt;probability&lt;=1.\n    \"\"\"\nsuper().__init__(probability)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\nreturn self.probability\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.verify_probability","title":"<code>verify_probability(probability, unacceptable_types=None)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def verify_probability(probability, unacceptable_types=None):\nif unacceptable_types is None:\nunacceptable_types = ()\nif isinstance(probability, int):\nprobability = float(probability)\nassert not isinstance(\nprobability, unacceptable_types\n), \"{} is of type {} which is not accepted. Check your policy's application level.\".format(\nprobability, type(probability)\n)\nif isinstance(probability, float):\nassert 0 &lt; probability &lt;= 1\nprobability = SimpleProbability(probability)\nelif isinstance(probability, list):\nfor i in range(len(probability)):\nassert not isinstance(\nprobability[i], unacceptable_types\n), \"{} is of type {} which is not accepted. Check your policy's application level\".format(\nprobability[i], type(probability[i])\n)\nif isinstance(probability[i], float):\nprobability[i] = SimpleProbability(probability[i])\nelse:\nassert isinstance(\nprobability, SamplingProbability\n), \"Probability passed to a policy needs to be float, integer or {}, not {}\".format(\ntype(SamplingProbability), type(probability)\n)\nreturn probability\n</code></pre>"},{"location":"api/read/diary/","title":"pam.read.diary","text":""},{"location":"api/read/diary/#pam.read.diary.add_hhs_from_hhs_attributes","title":"<code>add_hhs_from_hhs_attributes(population, hhs_attributes=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_hhs_from_hhs_attributes(\npopulation: core.Population, hhs_attributes: Optional[pd.DataFrame] = None\n):\nlogger = logging.getLogger(__name__)\nif hhs_attributes is None:\nreturn None\nlogger.info(\"Adding hhs from hhs_attributes\")\nfor hid, hh in hhs_attributes.groupby(\"hid\"):\nif hid not in population.households:\nhh_attributes = hhs_attributes.loc[hid].to_dict()\nhousehold = core.Household(\nhid,\nattributes=hh_attributes,\nfreq=hh_attributes.pop(\"freq\", None),\narea=hh_attributes.pop(\"hzone\", None),\n)\npopulation.add(household)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.add_hhs_from_persons_attributes","title":"<code>add_hhs_from_persons_attributes(population, persons_attributes=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_hhs_from_persons_attributes(\npopulation: core.Population, persons_attributes: Optional[pd.DataFrame] = None\n):\nlogger = logging.getLogger(__name__)\nif persons_attributes is None or \"hid\" not in persons_attributes.columns:\nreturn None\nif \"hzone\" in persons_attributes.columns:\nhzone_lookup = persons_attributes.groupby(\"hid\").head(1).set_index(\"hid\").hzone.to_dict()\nelse:\nhzone_lookup = {}\nlogger.info(\"Adding hhs from persons_attributes\")\nfor hid, hh_data in persons_attributes.groupby(\"hid\"):\nif hid not in population.households:\nhzone = hzone_lookup.get(hid)\nhousehold = core.Household(hid, area=hzone)\npopulation.add(household)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.add_hhs_from_trips","title":"<code>add_hhs_from_trips(population, trips=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_hhs_from_trips(population: core.Population, trips: Optional[pd.DataFrame] = None):\nlogger = logging.getLogger(__name__)\nif trips is None or \"hid\" not in trips.columns:\nreturn None\nlogger.info(\"Adding hhs from trips\")\nfor hid, hh_data in trips.groupby(\"hid\"):\nif hid not in population.households:\nhzone = hh_data.iloc[0].to_dict().get(\"hzone\")\nhousehold = core.Household(hid, area=hzone)\npopulation.add(household)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.add_persons_from_persons_attributes","title":"<code>add_persons_from_persons_attributes(population, persons_attributes=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_persons_from_persons_attributes(\npopulation: core.Population, persons_attributes: Optional[pd.DataFrame] = None\n):\nlogger = logging.getLogger(__name__)\nif persons_attributes is None or \"hid\" not in persons_attributes.columns:\nreturn None\npersons_attributes_dict = (\npersons_attributes.reset_index().set_index([\"hid\", \"pid\"]).to_dict(\"index\")\n)\nlogger.info(\"Adding persons from persons_attributes\")\nfor hid, hh_data in persons_attributes.groupby(\"hid\"):\nhousehold = population.get(hid)\nif household is None:\nlogger.warning(f\"Failed to find household {hid} in population - unable to add person.\")\ncontinue\nfor pid in hh_data.index:\nif pid in household.people:\ncontinue\nperson_attributes = persons_attributes_dict[hid, pid]\nperson = core.Person(\npid,\nattributes=person_attributes,\nhome_area=person_attributes.get(\"hzone\", None),\nfreq=person_attributes.pop(\"freq\", None),\n)\nhousehold.add(person)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.add_persons_from_trips","title":"<code>add_persons_from_trips(population, trips=None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_persons_from_trips(population: core.Population, trips: Optional[pd.DataFrame] = None):\nlogger = logging.getLogger(__name__)\nif trips is None or \"hid\" not in trips.columns:\nreturn None\nlogger.info(\"Adding persons from trips\")\nfor (hid, pid), hh_person_data in trips.groupby([\"hid\", \"pid\"]):\nhousehold = population.households.get(hid)\nif household is None:\nlogger.warning(f\"Failed to find household {hid} in population - unable to add person.\")\ncontinue\nif pid in household.people:\ncontinue\nperson = core.Person(pid, home_area=hh_person_data.iloc[0].to_dict().get(\"hzone\"))\nhousehold.add(person)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.build_population","title":"<code>build_population(trips=None, persons_attributes=None, hhs_attributes=None)</code>","text":"<p>Build a population of households and persons (without plans).</p> <p>Built from available trips, persons_attributes and households_attributes data. Details of required table formats are in the README.</p> PARAMETER  DESCRIPTION <code>trips</code> <p>trips table. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>persons_attributes</code> <p>persons attributes table. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>households attributes table. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>pam.Population: population object</p> Source code in <code>pam/read/diary.py</code> <pre><code>def build_population(\ntrips: Optional[pd.DataFrame] = None,\npersons_attributes: Optional[pd.DataFrame] = None,\nhhs_attributes: Optional[pd.DataFrame] = None,\n) -&gt; core.Population:\n\"\"\"Build a population of households and persons (without plans).\n    Built from available trips, persons_attributes and households_attributes data.\n    Details of required table formats are in the README.\n    Args:\n      trips (Optional[pd.DataFrame]): trips table. Defaults to None.\n      persons_attributes (Optional[pd.DataFrame]): persons attributes table. Defaults to None.\n      hhs_attributes (Optional[pd.DataFrame]): households attributes table. Defaults to None.\n    Returns:\n      pam.Population: population object\n    \"\"\"\npopulation = core.Population()\nadd_hhs_from_hhs_attributes(population=population, hhs_attributes=hhs_attributes)\nadd_hhs_from_persons_attributes(population=population, persons_attributes=persons_attributes)\nadd_hhs_from_trips(population=population, trips=trips)\nadd_persons_from_persons_attributes(\npopulation=population, persons_attributes=persons_attributes\n)\nadd_persons_from_trips(population=population, trips=trips)\nreturn population\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.from_to_travel_diary_read","title":"<code>from_to_travel_diary_read(trips, persons_attributes=None, hhs_attributes=None, include_loc=False, sort_by_seq=False)</code>","text":"<p>Turn Diary Plan tabular data inputs into core population format.</p> <p>Tabular data derived from travel survey and attributes.</p> <p>This is a variation of the standard load_travel_diary() method because it does not require activity inference or home location. We expect broadly the same data schema except rather than purp (purpose) we use trips oact (origin activity) and dact (destination activity).</p> PARAMETER  DESCRIPTION <code>trips</code> <p> TYPE: <code>DataFrame</code> </p> <code>persons_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>include_loc</code> <p>optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns) (Default value = False). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_by_seq</code> <p>optionally force trip sorting as True or False. Defaults to False.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/diary.py</code> <pre><code>def from_to_travel_diary_read(\ntrips: pd.DataFrame,\npersons_attributes: Optional[pd.DataFrame] = None,\nhhs_attributes: Optional[pd.DataFrame] = None,\ninclude_loc: bool = False,\nsort_by_seq: Optional[bool] = False,\n) -&gt; core.Population:\n\"\"\"Turn Diary Plan tabular data inputs into core population format.\n    Tabular data derived from travel survey and attributes.\n    This is a variation of the standard load_travel_diary() method because it does not require activity inference or home location.\n    We expect broadly the same data schema except rather than purp (purpose) we use trips oact (origin activity) and dact (destination activity).\n    Args:\n        trips (pd.DataFrame):\n        persons_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        hhs_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        include_loc (bool, optional): optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns) (Default value = False). Defaults to False.\n        sort_by_seq (Optional[bool], optional): optionally force trip sorting as True or False. Defaults to False.\n    Returns:\n        core.Population:\n    \"\"\"\nlogger = logging.getLogger(__name__)\npopulation = build_population(\ntrips=trips, persons_attributes=persons_attributes, hhs_attributes=hhs_attributes\n)\nif sort_by_seq is None and \"seq\" in trips.columns:\nsort_by_seq = True\nif sort_by_seq:\ntrips = trips.sort_values([\"hid\", \"pid\", \"seq\"])\ntrips_dict = hh_person_df_to_dict(trips, \"hid\", \"pid\")  # convert to dict for faster indexing\nfor hid, household in population:\nfor pid, person in household:\nperson_trips = trips_dict.get(hid, {}).get(pid, pd.DataFrame())\nif not len(person_trips):\nperson.stay_at_home()\ncontinue\nfirst_act = person_trips.iloc[0].oact.lower()\nif not first_act == \"home\":\nlogger.warning(\nf\" Person pid:{pid} hid:{hid} plan does not start with 'home' activity: {first_act}\"\n)\nloc = None\nif include_loc:\nloc = person_trips.start_loc.iloc[0]\nperson.add(\nactivity.Activity(\nseq=0,\nact=first_act,\narea=person_trips.iloc[0].ozone,\nloc=loc,\nstart_time=utils.parse_time(0),\n)\n)\nfor n, trip in person_trips.iterrows():\nstart_loc = None\nend_loc = None\nif include_loc:\nstart_loc = trip.start_loc\nend_loc = trip.end_loc\npurpose = trip.dact.lower()\nperson.add(\nactivity.Leg(\nseq=n,\npurp=purpose,\nmode=trip[\"mode\"].lower(),\nstart_area=trip.ozone,\nend_area=trip.dzone,\nstart_loc=start_loc,\nend_loc=end_loc,\nstart_time=utils.parse_time(trip.tst),\nend_time=utils.parse_time(trip.tet),\ndistance=trip.get(\"distance\"),\n)\n)\nperson.add(\nactivity.Activity(\nseq=n + 1,\nact=purpose,\narea=trip.dzone,\nloc=end_loc,\nstart_time=utils.parse_time(trip.tet),\n)\n)\nperson.plan.finalise_activity_end_times()\nhousehold.add(person)\npopulation.add(household)\nreturn population\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.hh_person_df_to_dict","title":"<code>hh_person_df_to_dict(df, key_hh, key_person)</code>","text":"<p>Restructure a dataframe as a nested dictionary of dataframes.</p> <p>The first level is the household index. The second level is the person index. The value is the dataframe slice corresponding to that person.</p> <p>The dictionary structure allows for much faster access to a person's data.</p> PARAMETER  DESCRIPTION <code>df</code> <p>the pandas dataframe to reindex.</p> <p> TYPE: <code>DataFrame</code> </p> <code>key_hh</code> <p>the household key column name.</p> <p> TYPE: <code>str</code> </p> <code>key_person</code> <p>the person key column name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p> TYPE: <code>dict[DataFrame]</code> </p> Source code in <code>pam/read/diary.py</code> <pre><code>def hh_person_df_to_dict(df: pd.DataFrame, key_hh: str, key_person: str) -&gt; dict[pd.DataFrame]:\n\"\"\"Restructure a dataframe as a nested dictionary of dataframes.\n    The first level is the household index.\n    The second level is the person index.\n    The value is the dataframe slice corresponding to that person.\n    The dictionary structure allows for much faster access to a person's data.\n    Args:\n        df (pd.DataFrame): the pandas dataframe to reindex.\n        key_hh (str): the household key column name.\n        key_person (str): the person key column name.\n    Returns:\n        dict:\n    \"\"\"\ndf_dict = {x: {} for x in df[key_hh].unique()}\nfor (hid, pid), person_data in df.groupby([key_hh, key_person]):\ndf_dict[hid][pid] = person_data\nreturn df_dict\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.load_travel_diary","title":"<code>load_travel_diary(trips, persons_attributes=None, hhs_attributes=None, sample_perc=None, tour_based=True, from_to=False, include_loc=False, sort_by_seq=None, trip_freq_as_person_freq=False, trip_freq_as_hh_freq=False)</code>","text":"<p>Turn standard tabular data inputs (travel survey and attributes) into core population format.</p> PARAMETER  DESCRIPTION <code>trips</code> <p> TYPE: <code>Union[DataFrame, str]</code> </p> <code>persons_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Union[DataFrame, str, None]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Union[DataFrame, str, None]</code> DEFAULT: <code>None</code> </p> <code>sample_perc</code> <p>If different to None, it samples the travel population by the corresponding percentage. Defaults to None.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>tour_based</code> <p>Set to False to force a simpler trip-based purpose parser. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>from_to</code> <p>Set to True to force the from-to purpose parser (requires 'oact' and 'dact' trips columns). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_loc</code> <p>If True, include location data as shapely Point geometries ('start_loc' and 'end_loc' trips columns). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_by_seq</code> <p>If not None, force trip sorting as True or False. Defaults to None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> <code>trip_freq_as_person_freq</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>trip_freq_as_hh_freq</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/diary.py</code> <pre><code>def load_travel_diary(\ntrips: Union[pd.DataFrame, str],\npersons_attributes: Union[pd.DataFrame, str, None] = None,\nhhs_attributes: Union[pd.DataFrame, str, None] = None,\nsample_perc: Optional[float] = None,\ntour_based: bool = True,\nfrom_to: bool = False,\ninclude_loc: bool = False,\nsort_by_seq: Optional[bool] = None,\ntrip_freq_as_person_freq: bool = False,\ntrip_freq_as_hh_freq: bool = False,\n) -&gt; core.Population:\n\"\"\"Turn standard tabular data inputs (travel survey and attributes) into core population format.\n    Args:\n      trips (Union[pd.DataFrame, str]):\n      persons_attributes (Union[pd.DataFrame, str, None], optional): Defaults to None.\n      hhs_attributes (Union[pd.DataFrame, str, None], optional): Defaults to None.\n      sample_perc (float, optional): If different to None, it samples the travel population by the corresponding percentage. Defaults to None.\n      tour_based (bool, optional): Set to False to force a simpler trip-based purpose parser. Defaults to True.\n      from_to (bool, optional): Set to True to force the from-to purpose parser (requires 'oact' and 'dact' trips columns). Defaults to False.\n      include_loc (bool, optional): If True, include location data as shapely Point geometries ('start_loc' and 'end_loc' trips columns). Defaults to False.\n      sort_by_seq (bool, optional): If not None, force trip sorting as True or False. Defaults to None.\n      trip_freq_as_person_freq (bool, optional): Defaults to False.\n      trip_freq_as_hh_freq (bool, optional): Defaults to False.\n    Returns:\n      core.Population:\n    \"\"\"\n# TODO check for required col headers and give useful error?\nlogger = logging.getLogger(__name__)\nif isinstance(trips, str):\nlogger.warning(f\"Attempting to load trips dataframe from path: {trips}\")\ntrips = pd.read_csv(trips)\nif isinstance(persons_attributes, str):\nlogger.warning(f\"Attempting to load trips dataframe from path: {persons_attributes}\")\npersons_attributes = pd.read_csv(persons_attributes)\nif isinstance(hhs_attributes, str):\nlogger.warning(f\"Attempting to load trips dataframe from path: {hhs_attributes}\")\nhhs_attributes = pd.read_csv(hhs_attributes)\nif not isinstance(trips, pd.DataFrame):\nraise UserWarning(\"Unrecognised input for trips input.\")\nif persons_attributes is not None and not isinstance(persons_attributes, pd.DataFrame):\nraise UserWarning(\"Unrecognised input for person_attributes\")\nif hhs_attributes is not None and not isinstance(hhs_attributes, pd.DataFrame):\nraise UserWarning(\"Unrecognised input for hh_attributes\")\n# reset indexes if named\nfor table in [trips, persons_attributes, hhs_attributes]:\nif table is not None and table.index.name is not None:\ntable.reset_index(inplace=True)\nif (\"oact\" in trips.columns and \"dact\" in trips.columns) or from_to:\nlogger.warning(\"Using from-to activity parser using 'oact' and 'dact' columns\")\nfrom_to = True\n# check that trips diary has required fields\nmissing = {\"pid\", \"ozone\", \"dzone\", \"oact\", \"dact\", \"mode\", \"tst\", \"tet\"} - set(\ntrips.columns\n)\nif missing:\nraise UserWarning(f\"Input trips_diary missing required column names: {missing}.\")\nelse:\nif tour_based:\nlogger.warning(\"Using tour based purpose parser (recommended)\")\nelse:\nlogger.warning(\n\"\"\"\nUsing simple trip based purpose parser, this assumes first activity is 'home'.\nIf you do not wish to assume this, try setting 'tour_based' = True (default).\n\"\"\"\n)\n# check that trips diary has required fields\nmissing = {\"pid\", \"ozone\", \"dzone\", \"purp\", \"mode\", \"tst\", \"tet\"} - set(trips.columns)\nif missing:\nraise UserWarning(f\"Input trips_diary missing required column names: {missing}.\")\nif sort_by_seq and \"seq\" not in trips.columns:\nraise UserWarning(\n\"\"\"\n    You must include a trips 'seq' column if you wish to sort trips:\n    Either include a 'seq' column or use the existing ordering by\n    setting 'sort_by_seq' = False/None (default).\n    \"\"\"\n)\nif include_loc and not all(x in trips.columns for x in [\"start_loc\", \"end_loc\"]):\nraise UserWarning(\n\"\"\"\n    You must include a trips 'start_loc' and 'end_loc' column if you wish to use precise locations:\n    Either include a 'start_loc' and 'end_loc' column or set 'include_loc' = False (default).\n    Note that these columns must be shapely Point geometries.\n    \"\"\"\n)\nif trip_freq_as_person_freq:  # use trip freq as person freq\nif \"freq\" not in trips.columns:\nraise UserWarning(\n\"\"\"\n                You have opted to use 'trip_freq_as_person_freq' but cannot build this mapping:\n                Please check 'freq' is included in the trips_diary input.\n                \"\"\"\n)\nlogger.info(\"Loading person freq ('freq') from trips_diary freq input.\")\npid_freq_map = dict(zip(trips.pid, trips.freq))  # this will take last freq from trips\nif persons_attributes is None:\nlogger.info(\"Building new person attributes dataframe to hold person frequency.\")\npersons_attributes = pd.DataFrame(\n{\"pid\": list(pid_freq_map.keys()), \"freq\": list(pid_freq_map.values())}\n)\nelse:\nlogger.info(\"Adding freq to person attributes using trip frequency.\")\npersons_attributes[\"freq\"] = persons_attributes.pid.map(pid_freq_map)\ntrips.drop(\"freq\", axis=1, inplace=True)\nif trip_freq_as_hh_freq:\nif \"freq\" not in trips.columns:\nraise UserWarning(\n\"\"\"\n                You have opted to use 'trip_freq_as_hh_freq' but cannot build this mapping:\n                Please check 'freq' is included in the trips_diary input.\n                \"\"\"\n)\nif \"hid\" not in trips.columns:\nraise UserWarning(\n\"\"\"\n                You have opted to use 'trip_freq_as_hh_freq' but cannot build this mapping:\n                Please check 'hid' is included in the trips_diary input.\n                \"\"\"\n)\nlogger.info(\"Loading houshold freq ('freq') from trips_diary freq input.\")\nhid_freq_map = dict(zip(trips.hid, trips.freq))  # this will take last freq from trips\nif hhs_attributes is None:\nlogger.info(\"Building new household attributes dataframe to hold houshold frequency.\")\nhhs_attributes = pd.DataFrame(\n{\"hid\": list(hid_freq_map.keys()), \"freq\": list(hid_freq_map.values())}\n)\nelse:\nlogger.info(\"Adding freq to household attributes using trip frequency.\")\nhhs_attributes[\"freq\"] = hhs_attributes.hid.map(hid_freq_map)\ntrips.drop(\"freq\", axis=1, inplace=True)\n# add hid to trips if not already added\nif (\n\"hid\" not in trips.columns\nand (persons_attributes is None or \"hid\" not in persons_attributes.columns)\nand (hhs_attributes is None or \"pid\" not in hhs_attributes.columns)\n):\nlogger.warning(\n\"\"\"\n            No household entities found, households will be composed of individual persons using 'pid':\n            If you wish to correct this, please add 'hid' to either the trips or persons_attributes inputs.\n            \"\"\"\n)\ntrips[\"hid\"] = trips.pid\n# check that person_attributes has required fields if used\nif persons_attributes is not None:\nif \"pid\" not in persons_attributes.columns and not persons_attributes.index.name == \"pid\":\nraise UserWarning(\n\"Input person_attributes dataframe missing required unique identifier column: 'pid'.\"\n)\nif \"hid\" not in persons_attributes and \"hid\" in trips:\nlogger.warning(\"Adding pid-&gt;hh mapping to persons_attributes from trips.\")\nmapping = dict(zip(trips.pid, trips.hid))\npersons_attributes[\"hid\"] = persons_attributes.pid.map(mapping)\nif \"hzone\" not in persons_attributes.columns and \"hid\" in persons_attributes.columns:\nif hhs_attributes is not None and \"hzone\" in hhs_attributes:\nlogger.warning(\"Adding home locations to persons attributes using hhs_attributes.\")\nmapping = dict(zip(hhs_attributes.hid, hhs_attributes.hzone))\npersons_attributes[\"hzone\"] = persons_attributes.hid.map(mapping)\nelif \"hzone\" in trips and \"hid\" in trips:\nlogger.warning(\n\"Adding home locations to persons attributes using trips attributes.\"\n)\nmapping = dict(zip(trips.hid, trips.hzone))\npersons_attributes[\"hzone\"] = persons_attributes.hid.map(mapping)\n# check if hh_attributes are being used\nif hhs_attributes is not None:\nif \"hid\" not in hhs_attributes.columns and not hhs_attributes.index.name == \"hid\":\nraise UserWarning(\n\"Input hh_attributes dataframe missing required unique identifier column: 'hid'.\"\n)\nif \"hid\" in trips.columns:\nlogger.info(\"Using person to household mapping from trips_diary data\")\nif persons_attributes is not None and \"hid\" not in persons_attributes.columns:\nlogger.info(\n\"Loading person to household mapping for person_attributes from trips data\"\n)\nperson_hh_mapping = dict(zip(trips.pid, trips.hid))\npersons_attributes[\"hid\"] = persons_attributes.pid.map(person_hh_mapping)\nelif persons_attributes is not None and \"hid\" in persons_attributes.columns:\nlogger.info(\"Loading person to household mapping from person_attributes data\")\nperson_hh_mapping = dict(zip(persons_attributes.pid, persons_attributes.hid))\ntrips[\"hid\"] = trips.pid.map(person_hh_mapping)\nelse:\nraise UserWarning(\n\"\"\"\n            Household attributes found but failed to build person to household mapping from provided inputs:\n            Please provide a household ID field ('hid') in either the trips_diary or person_attributes inputs.\n            \"\"\"\n)\nif \"hzone\" not in hhs_attributes.columns:\nif (\npersons_attributes is not None\nand \"hzone\" in persons_attributes\nand \"hid\" in persons_attributes.columns\n):\nlogger.warning(\"Adding home locations to hhs attributes using persons_attributes.\")\nmapping = dict(zip(persons_attributes.hid, persons_attributes.hzone))\nhhs_attributes[\"hzone\"] = hhs_attributes.hid.map(mapping)\nelif \"hzone\" in trips and \"hid\" in trips:\nlogger.warning(\"Adding home locations to hhs attributes using trips attributes.\")\nmapping = dict(zip(trips.hid, trips.hzone))\nhhs_attributes[\"hzone\"] = hhs_attributes.hid.map(mapping)\n# add hzone to trips_diary\nif \"hzone\" not in trips.columns:\nif hhs_attributes is not None and \"hzone\" in hhs_attributes.columns:\nlogger.info(\"Loading household area ('hzone') from hh_attributes input.\")\nhh_mapping = dict(zip(hhs_attributes.hid, hhs_attributes.hzone))\ntrips[\"hzone\"] = trips.hid.map(hh_mapping)\nelif (\npersons_attributes is not None\nand \"hzone\" in persons_attributes.columns\nand \"hid\" in persons_attributes.columns\n):\nlogger.info(\"Loading household area ('hzone') from person_attributes input.\")\nhh_mapping = dict(zip(persons_attributes.hid, persons_attributes.hzone))\ntrips[\"hzone\"] = trips.hid.map(hh_mapping)\nelse:\nlogger.warning(\n\"\"\"\n        Unable to load household area ('hzone') - not found in trips_diary or unable to build from attributes.\n        Pam will try to infer home location from activities, but this behaviour is not recommended.\n        \"\"\"\n)\n# Add an empty frequency fields if required\nif \"freq\" not in trips.columns:\nlogger.warning(\"Using freq of 'None' for all trips.\")\ntrips[\"freq\"] = None\nif persons_attributes is not None and \"freq\" not in persons_attributes.columns:\nlogger.warning(\"Using freq of 'None' for all persons.\")\npersons_attributes[\"freq\"] = None\nif hhs_attributes is not None and \"freq\" not in hhs_attributes.columns:\nlogger.warning(\"Using freq of 'None' for all households.\")\nhhs_attributes[\"freq\"] = None\nif sample_perc is not None:\nif \"freq\" not in trips.columns:\nraise UserWarning(\nf\"\"\"\n                You have opted to use a sample ({sample_perc}, but this option requires that trips frequencies are set:):\n                Please add a 'freq' column to the trips dataframe or remove sampling (set 'sample_perc' = None).\n                \"\"\"\n)\ntrips = sample_population(\ntrips=trips, sample_perc=sample_perc, weight_col=\"freq\"\n)  # sample the travel population\nlogger.debug(\"Resetting trips index if required\")\nif trips.index.name is not None:\npersons_attributes.reset_index(inplace=True)\nif persons_attributes is not None:\nlogger.debug(\"Setting persons_attributes index to pid\")\nif persons_attributes.index.name is None:\npersons_attributes.set_index(\"pid\", inplace=True)\nelif not persons_attributes.index.name == \"pid\":\npersons_attributes = persons_attributes.reset_index().set_index(\"pid\")\nif hhs_attributes is not None:\nlogger.debug(\"Setting households_attributes index to hid\")\nif hhs_attributes.index.name is None:\nhhs_attributes.set_index(\"hid\", inplace=True)\nelif not hhs_attributes.index.name == \"hid\":\nhhs_attributes = hhs_attributes.reset_index().set_index(\"hid\")\nif from_to:\nlogger.debug(\"Initiating from-to parser.\")\nreturn from_to_travel_diary_read(\ntrips=trips,\npersons_attributes=persons_attributes,\nhhs_attributes=hhs_attributes,\ninclude_loc=include_loc,\nsort_by_seq=sort_by_seq,\n)\nif tour_based:\nlogger.debug(\"Initiating tour-based parser.\")\nreturn tour_based_travel_diary_read(\ntrips=trips,\npersons_attributes=persons_attributes,\nhhs_attributes=hhs_attributes,\ninclude_loc=include_loc,\nsort_by_seq=sort_by_seq,\n)\nlogger.debug(\"Initiating trip-based parser.\")\nreturn trip_based_travel_diary_read(\ntrips=trips,\npersons_attributes=persons_attributes,\nhhs_attributes=hhs_attributes,\ninclude_loc=include_loc,\nsort_by_seq=sort_by_seq,\n)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.sample_population","title":"<code>sample_population(trips_df, sample_perc, attributes_df=None, weight_col='freq')</code>","text":"<p>Return the trips of a random sample of the travel population.</p> <p>We merge the trips and attribute datasets to enable probability weights based on population demographics.</p> PARAMETER  DESCRIPTION <code>trips_df</code> <p>Trips dataset</p> <p> TYPE: <code>DataFrame</code> </p> <code>sample_perc</code> <p>Sampling percentage</p> <p> TYPE: <code>float</code> </p> <code>attributes_df</code> <p>Population attributes dataset. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>weight_col</code> <p>The field to use for probability weighting. Defaults to \"freq\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'freq'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame:  a sampled version of the <code>trips_df</code> dataframe</p> Source code in <code>pam/read/diary.py</code> <pre><code>def sample_population(\ntrips_df: pd.DataFrame,\nsample_perc: float,\nattributes_df: Optional[pd.DataFrame] = None,\nweight_col: str = \"freq\",\n) -&gt; pd.DataFrame:\n\"\"\"Return the trips of a random sample of the travel population.\n    We merge the trips and attribute datasets to enable probability weights based on population demographics.\n    Args:\n        trips_df (pd.DataFrame): Trips dataset\n        sample_perc (float): Sampling percentage\n        attributes_df (Optional[pd.DataFrame], optional): Population attributes dataset. Defaults to None.\n        weight_col (str, optional): The field to use for probability weighting. Defaults to \"freq\".\n    Returns:\n        pd.DataFrame:  a sampled version of the `trips_df` dataframe\n    \"\"\"\nif attributes_df is not None:\nsample_pids = (\ntrips_df.groupby(\"pid\")[[\"freq\"]]\n.sum()\n.join(attributes_df, how=\"left\")\n.sample(frac=sample_perc, weights=weight_col)\n.index\n)\nelse:\nsample_pids = (\ntrips_df.groupby(\"pid\")[[\"freq\"]]\n.sum()\n.sample(frac=sample_perc, weights=weight_col)\n.index\n)\nreturn trips_df[trips_df.pid.isin(sample_pids)]\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.tour_based_travel_diary_read","title":"<code>tour_based_travel_diary_read(trips, persons_attributes=None, hhs_attributes=None, include_loc=False, sort_by_seq=None)</code>","text":"<p>Complex travel diray reader.</p> <p>Will try to infer home activiity and tour based purposes.</p> PARAMETER  DESCRIPTION <code>trips</code> <p> TYPE: <code>DataFrame</code> </p> <code>persons_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>include_loc</code> <p>optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_by_seq</code> <p>optionally force trip sorting as True or False. Defaults to None.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/diary.py</code> <pre><code>def tour_based_travel_diary_read(\ntrips: pd.DataFrame,\npersons_attributes: Optional[pd.DataFrame] = None,\nhhs_attributes: Optional[pd.DataFrame] = None,\ninclude_loc: bool = False,\nsort_by_seq: Optional[bool] = None,\n) -&gt; core.Population:\n\"\"\"Complex travel diray reader.\n    Will try to infer home activiity and tour based purposes.\n    Args:\n        trips (pd.DataFrame):\n        persons_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        hhs_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        include_loc (bool, optional): optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns). Defaults to False.\n        sort_by_seq (Optional[bool], optional): optionally force trip sorting as True or False. Defaults to None.\n    Returns:\n        core.Population:\n    \"\"\"\npopulation = build_population(\ntrips=trips, persons_attributes=persons_attributes, hhs_attributes=hhs_attributes\n)\nif sort_by_seq is None and \"seq\" in trips.columns:\nsort_by_seq = True\nif sort_by_seq:\ntrips = trips.sort_values([\"hid\", \"pid\", \"seq\"])\ntrips_dict = hh_person_df_to_dict(trips, \"hid\", \"pid\")  # convert to dict for faster indexing\nfor hid, household in population:\nfor pid, person in household:\nperson_trips = trips_dict.get(hid, {}).get(pid, pd.DataFrame())\nif not len(person_trips):\nperson.stay_at_home()\ncontinue\nloc = None\nif include_loc:\nloc = person_trips.start_loc.iloc[0]\nperson = population[hid][pid]\nperson.add(\nactivity.Activity(\nseq=0,\nact=None,\narea=person_trips.ozone.iloc[0],\nloc=loc,\nstart_time=utils.parse_time(0),\n)\n)\nfor n, trip in person_trips.iterrows():\nstart_loc = None\nend_loc = None\nif include_loc:\nstart_loc = trip.start_loc\nend_loc = trip.end_loc\nperson.add(\nactivity.Leg(\nseq=n,\npurp=trip.purp.lower(),\nmode=trip[\"mode\"].lower(),\nstart_area=trip.ozone,\nend_area=trip.dzone,\nstart_loc=start_loc,\nend_loc=end_loc,\nstart_time=utils.parse_time(trip.tst),\nend_time=utils.parse_time(trip.tet),\ndistance=trip.get(\"distance\"),\nfreq=trip.freq,\n)\n)\nperson.add(\nactivity.Activity(\nseq=n + 1,\nact=None,\narea=trip.dzone,\nloc=end_loc,\nstart_time=utils.parse_time(trip.tet),\n)\n)\nperson.plan.finalise_activity_end_times()\nperson.plan.infer_activities_from_tour_purpose()\nperson.plan.set_leg_purposes()\nreturn population\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.trip_based_travel_diary_read","title":"<code>trip_based_travel_diary_read(trips, persons_attributes=None, hhs_attributes=None, include_loc=False, sort_by_seq=None)</code>","text":"<p>Turn Activity Plan tabular data inputs into core population format.</p> <p>Tabular data inputs are derived from travel survey and attributes.</p> <p>This is a variation of the standard load_travel_diary() method because it does not require activity inference. However all plans are expected to be tour based, so assumed to start and end at home. We expect broadly the same data schema except rather than trip 'purpose' we use trips 'activity'.</p> PARAMETER  DESCRIPTION <code>trips</code> <p> TYPE: <code>DataFrame</code> </p> <code>persons_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>hhs_attributes</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>include_loc</code> <p>optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_by_seq</code> <p>optionally force trip sorting as True or False. Defaults to None.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/diary.py</code> <pre><code>def trip_based_travel_diary_read(\ntrips: pd.DataFrame,\npersons_attributes: Optional[pd.DataFrame] = None,\nhhs_attributes: Optional[pd.DataFrame] = None,\ninclude_loc: bool = False,\nsort_by_seq: Optional[bool] = None,\n) -&gt; core.Population:\n\"\"\"Turn Activity Plan tabular data inputs into core population format.\n    Tabular data inputs are derived from travel survey and attributes.\n    This is a variation of the standard load_travel_diary() method because it does not require activity inference.\n    However all plans are expected to be tour based, so assumed to start and end at home.\n    We expect broadly the same data schema except rather than trip 'purpose' we use trips 'activity'.\n    Args:\n        trips (pd.DataFrame):\n        persons_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        hhs_attributes (Optional[pd.DataFrame], optional): Defaults to None.\n        include_loc (bool, optional): optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns). Defaults to False.\n        sort_by_seq (Optional[bool], optional): optionally force trip sorting as True or False. Defaults to None.\n    Returns:\n        core.Population:\n    \"\"\"\npopulation = build_population(\ntrips=trips, persons_attributes=persons_attributes, hhs_attributes=hhs_attributes\n)\nif sort_by_seq is None and \"seq\" in trips.columns:\nsort_by_seq = True\nif sort_by_seq:\ntrips = trips.sort_values([\"hid\", \"pid\", \"seq\"])\ntrips_dict = hh_person_df_to_dict(trips, \"hid\", \"pid\")  # convert to dict for faster indexing\nfor hid, household in population:\nfor pid, person in household:\nperson_trips = trips_dict.get(hid, {}).get(pid, pd.DataFrame())\nif not len(person_trips):\nperson.stay_at_home()\ncontinue\nhousehold.location.area or person_trips.hzone.iloc[0]\norigin_area = person_trips.ozone.iloc[0]\nloc = None\nif include_loc:\nloc = person_trips.start_loc.iloc[0]\nperson.add(\nactivity.Activity(\nseq=0, act=\"home\", area=origin_area, loc=loc, start_time=utils.parse_time(0)\n)\n)\nfor n, trip in person_trips.iterrows():\nstart_loc = None\nend_loc = None\nif include_loc:\nstart_loc = trip.start_loc\nend_loc = trip.end_loc\npurpose = trip.purp.lower()\nperson.add(\nactivity.Leg(\nseq=n,\npurp=purpose,\nmode=trip[\"mode\"].lower(),\nstart_area=trip.ozone,\nend_area=trip.dzone,\nstart_loc=start_loc,\nend_loc=end_loc,\nstart_time=utils.parse_time(trip.tst),\nend_time=utils.parse_time(trip.tet),\ndistance=trip.get(\"distance\"),\n)\n)\nperson.add(\nactivity.Activity(\nseq=n + 1,\nact=purpose,\narea=trip.dzone,\nloc=end_loc,\nstart_time=utils.parse_time(trip.tet),\n)\n)\nperson.plan.finalise_activity_end_times()\nhousehold.add(person)\npopulation.add(household)\nreturn population\n</code></pre>"},{"location":"api/read/matsim/","title":"pam.read.matsim","text":""},{"location":"api/read/matsim/#pam.read.matsim.get_attributes_from_legs","title":"<code>get_attributes_from_legs(elem)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def get_attributes_from_legs(elem):\nattributes = {}\nfor attr in elem.xpath(\"./attributes/attribute\"):\nattributes[attr.get(\"name\")] = attr.text\nreturn attributes\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.get_attributes_from_person","title":"<code>get_attributes_from_person(elem)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def get_attributes_from_person(elem):\nident = elem.xpath(\"@id\")[0]\nattributes = {}\nfor attr in elem.xpath(\"./attributes/attribute\"):\nattribute_type = attr.get(\"class\")\nattribute_name = attr.get(\"name\")\nif attribute_type == \"java.lang.String\":\nattributes[attribute_name] = attr.text\nelif attribute_type == \"java.lang.Boolean\":\nattributes[attribute_name] = attr.text.lower() == \"true\"\nelif attribute_type == \"java.lang.Integer\":\nattributes[attribute_name] = int(attr.text)\nelif attribute_type == \"java.lang.Double\":\nattributes[attribute_name] = float(attr)\nelif attribute_type == \"org.matsim.vehicles.PersonVehicles\":\nattributes[attribute_name] = parse_veh_attribute(attr.text)\n# last try:\nelse:\nattributes[attribute_name] = attr.text\nreturn ident, attributes\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.load_attributes_map","title":"<code>load_attributes_map(attributes_path)</code>","text":"<p>Given path to MATSim attributes input, return dictionary of attributes (as dict).</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def load_attributes_map(attributes_path):\n\"\"\"Given path to MATSim attributes input, return dictionary of attributes (as dict).\"\"\"\nattributes_map = {}\npeople = utils.get_elems(attributes_path, \"object\")\nfor person in people:\natt_map = {}\nfor attribute in person:\natt_map[attribute.get(\"name\")] = attribute.text\nattributes_map[person.get(\"id\")] = att_map\nreturn attributes_map\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.load_attributes_map_from_v12","title":"<code>load_attributes_map_from_v12(plans_path)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def load_attributes_map_from_v12(plans_path):\nreturn dict(\n[get_attributes_from_person(elem) for elem in utils.get_elems(plans_path, \"person\")]\n)\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.parse_matsim_plan","title":"<code>parse_matsim_plan(plan_xml, person_id, version, simplify_pt_trips, crop, autocomplete, leg_attributes=True, leg_route=True)</code>","text":"<p>Parse a MATSim plan.</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def parse_matsim_plan(\nplan_xml,\nperson_id: str,\nversion: int,\nsimplify_pt_trips: bool,\ncrop: bool,\nautocomplete: bool,\nleg_attributes: bool = True,\nleg_route: bool = True,\n) -&gt; activity.Plan:\n\"\"\"Parse a MATSim plan.\"\"\"\nlogger = logging.getLogger(__name__)\nact_seq = 0\nleg_seq = 0\narrival_dt = START_OF_DAY\ndeparture_dt = None\nplan = activity.Plan()\nfor stage in plan_xml:\n\"\"\"\n        Loop through stages incrementing time and extracting attributes.\n        \"\"\"\nif stage.tag in [\"act\", \"activity\"]:\nact_seq += 1\nact_type = stage.get(\"type\")\nloc = None\nx, y = stage.get(\"x\"), stage.get(\"y\")\nif x and y:\nloc = Point(int(float(x)), int(float(y)))\nif act_type == \"pt interaction\":\ndeparture = stage.get(\"end_time\")\nif departure is not None:\ndeparture_dt = utils.safe_strptime(departure)\nelse:\ndeparture_dt = arrival_dt + timedelta(seconds=0.0)\nelse:\ndeparture_dt = utils.safe_strptime(stage.get(\"end_time\", \"24:00:00\"))\nif departure_dt &lt; arrival_dt:\nlogger.debug(f\"Negative duration activity found at pid={person_id}\")\nplan.add(\nactivity.Activity(\nseq=act_seq,\nact=act_type,\nloc=loc,\nlink=stage.get(\"link\"),\nstart_time=arrival_dt,\nend_time=departure_dt,\n)\n)\nif stage.tag == \"leg\":\nmode, route, attributes = unpack_leg(stage, version)\nif not leg_attributes:\nattributes = {}\nleg_seq += 1\ntrav_time = stage.get(\"trav_time\")\nif trav_time is not None:\nleg_duration = utils.safe_strpdelta(trav_time)\narrival_dt = departure_dt + leg_duration\nelse:\narrival_dt = departure_dt  # todo this assumes 0 duration unless known\nif not leg_route:\n# Optionally ignores route info such as links, distance and so on.\nplan.add(\nactivity.Leg(\nseq=leg_seq,\nmode=mode,\nstart_time=departure_dt,\nend_time=arrival_dt,\nattributes=attributes,\n)\n)\nelse:\nplan.add(\nactivity.Leg(\nseq=leg_seq,\nmode=mode,\nstart_link=route.get(\"start_link\"),\nend_link=route.get(\"end_link\"),\nstart_time=departure_dt,\nend_time=arrival_dt,\ndistance=route.distance,\nattributes=attributes,\nroute=route,\n)\n)\nif simplify_pt_trips:\nplan.simplify_pt_trips()\nplan.set_leg_purposes()\nscore = plan_xml.get(\"score\", None)\nif score:\nscore = float(score)\nplan.score = score  # experienced plan scores\nif crop:\nplan.crop()\nif autocomplete:\nplan.autocomplete_matsim()\nreturn plan\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.parse_veh_attribute","title":"<code>parse_veh_attribute(text)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def parse_veh_attribute(text) -&gt; dict:\nreturn json.loads(text)\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.read_matsim","title":"<code>read_matsim(plans_path, attributes_path=None, all_vehicles_path=None, electric_vehicles_path=None, weight=100, version=12, household_key=None, simplify_pt_trips=False, autocomplete=True, crop=False, keep_non_selected=False, leg_attributes=True, leg_route=True)</code>","text":"<p>Load a MATSim format population into core population format. It is possible to maintain the unity of housholds using a household uid in the attributes input, i.e.: <code>xml     &lt;attribute class=\"java.lang.String\" name=\"hid\"&gt;hh_0001&lt;/attribute&gt;</code>.</p> PARAMETER  DESCRIPTION <code>plans_path</code> <p>path to matsim format xml</p> <p> TYPE: <code>str</code> </p> <code>attributes_path</code> <p>path to matsim format xml. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>all_vehicles_path</code> <p>path to matsim all_vehicles xml file. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>electric_vehicles_path</code> <p>path to matsim electric_vehicles xml. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>weight</code> <p>int. Defaults to 100.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>version</code> <p>Defaults to 12.</p> <p> TYPE: <code>Literal[11, 12]</code> DEFAULT: <code>12</code> </p> <code>household_key</code> <p>Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>simplify_pt_trips</code> <p>bool, simplify legs in multi-leg trips. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>autocomplete</code> <p>bool, fills missing leg and activity attributes. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>crop</code> <p>bool, crop plans that go beyond 24 hours. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>keep_non_selected</code> <p>Whether to parse non-selected plans (storing them in person.plans_non_selected). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>leg_attributes</code> <p>Parse leg attributes such as routing mode. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>leg_route</code> <p>Parse leg route. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>core.Population:</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def read_matsim(\nplans_path: str,\nattributes_path: Optional[str] = None,\nall_vehicles_path: Optional[str] = None,\nelectric_vehicles_path: Optional[str] = None,\nweight: int = 100,\nversion: Literal[11, 12] = 12,\nhousehold_key: Optional[str] = None,\nsimplify_pt_trips: bool = False,\nautocomplete: bool = True,\ncrop: bool = False,\nkeep_non_selected: bool = False,\nleg_attributes: bool = True,\nleg_route: bool = True,\n) -&gt; core.Population:\n\"\"\"Load a MATSim format population into core population format.\n    It is possible to maintain the unity of housholds using a household uid in\n    the attributes input, i.e.:\n    ``` xml\n        &lt;attribute class=\"java.lang.String\" name=\"hid\"&gt;hh_0001&lt;/attribute&gt;\n    ```.\n    Args:\n        plans_path (str): path to matsim format xml\n        attributes_path (str, optional): path to matsim format xml. Defaults to None.\n        all_vehicles_path (str, optional): path to matsim all_vehicles xml file. Defaults to None.\n        electric_vehicles_path (str, optional): path to matsim electric_vehicles xml. Defaults to None.\n        weight (int, optional): int. Defaults to 100.\n        version (Literal[11, 12], optional): Defaults to 12.\n        household_key (str, optional): Defaults to None.\n        simplify_pt_trips (bool, optional): bool, simplify legs in multi-leg trips. Defaults to False.\n        autocomplete (bool, optional): bool, fills missing leg and activity attributes. Defaults to True.\n        crop (bool, optional): bool, crop plans that go beyond 24 hours. Defaults to False.\n        keep_non_selected (bool, optional): Whether to parse non-selected plans (storing them in person.plans_non_selected). Defaults to False.\n        leg_attributes (bool, optional): Parse leg attributes such as routing mode. Defaults to True.\n        leg_route (bool, optional): Parse leg route. Defaults to True.\n    Returns:\n        core.Population:\n    \"\"\"\nlogger = logging.getLogger(__name__)\npopulation = core.Population()\nif attributes_path is not None and version == 12:\nraise UserWarning(\n\"\"\"\nYou have provided an attributes_path and enabled matsim version 12, but\nv12 does not require an attributes input:\nEither remove the attributes_path arg, or enable version 11.\n\"\"\"\n)\nif version not in [11, 12]:\nraise UserWarning(\"Version must be set to 11 or 12.\")\nif version == 11 and not attributes_path:\nlogger.warning(\n\"\"\"\nYou have specified version 11 and not supplied an attributes path, population will not\nhave attributes or be able to use a household attribute id. Check this is intended.\n\"\"\"\n)\nif all_vehicles_path:\nlogger.debug(f\"Loading vehicles from {all_vehicles_path}\")\nif electric_vehicles_path:\nlogger.debug(f\"Loading EVs from {electric_vehicles_path}\")\npopulation._vehicles_manager.from_xml(all_vehicles_path, electric_vehicles_path)\nattributes = {}\nif attributes_path:\nlogger.debug(f\"Loading attributes from {attributes_path}\")\nif (version == 12) and (attributes_path is not None):\nlogger.warning(\n\"It is not required to load attributes from a separate path after version 11.\"\n)\nattributes = load_attributes_map(attributes_path)\nfor person in stream_matsim_persons(\nplans_path,\nattributes=attributes,\nvehicles_manager=population._vehicles_manager,\nweight=weight,\nversion=version,\nsimplify_pt_trips=simplify_pt_trips,\nautocomplete=autocomplete,\ncrop=crop,\nkeep_non_selected=keep_non_selected,\nleg_attributes=leg_attributes,\nleg_route=leg_route,\n):\n# Check if using households, then update population accordingly.\nif household_key and person.attributes.get(household_key):  # using households\nif population.get(person.attributes.get(household_key)):  # existing household\nhousehold = population.get(person.attributes.get(household_key))\nhousehold.add(person)\nelse:  # new household\nhousehold = core.Household(person.attributes.get(household_key), freq=weight)\nhousehold.add(person)\npopulation.add(household)\nelse:  # not using households, create dummy household\nhousehold = core.Household(person.pid, freq=weight)\nhousehold.add(person)\npopulation.add(household)\nreturn population\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.selected_plans","title":"<code>selected_plans(plans_path)</code>","text":"<p>Given path to MATSim plans input, yield person id and plan for all selected plans.</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def selected_plans(plans_path):\n\"\"\"Given path to MATSim plans input, yield person id and plan for all selected plans.\"\"\"\nfor person in utils.get_elems(plans_path, \"person\"):\nfor plan in person:\nif plan.get(\"selected\") == \"yes\":\nyield person.get(\"id\"), plan\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.stream_matsim_persons","title":"<code>stream_matsim_persons(plans_path, attributes={}, vehicles_manager=None, weight=100, version=12, simplify_pt_trips=False, autocomplete=True, crop=False, keep_non_selected=False, leg_attributes=True, leg_route=True)</code>","text":"<p>Stream a MATSim format population into core.Person objects. Expects agent attributes (and vehicles) to be supplied as optional dictionaries. This allows this function to support \"version 11\" plans.</p> <p>TODO: a v12 only method could also stream attributes and would use less memory</p> PARAMETER  DESCRIPTION <code>plans_path</code> <p>path to matsim format xml</p> <p> TYPE: <code>str</code> </p> <code>attributes</code> <p>map of person attributes, only required for v11. Defaults to {}.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>vehicles_manager</code> <p>Population vehicles manager. Defaults to None.</p> <p> TYPE: <code>VehicleManager</code> DEFAULT: <code>None</code> </p> <code>weight</code> <p>path to matsim electric_vehicles xml. Defaults to 100.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>version</code> <p>Defaults to 12.</p> <p> TYPE: <code>Literal[11, 12]</code> DEFAULT: <code>12</code> </p> <code>simplify_pt_trips</code> <p>simplify legs in multi-leg trips. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>autocomplete</code> <p>fills missing leg and activity attributes. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>crop</code> <p>crop plans that go beyond 24 hours. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>keep_non_selected</code> <p>Whether to parse non-selected plans (storing them in <code>person.plans_non_selected</code>). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>leg_attributes</code> <p>Parse leg attributes such as routing mode. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>leg_route</code> <p>Parse leg route. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p><code>version</code> must be set to 11 or 12.</p> YIELDS DESCRIPTION <code>Person</code> <p>Iterator[core.Person]:</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def stream_matsim_persons(\nplans_path: str,\nattributes: dict = {},\nvehicles_manager: Optional[VehicleManager] = None,\nweight: int = 100,\nversion: Literal[11, 12] = 12,\nsimplify_pt_trips: bool = False,\nautocomplete: bool = True,\ncrop: bool = False,\nkeep_non_selected: bool = False,\nleg_attributes: bool = True,\nleg_route: bool = True,\n) -&gt; Iterator[core.Person]:\n\"\"\"Stream a MATSim format population into core.Person objects.\n    Expects agent attributes (and vehicles) to be supplied as optional dictionaries.\n    This allows this function to support \"version 11\" plans.\n    TODO: a v12 only method could also stream attributes and would use less memory\n    Args:\n        plans_path (str):\n            path to matsim format xml\n        attributes (dict, optional):\n            map of person attributes, only required for v11. Defaults to {}.\n        vehicles_manager (VehicleManager, optional):\n            Population vehicles manager. Defaults to None.\n        weight (int, optional):\n            path to matsim electric_vehicles xml. Defaults to 100.\n        version (Literal[11, 12], optional):\n            Defaults to 12.\n        simplify_pt_trips (bool, optional):\n            simplify legs in multi-leg trips. Defaults to False.\n        autocomplete (bool, optional):\n            fills missing leg and activity attributes. Defaults to True.\n        crop (bool, optional):\n            crop plans that go beyond 24 hours. Defaults to False.\n        keep_non_selected (bool, optional):\n            Whether to parse non-selected plans (storing them in `person.plans_non_selected`). Defaults to False.\n        leg_attributes (bool, optional):\n            Parse leg attributes such as routing mode. Defaults to True.\n        leg_route (bool, optional):\n            Parse leg route. Defaults to True.\n    Raises:\n        UserWarning: `version` must be set to 11 or 12.\n    Yields:\n        Iterator[core.Person]:\n    \"\"\"\nif version not in [11, 12]:\nraise UserWarning(\"Version must be set to 11 or 12.\")\nif vehicles_manager is None:\nvehicles_manager = VehicleManager()\nfor person_xml in utils.get_elems(plans_path, \"person\"):\nif version == 11:\nperson_id = person_xml.xpath(\"@id\")[0]\nagent_attributes = attributes.get(person_id, {})\nelse:\nperson_id, agent_attributes = get_attributes_from_person(person_xml)\n# remove vehicle attribute from agent and create person vehicles dictionary\nperson_vehs = {}\nif vehicles_manager.len():\nagent_vehs = agent_attributes.pop(\"vehicles\", {})\nperson_vehs = {mode: vehicles_manager.pop(vid) for mode, vid in agent_vehs.items()}\nperson = core.Person(\nperson_id, attributes=agent_attributes, freq=weight, vehicles=person_vehs\n)\nfor plan_xml in person_xml:\nif plan_xml.get(\"selected\") == \"yes\":\nperson.plan = parse_matsim_plan(\nplan_xml=plan_xml,\nperson_id=person_id,\nversion=version,\nsimplify_pt_trips=simplify_pt_trips,\ncrop=crop,\nautocomplete=autocomplete,\nleg_attributes=leg_attributes,\nleg_route=leg_route,\n)\nelif keep_non_selected and plan_xml.get(\"selected\") == \"no\":\nperson.plans_non_selected.append(\nparse_matsim_plan(\nplan_xml=plan_xml,\nperson_id=person_id,\nversion=version,\nsimplify_pt_trips=simplify_pt_trips,\ncrop=crop,\nautocomplete=autocomplete,\nleg_attributes=leg_attributes,\nleg_route=leg_route,\n)\n)\nyield person\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.unpack_leg","title":"<code>unpack_leg(leg, version)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def unpack_leg(leg, version):\nif version == 12:\nreturn unpack_leg_v12(leg)\nreturn unpack_route_v11(leg)\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.unpack_leg_v12","title":"<code>unpack_leg_v12(leg)</code>","text":"<p>Extract mode, route and attributes as available.</p> PARAMETER  DESCRIPTION <code>leg</code> <p> TYPE: <code>xml_leg_element</code> </p> RETURNS DESCRIPTION <code>tuple[str, Route, dict]</code> <p>tuple[str, Route, dict]: mode, route, attributes</p> Example <p>There are four known cases:</p> <p>=== Unrouted ===</p> <p>For example a leg missing both attributes and route elements, this is the case for non experienced or non routed plans: <pre><code>    &lt;leg mode=\"car\" dep_time=\"07:00:00\" trav_time=\"00:07:34\"&gt;\n&lt;/leg&gt;\n</code></pre></p> <p>=== Transit ===</p> <p>This is a transit routed leg with the route encoded as json string and routingMode attribute: <pre><code>    &lt;leg mode=\"pt\" trav_time=\"00:43:42\"&gt;\n&lt;attributes&gt;\n&lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;bus&lt;/attribute&gt;\n&lt;/attributes&gt;\n&lt;route type=\"default_pt\" start_link=\"1-2\" end_link=\"3-4\" trav_time=\"00:43:42\" distance=\"10100.0\"&gt;\n{\"transitRouteId\":\"work_bound\",\"boardingTime\":\"07:30:00\",\"transitLineId\":\"city_line\",\"accessFacilityId\":\"home_stop_out\",\"egressFacilityId\":\"work_stop_in\"}\n        &lt;/route&gt;\n&lt;/leg&gt;\n</code></pre></p> <p>Route must be transit i.e. there will not be a network route. Route attributes include:     - type = \"default_pt\"     - start_link     - end_link     - trav_time     - distance</p> <p>=== Network Routed ===</p> <p>This is a network routed mode, eg car: <pre><code>    &lt;leg mode=\"car\" dep_time=\"07:58:00\" trav_time=\"00:04:52\"&gt;\n&lt;attributes&gt;\n&lt;attribute name=\"enterVehicleTime\" class=\"java.lang.Double\"&gt;28680.0&lt;/attribute&gt;\n&lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;car&lt;/attribute&gt;\n&lt;/attributes&gt;\n&lt;route type=\"links\" start_link=\"4155\" end_link=\"5221366698030330427_5221366698041252619\" trav_time=\"00:04:52\" distance=\"4898.473995989452\" vehicleRefId=\"null\"&gt;\n4155 5221366345330551489_5221366345327939575 2623 4337 5221366343808222067_5221366343837130911 2984 1636 3671 6110 etc...\n        &lt;/route&gt;\n&lt;/leg&gt;\n</code></pre></p> <p>Route attributes include:     - type = \"links\"     - start_link     - end_link     - trav_time     - distance     - vehicleRefId The network route is given as a space seperated sequence of link ids.</p> <p>=== Teleported ===</p> <p>This is a teleported route, eg walk/cycle: <pre><code>    &lt;leg mode=\"walk\" dep_time=\"09:23:00\" trav_time=\"01:54:10\"&gt;\n&lt;attributes&gt;\n&lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;walk&lt;/attribute&gt;\n&lt;/attributes&gt;\n&lt;route type=\"generic\" start_link=\"5221366698030330427_5221366698041252619\" end_link=\"114\" trav_time=\"01:54:10\" distance=\"5710.003987453454\"&gt;&lt;/route&gt;\n&lt;/leg&gt;\n</code></pre></p> <p>Route attributes include:     - type = \"generic\"     - start_link     - end_link     - trav_time     - distance The network route is empty.</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def unpack_leg_v12(leg) -&gt; tuple[str, Route, dict]:\n\"\"\"Extract mode, route and attributes as available.\n    Args:\n        leg (xml_leg_element):\n    Returns:\n        tuple[str, Route, dict]: mode, route, attributes\n    Example:\n        There are four known cases:\n        === Unrouted ===\n        For example a leg missing both attributes and route elements, this is the case for non experienced or non routed plans:\n        ```xml\n            &lt;leg mode=\"car\" dep_time=\"07:00:00\" trav_time=\"00:07:34\"&gt;\n            &lt;/leg&gt;\n        ```\n        === Transit ===\n        This is a transit routed leg with the route encoded as json string and routingMode attribute:\n        ```xml\n            &lt;leg mode=\"pt\" trav_time=\"00:43:42\"&gt;\n                &lt;attributes&gt;\n                    &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;bus&lt;/attribute&gt;\n                &lt;/attributes&gt;\n                &lt;route type=\"default_pt\" start_link=\"1-2\" end_link=\"3-4\" trav_time=\"00:43:42\" distance=\"10100.0\"&gt;\n                {\"transitRouteId\":\"work_bound\",\"boardingTime\":\"07:30:00\",\"transitLineId\":\"city_line\",\"accessFacilityId\":\"home_stop_out\",\"egressFacilityId\":\"work_stop_in\"}\n                &lt;/route&gt;\n            &lt;/leg&gt;\n        ```\n        Route must be transit i.e. there will not be a network route.\n        Route attributes include:\n            - type = \"default_pt\"\n            - start_link\n            - end_link\n            - trav_time\n            - distance\n        === Network Routed ===\n        This is a network routed mode, eg car:\n        ``` xml\n            &lt;leg mode=\"car\" dep_time=\"07:58:00\" trav_time=\"00:04:52\"&gt;\n                &lt;attributes&gt;\n                    &lt;attribute name=\"enterVehicleTime\" class=\"java.lang.Double\"&gt;28680.0&lt;/attribute&gt;\n                    &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;car&lt;/attribute&gt;\n                &lt;/attributes&gt;\n                &lt;route type=\"links\" start_link=\"4155\" end_link=\"5221366698030330427_5221366698041252619\" trav_time=\"00:04:52\" distance=\"4898.473995989452\" vehicleRefId=\"null\"&gt;\n                4155 5221366345330551489_5221366345327939575 2623 4337 5221366343808222067_5221366343837130911 2984 1636 3671 6110 etc...\n                &lt;/route&gt;\n            &lt;/leg&gt;\n        ```\n        Route attributes include:\n            - type = \"links\"\n            - start_link\n            - end_link\n            - trav_time\n            - distance\n            - vehicleRefId\n        The network route is given as a space seperated sequence of link ids.\n        === Teleported ===\n        This is a teleported route, eg walk/cycle:\n        ``` xml\n            &lt;leg mode=\"walk\" dep_time=\"09:23:00\" trav_time=\"01:54:10\"&gt;\n                &lt;attributes&gt;\n                    &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;walk&lt;/attribute&gt;\n                &lt;/attributes&gt;\n                &lt;route type=\"generic\" start_link=\"5221366698030330427_5221366698041252619\" end_link=\"114\" trav_time=\"01:54:10\" distance=\"5710.003987453454\"&gt;&lt;/route&gt;\n            &lt;/leg&gt;\n        ```\n        Route attributes include:\n            - type = \"generic\"\n            - start_link\n            - end_link\n            - trav_time\n            - distance\n        The network route is empty.\n    \"\"\"\nmode = leg.get(\"mode\")\nroute = Route(leg.xpath(\"route\"))\nattributes = get_attributes_from_legs(leg)\nreturn mode, route, attributes\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.unpack_route_v11","title":"<code>unpack_route_v11(leg)</code>","text":"<p>Extract mode, network route and transit route as available.</p> PARAMETER  DESCRIPTION <code>leg</code> <p> TYPE: <code>xml_leg_element</code> </p> RETURNS DESCRIPTION <code>tuple[str, RouteV11, dict]</code> <p>tuple[str, RouteV11, dict]: mode, route, attributes</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def unpack_route_v11(leg) -&gt; tuple[str, RouteV11, dict]:\n\"\"\"Extract mode, network route and transit route as available.\n    Args:\n        leg (xml_leg_element):\n    Returns:\n        tuple[str, RouteV11, dict]: mode, route, attributes\n    \"\"\"\nmode = leg.get(\"mode\")\nroute = RouteV11(leg.xpath(\"route\"))\nreturn mode, route, {}\n</code></pre>"},{"location":"api/report/benchmarks/","title":"pam.report.benchmarks","text":""},{"location":"api/report/benchmarks/#pam.report.benchmarks.BenchmarkDict","title":"<code>BenchmarkDict</code>","text":"<p>             Bases: <code>TypedDict</code></p>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.BenchmarkDict.aggfunc","title":"<code>aggfunc: list[Callable]</code>  <code>instance-attribute</code>","text":""},{"location":"api/report/benchmarks/#pam.report.benchmarks.BenchmarkDict.colnames","title":"<code>colnames: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/report/benchmarks/#pam.report.benchmarks.BenchmarkDict.data_fields","title":"<code>data_fields: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/report/benchmarks/#pam.report.benchmarks.BenchmarkDict.dimensions","title":"<code>dimensions: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/report/benchmarks/#pam.report.benchmarks.benchmarks","title":"<code>benchmarks(population)</code>","text":"<p>Yield benchmarks.</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> YIELDS DESCRIPTION <code>str</code> <p>Iterator[tuple[str, pd.DataFrame]]: (filename, benchmark).</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def benchmarks(population: Population) -&gt; Iterator[tuple[str, pd.DataFrame]]:\n\"\"\"Yield benchmarks.\n    Args:\n        population (Population):\n    Yields:\n        Iterator[tuple[str, pd.DataFrame]]: (filename, benchmark).\n    \"\"\"\nbms: list[tuple[str, BenchmarkDict]] = [\n(\n\"mode_counts.csv\",\n{\n\"dimensions\": [\"mode\"],\n\"data_fields\": [\"freq\"],\n\"colnames\": [\"mode\", \"trips\"],\n\"aggfunc\": [sum],\n},\n),\n(\n\"distances.csv\",\n{\n\"dimensions\": [\"euclidean_distance_category\"],\n\"data_fields\": [\"freq\"],\n\"colnames\": [\"distance\", \"trips\"],\n\"aggfunc\": [sum],\n},\n),\n(\n\"mode_distances.csv\",\n{\n\"dimensions\": [\"mode\", \"euclidean_distance_category\"],\n\"data_fields\": [\"freq\"],\n\"colnames\": [\"mode\", \"distance\", \"trips\"],\n\"aggfunc\": [sum],\n},\n),\n(\n\"durations.csv\",\n{\n\"dimensions\": [\"duration_category\"],\n\"data_fields\": [\"freq\"],\n\"colnames\": [\"duration\", \"trips\"],\n\"aggfunc\": [sum],\n},\n),\n(\n\"mode_durations.csv\",\n{\n\"dimensions\": [\"mode\", \"duration_category\"],\n\"data_fields\": [\"freq\"],\n\"colnames\": [\"mode\", \"duration\", \"trips\"],\n\"aggfunc\": [sum],\n},\n),\n(\n\"departure_times.csv\",\n{\n\"dimensions\": [\"departure_hour\"],\n\"data_fields\": [\"freq\"],\n\"colnames\": [\"departure_hour\", \"trips\"],\n\"aggfunc\": [sum],\n},\n),\n(\n\"mode_purposes.csv\",\n{\n\"dimensions\": [\"mode\", \"purp\"],\n\"data_fields\": [\"freq\"],\n\"colnames\": [\"mode\", \"purpose\", \"trips\"],\n\"aggfunc\": [sum],\n},\n),\n]\ntrips = population.trips_df()\nfor path, kwargs in bms:\nyield path, create_benchmark(trips.copy(), **kwargs)\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.create_benchmark","title":"<code>create_benchmark(data, dimensions=None, data_fields=None, aggfunc=[len], normalise_by=None, colnames=None)</code>","text":"<p>Extract user-specified benchmarks from the population</p> PARAMETER  DESCRIPTION <code>data</code> <p>dataframe of trip or leg logs with required fields.</p> <p> TYPE: <code>DataFrame</code> </p> <code>dimensions</code> <p>Dimensions to group by. If None, return the disaggregate dataset. Defaults to None.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>data_fields</code> <p>The data to summarise. If None, simply count the instances of each group. Defaults to None.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>aggfunc</code> <p>A set of functions to apply to each data field in <code>data_fields</code>, after grouping by the specified dimensions. For example: [len, sum], [sum, np.mean], [np.sum]. Defaults to [len].</p> <p> TYPE: <code>list[Callable]</code> DEFAULT: <code>[len]</code> </p> <code>normalise_by</code> <p>If given, convert calculated values to percentages across the dimension(s) specified here. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>colnames</code> <p>If given, rename the columns of the returned dataset. Defaults to None.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame:</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def create_benchmark(\ndata: pd.DataFrame,\ndimensions: Optional[list[str]] = None,\ndata_fields: Optional[list[str]] = None,\naggfunc: list[Callable] = [len],\nnormalise_by: Optional[str] = None,\ncolnames: Optional[list[str]] = None,\n) -&gt; pd.DataFrame:\n\"\"\"Extract user-specified benchmarks from the population\n    Args:\n        data (pd.DataFrame): dataframe of trip or leg logs with required fields.\n        dimensions (Optional[list[str]], optional): Dimensions to group by. If None, return the disaggregate dataset. Defaults to None.\n        data_fields (Optional[list[str]], optional): The data to summarise. If None, simply count the instances of each group. Defaults to None.\n        aggfunc (list[Callable], optional):\n            A set of functions to apply to each data field in `data_fields`, after grouping by the specified dimensions.\n            For example: [len, sum], [sum, np.mean], [np.sum].\n            Defaults to [len].\n        normalise_by (Optional[str], optional): If given, convert calculated values to percentages across the dimension(s) specified here. Defaults to None.\n        colnames (Optional[list[str]], optional): If given, rename the columns of the returned dataset. Defaults to None.\n    Returns:\n        pd.DataFrame:\n    \"\"\"\ndf = data.copy()\n# aggregate across specified dimensions\nif dimensions is not None:\nif data_fields is not None:\ndf = df.groupby(dimensions)[data_fields].agg(aggfunc).fillna(0)\nelse:\ndf = df.value_counts(dimensions)\n# show as percentages\nif normalise_by is not None:\nif normalise_by == \"total\":\ndf = df / df.sum(axis=0)\nelse:\ndf = df.groupby(level=normalise_by).transform(lambda x: x / x.sum())\ndf = df.sort_index().reset_index()\n# flatten column MultiIndex\nif isinstance(df.columns, pd.MultiIndex):\ndf.columns = df.columns.map(\"_\".join).str.strip(\"_\")\n# rename columns\nif colnames is not None:\ndf.columns = colnames\nreturn df\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.departure_time_counts","title":"<code>departure_time_counts(population)</code>","text":"<p>number of trips by hour of departure.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def departure_time_counts(population):\n\"number of trips by hour of departure.\"\ndata = population.trips_df()\nreturn create_benchmark(\ndata,\ndimensions=[\"departure_hour\"],\ndata_fields=[\"freq\"],\ncolnames=[\"departure_hour\", \"trips\"],\naggfunc=[sum],\n)\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.distance_counts","title":"<code>distance_counts(population)</code>","text":"<p>number of trips by (euclidean) distance category.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def distance_counts(population):\n\"number of trips by (euclidean) distance category.\"\ndata = population.trips_df()\nreturn create_benchmark(\ndata,\ndimensions=[\"euclidean_distance_category\"],\ndata_fields=[\"freq\"],\ncolnames=[\"distance\", \"trips\"],\naggfunc=[sum],\n)\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.duration_counts","title":"<code>duration_counts(population)</code>","text":"<p>number of trips by duration.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def duration_counts(population):\n\"number of trips by duration.\"\ndata = population.trips_df()\nreturn create_benchmark(\ndata,\ndimensions=[\"duration_category\"],\ndata_fields=[\"freq\"],\ncolnames=[\"duration\", \"trips\"],\naggfunc=[sum],\n)\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.mode_counts","title":"<code>mode_counts(population)</code>","text":"<p>number of trips by (euclidean) distance category.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_counts(population):\n\"number of trips by (euclidean) distance category.\"\ndata = population.trips_df()\nreturn create_benchmark(\ndata, dimensions=[\"mode\"], data_fields=[\"freq\"], colnames=[\"mode\", \"trips\"], aggfunc=[sum]\n)\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.mode_distance_counts","title":"<code>mode_distance_counts(population)</code>","text":"<p>number of trips by (euclidean) distance category and mode.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_distance_counts(population):\n\"number of trips by (euclidean) distance category and mode.\"\ndata = population.trips_df()\nreturn create_benchmark(\ndata,\ndimensions=[\"mode\", \"euclidean_distance_category\"],\ndata_fields=[\"freq\"],\ncolnames=[\"mode\", \"distance\", \"trips\"],\naggfunc=[sum],\n)\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.mode_duration_counts","title":"<code>mode_duration_counts(population)</code>","text":"<p>number of trips by duration and mode.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_duration_counts(population):\n\"number of trips by duration and mode.\"\ndata = population.trips_df()\nreturn create_benchmark(\ndata,\ndimensions=[\"mode\", \"duration_category\"],\ndata_fields=[\"freq\"],\ncolnames=[\"mode\", \"duration\", \"trips\"],\naggfunc=[sum],\n)\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.mode_purpose_counts","title":"<code>mode_purpose_counts(population)</code>","text":"<p>purpose split for each mode.</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_purpose_counts(population):\n\"purpose split for each mode.\"\ndata = population.trips_df()\nreturn create_benchmark(\ndata,\ndimensions=[\"mode\", \"purp\"],\ndata_fields=[\"freq\"],\ncolnames=[\"mode\", \"purpose\", \"trips\"],\naggfunc=[sum],\n)\n</code></pre>"},{"location":"api/report/stringify/","title":"pam.report.stringify","text":""},{"location":"api/report/stringify/#pam.report.stringify.ActColour","title":"<code>ActColour(colour=True)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def __init__(self, colour=True) -&gt; None:\nif colour:\nself._queue = inf_yield(self._col_queue)\nelse:\nself._queue = inf_yield(self._bw_queue)\n</code></pre>"},{"location":"api/report/stringify/#pam.report.stringify.ActColour.mapping","title":"<code>mapping = {'travel': 232}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/stringify/#pam.report.stringify.ActColour.paint","title":"<code>paint(act, text)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def paint(self, act, text):\nif act not in self.mapping:\nself.mapping[act] = next(self._queue)\nreturn f\"\\033[38;5;{self.mapping[act]}m{text}\\033[0m\"\n</code></pre>"},{"location":"api/report/stringify/#pam.report.stringify.inf_yield","title":"<code>inf_yield(queue)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def inf_yield(queue: list):\nwhile True:\nfor i in queue:\nyield i\n</code></pre>"},{"location":"api/report/stringify/#pam.report.stringify.stringify_plan","title":"<code>stringify_plan(plan_array, mapping, colourer)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def stringify_plan(plan_array, mapping, colourer):\nreturn \"\".join([colourer.paint(mapping[i], \"\u2587\") for i in plan_array])\n</code></pre>"},{"location":"api/report/stringify/#pam.report.stringify.stringify_plans","title":"<code>stringify_plans(plans_path, simplify_pt_trips=False, crop=False, colour=True, width=101)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def stringify_plans(\nplans_path, simplify_pt_trips: bool = False, crop: bool = False, colour=True, width=101\n):\nprint(f\"Loading plan sequences from {plans_path}.\")\nencoder = PlansToCategorical(bin_size=int(86400 / width), duration=86400)\ncolourer = ActColour(colour=colour)\nfor person in stream_matsim_persons(plans_path, simplify_pt_trips=simplify_pt_trips, crop=crop):\napply_jitter_to_plan(\nplan=person.plan, jitter=timedelta(minutes=30), min_duration=timedelta(minutes=5)\n)\nencoded = encoder.encode(person.plan)\nstring = stringify_plan(plan_array=encoded, mapping=encoder.index_to_act, colourer=colourer)\nprint(person.pid, string)\nprint()\nprint(\"Key:\")\nfor act in encoder.act_to_index:\nprint(f\"{colourer.paint(act, '\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587')}: {act}\")\n</code></pre>"},{"location":"api/report/summary/","title":"pam.report.summary","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT","title":"<code>TEXT</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/report/summary/#pam.report.summary.TEXT.BOLD","title":"<code>BOLD = '\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.END","title":"<code>END = '\\x1b[0m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.FAIL","title":"<code>FAIL = '\\x1b[91m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.HEADER","title":"<code>HEADER = '\\x1b[95m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.OKBLUE","title":"<code>OKBLUE = '\\x1b[94m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.OKCYAN","title":"<code>OKCYAN = '\\x1b[96m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.OKGREEN","title":"<code>OKGREEN = '\\x1b[92m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.TITLE","title":"<code>TITLE = '\\n\\x1b[95m\\x1b[4m\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.UNDERLINE","title":"<code>UNDERLINE = '\\x1b[4m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.WARNING","title":"<code>WARNING = '\\x1b[93m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.activities_summary","title":"<code>activities_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def activities_summary(population: Population, key=\"subpopulation\") -&gt; PrettyTable:\ntable = PrettyTable()\nsummary = {}\nsummary[\"total\"] = count_activites(population)\nslices = []\nif key is not None:\nslices = population.attributes.get(key, [])\nfor value in slices:\nsummary[value] = count_activites(population, key, value)\ntable.field_names = [\"activities\", \"total\"] + list(slices)\nfor stat, total_value in summary[\"total\"].items():\nrow = [stat, total_value]\nfor k in slices:\nrow.append(summary[k].get(stat))\ntable.add_row(row)\ntable.align[\"activities\"] = \"r\"\nreturn table\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.calc_stats","title":"<code>calc_stats(population, key=None, value=None)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def calc_stats(population: Population, key=None, value=None) -&gt; dict:\nsummary = {\"hhs\": 0, \"persons\": 0}\nhh_occupants = []\nfor _, hh in population:\nif key is not None and value not in hh.get_attribute(key):\ncontinue\nsummary[\"hhs\"] += hh.freq\noccupants = 0\nfor _, person in hh:\nif key is not None and not person.attributes.get(key) == value:\ncontinue\noccupants += 1\nsummary[\"persons\"] += person.freq\nhh_occupants.append(occupants)\nif hh_occupants:\nsummary[\"av_occupancy\"] = sum(hh_occupants) / len(hh_occupants)\nreturn summary\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.count_activites","title":"<code>count_activites(population, key=None, value=None)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def count_activites(population: Population, key=None, value=None) -&gt; dict:\nclasses = population.activity_classes\nsummary = {a: 0 for a in classes}\nfor _, _, person in population.people():\nif key is not None and not person.attributes.get(key) == value:\ncontinue\nfreq = person.freq\nfor act in person.activities:\nsummary[act.act] += freq\nreturn summary\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.count_modes","title":"<code>count_modes(population, key=None, value=None)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def count_modes(population: Population, key=None, value=None) -&gt; dict:\nmodes = population.mode_classes\nsummary = {m: 0 for m in modes}\nfor _, _, person in population.people():\nif key is not None and not person.attributes.get(key) == value:\ncontinue\nfreq = person.freq\nfor leg in person.legs:\nsummary[leg.mode] += freq\nreturn summary\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.get_attributes","title":"<code>get_attributes(population, show=10, key=None, value=None)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def get_attributes(population, show: int = 10, key=None, value=None) -&gt; dict:\nattributes = defaultdict(set)\nfor _, _, person in population.people():\nif key is not None and not person.attributes.get(key) == value:\ncontinue\nfor k, v in person.attributes.items():\nif k == key:\ncontinue\nattributes[k].add(str(v))\nfor k, v in attributes.items():\nif len(v) &gt; show:\nattributes[k] = \"---\"\nreturn dict(attributes)\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.header","title":"<code>header(head)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def header(head: str):\nprint(f\"{TEXT.HEADER.value}{head}{TEXT.END.value}\")\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.header_and_text","title":"<code>header_and_text(head, text)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def header_and_text(head: str, text: str):\nprint(f\"{TEXT.HEADER.value}{head}{TEXT.END.value} {text}\")\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.modes_summary","title":"<code>modes_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def modes_summary(population: Population, key=\"subpopulation\") -&gt; PrettyTable:\ntable = PrettyTable()\nsummary = {}\nsummary[\"total\"] = count_modes(population)\nslices = []\nif key is not None:\nslices = population.attributes.get(key, [])\nfor value in slices:\nsummary[value] = count_modes(population, key, value)\ntable.field_names = [\"modes\", \"total\"] + list(slices)\nfor stat, total_value in summary[\"total\"].items():\nrow = [stat, total_value]\nfor k in slices:\nrow.append(summary[k].get(stat))\ntable.add_row(row)\ntable.align[\"modes\"] = \"r\"\nreturn table\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.pretty_print_summary","title":"<code>pretty_print_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def pretty_print_summary(population: Population, key=\"subpopulation\"):\n# stats\nheader(\"Population Stats:\")\nprint(stats_summary(population, key))\nprint()\n# attributes\nheader(\"Population Attributes:\")\nfor k, vs in get_attributes(population).items():\nsubheader_and_text(f\"{k}:\", vs)\nprint()\nif key is not None:\nfor v in population.attributes.get(key, []):\nheader(f\"Attribute: \\033[4m{v}\\033[0m:\")\nfor k, vs in get_attributes(population, key=key, value=v).items():\nsubheader_and_text(f\"{k}:\", vs)\nprint()\n# activites\nheader(\"Activities:\")\nprint(activities_summary(population, key))\nprint()\n# modes\nheader(\"Modes:\")\nprint(modes_summary(population, key))\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.print_summary","title":"<code>print_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def print_summary(population: Population, key=\"subpopulation\"):\n# stats\nprint(\"Population Stats:\")\nprint(stats_summary(population, key))\nprint()\n# attributes\nprint(\"Population Attributes:\")\nfor k, vs in get_attributes(population).items():\nprint(f\"{k}:\", vs)\nprint()\nif key is not None:\nfor v in population.attributes.get(key, []):\nprint(f\"Attribute: {v}\")\nfor k, vs in get_attributes(population, key=key, value=v).items():\nprint(f\"{k}:\", vs)\nprint()\n# activites\nprint(\"Activities:\")\nprint(activities_summary(population, key))\nprint()\n# modes\nprint(\"Modes:\")\nprint(modes_summary(population, key))\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.stats_summary","title":"<code>stats_summary(population, key='subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def stats_summary(population: Population, key=\"subpopulation\") -&gt; PrettyTable:\ntable = PrettyTable()\nsummary = {}\nsummary[\"total\"] = calc_stats(population)\nslices = []\nif key is not None:\nslices = population.attributes.get(key, [])\nfor value in slices:\nsummary[value] = calc_stats(population, key, value)\ntable.field_names = [\"stat\", \"total\"] + list(slices)\nfor stat, total_value in summary[\"total\"].items():\nrow = [stat, total_value]\nfor k in slices:\nrow.append(summary[k].get(stat))\ntable.add_row(row)\ntable.align[\"stat\"] = \"r\"\nreturn table\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.subheader_and_text","title":"<code>subheader_and_text(head, text)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def subheader_and_text(head: str, text: str):\nprint(f\"{TEXT.OKBLUE.value}{head}{TEXT.END.value} {text}\")\n</code></pre>"},{"location":"api/samplers/attributes/","title":"pam.samplers.attributes","text":""},{"location":"api/samplers/attributes/#pam.samplers.attributes.bin_integer_transformer","title":"<code>bin_integer_transformer(features, target, bins, default=None)</code>","text":"<p>Bin a target integer feature based on bins.</p> <p>Where bins are a dict, with keys as a tuple of bin extends (inclusive) and values as the new mapping. Missing ranges will return None. Where features are a dictionary structure of features, eg: {'age':1, ...}.</p> Source code in <code>pam/samplers/attributes.py</code> <pre><code>def bin_integer_transformer(features, target, bins, default=None):\n\"\"\"Bin a target integer feature based on bins.\n    Where bins are a dict, with keys as a tuple of bin extends (inclusive) and values as the new mapping.\n    Missing ranges will return None.\n    Where features are a dictionary structure of features, eg: {'age':1, ...}.\n    \"\"\"\nvalue = features.get(target)\nif value is None:\nraise KeyError(f\"Can not find target key: {target} in sampling features: {features}\")\nfor (lower, upper), new_value in bins.items():\nif lower &lt; int(value) &lt;= upper:\nreturn new_value\nreturn default\n</code></pre>"},{"location":"api/samplers/attributes/#pam.samplers.attributes.discrete_joint_distribution_sampler","title":"<code>discrete_joint_distribution_sampler(features, mapping, distribution, careful=False, seed=None)</code>","text":"<p>Randomly sample from a joint distribution based some discrete features.</p> PARAMETER  DESCRIPTION <code>features</code> <p>a dictionary structure of features, eg: {'gender':'female'}</p> <p> TYPE: <code>dict</code> </p> <code>mapping</code> <p>the feature name for each level of the distribution, e.g.: ['age', 'gender']</p> <p> TYPE: <code>Any</code> </p> <code>distribution</code> <p>A nested dict of probabilities based on possible features. E.g.: {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': .5}}</p> <p> TYPE: <code>dict[dict]</code> </p> <code>careful</code> <p>If True, missing mapped feature in <code>distribution</code> will raise an exception. If False, missing values will return False. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>all <code>mapping</code> keys must be in <code>features</code>.</p> <code>KeyError</code> <p>If <code>careful</code>, mapped feature must be a key in <code>distribution</code>.</p> RETURNS DESCRIPTION <code>bool</code> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/samplers/attributes.py</code> <pre><code>def discrete_joint_distribution_sampler(\nfeatures: dict,\nmapping: Any,\ndistribution: dict[dict],\ncareful: bool = False,\nseed: Optional[int] = None,\n) -&gt; bool:\n\"\"\"Randomly sample from a joint distribution based some discrete features.\n    Args:\n        features (dict): a dictionary structure of features, eg: {'gender':'female'}\n        mapping (Any): the feature name for each level of the distribution, e.g.: ['age', 'gender']\n        distribution (dict[dict]):\n            A nested dict of probabilities based on possible features.\n            E.g.: {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': .5}}\n        careful (bool, optional):\n            If True, missing mapped feature in `distribution` will raise an exception. If False, missing values will return False.\n            Defaults to False.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n    Raises:\n        KeyError: all `mapping` keys must be in `features`.\n        KeyError: If `careful`, mapped feature must be a key in `distribution`.\n    Returns:\n        bool:\n    \"\"\"\n# Fix random seed\nrandom.seed(seed)\np = distribution\nfor key in mapping:\nvalue = features.get(key)\nif value is None:\nraise KeyError(f\"Can not find mapping: {key} in sampling features: {features}\")\np = p.get(value)\nif p is None:\nif careful:\nraise KeyError(f\"Can not find feature for {key}: {value} in distribution: {p}\")\nelse:\nreturn False\nreturn random.random() &lt;= p\n</code></pre>"},{"location":"api/samplers/basic/","title":"pam.samplers.basic","text":""},{"location":"api/samplers/basic/#pam.samplers.basic.freq_sample","title":"<code>freq_sample(freq, sample, seed=None)</code>","text":"<p>Down or up sample a frequency based on a sample size.</p> <p>Sub unit frequencies are rounded probabalistically.</p> PARAMETER  DESCRIPTION <code>freq</code> <p>pre sampled frequency.</p> <p> TYPE: <code>float</code> </p> <code>sample</code> <p>sample size.</p> <p> TYPE: <code>float</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>new frequency</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/samplers/basic.py</code> <pre><code>def freq_sample(freq: float, sample: float, seed: Optional[int] = None) -&gt; int:\n\"\"\"Down or up sample a frequency based on a sample size.\n    Sub unit frequencies are rounded probabalistically.\n    Args:\n        freq (float): pre sampled frequency.\n        sample (float): sample size.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n    Returns:\n        int: new frequency\n    \"\"\"\n# Fix random seed\nrandom.seed(seed)\nnew_freq = freq * sample\nremainder = new_freq - int(new_freq)\nremainder = int(random.random() &lt; remainder)\nreturn int(new_freq) + remainder\n</code></pre>"},{"location":"api/samplers/facility/","title":"pam.samplers.facility","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler","title":"<code>FacilitySampler(facilities, zones, activities=None, build_xml=True, fail=True, random_default=True, weight_on=None, max_walk=None, transit_modes=None, expected_euclidean_speeds=None, activity_areas_path=None, seed=None)</code>","text":"<p>Sampler object for facilities.</p> Note <p>If a zone id is missing then the sampler will not be able to default to random sample, so will either return None or fail as per the fail flag.</p> PARAMETER  DESCRIPTION <code>facilities</code> <p>facilities Geodataframe</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>zones</code> <p>zones Geodataframe</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>activities</code> <p>optionally set list of subset of activities to be considered. Defaults to None.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>build_xml</code> <p>flag to build a facility xml output (for MATSim). Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>fail</code> <p>flag hard fail if sample not found. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>random_default</code> <p>flag for defaulting to random sample when activity missing. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>weight_on</code> <p>the column name of the facilities geodataframe which contains facility weights (for sampling). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>max_walk</code> <p>maximum walking distnace from a transit stop. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>transit_modes</code> <p>a list of PT modes. If not specified, the default list in variables.TRANSIT_MODES is used. Defaults to None.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>expected_euclidean_speeds</code> <p>a dictionary specifying the euclidean speed of the various modes (m/s). If not specified, the default list in variables.EXPECTED_EUCLIDEAN_SPEEDS is used. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>activity_areas_path</code> <p>path to the activity areas shapefile (previously exported throught the FacilitySampler.export_activity_areas method). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def __init__(\nself,\nfacilities: gp.GeoDataFrame,\nzones: gp.GeoDataFrame,\nactivities: Optional[list] = None,\nbuild_xml: bool = True,\nfail: bool = True,\nrandom_default: bool = True,\nweight_on: Optional[str] = None,\nmax_walk: Optional[float] = None,\ntransit_modes: Optional[list] = None,\nexpected_euclidean_speeds: Optional[dict] = None,\nactivity_areas_path: Optional[str] = None,\nseed: Optional[int] = None,\n) -&gt; None:\n\"\"\"Sampler object for facilities.\n    Note:\n      If a zone id is missing then the sampler will not be able to default to random sample, so will either return None or fail as per the fail flag.\n    Args:\n        facilities (gp.GeoDataFrame): facilities Geodataframe\n        zones (gp.GeoDataFrame): zones Geodataframe\n        activities (Optional[list], optional): optionally set list of subset of activities to be considered. Defaults to None.\n        build_xml (bool, optional): flag to build a facility xml output (for MATSim). Defaults to True.\n        fail (bool, optional): flag hard fail if sample not found. Defaults to True.\n        random_default (bool, optional): flag for defaulting to random sample when activity missing. Defaults to True.\n        weight_on (Optional[str], optional): the column name of the facilities geodataframe which contains facility weights (for sampling). Defaults to None.\n        max_walk (Optional[float], optional): maximum walking distnace from a transit stop. Defaults to None.\n        transit_modes (Optional[list], optional):  a list of PT modes. If not specified, the default list in variables.TRANSIT_MODES is used. Defaults to None.\n        expected_euclidean_speeds (Optional[dict], optional): a dictionary specifying the euclidean speed of the various modes (m/s). If not specified, the default list in variables.EXPECTED_EUCLIDEAN_SPEEDS is used. Defaults to None.\n        activity_areas_path (Optional[str], optional): path to the activity areas shapefile (previously exported throught the FacilitySampler.export_activity_areas method). Defaults to None.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n    \"\"\"\nself.logger = logging.getLogger(__name__)\n# Fix random seed\nself.seed = seed\nif activities is None:\nself.activities = list(set(facilities.activity))\nelse:\nself.activities = activities\n## overrides for transit mode and speed specifications\nself.TRANSIT_MODES = transit_modes if transit_modes is not None else variables.TRANSIT_MODES\nself.EXPECTED_EUCLIDEAN_SPEEDS = (\nexpected_euclidean_speeds\nif expected_euclidean_speeds is not None\nelse variables.EXPECTED_EUCLIDEAN_SPEEDS\n)\n# spatial join\nif activity_areas_path is None:\nself.activity_areas = self.spatial_join(facilities, zones)\nself.activity_areas_dict = self.activity_areas_indexing(self.activity_areas)\nelse:\nself.load_activity_areas(activity_areas_path)\n# build samplers\nself.samplers = self.build_facilities_sampler(\nself.activity_areas_dict, weight_on=weight_on, max_walk=max_walk\n)\nself.build_xml = build_xml\nself.fail = fail\nself.random_default = random_default\nif random_default:\nself.random_sampler = RandomPointSampler(geoms=zones, fail=fail, seed=seed)\nself.facilities = {}\nself.index_counter = 0\nself.error_counter = 0\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.EXPECTED_EUCLIDEAN_SPEEDS","title":"<code>EXPECTED_EUCLIDEAN_SPEEDS = expected_euclidean_speeds if expected_euclidean_speeds is not None else variables.EXPECTED_EUCLIDEAN_SPEEDS</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.TRANSIT_MODES","title":"<code>TRANSIT_MODES = transit_modes if transit_modes is not None else variables.TRANSIT_MODES</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.activities","title":"<code>activities = list(set(facilities.activity))</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.activity_areas","title":"<code>activity_areas = self.spatial_join(facilities, zones)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.activity_areas_dict","title":"<code>activity_areas_dict = self.activity_areas_indexing(self.activity_areas)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.build_xml","title":"<code>build_xml = build_xml</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.error_counter","title":"<code>error_counter = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.facilities","title":"<code>facilities = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.fail","title":"<code>fail = fail</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.index_counter","title":"<code>index_counter = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.random_default","title":"<code>random_default = random_default</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.random_sampler","title":"<code>random_sampler = RandomPointSampler(geoms=zones, fail=fail, seed=seed)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.samplers","title":"<code>samplers = self.build_facilities_sampler(self.activity_areas_dict, weight_on=weight_on, max_walk=max_walk)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.seed","title":"<code>seed = seed</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.activity_areas_indexing","title":"<code>activity_areas_indexing(activity_areas)</code>","text":"<p>Convert joined zone-activities gdf to a nested dictionary for faster indexing.</p> <p>The first index level refers to zones, while the second to activity purposes.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def activity_areas_indexing(self, activity_areas):\n\"\"\"Convert joined zone-activities gdf to a nested dictionary for faster indexing.\n    The first index level refers to zones, while the second to activity purposes.\n    \"\"\"\nactivity_areas_dict = {x: {} for x in activity_areas[\"index_right\"].unique()}\nfor (zone, act), facility_data in activity_areas.groupby([\"index_right\", \"activity\"]):\nactivity_areas_dict[zone][act] = facility_data\nreturn activity_areas_dict\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.build_facilities_sampler","title":"<code>build_facilities_sampler(activity_areas, weight_on=None, max_walk=None)</code>","text":"<p>Build facility location sampler from osmfs input.</p> <p>The sampler returns a tuple of (uid, Point). TODO: I do not like having a sjoin and assuming index names here TODO: look to move to more carefully defined input data format for facilities.</p> PARAMETER  DESCRIPTION <code>activity_areas</code> <p> TYPE: <code>dict</code> </p> <code>weight_on</code> <p>a column (name) of the facilities geodataframe to be used as a sampling weight. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>max_walk</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p> TYPE: <code>dict</code> </p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def build_facilities_sampler(\nself,\nactivity_areas: dict,\nweight_on: Optional[str] = None,\nmax_walk: Optional[float] = None,\n) -&gt; dict:\n\"\"\"Build facility location sampler from osmfs input.\n    The sampler returns a tuple of (uid, Point).\n    TODO: I do not like having a sjoin and assuming index names here\n    TODO: look to move to more carefully defined input data format for facilities.\n    Args:\n        activity_areas (dict):\n        weight_on (Optional[str], optional): a column (name) of the facilities geodataframe to be used as a sampling weight. Defaults to None.\n        max_walk (Optional[float], optional): Defaults to None.\n    Returns:\n        dict:\n    \"\"\"\nsampler_dict = {}\nself.logger.warning(\"Building sampler, this may take a while.\")\nfor zone in set(activity_areas.keys()):\nsampler_dict[zone] = {}\nzone_facs = activity_areas.get(zone, {})\nfor act in self.activities:\nself.logger.debug(f\"Building sampler for zone:{zone} act:{act}.\")\nfacs = zone_facs.get(act, None)\nif facs is not None:\npoints = list(facs.geometry.items())\nif weight_on is not None:\n# weighted sampler\nweights = facs[weight_on]\ntransit_distance = facs[\"transit\"] if max_walk is not None else None\nsampler_dict[zone][act] = inf_yielder(\npoints,\nweights,\ntransit_distance,\nmax_walk,\nself.TRANSIT_MODES,\nself.EXPECTED_EUCLIDEAN_SPEEDS,\nseed=self.seed,\n)\nelse:\n# simple sampler\nsampler_dict[zone][act] = inf_yielder(points, seed=self.seed)\nelse:\nsampler_dict[zone][act] = None\nreturn sampler_dict\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.clear","title":"<code>clear()</code>","text":"Source code in <code>pam/samplers/facility.py</code> <pre><code>def clear(self):\nself.facilities = {}\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.export_activity_areas","title":"<code>export_activity_areas(filepath)</code>","text":"<p>Export the spatially joined facilities-zones geodataframe.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def export_activity_areas(self, filepath):\n\"Export the spatially joined facilities-zones geodataframe.\"\nwith open(filepath, \"wb\") as f:\npickle.dump(self.activity_areas_dict, f)\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.load_activity_areas","title":"<code>load_activity_areas(filepath)</code>","text":"<p>Load the spatially joined facilities-zones geodataframe.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def load_activity_areas(self, filepath):\n\"Load the spatially joined facilities-zones geodataframe.\"\nwith open(filepath, \"rb\") as f:\nself.activity_areas_dict = pickle.load(f)\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.sample","title":"<code>sample(location_idx, activity, mode=None, previous_duration=None, previous_loc=None)</code>","text":"<p>Sample a Point from the given location and for the given activity.</p> PARAMETER  DESCRIPTION <code>location_idx</code> <p>the zone to sample from</p> <p> TYPE: <code>str</code> </p> <code>activity</code> <p>activity purpose</p> <p> TYPE: <code>str</code> </p> <code>mode</code> <p>transport mode used to access facility. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>previous_duration</code> <p>the time duration of the arriving leg. Defaults to None.</p> <p> TYPE: <code>Optional[Timedelta]</code> DEFAULT: <code>None</code> </p> <code>previous_loc</code> <p>the location of the last visited activity. Defaults to None.</p> <p> TYPE: <code>Optional[Point]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Point</code> <p>shapely.geometry.Point: Sampled point</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def sample(\nself,\nlocation_idx: str,\nactivity: str,\nmode: Optional[str] = None,\nprevious_duration: Optional[pd.Timedelta] = None,\nprevious_loc: Optional[shapely.geometry.Point] = None,\n) -&gt; shapely.geometry.Point:\n\"\"\"Sample a Point from the given location and for the given activity.\n    Args:\n        location_idx (str): the zone to sample from\n        activity (str): activity purpose\n        mode (Optional[str], optional): transport mode used to access facility. Defaults to None.\n        previous_duration (Optional[pd.Timedelta], optional): the time duration of the arriving leg. Defaults to None.\n        previous_loc (Optional[shapely.geometry.Point], optional): the location of the last visited activity. Defaults to None.\n    Returns:\n        shapely.geometry.Point: Sampled point\n    \"\"\"\nidx, loc = self.sample_facility(\nlocation_idx,\nactivity,\nmode=mode,\nprevious_duration=previous_duration,\nprevious_loc=previous_loc,\n)\nif idx is not None and self.build_xml:\nself.facilities[idx] = {\"loc\": loc, \"act\": activity}\nreturn loc\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.sample_facility","title":"<code>sample_facility(location_idx, activity, patience=1000, mode=None, previous_duration=None, previous_loc=None)</code>","text":"<p>Sample a facility id and location. If a location idx is missing, can return a random location.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def sample_facility(\nself,\nlocation_idx: str,\nactivity: str,\npatience=1000,\nmode: Optional[str] = None,\nprevious_duration: Optional[pd.Timedelta] = None,\nprevious_loc: Optional[shapely.geometry.Point] = None,\n):\n\"\"\"Sample a facility id and location. If a location idx is missing, can return a random location.\"\"\"\nif location_idx not in self.samplers:\nif self.random_default:\nself.logger.warning(f\"Using random sample for zone:{location_idx}:{activity}\")\nidx = f\"_{self.index_counter}\"\nself.index_counter += 1\nreturn idx, self.random_sampler.sample(location_idx, activity)\nif self.fail:\nraise IndexError(f\"Cannot find idx: {location_idx} in facilities sampler\")\nself.logger.warning(f\"Missing location idx:{location_idx}\")\nreturn None, None\nsampler = self.samplers[location_idx][activity]\nif sampler is None:\nself.error_counter += 1\nif self.error_counter &gt;= patience:\nraise UserWarning(f\"Failures to sample, exceeded patience of {patience}.\")\nif self.random_default:\nself.logger.warning(f\"Using random sample for zone:{location_idx}:{activity}\")\nidx = f\"_{self.index_counter}\"\nself.index_counter += 1\nreturn idx, self.random_sampler.sample(location_idx, activity)\nelif self.fail:\nraise UserWarning(\nf\"Cannot find activity: {activity} in location: {location_idx}, consider allowing random default.\"\n)\nelse:\nreturn None, None\nelse:\nself.error_counter = 0\nif isinstance(sampler, Generator):\nreturn next(sampler)\nelse:\nreturn next(sampler(mode, previous_duration, previous_loc))\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.spatial_join","title":"<code>spatial_join(facilities, zones)</code>","text":"<p>Spatially join facility and zone data.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def spatial_join(self, facilities, zones):\n\"Spatially join facility and zone data.\"\nself.logger.warning(\"Joining facilities data to zones, this may take a while.\")\nactivity_areas = gp.sjoin(facilities, zones, how=\"inner\", predicate=\"intersects\")\nreturn activity_areas\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.write_facilities_xml","title":"<code>write_facilities_xml(path, comment=None, coordinate_reference_system=None)</code>","text":"Source code in <code>pam/samplers/facility.py</code> <pre><code>def write_facilities_xml(self, path, comment=None, coordinate_reference_system=None):\ncreate_local_dir(os.path.dirname(path))\ncompression = DEFAULT_GZIP_COMPRESSION if is_gzip(path) else 0\nwith et.xmlfile(path, encoding=\"utf-8\", compression=compression) as xf:\nxf.write_declaration()\nxf.write_doctype(\n'&lt;!DOCTYPE facilities SYSTEM \"http://matsim.org/files/dtd/facilities_v1.dtd\"&gt;'\n)\nwith xf.element(\"facilities\"):\nif comment:\nxf.write(et.Comment(comment), pretty_print=True)\nif coordinate_reference_system is not None:\nxf.write(create_crs_attribute(coordinate_reference_system), pretty_print=True)\nfor i, data in self.facilities.items():\nfacility_xml = et.Element(\n\"facility\", {\"id\": str(i), \"x\": str(data[\"loc\"].x), \"y\": str(data[\"loc\"].y)}\n)\net.SubElement(facility_xml, \"activity\", {\"type\": data[\"act\"]})\nxf.write(facility_xml, pretty_print=True)\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.euclidean_distance","title":"<code>euclidean_distance(p1, p2)</code>","text":"<p>Calculate euclidean distance between two Activity.location.loc objects.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def euclidean_distance(p1, p2):\n\"\"\"Calculate euclidean distance between two Activity.location.loc objects.\"\"\"\nreturn ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** 0.5\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.inf_yielder","title":"<code>inf_yielder(candidates, weights=None, transit_distance=None, max_walk=None, transit_modes=None, expected_euclidean_speeds=None, seed=None)</code>","text":"<p>Redirect to the appropriate sampler.</p> PARAMETER  DESCRIPTION <code>candidates</code> <p>Tuples contain candidate facilities index values and their geolocation.</p> <p> TYPE: <code>list[tuple[Any, Point]]</code> </p> <code>weights</code> <p>sampling weights (ie facility floorspace). Defaults to None.</p> <p> TYPE: <code>Optional[Series]</code> DEFAULT: <code>None</code> </p> <code>transit_distance</code> <p>distance of each candidate facility from the closest PT stop. Defaults to None.</p> <p> TYPE: <code>Optional[Series]</code> DEFAULT: <code>None</code> </p> <code>max_walk</code> <p>maximum walking distance from a PT stop. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>transit_modes</code> <p>Possible transit modes. Defaults to None.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>expected_euclidean_speeds</code> <p>Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[Any, Point]</code> <p>tuple[Any, shapely.geometry.Point]: Sampled candidate.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def inf_yielder(\ncandidates: list[tuple[Any, shapely.geometry.Point]],\nweights: Optional[pd.Series] = None,\ntransit_distance: Optional[pd.Series] = None,\nmax_walk: Optional[float] = None,\ntransit_modes: Optional[list[str]] = None,\nexpected_euclidean_speeds: Optional[dict] = None,\nseed: Optional[int] = None,\n) -&gt; tuple[Any, shapely.geometry.Point]:\n\"\"\"Redirect to the appropriate sampler.\n    Args:\n        candidates (list[tuple[Any, shapely.geometry.Point]]): Tuples contain candidate facilities index values and their geolocation.\n        weights (Optional[pd.Series], optional): sampling weights (ie facility floorspace). Defaults to None.\n        transit_distance (Optional[pd.Series], optional):  distance of each candidate facility from the closest PT stop. Defaults to None.\n        max_walk (Optional[float], optional): maximum walking distance from a PT stop. Defaults to None.\n        transit_modes (Optional[list[str]], optional): Possible transit modes. Defaults to None.\n        expected_euclidean_speeds (Optional[dict], optional): Defaults to None.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n    Returns:\n        tuple[Any, shapely.geometry.Point]: Sampled candidate.\n    \"\"\"\nif isinstance(weights, pd.Series):\nreturn lambda mode=None, previous_duration=None, previous_loc=None: inf_yielder_weighted(\ncandidates=candidates,\nweights=weights,\ntransit_distance=transit_distance,\nmax_walk=max_walk,\ntransit_modes=transit_modes,\nexpected_euclidean_speeds=expected_euclidean_speeds,\nmode=mode,\nprevious_duration=previous_duration,\nprevious_loc=previous_loc,\nseed=seed,\n)\nelse:\nreturn inf_yielder_simple(candidates, seed=seed)\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.inf_yielder_simple","title":"<code>inf_yielder_simple(candidates, seed=None)</code>","text":"<p>Endlessly yield shuffled candidate items.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def inf_yielder_simple(\ncandidates: list[tuple[Any, shapely.geometry.Point]], seed: Optional[int] = None\n) -&gt; Iterator[tuple[Any, shapely.geometry.Point]]:\n\"\"\"Endlessly yield shuffled candidate items.\"\"\"\n# Fix random seed\nrandom.seed(seed)\nwhile True:\nrandom.shuffle(candidates)\nfor c in candidates:\nyield c\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.inf_yielder_weighted","title":"<code>inf_yielder_weighted(candidates, weights, transit_distance, max_walk, transit_modes, expected_euclidean_speeds, mode, previous_duration, previous_loc, seed=None)</code>","text":"<p>A more complex sampler, which allows for weighted and rule-based sampling (with replacement).</p> PARAMETER  DESCRIPTION <code>candidates</code> <p>Tuples contain candidate facilities index values and their geolocation.</p> <p> TYPE: <code>list[tuple[Any, Point]]</code> </p> <code>weights</code> <p>sampling weights (ie facility floorspace).</p> <p> TYPE: <code>Optional[Series]</code> </p> <code>transit_distance</code> <p>distance of each candidate facility from the closest public transport (PT) stop.</p> <p> TYPE: <code>Optional[Series]</code> </p> <code>max_walk</code> <p>maximum walking distance from a PT stop.</p> <p> TYPE: <code>Optional[float]</code> </p> <code>transit_modes</code> <p>Possible transit modes.</p> <p> TYPE: <code>Optional[list[str]]</code> </p> <code>expected_euclidean_speeds</code> <p> TYPE: <code>Optional[dict]</code> </p> <code>mode</code> <p>transport mode used to access facility.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>previous_duration</code> <p>the time duration of the arriving leg.</p> <p> TYPE: <code>Optional[Timedelta]</code> </p> <code>previous_loc</code> <p>the location of the last visited activity.</p> <p> TYPE: <code>Optional[Point]</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>Any</code> <p>Iterator[tuple[Any, shapely.geometry.Point]]:</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def inf_yielder_weighted(\ncandidates: list[tuple[Any, shapely.geometry.Point]],\nweights: Optional[pd.Series],\ntransit_distance: Optional[pd.Series],\nmax_walk: Optional[float],\ntransit_modes: Optional[list[str]],\nexpected_euclidean_speeds: Optional[dict],\nmode: Optional[str],\nprevious_duration: Optional[pd.Timedelta],\nprevious_loc: Optional[shapely.geometry.Point],\nseed: Optional[int] = None,\n) -&gt; Iterator[tuple[Any, shapely.geometry.Point]]:\n\"\"\"A more complex sampler, which allows for weighted and rule-based sampling (with replacement).\n    Args:\n        candidates (list[tuple[Any, shapely.geometry.Point]]): Tuples contain candidate facilities index values and their geolocation.\n        weights (Optional[pd.Series]): sampling weights (ie facility floorspace).\n        transit_distance (Optional[pd.Series]): distance of each candidate facility from the closest public transport (PT) stop.\n        max_walk (Optional[float]): maximum walking distance from a PT stop.\n        transit_modes (Optional[list[str]]): Possible transit modes.\n        expected_euclidean_speeds (Optional[dict]):\n        mode (Optional[str]):  transport mode used to access facility.\n        previous_duration (Optional[pd.Timedelta]): the time duration of the arriving leg.\n        previous_loc (Optional[shapely.geometry.Point]):  the location of the last visited activity.\n        seed (Optional[int], optional):  If given, seed number for reproducible results. Defaults to None.\n    Yields:\n        Iterator[tuple[Any, shapely.geometry.Point]]:\n    \"\"\"\n# Fix random seed\nnp.random.seed(seed)\nif isinstance(weights, pd.Series):\n# if a series of facility weights is provided, perform weighted sampling with replacement\nwhile True:\n## if a transit mode is used and the distance from a stop is longer than the maximum walking distance,\n## then replace the weight with a very small value\nif isinstance(transit_distance, pd.Series) and mode in transit_modes:\nweights = np.where(\ntransit_distance &gt; max_walk,\nweights\n* variables.SMALL_VALUE,  # if no alternative is found within the acceptable range, the initial weights will be used\nweights,\n)\nelse:\nweights = weights.values\n# if the last location has been passed to the sampler, normalise by (expected) distance\nif previous_loc is not None:\n# calculate euclidean distance between the last visited location and every candidate location\ndistances = np.array(\n[euclidean_distance(previous_loc, candidate[1]) for candidate in candidates]\n)\n# calculate deviation from \"expected\" distance\nspeed = (\nexpected_euclidean_speeds[mode]\nif mode in expected_euclidean_speeds.keys()\nelse expected_euclidean_speeds[\"average\"]\n)\nexpected_distance = (\nprevious_duration / pd.Timedelta(seconds=1)\n) * speed  # (in meters)\ndistance_weights = np.abs(distances - expected_distance)\ndistance_weights = np.where(\ndistance_weights == 0, variables.SMALL_VALUE, distance_weights\n)  # avoid having zero weights\n## normalise weights by distance\nweights = weights / (distance_weights**2)  # distance decay factor of 2\nweights = weights / weights.sum()  # probability weights should add up to 1\nyield candidates[np.random.choice(len(candidates), p=weights)]\n</code></pre>"},{"location":"api/samplers/population/","title":"pam.samplers.population","text":""},{"location":"api/samplers/population/#pam.samplers.population.sample","title":"<code>sample(population, sample, seed=None, verbose=False)</code>","text":"<p>Sample a new population from the existing using a sample size.</p> <p>Frequency of returned population is set to 1/sample, eg 0.1 -&gt; 10, such that each household and person represents 10 people from input population. Note that in the current implementation frequencies are automatically discovered from the population object households, person and leg weights, in that order. When gathering frequencies, for example for a household from multiple person in that houshold, the household frequency is taken as the average person frequency. Similarly for persons and their legs.</p> PARAMETER  DESCRIPTION <code>population</code> <p>input population object to sample from using population frequency.</p> <p> TYPE: <code>Population</code> </p> <code>sample</code> <p>sample size of new population, eg 0.1 for a 10% sample.</p> <p> TYPE: <code>float</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>verbose</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Population</code> <p>A new Population object with households sampled based on input frequency.</p> <p> TYPE: <code>Population</code> </p> Source code in <code>pam/samplers/population.py</code> <pre><code>def sample(\npopulation: Population, sample: float, seed: Optional[int] = None, verbose: bool = False\n) -&gt; Population:\n\"\"\"Sample a new population from the existing using a sample size.\n    Frequency of returned population is set to 1/sample, eg 0.1 -&gt; 10, such that each household and person represents 10 people from input population.\n    Note that in the current implementation frequencies are automatically discovered from the population object households, person and leg weights, in that order.\n    When gathering frequencies, for example for a household from multiple person in that houshold, the household frequency is taken as the average person frequency.\n    Similarly for persons and their legs.\n    Args:\n        population (Population): input population object to sample from using population frequency.\n        sample (float):  sample size of new population, eg 0.1 for a 10% sample.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n        verbose (bool, optional): Defaults to False.\n    Returns:\n        Population:\n            A new Population object with households sampled based on input frequency.\n    \"\"\"\nsampled_population = Population()\nsample_freq = int(1 / sample)\nsize = population.size * sample\nsampled = 0\nfor _, hh in population:\nsampled_count = freq_sample(freq=hh.freq, sample=sample, seed=seed)\nfor n in range(sampled_count):  # add sampled hhs (note we provide new unique hid)\nsampled_hh = deepcopy(hh)\nsampled_hh.hid = f\"{hh.hid}-{n}\"\nsampled_hh.people = {}\nsampled_hh.hh_freq = sample_freq\n# add sampled people (note we provide a new unique pid)\nfor pid, person in hh.people.items():\nsampled_person = deepcopy(person)\nsampled_person.pid = f\"{pid}-{n}\"\nsampled_person.person_freq = sample_freq\nsampled_hh.add(sampled_person)\nsampled_population.add(sampled_hh)\nif verbose:\nsampled += sampled_count\nprogress = sampled / size\nif progress % 0.01 == 0:\nprint(f\"Sampled approx. {progress*100}%\")\nif verbose:\nprint(f\"Population sampler completed: {sampled} households from target of {size} sampled\")\nreturn sampled_population\n</code></pre>"},{"location":"api/samplers/spatial/","title":"pam.samplers.spatial","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler","title":"<code>GeometryRandomSampler(geo_df_file, geometry_name_column, default_region, seed=None)</code>","text":"PARAMETER  DESCRIPTION <code>geo_df_file</code> <p> TYPE: <code>str</code> </p> <code>geometry_name_column</code> <p> TYPE: <code>str</code> </p> <code>default_region</code> <p> TYPE: <code>str</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def __init__(\nself,\ngeo_df_file: str,\ngeometry_name_column: str,\ndefault_region: str,\nseed: Optional[int] = None,\n) -&gt; None:\n\"\"\"\n    Args:\n        geo_df_file (str):\n        geometry_name_column (str):\n        default_region (str):\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n    \"\"\"\nself.geo_df = gp.read_file(geo_df_file)\nself.geometry_name_column = geometry_name_column\nself.default_region = default_region\nself.geo_df_loc_lookup = {\nvalue: key for (key, value) in self.geo_df[geometry_name_column].to_dict().items()\n}\n# Throws exception if default_region is invalid\ndefault_id = self.geo_df_loc_lookup[default_region]\nself.default_geom = self.geo_df.geometry.loc[default_id]\n# Store random seed\nself.seed = seed\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.default_geom","title":"<code>default_geom = self.geo_df.geometry.loc[default_id]</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.default_region","title":"<code>default_region = default_region</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.geo_df","title":"<code>geo_df = gp.read_file(geo_df_file)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.geo_df_loc_lookup","title":"<code>geo_df_loc_lookup = {value: keyfor (key, value) in self.geo_df[geometry_name_column].to_dict().items()}</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.geometry_name_column","title":"<code>geometry_name_column = geometry_name_column</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.seed","title":"<code>seed = seed</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.sample_point","title":"<code>sample_point(geo_region, patience=1000)</code>","text":"<p>Randomly sample point within geodata loaded on class initialisation.</p> <p>Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry.</p> PARAMETER  DESCRIPTION <code>geo_region</code> <p> TYPE: <code>str</code> </p> <code>patience</code> <p>Defaults to 1000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RAISES DESCRIPTION <code>RuntimeWarning</code> <p>If the method cannot return a valid point within 50 attempts then a RunTimeWarning is raised.</p> RETURNS DESCRIPTION <code>Point</code> <p>Sampled geometry.</p> <p> TYPE: <code>Point</code> </p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point(self, geo_region: str, patience: int = 1000) -&gt; Point:\n\"\"\"Randomly sample point within geodata loaded on class initialisation.\n    Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry.\n    Args:\n        geo_region (str):\n        patience (int, optional): Defaults to 1000.\n    Raises:\n        RuntimeWarning: If the method cannot return a valid point within 50 attempts then a RunTimeWarning is raised.\n    Returns:\n        Point: Sampled geometry.\n    \"\"\"\ntry:\ngeo_id = self.geo_df_loc_lookup[geo_region]\ngeom = self.geo_df.geometry.loc[geo_id]\nexcept KeyError:\nprint(\"Unknown region: {}, sampling from {}\".format(geo_region, self.default_region))\ngeom = self.default_geom\n# Fix random seed\nrandom.seed(self.seed)\nmin_x, min_y, max_x, max_y = geom.bounds\nfor attempt in range(patience):\nrandom_point = Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))\nif geom.is_valid:\nif random_point.within(geom):\nreturn random_point\nelse:\nif random_point.within(geom.buffer(0)):\nreturn random_point\nraise RuntimeWarning(\nf\"unable to sample point from geometry:{geo_region} with {patience} attempts\"\n)\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler","title":"<code>RandomPointSampler(geoms, patience=100, fail=True, seed=None)</code>","text":"<p>Returns randomly placed point within given geometries, as defined by geoms.</p> <p>Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry. If the method cannot return a valid point within 'patience' attempts then either a RunTimeWarning is raised or returns None.</p> PARAMETER  DESCRIPTION <code>geoms</code> <p> TYPE: <code>Union[GeoSeries, GeoDataFrame]</code> </p> <code>patience</code> <p>number of tries to sample point. Defaults to 100.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>fail</code> <p>If True, raise error rather than return None. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>seed</code> <p>If given, seed number for reproducible results. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p><code>geoms</code> must be one of [gp.GeoSeries, gp.GeoDataFrame].</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def __init__(\nself,\ngeoms: Union[gp.GeoSeries, gp.GeoDataFrame],\npatience: int = 100,\nfail: bool = True,\nseed: Optional[int] = None,\n) -&gt; None:\n\"\"\"Returns randomly placed point within given geometries, as defined by geoms.\n    Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry.\n    If the method cannot return a valid point within 'patience' attempts then either a RunTimeWarning is raised or returns None.\n    Args:\n        geoms (Union[gp.GeoSeries, gp.GeoDataFrame]):\n        patience (int, optional): number of tries to sample point. Defaults to 100.\n        fail (bool, optional): If True, raise error rather than return None. Defaults to True.\n        seed (Optional[int], optional): If given, seed number for reproducible results. Defaults to None.\n    Raises:\n        UserWarning: `geoms` must be one of [gp.GeoSeries, gp.GeoDataFrame].\n    \"\"\"\nself.logger = logging.getLogger(__name__)\nself.index = list(geoms.index)\nif isinstance(geoms, gp.GeoSeries):\nself.geoms = geoms\nelif isinstance(geoms, gp.GeoDataFrame):\nself.geoms = geoms.geometry\nelse:\nraise UserWarning(\nf\"Unknown datatype: {type(geoms)}, please use GeoSeries or GeoDataFrame\"\n)\nself.patience = patience\nself.fail = fail\n# Store random seed\nself.seed = seed\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.fail","title":"<code>fail = fail</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.geoms","title":"<code>geoms = geoms</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.index","title":"<code>index = list(geoms.index)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.patience","title":"<code>patience = patience</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.seed","title":"<code>seed = seed</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample","title":"<code>sample(idx, activity)</code>","text":"PARAMETER  DESCRIPTION <code>idx</code> <p>index of initialised geometry dataset.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>activity</code> <p>Unused. Kept for consistency across samplers.</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p><code>idx</code> must be in input geometry if <code>self.fail</code> is True.</p> RETURNS DESCRIPTION <code>Optional[Point]</code> <p>Optional[Point]: None if <code>idx</code> not in input geometry and <code>self.fail</code> is False.</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample(self, idx: Union[int, str], activity: Any) -&gt; Optional[Point]:\n\"\"\"\n    Args:\n        idx (Union[int, str]): index of initialised geometry dataset.\n        activity (Any): Unused. Kept for consistency across samplers.\n    Raises:\n        IndexError: `idx` must be in input geometry if `self.fail` is True.\n    Returns:\n        Optional[Point]: None if `idx` not in input geometry and `self.fail` is False.\n    \"\"\"\nif idx not in self.index:\nif self.fail:\nraise IndexError(f\"Cannot find idx: {idx} in geoms index\")\nself.logger.warning(f\"Cannot find idx:{idx}, returning None\")\nreturn None\ngeom = self.geoms[idx]\nif not geom.is_valid:\ngeom.buffer(0)\nif geom.geom_type == \"Polygon\":\nreturn self.validate_return(self.sample_point_from_polygon(geom), idx)\nif geom.geom_type == \"MultiPolygon\":\nreturn self.validate_return(self.sample_point_from_multipolygon(geom), idx)\nif geom.geom_type == \"LineString\" or geom.geom_type == \"LinearRing\":\nreturn self.validate_return(self.sample_point_from_linestring(geom), idx)\nif geom.geom_type == \"MultiLineString\":\nreturn self.validate_return(self.sample_point_from_multilinestring(geom), idx)\nif geom.geom_type == \"Point\":\nreturn self.validate_return(self.sample_point_from_point(geom), idx)\nif geom.geom_type == \"MultiPoint\":\nreturn self.validate_return(self.sample_point_from_multipoint(geom), idx)\nself.logger.warning(f\"Unknown geom type {geom.geom_type}, attempting to sample.\")\nreturn self.validate_return(self.sample_point_from_polygon(geom), idx)\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_linestring","title":"<code>sample_point_from_linestring(geom)</code>","text":"<p>Also works for linearRing.</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_linestring(self, geom):\n\"\"\"Also works for linearRing.\"\"\"\n# Fix random seed\nrandom.seed(self.seed)\nreturn geom.interpolate(random.random(), True)\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_multilinestring","title":"<code>sample_point_from_multilinestring(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_multilinestring(self, geom):\n# Fix random seed\nrandom.seed(self.seed)\nline = random.choice(list(geom.geoms))\nreturn self.sample_point_from_linestring(line)\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_multipoint","title":"<code>sample_point_from_multipoint(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_multipoint(self, geom):\n# Fix random seed\nrandom.seed(self.seed)\nreturn random.choice(list(geom.geoms))\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_multipolygon","title":"<code>sample_point_from_multipolygon(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_multipolygon(self, geom):\n# Fix random seed\nrandom.seed(self.seed)\npoly = random.choices(geom.geoms, weights=[poly.area for poly in geom.geoms])[0]\nreturn self.sample_point_from_polygon(poly)\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_point","title":"<code>sample_point_from_point(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_point(self, geom):\nreturn geom\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_polygon","title":"<code>sample_point_from_polygon(geom)</code>","text":"<p>Return random coordinates within polygon, note that will return float coordinates.</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_polygon(self, geom):\n\"\"\"Return random coordinates within polygon, note that will return float coordinates.\"\"\"\n# Fix random seed\nrandom.seed(self.seed)\nmin_x, min_y, max_x, max_y = geom.bounds\nfor _ in range(self.patience):\nrandom_point = Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))\nif random_point.within(geom):\nreturn random_point\nreturn Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.validate_return","title":"<code>validate_return(point, idx)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def validate_return(self, point, idx):\nif point is None and self.fail:\nraise TimeoutError(f\"Failed to sample point for geom idx: {idx}\")\nreturn point\n</code></pre>"},{"location":"api/samplers/time/","title":"pam.samplers.time","text":""},{"location":"api/samplers/time/#pam.samplers.time.apply_jitter_to_plan","title":"<code>apply_jitter_to_plan(plan, jitter, min_duration)</code>","text":"<p>Apply time jitter to activity durations in a plan, leg durations are kept the same. Activity durations are jittered in sequence order. At each step the activity is jittered according to the maximum jitter and minimum duration of all activities in the plan.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>plan to be jittered</p> <p> TYPE: <code>Plan</code> </p> <code>jitter</code> <p>maximum jitter</p> <p> TYPE: <code>timedelta</code> </p> <code>min_duration</code> <p>minimum activity duration.</p> <p> TYPE: <code>timedelta</code> </p> Source code in <code>pam/samplers/time.py</code> <pre><code>def apply_jitter_to_plan(plan: Plan, jitter: timedelta, min_duration: timedelta):\n\"\"\"Apply time jitter to activity durations in a plan, leg durations are kept the same.\n    Activity durations are jittered in sequence order. At each step the activity\n    is jittered according to the maximum jitter and minimum duration of all activities\n    in the plan.\n    Args:\n        plan (Plan): plan to be jittered\n        jitter (timedelta): maximum jitter\n        min_duration (timedelta): minimum activity duration.\n    \"\"\"\nif plan.length == 1:  # do nothing\nreturn None\nfor i in range(0, plan.length - 1, 2):\njitter_activity(plan, i, jitter=jitter, min_duration=min_duration)\n</code></pre>"},{"location":"api/samplers/time/#pam.samplers.time.jitter_activity","title":"<code>jitter_activity(plan, i, jitter, min_duration)</code>","text":"<p>Jitter duration of given activity at index i.</p> <p>Remaining activities and legs after activity are also shifted. Leg durations are not changed. Subsequent activity durations are equally change to maintain 24hr plan.</p> PARAMETER  DESCRIPTION <code>plan</code> <p> TYPE: <code>Plan</code> </p> <code>i</code> <p> TYPE: <code>int</code> </p> <code>jitter</code> <p> TYPE: <code>timedelta</code> </p> <code>min_duration</code> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>index <code>i</code> of <code>plan</code> must be of type <code>Activity</code>.</p> Source code in <code>pam/samplers/time.py</code> <pre><code>def jitter_activity(plan: Plan, i: int, jitter: timedelta, min_duration: timedelta):\n\"\"\"Jitter duration of given activity at index i.\n    Remaining activities and legs after activity are also shifted.\n    Leg durations are not changed.\n    Subsequent activity durations are equally change to maintain 24hr plan.\n    Args:\n        plan (Plan):\n        i (int):\n        jitter (timedelta):\n        min_duration (timedelta):\n    Raises:\n        UserWarning: index `i` of `plan` must be of type `Activity`.\n    \"\"\"\nact = plan[i]\nif not isinstance(act, Activity):\nraise UserWarning(f\"Expected type of Activity for act, not {type(act)}\")\nprev_duration = act.duration\ntail = (len(plan) - i) / 2\nmin_end = max(act.start_time + min_duration, act.end_time - jitter)\nallowance = plan[-1].end_time - act.end_time\nfor j in range(i + 1, len(plan), 2):  # legs\nallowance = -plan[j].duration\nfor j in range(i + 2, len(plan) + 1, 2):  # acts\nallowance = -min_duration\nmax_end = min(plan[-1].end_time - allowance, act.end_time + jitter)\njitter_range = max((max_end - min_end).seconds, 1)\njitter = timedelta(seconds=randrange(jitter_range))\nnew_duration = min_end - act.start_time + jitter\nchange = (new_duration - prev_duration) / tail\ntime = act.shift_duration(new_duration)\ntime = plan[i + 1].shift_start_time(time)  # shift first tail leg\nfor j in range(i + 2, len(plan) - 1, 2):  # tail acts\ntime = plan[j].shift_start_time(time)\ntime = plan[j].shift_duration(plan[j].duration - change)\ntime = plan[j + 1].shift_start_time(time)  # leg\n# final act\ntime = plan[-1].shift_start_time(time)\nplan[-1].end_time = END_OF_DAY\n</code></pre>"},{"location":"api/samplers/tour/","title":"pam.samplers.tour","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.DurationEstimator","title":"<code>DurationEstimator</code>","text":"<p>Object to estimate the distance, journey time, and stop time of activities. The last function activity_duration combines these three functions to output parameters that help build tour plans.</p>"},{"location":"api/samplers/tour/#pam.samplers.tour.DurationEstimator.model_activity_duration","title":"<code>model_activity_duration(o_loc, d_loc, end_tm, speed=50000 / 3600, maxi=3600, mini=600)</code>","text":"<p>Returns estimated Activity duration.</p> <p>Duration is a combination of previous three functions to return parameters for next activity in Plan.</p> PARAMETER  DESCRIPTION <code>o_loc</code> <p>origin facility.</p> <p> TYPE: <code>Point</code> </p> <code>d_loc</code> <p>destination facility.</p> <p> TYPE: <code>Point</code> </p> <code>end_tm</code> <p>most recent end time of previous leg.</p> <p> TYPE: <code>int</code> </p> <code>speed</code> <p>Speed of vehicle in metres/second. Defaults to 50000 / 3600 (50km/hr).</p> <p> TYPE: <code>Union[int, float]</code> DEFAULT: <code>50000 / 3600</code> </p> <code>maxi</code> <p>maximum stop time in seconds. Defaults to 3600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3600</code> </p> <code>mini</code> <p>minimum stop time in seconds. Defaults to 600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>600</code> </p> RETURNS DESCRIPTION <code>tuple[int, int, int]</code> <p>tuple[int, int, int]: (stop_duration, start_tm, end_tm) for new activity.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_activity_duration(\nself,\no_loc: Point,\nd_loc: Point,\nend_tm: int,\nspeed: Union[int, float] = 50000 / 3600,\nmaxi: int = 3600,\nmini: int = 600,\n) -&gt; tuple[int, int, int]:\n\"\"\"Returns estimated Activity duration.\n    Duration is a combination of previous three functions to return parameters for next activity in Plan.\n    Args:\n      o_loc (shapely.Point): origin facility.\n      d_loc (shapely.Point): destination facility.\n      end_tm (int): most recent end time of previous leg.\n      speed (Union[int, float], optional): Speed of vehicle in metres/second. Defaults to 50000 / 3600 (50km/hr).\n      maxi (int, optional): maximum stop time in seconds. Defaults to 3600.\n      mini (int, optional): minimum stop time in seconds. Defaults to 600.\n    Returns:\n      tuple[int, int, int]: (stop_duration, start_tm, end_tm) for new activity.\n    \"\"\"\ntrip_distance = self.model_distance(o_loc, d_loc)\ntrip_duration = self.model_journey_time(trip_distance, speed)\nstop_duration = self.model_stop_time(trip_duration, maxi, mini)\nstart_tm = end_tm\nend_tm = end_tm + int(trip_duration / 60)\nreturn stop_duration, start_tm, end_tm\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.DurationEstimator.model_distance","title":"<code>model_distance(o, d, scale=1.4)</code>","text":"<p>Models distance between two shapely points.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_distance(self, o, d, scale=1.4):\n\"\"\"Models distance between two shapely points.\"\"\"\nreturn o.distance(d) * scale\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.DurationEstimator.model_journey_time","title":"<code>model_journey_time(distance, speed=50000 / 3600)</code>","text":"PARAMETER  DESCRIPTION <code>distance</code> <p>Distance in metres.</p> <p> TYPE: <code>Union[float, int]</code> </p> <code>speed</code> <p>Speed in metres/second. Defaults to 50000 / 3600 (50km/hr).</p> <p> TYPE: <code>float</code> DEFAULT: <code>50000 / 3600</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Modelled journey time.</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_journey_time(self, distance: Union[float, int], speed: float = 50000 / 3600) -&gt; float:\n\"\"\"\n    Args:\n      distance (Union[float, int]): Distance in metres.\n      speed (float, optional): Speed in metres/second. Defaults to 50000 / 3600 (50km/hr).\n    Returns:\n      float: Modelled journey time.\n    \"\"\"\nreturn distance / speed\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.DurationEstimator.model_stop_time","title":"<code>model_stop_time(time, maxi=3600, mini=600)</code>","text":"<p>Returns a duration that is between the minimum amount of seconds, an input journey time, or maximum time.</p> PARAMETER  DESCRIPTION <code>time</code> <p>Time in seconds.</p> <p> TYPE: <code>int</code> </p> <code>maxi</code> <p>maximum time for a journey. Defaults to 3600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3600</code> </p> <code>mini</code> <p>minimum time for a journey. Defaults to 600.</p> <p> TYPE: <code>int</code> DEFAULT: <code>600</code> </p> RETURNS DESCRIPTION <code>int</code> <p>maximum value between minimum time or the minimum of journey time and maximum time.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_stop_time(self, time: int, maxi: int = 3600, mini: int = 600) -&gt; int:\n\"\"\"Returns a duration that is between the minimum amount of seconds, an input journey time, or maximum time.\n    Args:\n      time (int): Time in seconds.\n      maxi (int, optional): maximum time for a journey. Defaults to 3600.\n      mini (int, optional): minimum time for a journey. Defaults to 600.\n    Returns:\n      int: maximum value between minimum time or the minimum of journey time and maximum time.\n    \"\"\"\nreturn max([mini, min([time, maxi])])\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler","title":"<code>FrequencySampler(dist, freq=None, threshold_matrix=None, threshold_value=None)</code>","text":"<p>Object for initiating and sampling from frequency weighted distributing. This object includes three samplers: a single sample, multiple samples, or sample based on a threshold value (requires a threshold matrix).</p> PARAMETER  DESCRIPTION <code>dist</code> <p>Input distribution. If a DataFrame is given, the index will be used.</p> <p> TYPE: <code>Union[Iterable, DataFrame]</code> </p> <code>freq</code> <p>If given, weighting for input items, either as an iterable or a reference to a column of <code>dist</code> (which then must be a DataFrame). Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Iterable]]</code> DEFAULT: <code>None</code> </p> <code>threshold_matrix</code> <p>A dataframe that will be reduced based on a specified threshold_value. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> <code>threshold_value</code> <p>A value to filter the threshold_matrix. This is the maximum allowed value. Defaults to None.</p> <p> TYPE: <code>Optional[Union[int, float]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(\nself,\ndist: Union[Iterable, pd.DataFrame],\nfreq: Optional[Union[str, Iterable]] = None,\nthreshold_matrix: Optional[pd.DataFrame] = None,\nthreshold_value: Optional[Union[int, float]] = None,\n) -&gt; None:\n\"\"\"\n    Args:\n        dist (Union[Iterable, pd.DataFrame]):\n            Input distribution. If a DataFrame is given, the index will be used.\n        freq (Optional[Union[str, Iterable]], optional):\n            If given, weighting for input items, either as an iterable or a reference to a column of `dist` (which then must be a DataFrame).\n            Defaults to None.\n        threshold_matrix (Optional[pd.DataFrame], optional):\n            A dataframe that will be reduced based on a specified threshold_value. Defaults to None.\n        threshold_value (Optional[Union[int, float]], optional):\n            A value to filter the threshold_matrix. This is the maximum allowed value. Defaults to None.\n    \"\"\"\nself.distribution = dist\nself.frequency = freq\nself.threshold_matrix = threshold_matrix\nself.threshold_value = threshold_value\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.distribution","title":"<code>distribution = dist</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.frequency","title":"<code>frequency = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.threshold_matrix","title":"<code>threshold_matrix = threshold_matrix</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.threshold_value","title":"<code>threshold_value = threshold_value</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.sample","title":"<code>sample()</code>","text":"RETURNS DESCRIPTION <code>Any</code> <p>Single object sampled from distribution</p> <p> TYPE: <code>Any</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def sample(self) -&gt; Any:\n\"\"\"\n    Returns:\n        Any: Single object sampled from distribution\n    \"\"\"\nreturn random.choices(self.distribution, weights=self.frequency, k=1)[0]\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.samples","title":"<code>samples(n=1)</code>","text":"PARAMETER  DESCRIPTION <code>n</code> <p>number of samples to be returned. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list</code> <p>objects sampled from distribution</p> <p> TYPE: <code>list</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def samples(self, n: int = 1) -&gt; list:\n\"\"\"\n    Args:\n      n (int, optional): number of samples to be returned. Defaults to 1.\n    Returns:\n      list: objects sampled from distribution\n    \"\"\"\nreturn random.choices(self.distribution, weights=self.frequency, k=n)\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.threshold_sample","title":"<code>threshold_sample()</code>","text":"<p>Returns a sampler of a distribution that has been reduced based on a threshold value.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def threshold_sample(self):\n\"\"\"Returns a sampler of a distribution that has been reduced based on a threshold value.\"\"\"\nd_list = self.threshold_matrix\nd_list = d_list[d_list &lt;= self.threshold_value].index\nd_threshold = self.distribution[self.distribution.index.isin(d_list)]\nif len(d_threshold) == 0:\nwarnings.warn(\"No destinations within this threshold value, change threshold\")\nreturn None\nelse:\nreturn random.choices(\nlist(d_threshold.index), weights=list(d_threshold[self.frequency]), k=1\n)[0]\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.PivotDistributionSampler","title":"<code>PivotDistributionSampler(bins, pivots, total=None)</code>","text":"<p>Defines a distribution, a sampler, and plots based on input values. The resulting distribution can be sampled for inputs required to build an agent plan (i.e, time of day, repetition of activities).</p> <p>Builds a dict distribution based on bins (i.e, hours) and pivots (i.e, hourly demand).</p> <p>Where the input pivot does not specify a value, values are estimated within the bin range by interpolation.</p> PARAMETER  DESCRIPTION <code>bins</code> <p>a range or dictionary of values</p> <p> TYPE: <code>Iterable</code> </p> <code>pivots</code> <p>a dictionary of values associated with the bins.</p> <p> TYPE: <code>dict</code> </p> <code>total</code> <p>Defaults to None.</p> <p> TYPE: <code>optional</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(self, bins: Iterable, pivots: dict, total=None):\n\"\"\"Builds a dict distribution based on bins (i.e, hours) and pivots (i.e, hourly demand).\n    Where the input pivot does not specify a value, values are estimated within the bin range by interpolation.\n    Args:\n        bins (Iterable): a range or dictionary of values\n        pivots (dict): a dictionary of values associated with the bins.\n        total (optional): Defaults to None.\n    \"\"\"\nself.demand = {}\nif bins[0] not in pivots:\npivots[bins[0]] = 0\nif bins[-1] + 1 not in pivots:\npivots[bins[-1] + 1] = 0\npivot_keys = sorted(pivots.keys())\nfor k in range(len(pivot_keys) - 1):\nka = pivot_keys[k]\nkb = pivot_keys[k + 1]\npivot_a = pivots[ka]\npivot_b = pivots[kb]\nfor i in bins:\nif ka &lt;= i &lt; kb:\nself.demand[i] = self._interpolate(i, ka, pivot_a, kb, pivot_b)\nelse:\ncontinue\nif total is not None:\ndist_sum = sum(self.demand.values())\nfor i in bins:\nself.demand[i] = (self.demand[i] / dist_sum) * total\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.PivotDistributionSampler.demand","title":"<code>demand = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.PivotDistributionSampler.plot","title":"<code>plot(plot_title, x_label, y_label)</code>","text":"<p>Plots distribution to validate the distribution aligns with expected hourly demand.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot(self, plot_title, x_label, y_label):\n\"\"\"Plots distribution to validate the distribution aligns with expected hourly demand.\"\"\"\nfig, ax = plt.subplots(figsize=(10, 4))\nax.bar(list(self.demand.keys()), list(self.demand.values()))\nax.plot(list(self.demand.keys()), list(self.demand.values()), c=\"orange\")\nax.set_title(plot_title)\nax.set_xlabel(x_label)\nax.set_ylabel(y_label)\nreturn fig\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.PivotDistributionSampler.sample","title":"<code>sample()</code>","text":"Source code in <code>pam/samplers/tour.py</code> <pre><code>def sample(self):\nreturn random.choices(list(self.demand.keys()), list(self.demand.values()), k=1)[0]\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner","title":"<code>TourPlanner(stops, hour, minute, o_zone, d_dist, d_freq, facility_sampler, activity_params, threshold_matrix=None, threshold_value=None)</code>","text":"<p>Object for agents to efficiently plan their tours by sequencing stops and adding activities and legs.</p> <p>The TourPlanner optimises the sequence of stops using a Greedy Travelling Salesman Problem (TSP) algorithm based on Eucledian distances between sampled stops. It takes into account origin and destination zones, facility distributions, and other relevant parameters to build a tour plan for agents.</p> PARAMETER  DESCRIPTION <code>stops</code> <p> TYPE: <code>int</code> </p> <code>hour</code> <p>input of sampled hour.</p> <p> TYPE: <code>int</code> </p> <code>minute</code> <p>input of sampled minute.</p> <p> TYPE: <code>int</code> </p> <code>o_zone</code> <p>origin zone.</p> <p> TYPE: <code>str</code> </p> <code>d_dist</code> <p>distribution of destination zones.</p> <p> TYPE: <code>Union[Iterable, DataFrame]</code> </p> <code>d_freq</code> <p>frequency value to sample of destination distribution.</p> <p> TYPE: <code>Union[str, Iterable]</code> </p> <code>facility_sampler</code> <p> TYPE: <code>FacilitySampler</code> </p> <code>activity_params</code> <p>dictionary of str of origin activity (str) and destination activity (str).</p> <p> TYPE: <code>dict[str, str]</code> </p> <code>threshold_matrix</code> <p>dataframe that will be reduced based on threshold value. Defaults to None.</p> <p> TYPE: <code>optional</code> DEFAULT: <code>None</code> </p> <code>threshold_value</code> <p>maximum threshold value allowed between origin and destination in threshold_matrix. Defaults to None.</p> <p> TYPE: <code>optional</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(\nself,\nstops: int,\nhour: int,\nminute: int,\no_zone: str,\nd_dist: pd.DataFrame,\nd_freq: Union[str, Iterable],\nfacility_sampler: FacilitySampler,\nactivity_params: dict[str, str],\nthreshold_matrix=None,\nthreshold_value=None,\n):\n\"\"\"\n    Args:\n        stops (int): # of stops.\n        hour (int): input of sampled hour.\n        minute (int): input of sampled minute.\n        o_zone (str): origin zone.\n        d_dist (Union[Iterable, pd.DataFrame]): distribution of destination zones.\n        d_freq (Union[str, Iterable]): frequency value to sample of destination distribution.\n        facility_sampler (FacilitySampler):\n        activity_params (dict[str, str]): dictionary of str of origin activity (str) and destination activity (str).\n        threshold_matrix (optional): dataframe that will be reduced based on threshold value. Defaults to None.\n        threshold_value (optional): maximum threshold value allowed between origin and destination in threshold_matrix. Defaults to None.\n    \"\"\"\nself.stops = stops\nself.hour = hour\nself.minute = minute\nself.o_zone = o_zone\nself.threshold_matrix = threshold_matrix\nself.d_dist = d_dist\nself.d_freq = d_freq\nself.threshold_value = threshold_value\nself.facility_sampler = facility_sampler\nself.o_activity = activity_params[\"o_activity\"]\nself.d_activity = activity_params[\"d_activity\"]\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner--of-stops","title":"of stops.","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.d_activity","title":"<code>d_activity = activity_params['d_activity']</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.d_dist","title":"<code>d_dist = d_dist</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.d_freq","title":"<code>d_freq = d_freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.facility_sampler","title":"<code>facility_sampler = facility_sampler</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.hour","title":"<code>hour = hour</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.minute","title":"<code>minute = minute</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.o_activity","title":"<code>o_activity = activity_params['o_activity']</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.o_zone","title":"<code>o_zone = o_zone</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.stops","title":"<code>stops = stops</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.threshold_matrix","title":"<code>threshold_matrix = threshold_matrix</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.threshold_value","title":"<code>threshold_value = threshold_value</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.add_return_origin","title":"<code>add_return_origin(agent, k, o_loc, d_zone, d_loc, end_tm)</code>","text":"<p>The agent returns to their origin activity, from their most recent stop to the origin location.</p> PARAMETER  DESCRIPTION <code>agent</code> <p>agent for which the leg &amp; activity will be added to Plan</p> <p> TYPE: <code>str</code> </p> <code>k</code> <p>when used in a for loop, k populates the next sequence valuey</p> <p> TYPE: <code>Iterable</code> </p> <code>o_loc</code> <p>origin facility of leg &amp; activity</p> <p> TYPE: <code>Point</code> </p> <code>d_zone</code> <p>destination zone of leg &amp; activity</p> <p> TYPE: <code>str</code> </p> <code>d_loc</code> <p>destination facility of leg &amp; activity</p> <p> TYPE: <code>Point</code> </p> <code>end_tm</code> <p>obtained from DurationEstimator object</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>end_tm after returning to origin.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def add_return_origin(\nself, agent: str, k: Iterable, o_loc: Point, d_zone: str, d_loc: Point, end_tm: int\n) -&gt; int:\n\"\"\"The agent returns to their origin activity, from their most recent stop to the origin location.\n    Args:\n      agent (str): agent for which the leg &amp; activity will be added to Plan\n      k (Iterable): when used in a for loop, k populates the next sequence valuey\n      o_loc (shapely.Point): origin facility of leg &amp; activity\n      d_zone (str): destination zone of leg &amp; activity\n      d_loc (shapely.Point): destination facility of leg &amp; activity\n      end_tm (int): obtained from DurationEstimator object\n    Returns:\n      int: end_tm after returning to origin.\n    \"\"\"\ntrip_distance = DurationEstimator().model_distance(o_loc, d_loc)\ntrip_duration = DurationEstimator().model_journey_time(trip_distance)\nstart_tm = end_tm\nend_tm = end_tm + int(trip_duration / 60)\nend_tm = self.add_tour_leg(\nagent=agent,\nk=k,\no_zone=d_zone,\no_loc=d_loc,\nd_zone=self.o_zone,\nd_loc=o_loc,\nstart_tm=start_tm,\nend_tm=end_tm,\n)\ntime_params = {\"start_tm\": end_tm, \"end_tm\": END_OF_DAY}\nend_tm = self.add_tour_activity(\nagent=agent,\nk=k,\nzone=self.o_zone,\nloc=o_loc,\nactivity_type=\"return_origin\",\ntime_params=time_params,\n)\nreturn end_tm\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.add_tour_activity","title":"<code>add_tour_activity(agent, k, zone, loc, activity_type, time_params)</code>","text":"<p>Add activity to tour plan. This will add an activity to the agent plan after each leg within the tour.</p> PARAMETER  DESCRIPTION <code>agent</code> <p>agent for which the activity will be added to Plan</p> <p> TYPE: <code>str</code> </p> <code>k</code> <p>when used in a for loop, k populates the next sequence value</p> <p> TYPE: <code>int</code> </p> <code>zone</code> <p>zone where activity takes place</p> <p> TYPE: <code>str</code> </p> <code>loc</code> <p>facility location where activity takes place</p> <p> TYPE: <code>Point</code> </p> <code>activity_type</code> <p>this function has specific logic for 'return_origin'</p> <p> TYPE: <code>str</code> </p> <code>time_params</code> <p>dictionary of time_params that may be time samplers or times of previous journeys</p> <p> TYPE: <code>dict[str, str]</code> </p> RETURNS DESCRIPTION <code>int</code> <p>end_tm of activity.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def add_tour_activity(\nself, agent: str, k: Iterable, zone: str, loc: Point, activity_type: str, time_params: dict\n) -&gt; int:\n\"\"\"Add activity to tour plan. This will add an activity to the agent plan after each leg within the tour.\n    Args:\n      agent (str): agent for which the activity will be added to Plan\n      k (int): when used in a for loop, k populates the next sequence value\n      zone (str): zone where activity takes place\n      loc (shapely.Point): facility location where activity takes place\n      activity_type (str): this function has specific logic for 'return_origin'\n      time_params (dict[str, str]): dictionary of time_params that may be time samplers or times of previous journeys\n    Returns:\n      int: end_tm of activity.\n    \"\"\"\nif activity_type == self.o_activity:\nstart_tm = 0\nend_tm = (time_params[\"hour\"] * 60) + time_params[\"minute\"]\nseq = 1\nact = activity_type\nelif activity_type == \"return_origin\":\nstart_tm = time_params[\"start_tm\"]  # end_tm\nend_tm = time_params[\"end_tm\"]  # END_OF_DAY we'll let pam trim this to 24 hours later\nseq = k + 2\nact = self.o_activity\nelse:\nstart_tm = time_params[\"end_tm\"]\nend_tm = time_params[\"end_tm\"] + int(time_params[\"stop_duration\"] / 60)\nseq = k + 2\nact = activity_type\n# Activity plan requires mtdt format, but int format needs to passed for other functions to calculate new start time.\n# END_OF_DAY is already in mtdt format, adding an exception to keep set mtdt format when not END_OF_DAY.\nif end_tm is not END_OF_DAY:\nend_tm_mtdt = mtdt(end_tm)\nelse:\nend_tm_mtdt = end_tm\nagent.add(\nActivity(\nseq=seq,\nact=act,\narea=zone,\nloc=loc,\nstart_time=mtdt(start_tm),\nend_time=end_tm_mtdt,\n)\n)\nreturn end_tm\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.add_tour_leg","title":"<code>add_tour_leg(agent, k, o_zone, o_loc, d_zone, d_loc, start_tm, end_tm)</code>","text":"<p>Leg to Next Activity within the tour. This adds a leg to the agent plan after each activity is complete within the tour.</p> PARAMETER  DESCRIPTION <code>agent</code> <p>agent for which the leg will be added to Plan</p> <p> TYPE: <code>str</code> </p> <code>k</code> <p>when used in a for loop, k populates the next sequence value</p> <p> TYPE: <code>Iterable</code> </p> <code>o_zone</code> <p>origin zone of leg</p> <p> TYPE: <code>str</code> </p> <code>o_loc</code> <p>origin facility of leg</p> <p> TYPE: <code>point</code> </p> <code>d_zone</code> <p>destination zone of leg</p> <p> TYPE: <code>str</code> </p> <code>d_loc</code> <p>destination facility of leg</p> <p> TYPE: <code>point</code> </p> <code>start_tm</code> <p>obtained from DurationEstimator object</p> <p> TYPE: <code>int</code> </p> <code>end_tm</code> <p>obtained from DurationEstimator object</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>new end_tm after leg is added to plan.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def add_tour_leg(\nself,\nagent: str,\nk: Iterable,\no_zone: str,\no_loc: Point,\nd_zone: str,\nd_loc: Point,\nstart_tm: int,\nend_tm: int,\n) -&gt; int:\n\"\"\"Leg to Next Activity within the tour. This adds a leg to the agent plan after each activity is complete within the tour.\n    Args:\n      agent (str): agent for which the leg will be added to Plan\n      k (Iterable): when used in a for loop, k populates the next sequence value\n      o_zone (str): origin zone of leg\n      o_loc (shapely.point): origin facility of leg\n      d_zone (str): destination zone of leg\n      d_loc (shapely.point): destination facility of leg\n      start_tm (int): obtained from DurationEstimator object\n      end_tm (int): obtained from DurationEstimator object\n    Returns:\n      int: new end_tm after leg is added to plan.\n    \"\"\"\nagent.add(\nLeg(\nseq=k + 1,\nmode=\"car\",\nstart_area=o_zone,\nend_area=d_zone,\nstart_loc=o_loc,\nend_loc=d_loc,\nstart_time=mtdt(start_tm),\nend_time=mtdt(end_tm),\n)\n)\nreturn end_tm\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.apply","title":"<code>apply(agent, o_loc, d_zones, d_locs)</code>","text":"<p>Apply the above functions to the agent to build a plan.</p> PARAMETER  DESCRIPTION <code>agent</code> <p>agent to build a plan fory</p> <p> TYPE: <code>str</code> </p> <code>o_loc</code> <p>origin facility of leg &amp; activity</p> <p> TYPE: <code>Point</code> </p> <code>d_zones</code> <p>destination zones of leg &amp; activity</p> <p> TYPE: <code>list</code> </p> <code>d_locs</code> <p>destination facilities of leg &amp; activity.</p> <p> TYPE: <code>list</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def apply(self, agent: str, o_loc: Point, d_zones: list, d_locs: list) -&gt; None:\n\"\"\"Apply the above functions to the agent to build a plan.\n    Args:\n      agent (str): agent to build a plan fory\n      o_loc (shapely.Point): origin facility of leg &amp; activity\n      d_zones (list): destination zones of leg &amp; activity\n      d_locs (list): destination facilities of leg &amp; activity.\n    \"\"\"\ntime_params = {\"hour\": self.hour, \"minute\": self.minute}\nend_tm = self.add_tour_activity(\nagent=agent,\nk=1,\nzone=self.o_zone,\nloc=o_loc,\nactivity_type=self.o_activity,\ntime_params=time_params,\n)\nfor k in range(self.stops):\nstop_duration, start_tm, end_tm = DurationEstimator().model_activity_duration(\no_loc, d_locs[k], end_tm\n)\nif (mtdt(end_tm) &gt;= END_OF_DAY) | (\nmtdt(end_tm + int(stop_duration / 60)) &gt;= END_OF_DAY\n):\nbreak\nelif k == 0:\nend_tm = self.add_tour_leg(\nagent=agent,\nk=k,\no_zone=self.o_zone,\no_loc=o_loc,\nd_zone=d_zones[k],\nd_loc=d_locs[k],\nstart_tm=start_tm,\nend_tm=end_tm,\n)\ntime_params = {\"end_tm\": end_tm, \"stop_duration\": stop_duration}\nend_tm = self.add_tour_activity(\nagent=agent,\nk=k,\nzone=d_zones[k],\nloc=d_locs[k],\nactivity_type=self.d_activity,\ntime_params=time_params,\n)\nelse:\nend_tm = self.add_tour_leg(\nagent=agent,\nk=k,\no_zone=d_zones[k - 1],\no_loc=d_locs[k - 1],\nd_zone=d_zones[k],\nd_loc=d_locs[k],\nstart_tm=start_tm,\nend_tm=end_tm,\n)\ntime_params = {\"end_tm\": end_tm, \"stop_duration\": stop_duration}\nend_tm = self.add_tour_activity(\nagent=agent,\nk=k,\nzone=d_zones[k],\nloc=d_locs[k],\nactivity_type=self.d_activity,\ntime_params=time_params,\n)\nend_tm = self.add_return_origin(\nagent=agent,\nk=self.stops,\no_loc=o_loc,\nd_zone=d_zones[self.stops - 1],\nd_loc=d_locs[self.stops - 1],\nend_tm=end_tm,\n)\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.approx_greedy_tsp","title":"<code>approx_greedy_tsp(dist_matrix)</code>","text":"<p>Approximate solution to the Travelling Saleman Problem using the GreedyTSP algorithm.</p> PARAMETER  DESCRIPTION <code>dist_matrix</code> <p>2D NumPy array representing the distance matrix between origin and destinations.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>List[int]</code> <p>List[int]: List of integers representing the optimised sequence of stops.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def approx_greedy_tsp(self, dist_matrix) -&gt; List[int]:\n\"\"\"Approximate solution to the Travelling Saleman Problem using the GreedyTSP algorithm.\n    Args:\n        dist_matrix (np.ndarray): 2D NumPy array representing the distance matrix between origin and destinations.\n    Returns:\n        List[int]: List of integers representing the optimised sequence of stops.\n    \"\"\"\ndistance_graph = nx.from_numpy_array(dist_matrix)\nseq = nx.algorithms.approximation.greedy_tsp(distance_graph, source=0)\nreturn seq\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.create_distance_matrix","title":"<code>create_distance_matrix(o_loc, d_seq)</code>","text":"<p>Create a distance matrix between the origin location and a list of destinations.</p> PARAMETER  DESCRIPTION <code>o_loc</code> <p>shapely.geometry.Point representing the sampled origin location.</p> <p> TYPE: <code>Point</code> </p> <code>d_seq</code> <p>A list of dictionaries containing information about each stop in the tour.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: 2D NumPy array representing the distance matrix between origin and destinations.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def create_distance_matrix(self, o_loc, d_seq) -&gt; np.ndarray:\n\"\"\"Create a distance matrix between the origin location and a list of destinations.\n    Args:\n        o_loc (Point): shapely.geometry.Point representing the sampled origin location.\n        d_seq (List[Dict[str, Any]]): A list of dictionaries containing information about each stop in the tour.\n    Returns:\n        np.ndarray: 2D NumPy array representing the distance matrix between origin and destinations.\n    \"\"\"\n# extract o_loc coordinates into array\no_location = np.array([[o_loc.x, o_loc.y]])\n# extract d_facility\nd_locations = np.array(\n[[location.x, location.y] for location in [d[\"destination_facility\"] for d in d_seq]]\n)\nlocs = np.concatenate([o_location, d_locations], 0)\ndist_matrix = distance_matrix(locs, locs)\nreturn dist_matrix\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.d_zone_sample_choice","title":"<code>d_zone_sample_choice()</code>","text":"<p>Samples a destination zone (d_zone) as a string, dependent on the presence of a threshold matrix.</p> RETURNS DESCRIPTION <code>str</code> <p>d_zone</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def d_zone_sample_choice(self) -&gt; str:\n\"\"\"Samples a destination zone (d_zone) as a string, dependent on the presence of a threshold matrix.\n    Returns:\n        str: d_zone\n    \"\"\" \"\"\nif self.threshold_matrix is None:\nd_zone = FrequencySampler(self.d_dist.index, self.d_dist[self.d_freq]).sample()\nelse:\nd_zone = FrequencySampler(\ndist=self.d_dist,\nfreq=self.d_freq,\nthreshold_matrix=self.threshold_matrix.loc[self.o_zone],\nthreshold_value=self.threshold_value,\n).threshold_sample()\nreturn d_zone\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.reorder_destinations","title":"<code>reorder_destinations(d_seq, seq)</code>","text":"<p>Reorder the destinations based on the provided sequence.</p> PARAMETER  DESCRIPTION <code>d_seq</code> <p>A list of dictionaries containing information about each stop (destination) in the tour.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>seq</code> <p>List of integers representing the optimised sequence of stops.</p> <p> TYPE: <code>List[int]</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing the reordered stops (destinations)</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def reorder_destinations(self, d_seq, seq) -&gt; List[Dict[str, Any]]:\n\"\"\"Reorder the destinations based on the provided sequence.\n    Args:\n        d_seq (List[Dict[str, Any]]): A list of dictionaries containing information about each stop (destination) in the tour.\n        seq (List[int]): List of integers representing the optimised sequence of stops.\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing the reordered stops (destinations)\n    \"\"\"\n# use `seq` to re-order `d_locs` into an ordered list of dictionaries\n# remove o_loc (first and last stop) from sequence &amp; adjust sequence range\nd_seq = [d_seq[order - 1] for order in seq[1:-1]]\nreturn d_seq\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.sample_destinations","title":"<code>sample_destinations(o_loc)</code>","text":"<p>Samples destinations and prevents repeated sampling of destinations, and prevents origin from be sampled as a destination</p> PARAMETER  DESCRIPTION <code>o_loc</code> <p>shapely.geometry.Point representing the sampled origin location.</p> <p> TYPE: <code>Point</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries containing information about each stop in the tour.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def sample_destinations(self, o_loc) -&gt; List[Dict[str, Any]]:\n\"\"\"Samples destinations and prevents repeated sampling of destinations, and prevents origin from be sampled as a destination\n    Args:\n        o_loc (Point): shapely.geometry.Point representing the sampled origin location.\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries containing information about each stop in the tour.\n    \"\"\"\nd_seq = []\nsampled_d_facilities = []\nfor stop in range(self.stops):\n# If threshold matrix is none, sample a random d_zone, else select a d_zone within threshold value\nd_zone = TourPlanner.d_zone_sample_choice(self)\n# once d_zone is selected, select a specific point location for d_activity\nd_facility = self.facility_sampler.sample(d_zone, self.d_activity)\n# prevent the depot from being sampled as a delivery (destination) or duplicate sampling of delivery (destination) locations\nwhile d_facility == o_loc or d_facility in sampled_d_facilities:\nd_zone = TourPlanner.d_zone_sample_choice(self)\nd_facility = self.facility_sampler.sample(d_zone, self.d_activity)\n# append select d_facility to sampled list for tracking\nsampled_d_facilities.append(d_facility)\n# append to a dictionary to sequence destinations\nd_seq.append(\n{\n\"stops\": stop,\n\"destination_zone\": d_zone,\n\"destination_facility\": d_facility,\n\"distance\": DurationEstimator().model_distance(o_loc, d_facility),\n}\n)\nreturn d_seq\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.sequence_stops","title":"<code>sequence_stops()</code>","text":"<p>Creates a sequence for a number of stops. Sequence is determined by approximated greedy TSP</p> RETURNS DESCRIPTION <code>tuple[list, list, list]</code> <p>tuple[list, list, list]: (o_loc, d_zones, d_locs).</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def sequence_stops(self) -&gt; tuple[list, list, list]:\n\"\"\"Creates a sequence for a number of stops. Sequence is determined by approximated greedy TSP\n    Returns:\n      tuple[list, list, list]: (o_loc, d_zones, d_locs).\n    \"\"\"\no_loc = self.facility_sampler.sample(self.o_zone, self.o_activity)\nd_seq = TourPlanner.sample_destinations(self, o_loc)\ndist_matrix = TourPlanner.create_distance_matrix(self, o_loc, d_seq)\nseq = TourPlanner.approx_greedy_tsp(self, dist_matrix)\nd_optimised_seq = TourPlanner.reorder_destinations(self, d_seq, seq)\n# sort distance: furthest facility to closest facility to origin facility. The final stop should be closest to origin.\nd_zones = [item.get(\"destination_zone\") for item in d_optimised_seq]\nd_locs = [item.get(\"destination_facility\") for item in d_optimised_seq]\nreturn o_loc, d_zones, d_locs\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD","title":"<code>ValidateTourOD(trips, zone, o_dist, d_dist, o_activity, d_activity, o_freq, d_freq)</code>","text":"<p>Object to build a dataframe that produces both spatial and statistical plots to validate the tour origin and destinations align with input data.</p> <p>Create a dataframe that counts the number of origin and destination activities.</p> <p>Merge this against the density information from the input origin and destination samplers.</p> PARAMETER  DESCRIPTION <code>trips</code> <p>the legs.csv output after building population.</p> <p> TYPE: <code>DataFrame</code> </p> <code>zone</code> <p> TYPE: <code>GeoDataFrame</code> </p> <code>o_dist</code> <p>sampler containing origin distributions to be sampled.</p> <p> TYPE: <code>DataFrame</code> </p> <code>d_dist</code> <p>sampler containing destination distributions to be sampled.</p> <p> TYPE: <code>DataFrame</code> </p> <code>o_activity</code> <p>activity utilised within o_dist.</p> <p> TYPE: <code>str</code> </p> <code>d_activity</code> <p>activity utilised within d_dist.</p> <p> TYPE: <code>str</code> </p> <code>o_freq</code> <p>destination frequency that is used to sample origin distributions.</p> <p> TYPE: <code>str</code> </p> <code>d_freq</code> <p>destination frequency that is used to sample destination distributions.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(\nself,\ntrips: pd.DataFrame,\nzone: gp.GeoDataFrame,\no_dist: pd.DataFrame,\nd_dist: pd.DataFrame,\no_activity: str,\nd_activity: str,\no_freq: str,\nd_freq: str,\n):\n\"\"\"Create a dataframe that counts the number of origin and destination activities.\n    Merge this against the density information from the input origin and destination samplers.\n    Args:\n        trips (pd.DataFrame): the legs.csv output after building population.\n        zone (gp.GeoDataFrame):\n        o_dist (pd.DataFrame): sampler containing origin distributions to be sampled.\n        d_dist (pd.DataFrame): sampler containing destination distributions to be sampled.\n        o_activity (str): activity utilised within o_dist.\n        d_activity (str): activity utilised within d_dist.\n        o_freq (str): destination frequency that is used to sample origin distributions.\n        d_freq (str): destination frequency that is used to sample destination distributions.\n    \"\"\"\n# Create a dataframe to plot od trips and compare against facility density and flows density.\ndf_trips_o = (\ntrips[trips[\"origin activity\"] == o_activity]\n.groupby([\"ozone\"])\n.agg({\"pid\": \"count\"})\n.reset_index()\n)\ndf_trips_o.rename(columns={\"pid\": \"origin_trips\"}, inplace=True)\ndf_trips_o.set_index(\"ozone\", inplace=True)\ndf_trips_d = (\ntrips[trips[\"destination activity\"] == d_activity]\n.groupby([\"dzone\"])\n.agg({\"pid\": \"count\"})\n.reset_index()\n)\ndf_trips_d.rename(columns={\"pid\": \"destination_trips\"}, inplace=True)\ndf_trips_d.set_index(\"dzone\", inplace=True)\nself.od_density = zone.copy()\n# Merge in trips information\nself.od_density = pd.merge(\nself.od_density,\ndf_trips_o,\nleft_on=self.od_density.index,\nright_on=df_trips_o.index,\nhow=\"left\",\n)\nself.od_density = pd.merge(\nself.od_density, df_trips_d, left_on=\"key_0\", right_on=df_trips_d.index, how=\"left\"\n)\n# Merge in density information\no_density = o_dist.reset_index()\no_density = o_density.groupby(o_dist.index).agg({o_freq: \"sum\"})\nd_density = d_dist.reset_index()\nd_density = d_density.groupby(d_dist.index).agg({d_freq: \"sum\"})\nself.od_density[f\"{o_activity}_density\"] = self.od_density.key_0.map(o_density[o_freq])\nself.od_density[f\"{d_activity}_density\"] = self.od_density.key_0.map(d_density[d_freq])\nself.od_density.rename(columns={\"key_0\": zone.index.name}, inplace=True)\nself.od_density.set_index(zone.index.name, inplace=True)\n# Add in features for analysis\nself.od_density = self.od_density.fillna(0)\nself.od_density[\"origin_trip_density\"] = (\nself.od_density.origin_trips / self.od_density.origin_trips.sum()\n)\nself.od_density[\"destination_trip_density\"] = (\nself.od_density.destination_trips / self.od_density.destination_trips.sum()\n)\nself.od_density[\"origin_diff\"] = (\nself.od_density[\"origin_trip_density\"] - self.od_density[f\"{o_activity}_density\"]\n)\nself.od_density[\"destination_diff\"] = (\nself.od_density[\"destination_trip_density\"] - self.od_density[f\"{d_activity}_density\"]\n)\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD.od_density","title":"<code>od_density = self.od_density.fillna(0)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD.plot_compare_density","title":"<code>plot_compare_density(title_1, title_2, o_activity, d_activity)</code>","text":"<p>Compares density of input origin/destination activities and trips. As density of locations increases, so should trips.</p> PARAMETER  DESCRIPTION <code>title_1</code> <p>input for plot origin title name.</p> <p> TYPE: <code>str</code> </p> <code>title_2</code> <p>input for plot destination title name.</p> <p> TYPE: <code>str</code> </p> <code>o_activity</code> <p>activity used to measure density of origin locations.</p> <p> TYPE: <code>str</code> </p> <code>d_activity</code> <p>activity used to measure density of destination locations.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>plt.Figure:</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot_compare_density(\nself, title_1: str, title_2: str, o_activity: str, d_activity: str\n) -&gt; plt.Figure:\n\"\"\"Compares density of input origin/destination activities and trips. As density of locations increases, so should trips.\n    Args:\n      title_1 (str): input for plot origin title name.\n      title_2 (str): input for plot destination title name.\n      o_activity (str): activity used to measure density of origin locations.\n      d_activity (str): activity used to measure density of destination locations.\n    Returns:\n        plt.Figure:\n    \"\"\"\nfig, ax = plt.subplots(1, 2, figsize=(15, 7))\nm1, b1 = np.polyfit(self.od_density[o_activity], self.od_density.origin_trip_density, 1)\nm2, b2 = np.polyfit(\nself.od_density[d_activity], self.od_density.destination_trip_density, 1\n)\nax[0].scatter(x=o_activity, y=\"origin_trip_density\", data=self.od_density)\nax[0].plot(\nself.od_density[o_activity],\n(m1 * self.od_density[o_activity] + b1),\nlabel=\"y = {:.2f} + {:.2f}*x\".format(m1, b1),\n)\nax[0].legend(loc=\"lower right\")\nax[0].set_title(title_1)\nax[1].scatter(x=d_activity, y=\"destination_trip_density\", data=self.od_density)\nax[1].plot(\nself.od_density[o_activity],\n(m2 * self.od_density[o_activity] + b2),\nlabel=\"y = {:.2f} + {:.2f}*x\".format(m2, b2),\n)\nax[1].legend(loc=\"lower right\")\nax[1].set_title(title_2)\nreturn fig\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD.plot_density_difference","title":"<code>plot_density_difference(title_1, title_2, cmap='coolwarm')</code>","text":"<p>Creates a spatial plot of the difference between input and output densities.</p> PARAMETER  DESCRIPTION <code>title_1</code> <p>input for plot origin title name.</p> <p> TYPE: <code>str</code> </p> <code>title_2</code> <p>input for plot destination title name.</p> <p> TYPE: <code>str</code> </p> <code>cmap</code> <p>Defaults to \"coolwarm\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'coolwarm'</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>plt.Figure:</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot_density_difference(\nself, title_1: str, title_2: str, cmap: str = \"coolwarm\"\n) -&gt; plt.Figure:\n\"\"\"Creates a spatial plot of the difference between input and output densities.\n    Args:\n      title_1 (str): input for plot origin title name.\n      title_2 (str): input for plot destination title name.\n      cmap (str, optional): Defaults to \"coolwarm\"\n    Returns:\n        plt.Figure:\n    \"\"\"\nfig, ax = plt.subplots(1, 2, figsize=(20, 10))\nself.od_density.plot(\"origin_diff\", ax=ax[0], cmap=cmap)\nax[0].axis(\"off\")\nax[0].set_title(title_1)\nself.od_density.plot(\"destination_diff\", ax=ax[1], cmap=cmap)\nax[1].axis(\"off\")\nax[1].set_title(title_2)\nim = plt.gca().get_children()[0]\ncax = fig.add_axes([1, 0.2, 0.03, 0.6])\nplt.colorbar(im, cax=cax)\nreturn fig\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD.plot_validate_spatial_density","title":"<code>plot_validate_spatial_density(title_1, title_2, density_metric, density_trips, cmap='coolwarm')</code>","text":"<p>Creates a spatial plot between input densities and resulting trips to validate trips spatially align with input densities.</p> PARAMETER  DESCRIPTION <code>title_1</code> <p>Input densities plot title.</p> <p> TYPE: <code>str</code> </p> <code>title_2</code> <p>Resulting trips plot title.</p> <p> TYPE: <code>str</code> </p> <code>density_metric</code> <p>the measure for density output from the above dataframe, in the format of 'activity_density'</p> <p> TYPE: <code>str</code> </p> <code>density_trips</code> <p>the measure of trips that require validation, either 'origin_trips' or 'destination_trips'.</p> <p> TYPE: <code>str</code> </p> <code>cmap</code> <p>Defaults to \"coolwarm\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'coolwarm'</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>plt.Figure:</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot_validate_spatial_density(\nself,\ntitle_1: str,\ntitle_2: str,\ndensity_metric: str,\ndensity_trips: str,\ncmap: str = \"coolwarm\",\n) -&gt; plt.Figure:\n\"\"\"Creates a spatial plot between input densities and resulting trips to validate trips spatially align with input densities.\n    Args:\n      title_1 (str): Input densities plot title.\n      title_2 (str): Resulting trips plot title.\n      density_metric (str): the measure for density output from the above dataframe, in the format of 'activity_density'\n      density_trips (str): the measure of trips that require validation, either 'origin_trips' or 'destination_trips'.\n      cmap (str): Defaults to \"coolwarm\".\n    Returns:\n        plt.Figure:\n    \"\"\"\nfig, ax = plt.subplots(1, 2, figsize=(20, 10))\nself.od_density.plot(density_metric, ax=ax[0], cmap=cmap)\nax[0].axis(\"off\")\nax[0].set_title(title_1)\nself.od_density.plot(density_trips, ax=ax[1], cmap=cmap)\nax[1].axis(\"off\")\nax[1].set_title(title_2)\nim = plt.gca().get_children()[0]\ncax = fig.add_axes([1, 0.2, 0.03, 0.6])\nplt.colorbar(im, cax=cax)\nreturn fig\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.create_density_gdf","title":"<code>create_density_gdf(facility_zone, zone, activity, normalise=None)</code>","text":"<p>Calculate the spatial density of input activity.</p> PARAMETER  DESCRIPTION <code>facility_zone</code> <p>Spatial join between facility and zone information.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>zone</code> <p>zones information.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>activity</code> <p>a list of activities that are within facility data.</p> <p> TYPE: <code>list[str]</code> </p> <code>normalise</code> <p>If given, normalise density against this variable. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>gp.GeoDataFrame: measure of density of activities in each zone</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def create_density_gdf(\nfacility_zone: gp.GeoDataFrame,\nzone: gp.GeoDataFrame,\nactivity: list[str],\nnormalise: Optional[str] = None,\n) -&gt; gp.GeoDataFrame:\n\"\"\"Calculate the spatial density of input activity.\n    Args:\n        facility_zone (gp.GeoDataFrame): Spatial join between facility and zone information.\n        zone (gp.GeoDataFrame): zones information.\n        activity (list[str]): a list of activities that are within facility data.\n        normalise (Optional[str], optional): If given, normalise density against this variable. Defaults to None.\n    Returns:\n        gp.GeoDataFrame: measure of density of activities in each zone\n    \"\"\"\nif normalise is not None:\ndensity = (\nfacility_zone.groupby([facility_zone.index, \"activity\", normalise])\n.agg({\"id\": \"count\"})\n.reset_index()\n)\ndensity.set_index(facility_zone.index.name, inplace=True)\ndensity = density[density[\"activity\"].isin(activity)]\ndensity[\"density\"] = density[\"id\"] / density[normalise]\ntotal_density = density[~(density[normalise] == 0)][\"density\"].sum()\ndensity[\"density\"] = density[\"density\"] / total_density\nelse:\ndensity = (\nfacility_zone.groupby([facility_zone.index, \"activity\"])\n.agg({\"id\": \"count\"})\n.reset_index()\n)\ndensity.set_index(facility_zone.index.name, inplace=True)\ndensity = density[density[\"activity\"].isin(activity)]\ndensity[\"density\"] = density[\"id\"] / density[\"id\"].sum()\n# Convert back to geodataframe for merging.\ndensity = pd.merge(\ndensity, zone[\"geometry\"], left_on=density.index, right_on=zone.index, how=\"left\"\n)\ndensity.rename(columns={\"key_0\": facility_zone.index.name}, inplace=True)\ndensity = gp.GeoDataFrame(data=density, geometry=\"geometry\")\ndensity.set_index(facility_zone.index.name, inplace=True)\nif np.isinf(density[\"density\"]).sum() &gt;= 1:\nwarnings.warn(\"Your density gdf has infinite values\")\nreturn density\n</code></pre>"},{"location":"api/scoring/","title":"pam.scoring","text":""},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer","title":"<code>CharyparNagelPlanScorer</code>","text":"<p>             Bases: <code>PlanScorer</code></p>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.example_config","title":"<code>example_config = {'default': {'mUM': 10, 'utilityOfLineSwitch': -1, 'performing': 6, 'waiting': -0, 'waitingPt': -1, 'lateArrival': -18, 'earlyDeparture': -10, 'work': {'typicalDuration': '08:00:00', 'openingTime': '06:00:00', 'closingTime': '20:00:00', 'latestStartTime': '09:30:00', 'earliestEndTime': '16:00:00', 'minimalDuration': '01:00:00'}, 'home': {'typicalDuration': '12:00:00', 'minimalDuration': '05:00:00'}, 'shop': {'typicalDuration': '00:30:00', 'openingTime': '06:00:00', 'closingTime': '20:00:00'}, 'car': {'constant': -10, 'dailyMonetaryConstant': -1, 'dailyUtilityConstant': -1, 'marginalUtilityOfDistance': -0.001, 'marginalUtilityOfTravelling': -1, 'monetaryDistanceRate': -0.0001}, 'walk': {'constant': -20}}}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.activities_wrapper","title":"<code>activities_wrapper(activities)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def activities_wrapper(self, activities):\nnon_wrapped = activities[1:-1]\nwrapped_act = Activity(\nact=activities[0].act,\nstart_time=activities[-1].start_time,\nend_time=activities[0].end_time + td(days=1),\n)\nreturn wrapped_act, non_wrapped\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.duration_score","title":"<code>duration_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def duration_score(self, activity, cnfg) -&gt; float:\nprio = 1\nperforming = cnfg[\"performing\"]\ntypical_dur = utils.matsim_duration_to_hours(cnfg[activity.act][\"typicalDuration\"])\nopening_time = cnfg[activity.act].get(\"openingTime\")\nif opening_time is not None:\nopening_time = utils.matsim_time_to_datetime(opening_time)\nif opening_time.time() &gt; activity.start_time.time():\nactual_start_time = opening_time\nelse:\nactual_start_time = activity.start_time\nelse:\nactual_start_time = activity.start_time\nclosing_time = cnfg[activity.act].get(\"closingTime\")\nif closing_time is not None:\nclosing_time = utils.matsim_time_to_datetime(closing_time)\nif closing_time.time() &lt; activity.end_time.time():\nactual_end_time = closing_time\nelse:\nactual_end_time = activity.end_time\nelse:\nactual_end_time = activity.end_time\nif actual_end_time &lt; actual_start_time or actual_start_time &gt; actual_end_time:\nduration = 0\nelse:\nduration = (actual_end_time - actual_start_time) / td(hours=1)\nif duration &lt; typical_dur / np.e:\nreturn (duration * np.e - typical_dur) * performing\nreturn performing * typical_dur * (np.log(duration / typical_dur) + (1 / prio))\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.early_departure_score","title":"<code>early_departure_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def early_departure_score(self, activity, cnfg) -&gt; float:\nif cnfg[activity.act].get(\"earliestEndTime\") is not None and cnfg.get(\"earlyDeparture\"):\nearliest_end_time = utils.matsim_time_to_datetime(cnfg[activity.act][\"earliestEndTime\"])\nif activity.end_time.time() &lt; earliest_end_time.time():\nreturn cnfg[\"earlyDeparture\"] * (\n(earliest_end_time - activity.end_time) / td(hours=1)\n)\nreturn 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.late_arrival_score","title":"<code>late_arrival_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def late_arrival_score(self, activity, cnfg) -&gt; float:\nif cnfg[activity.act].get(\"latestStartTime\") is not None and cnfg.get(\"lateArrival\"):\nlatest_start_time = utils.matsim_time_to_datetime(cnfg[activity.act][\"latestStartTime\"])\nif activity.start_time.time() &gt; latest_start_time.time():\nreturn cnfg[\"lateArrival\"] * (\n(activity.start_time - latest_start_time) / td(hours=1)\n)\nreturn 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.mode_constant_score","title":"<code>mode_constant_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def mode_constant_score(self, leg, cnfg):\nreturn cnfg[leg.mode].get(\"constant\", 0.0)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.print_summary","title":"<code>print_summary(person, subpopulation='subpopulation')</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def print_summary(self, person, subpopulation=\"subpopulation\"):\nprint(f\"Total plan score: {self.score_person(person)}\")\nconfig = self.cnfg[person.attributes[subpopulation]]\nprint(f\"Total activities score: {self.score_plan_activities(person.plan, cnfg=config)}\")\nprint(f\"Total legs score: {self.score_plan_legs(person.plan, cnfg=config)}\")\nprint(f\"Pt interchanges score: {self.score_pt_interchanges(person.plan, cnfg=config)}\")\nprint(f\"Day score: {self.score_plan_daily(person.plan, cnfg=config)}\")\nprint()\nfor i, component in enumerate(person.plan):\nif isinstance(component, Activity):\nprint()\nprint(f\"({i}) Activity: {component.act}\")\nprint(f\"\\tDuration: {component.duration}\")\nif component.act in [\"pt interaction\", \"pt_interaction\"]:\ncontinue\nprint(f\"\\tScore: {self.score_activity(component, cnfg=config)}\")\nprint(f\"\\tDuration_score: {self.duration_score(component, cnfg=config)}\")\nprint(f\"\\tWaiting_score: {self.waiting_score(component, cnfg=config)}\")\nprint(f\"\\tLate_arrival_score: {self.late_arrival_score(component, cnfg=config)}\")\nprint(\nf\"\\tEarly_departure_score: {self.early_departure_score(component, cnfg=config)}\"\n)\nprint(f\"\\tToo_short_score: {self.too_short_score(component, cnfg=config)}\")\nif isinstance(component, Leg):\nprint()\nprint(f\"({i}) Leg: {component.mode}\")\nprint(f\"\\tDistance: {component.distance} Duration: {component.duration}\")\nprint(f\"\\tScore: {self.score_leg(component, cnfg=config)}\")\nprint(\nf\"\\tPt_waiting_time_score: {self.pt_waiting_time_score(component, cnfg=config)}\"\n)\nprint(f\"\\tConstant: {self.mode_constant_score(component, cnfg=config)}\")\nprint(f\"\\tTravel_time_score: {self.travel_time_score(component, cnfg=config)}\")\nprint(\nf\"\\tTravel_distance_score: {self.travel_distance_score(component, cnfg=config)}\"\n)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.pt_waiting_time_score","title":"<code>pt_waiting_time_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def pt_waiting_time_score(self, leg, cnfg):\nif cnfg.get(\"waitingPt\") and leg.boarding_time:\nwaiting = (leg.boarding_time - leg.start_time) / td(hours=1)\nif waiting &gt; 0:\nreturn cnfg[\"waitingPt\"] * waiting\nreturn 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_activity","title":"<code>score_activity(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_activity(self, activity, cnfg):\nreturn sum(\n[\nself.duration_score(activity, cnfg),\nself.waiting_score(activity, cnfg),\nself.late_arrival_score(activity, cnfg),\nself.early_departure_score(activity, cnfg),\n]\n)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_day_mode_use","title":"<code>score_day_mode_use(mode, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_day_mode_use(self, mode, cnfg) -&gt; float:\nreturn cnfg[mode].get(\"dailyUtilityConstant\", 0) + (\ncnfg[mode].get(\"dailyMonetaryConstant\", 0) * cnfg.get(\"mUM\", 1)\n)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_leg","title":"<code>score_leg(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_leg(self, leg, cnfg):\nreturn sum(\n[\nself.pt_waiting_time_score(leg, cnfg),\nself.mode_constant_score(leg, cnfg),\nself.travel_time_score(leg, cnfg),\nself.travel_distance_score(leg, cnfg),\n]\n)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_person","title":"<code>score_person(person, key='subpopulation', plan_costs=None)</code>","text":"<p>Score a pam.core.Person Plan.</p> PARAMETER  DESCRIPTION <code>person</code> <p> TYPE: <code>Person</code> </p> <code>subpopulation</code> <p>person attribute name for subpopulation. Defaults to \"subpopulation\".</p> <p> TYPE: <code>str</code> </p> <code>plan_costs</code> <p>Optionally add monetary costs such as tolls. Defaults to None.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>score</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>def score_person(\nself, person: Person, key: str = \"subpopulation\", plan_costs: Optional[float] = None\n) -&gt; float:\n\"\"\"Score a pam.core.Person Plan.\n    Args:\n      person (Person):\n      subpopulation (str, optional): person attribute name for subpopulation. Defaults to \"subpopulation\".\n      plan_costs (float, optional): Optionally add monetary costs such as tolls. Defaults to None.\n    Returns:\n        float: score\n    \"\"\"\nsubpop = person.attributes[key]\ncnfg = self.cnfg[subpop]\nreturn self.score_plan(person.plan, plan_cost=plan_costs, cnfg=cnfg)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan","title":"<code>score_plan(plan, cnfg, plan_cost=None)</code>","text":"<p>Score a pam.activity.Plan.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>activity plan to be scored.</p> <p> TYPE: <code>Plan</code> </p> <code>cnfg</code> <p>configuration for plan scoring, refer to self.example_config for example.</p> <p> TYPE: <code>dict</code> </p> <code>plan_cost</code> <p>Optionally add a plan monetary cost. Defaults to None.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Charypar-Nagel score</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>def score_plan(self, plan: Plan, cnfg: dict, plan_cost: Optional[float] = None) -&gt; float:\n\"\"\"Score a pam.activity.Plan.\n    Args:\n      plan (Plan): activity plan to be scored.\n      cnfg (dict): configuration for plan scoring, refer to self.example_config for example.\n      plan_cost (float, optional): Optionally add a plan monetary cost. Defaults to None.\n    Returns:\n      float: Charypar-Nagel score\n    \"\"\"\nreturn (\nself.score_plan_activities(plan, cnfg)\n+ self.score_plan_legs(plan, cnfg)\n+ self.score_plan_monetary_cost(plan_cost, cnfg)\n+ self.score_plan_daily(plan, cnfg)\n)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_activities","title":"<code>score_plan_activities(plan, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_activities(self, plan, cnfg):\nactivities = list(plan.activities)\nif len(activities) == 1:\nreturn self.score_activity(activities[0], cnfg)\nif activities[0].act != activities[-1].act:\n# if the first and last activity are not of the same type\n# then the activities are not wrapped\n# see https://github.com/matsim-org/matsim-libs/blob/77536f9f05ff70b69bdf54f19604f5732d81949c/matsim/src/main/java/org/matsim/core/scoring/functions/CharyparNagelActivityScoring.java#L241-L265\nscore = sum(\n[\nself.score_activity(act, cnfg)\nfor act in activities\nif act.act not in [\"pt interaction\", \"pt_interaction\"]\n]\n)\nelse:\nwrapped_activity, other_activities = self.activities_wrapper(activities)\nscore = self.score_activity(wrapped_activity, cnfg) + sum(\n[\nself.score_activity(act, cnfg)\nfor act in other_activities\nif act.act not in [\"pt interaction\", \"pt_interaction\"]\n]\n)\nreturn score\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_daily","title":"<code>score_plan_daily(plan, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_daily(self, plan, cnfg) -&gt; float:\nmodes = plan.mode_classes\nreturn sum([self.score_day_mode_use(mode, cnfg) for mode in modes])\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_legs","title":"<code>score_plan_legs(plan, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_legs(self, plan, cnfg):\nreturn self.score_pt_interchanges(plan, cnfg) + sum(\n[self.score_leg(leg, cnfg) for leg in plan.legs]\n)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_monetary_cost","title":"<code>score_plan_monetary_cost(plan_cost, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_monetary_cost(self, plan_cost, cnfg) -&gt; float:\nif plan_cost is not None:\nreturn cnfg.get(\"mUM\", 1) * plan_cost\nreturn 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_pt_interchanges","title":"<code>score_pt_interchanges(plan, cnfg)</code>","text":"<p>Calculates utility of line switch.</p> PARAMETER  DESCRIPTION <code>plan</code> <p> TYPE: <code>Plan</code> </p> <code>cnfg</code> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>float</code> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>def score_pt_interchanges(self, plan: Plan, cnfg: dict) -&gt; float:\n\"\"\"Calculates utility of line switch.\n    Args:\n      plan (Plan):\n      cnfg (dict):\n    Returns:\n        float:\n    \"\"\"\nif not cnfg.get(\"utilityOfLineSwitch\"):\nreturn 0.0\ntransits = []\nin_transit = 0\nfor i in plan:\nif isinstance(i, Activity):\nif i.act not in [\"pt interaction\", \"pt_interaction\"]:\nif in_transit &gt; 0:\nin_transit -= 1  # the first PT vehicle does not incur a line switch penalty\ntransits.append(in_transit)\nin_transit = 0\nelif isinstance(i, Leg):\nif i.mode in TRANSIT_MODES:\n# number of PT modes used in each trip\nin_transit += 1\ncost = sum(transits) * cnfg.get(\"utilityOfLineSwitch\", 0)\nreturn cost\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.too_short_score","title":"<code>too_short_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def too_short_score(self, activity, cnfg) -&gt; float:\nif cnfg[activity.act].get(\"minimalDuration\") and cnfg.get(\"earlyDeparture\"):\nminimal_duration = utils.matsim_duration_to_hours(cnfg[activity.act][\"minimalDuration\"])\nif activity.hours &lt; minimal_duration:\nreturn cnfg[\"earlyDeparture\"] * (minimal_duration - activity.hours)\nreturn 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.travel_distance_score","title":"<code>travel_distance_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def travel_distance_score(self, leg, cnfg) -&gt; float:\nreturn leg.distance * (\ncnfg[leg.mode].get(\"marginalUtilityOfDistance\", 0.0)\n+ (cnfg.get(\"mUM\", 1.0) * cnfg[leg.mode].get(\"monetaryDistanceRate\", 0.0))\n)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.travel_time_score","title":"<code>travel_time_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def travel_time_score(self, leg, cnfg) -&gt; float:\nduration = leg.hours\nif cnfg.get(\"waitingPt\") and leg.boarding_time:\nduration -= (leg.boarding_time - leg.start_time) / td(hours=1)\nreturn duration * cnfg[leg.mode].get(\"marginalUtilityOfTravelling\", 0.0)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.waiting_score","title":"<code>waiting_score(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def waiting_score(self, activity, cnfg) -&gt; float:\nwaiting = cnfg[\"waiting\"]\nif not waiting:\nreturn 0.0\nopening_time = cnfg[activity.act].get(\"openingTime\")\nif opening_time is None:\nreturn 0.0\nopening_dt = utils.matsim_time_to_datetime(opening_time)\nstart_dt = activity.start_time\nif start_dt.time() &lt; opening_dt.time():\nreturn waiting * ((opening_dt - start_dt) / td(hours=1))\nreturn 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.PlanScorer","title":"<code>PlanScorer(cnfg)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Object for scoring agent plans. This is a prelim interface.</p> PARAMETER  DESCRIPTION <code>cnfg</code> <p>scoring configuration.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>def __init__(self, cnfg: dict) -&gt; None:\n\"\"\"Object for scoring agent plans. This is a prelim interface.\n    Args:\n        cnfg (dict): scoring configuration.\n    \"\"\"\nself.logger = logging.getLogger(__name__)\nself.cnfg = cnfg\n</code></pre>"},{"location":"api/scoring/#pam.scoring.PlanScorer.cnfg","title":"<code>cnfg = cnfg</code>  <code>instance-attribute</code>","text":""},{"location":"api/scoring/#pam.scoring.PlanScorer.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/scoring/#pam.scoring.PlanScorer.score_person","title":"<code>score_person(person, key='subpopulation', plan_costs=None)</code>  <code>abstractmethod</code>","text":"<p>Score person.</p> PARAMETER  DESCRIPTION <code>person</code> <p>Person to be scores.</p> <p> TYPE: <code>Person</code> </p> <code>key</code> <p>Person attribute key used for config segmentation (\"subpopulations\"). Defaults to \"subpopulation\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'subpopulation'</code> </p> <code>plan_costs</code> <p>Monetary costs, such as tolls. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Score.</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>@abstractmethod\ndef score_person(\nself, person: Person, key: str = \"subpopulation\", plan_costs: Optional[float] = None\n) -&gt; float:\n\"\"\"Score person.\n    Args:\n        person (Person): Person to be scores.\n        key (str, optional): Person attribute key used for config segmentation (\"subpopulations\"). Defaults to \"subpopulation\".\n        plan_costs (Optional[float], optional): Monetary costs, such as tolls. Defaults to None.\n    Returns:\n        float: Score.\n    \"\"\"\n</code></pre>"},{"location":"api/scoring/#pam.scoring.PlanScorer.score_plan","title":"<code>score_plan(plan, cnfg, plan_cost=None)</code>  <code>abstractmethod</code>","text":"<p>Score plan.</p> PARAMETER  DESCRIPTION <code>plan</code> <p>Plan to be scored.</p> <p> TYPE: <code>Plan</code> </p> <code>cnfg</code> <p>Scorer configuration.</p> <p> TYPE: <code>dict</code> </p> <code>plan_cost</code> <p>Monetary costs, such as tolls. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Score.</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/scoring.py</code> <pre><code>@abstractmethod\ndef score_plan(self, plan: Plan, cnfg: dict, plan_cost: Optional[float] = None) -&gt; float:\n\"\"\"Score plan.\n    Args:\n        plan (Plan): Plan to be scored.\n        cnfg (dict): Scorer configuration.\n        plan_cost (Optional[float], optional): Monetary costs, such as tolls. Defaults to None.\n    Returns:\n        float: Score.\n    \"\"\"\n</code></pre>"},{"location":"api/utils/","title":"pam.utils","text":""},{"location":"api/utils/#pam.utils.DEFAULT_GZIP_COMPRESSION","title":"<code>DEFAULT_GZIP_COMPRESSION = 6</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#pam.utils.create_crs_attribute","title":"<code>create_crs_attribute(coordinate_reference_system)</code>","text":"<p>Create a CRS attribute as expected by MATSim's ProjectionUtils.getCRS.</p> PARAMETER  DESCRIPTION <code>coordinate_reference_system</code> <p>coordinate reference system.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>et.Element: CRS attribute as xml element</p> Source code in <code>pam/utils.py</code> <pre><code>def create_crs_attribute(coordinate_reference_system: str) -&gt; et.Element:\n\"\"\"Create a CRS attribute as expected by MATSim's ProjectionUtils.getCRS.\n    Args:\n        coordinate_reference_system (str): coordinate reference system.\n    Returns:\n        et.Element: CRS attribute as xml element\n    \"\"\"\nattributes_element = et.Element(\"attributes\")\ncrs_attribute = et.SubElement(\nattributes_element,\n\"attribute\",\n{\"class\": \"java.lang.String\", \"name\": \"coordinateReferenceSystem\"},\n)\ncrs_attribute.text = str(coordinate_reference_system)\nreturn attributes_element\n</code></pre>"},{"location":"api/utils/#pam.utils.create_local_dir","title":"<code>create_local_dir(directory)</code>","text":"<p>Safely create new directory. TODO this can be replaced with pathlib I think</p> PARAMETER  DESCRIPTION <code>directory</code> <p>new directory path</p> <p> TYPE: <code>Union[str, Path]</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def create_local_dir(directory: Union[str, Path]):\n\"\"\"Safely create new directory.\n    TODO this can be replaced with pathlib I think\n    Args:\n        directory (Union[str, Path]): new directory path\n    \"\"\"\nif not os.path.exists(directory):\nos.makedirs(directory)\n</code></pre>"},{"location":"api/utils/#pam.utils.datetime_string_to_datetime","title":"<code>datetime_string_to_datetime(string)</code>","text":"<p>Convert datetime formatted string to datetime.</p> PARAMETER  DESCRIPTION <code>string</code> <p>time string formatted \"%Y-%m-%d %H:%M:%S\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def datetime_string_to_datetime(string: str) -&gt; datetime:\n\"\"\"Convert datetime formatted string to datetime.\n    Args:\n        string (str): time string formatted \"%Y-%m-%d %H:%M:%S\".\n    Returns:\n        datetime: datetime\n    \"\"\"\nreturn datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n</code></pre>"},{"location":"api/utils/#pam.utils.datetime_to_matsim_time","title":"<code>datetime_to_matsim_time(dt)</code>","text":"<p>Convert datetime to matsim format time (<code>hh:mm:ss</code>).</p> <p>Datetimes beyond 1 day will be converted to hours, eg 25:00:00, for 1am the next day.</p> PARAMETER  DESCRIPTION <code>dt</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> RETURNS DESCRIPTION <code>str</code> <p>MATSim time format (<code>hh:mm:ss</code>)</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def datetime_to_matsim_time(dt: datetime) -&gt; str:\n\"\"\"Convert datetime to matsim format time (`hh:mm:ss`).\n    Datetimes beyond 1 day will be converted to hours, eg 25:00:00, for 1am the next day.\n    Args:\n        dt (datetime): datetime\n    Returns:\n        str: MATSim time format (`hh:mm:ss`)\n    \"\"\"\nreturn timedelta_to_matsim_time(dt - START_OF_DAY)\n</code></pre>"},{"location":"api/utils/#pam.utils.dt_to_s","title":"<code>dt_to_s(dt)</code>","text":"<p>Convert datetime to seconds since start of day.</p> PARAMETER  DESCRIPTION <code>dt</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> RETURNS DESCRIPTION <code>int</code> <p>seconds as integer</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def dt_to_s(dt: datetime) -&gt; int:\n\"\"\"Convert datetime to seconds since start of day.\n    Args:\n        dt (datetime): datetime\n    Returns:\n        int: seconds as integer\n    \"\"\"\nreturn (((dt.hour * 60) + dt.minute) * 60) + dt.second\n</code></pre>"},{"location":"api/utils/#pam.utils.get_elems","title":"<code>get_elems(path, tag)</code>","text":"<p>Wrapper for unzipping and dealing with xml namespaces</p> PARAMETER  DESCRIPTION <code>path</code> <p>xml path</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>tag</code> <p>The tag type to extract , e.g. 'link'</p> <p> TYPE: <code>str</code> </p> YIELDS DESCRIPTION <code>Generator</code> <p>Generator of elements</p> <p> TYPE:: <code>Generator</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def get_elems(path: Union[str, Path], tag: str) -&gt; Generator:\n\"\"\"Wrapper for unzipping and dealing with xml namespaces\n    Args:\n        path (Union[str, Path]): xml path\n        tag (str): The tag type to extract , e.g. 'link'\n    Yields:\n        Generator:  Generator of elements\n    \"\"\"\ntarget = try_unzip(path)\ntag = get_tag(target, tag)\ntarget = try_unzip(path)  # need to repeat :(\nreturn parse_elems(target, tag)\n</code></pre>"},{"location":"api/utils/#pam.utils.get_linestring","title":"<code>get_linestring(from_point, to_point)</code>","text":"<p>Makes a shapely.geometry.LineString out of two points.</p> PARAMETER  DESCRIPTION <code>from_point</code> <p>shapely.geometry.Point or s2sphere.CellId</p> <p> TYPE: <code>Union[Point, CellId]</code> </p> <code>to_point</code> <p>shapely.geometry.Point or s2sphere.CellId</p> <p> TYPE: <code>Union[Point, CellId]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>Failure to parse inputs</p> RETURNS DESCRIPTION <code>LineString</code> <p>LineString</p> <p> TYPE: <code>LineString</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def get_linestring(from_point: Union[Point, CellId], to_point: Union[Point, CellId]) -&gt; LineString:\n\"\"\"Makes a shapely.geometry.LineString out of two points.\n    Args:\n        from_point (Union[Point, CellId]): shapely.geometry.Point or s2sphere.CellId\n        to_point (Union[Point, CellId])): shapely.geometry.Point or s2sphere.CellId\n    Raises:\n        TypeError: Failure to parse inputs\n    Returns:\n        LineString: LineString\n    \"\"\"\nif all(isinstance(p, CellId) for p in [from_point, to_point]):\nfrom_point = from_point.to_lat_lng()\nfrom_point = Point(from_point.lng().degrees, from_point.lat().degrees)\nto_point = to_point.to_lat_lng()\nto_point = Point(to_point.lng().degrees, to_point.lat().degrees)\nif not all(isinstance(p, Point) for p in [from_point, to_point]):\nraise TypeError(\nf\"You need to pass points of type {type(Point)} or {type(CellId)}.\"\nf\"Types passed: type(from_point)={type(from_point)} and type(to_point)={type(to_point)}\"\n)\nreturn LineString([from_point, to_point])\n</code></pre>"},{"location":"api/utils/#pam.utils.get_tag","title":"<code>get_tag(target, tag)</code>","text":"<p>Check for namespace declaration.</p> <p>If they exists return tag string with namespace [''] ie {namespaces['']}tag. If no namespaces declared return original tag.</p> <p>TODO: Not working with iterparse, generated elem also have ns which is dealt with later.</p> PARAMETER  DESCRIPTION <code>target</code> <p>Target xml, either BytesIO object or path.</p> <p> TYPE: <code>Union[BytesIO, str, Path]</code> </p> <code>tag</code> <p>The tag type to extract , e.g. 'link'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>tag.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def get_tag(target: Union[BytesIO, str, Path], tag: str) -&gt; str:\n\"\"\"Check for namespace declaration.\n    If they exists return tag string with namespace [''] ie {namespaces['']}tag.\n    If no namespaces declared return original tag.\n    TODO: Not working with iterparse, generated elem also have ns which is dealt with later.\n    Args:\n        target (Union[BytesIO, str, Path]): Target xml, either BytesIO object or path.\n        tag (str): The tag type to extract , e.g. 'link'.\n    Returns:\n        str: tag.\n    \"\"\"\nnsmap = {}\ndoc = et.iterparse(target, events=(\"end\", \"start-ns\"))\ncount = 0\nfor event, element in doc:\ncount += 1\nif event == \"start-ns\":\nnsmap[element[0]] = element[1]\nif count == 10:  # assume namespace declared at top so can break early\ndel doc\nbreak\nif not nsmap:\nreturn tag\nelse:\ntag = \"{\" + nsmap[\"\"] + \"}\" + tag\nreturn tag\n</code></pre>"},{"location":"api/utils/#pam.utils.is_gzip","title":"<code>is_gzip(location)</code>","text":"<p>Checks if file is gzipped based on extension.</p> PARAMETER  DESCRIPTION <code>location</code> <p>file path</p> <p> TYPE: <code>Union[str, Path]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>is gzipped?</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def is_gzip(location: Union[str, Path]) -&gt; bool:\n\"\"\"Checks if file is gzipped based on extension.\n    Args:\n        location (Union[str, Path]): file path\n    Returns:\n        bool: is gzipped?\n    \"\"\"\nsuffix = Path(location).suffix.lower()\nreturn suffix == \".gz\" or suffix == \".gzip\"\n</code></pre>"},{"location":"api/utils/#pam.utils.is_xml","title":"<code>is_xml(location)</code>","text":"<p>Checks if file is xml based on extension.</p> PARAMETER  DESCRIPTION <code>location</code> <p>file path.</p> <p> TYPE: <code>Union[str, Path]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>is xml?</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def is_xml(location: Union[str, Path]) -&gt; bool:\n\"\"\"Checks if file is xml based on extension.\n    Args:\n        location (Union[str, Path]): file path.\n    Returns:\n        bool: is xml?\n    \"\"\"\nreturn Path(location).suffix.lower() == \".xml\"\n</code></pre>"},{"location":"api/utils/#pam.utils.matsim_duration_to_hours","title":"<code>matsim_duration_to_hours(mt)</code>","text":"<p>Turn MATSim time string (<code>hh:mm:ss</code> or <code>hh:mm</code>) into hours.</p> PARAMETER  DESCRIPTION <code>mt</code> <p>MATSim time string (<code>hh:mm:ss</code> or <code>hh:mm</code>)</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Incorrect formatted input</p> RETURNS DESCRIPTION <code>int</code> <p>hours as integer</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def matsim_duration_to_hours(mt: str) -&gt; float:\n\"\"\"Turn MATSim time string (`hh:mm:ss` or `hh:mm`) into hours.\n    Args:\n        mt (str): MATSim time string (`hh:mm:ss` or `hh:mm`)\n    Raises:\n        UserWarning: Incorrect formatted input\n    Returns:\n        int: hours as integer\n    \"\"\"\ntd = safe_strpdelta(mt)\nreturn timedelta_to_hours(td)\n</code></pre>"},{"location":"api/utils/#pam.utils.matsim_time_to_datetime","title":"<code>matsim_time_to_datetime(string)</code>","text":"<p>Convert matsim format time (<code>hh:mm:ss</code>) to datetime.</p> <p>Can read MATSim times for any day of a simulation (ie 25:00:00 is read as 01:00:00 of the next day).</p> PARAMETER  DESCRIPTION <code>string</code> <p>MATSim time from start of the simulation (%H:%M:%S)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def matsim_time_to_datetime(string: str) -&gt; datetime:\n\"\"\"Convert matsim format time (`hh:mm:ss`) to datetime.\n    Can read MATSim times for any day of a simulation (ie 25:00:00 is read as 01:00:00 of the next day).\n    Args:\n        string (str): MATSim time from start of the simulation (%H:%M:%S)\n    Returns:\n        datetime: datetime\n    \"\"\"\nreturn safe_strptime(string)\n</code></pre>"},{"location":"api/utils/#pam.utils.minutes_to_datetime","title":"<code>minutes_to_datetime(minutes)</code>","text":"<p>Convert minutes to datetime.</p> PARAMETER  DESCRIPTION <code>minutes</code> <p>minutes.</p> <p> TYPE: <code>Union[int, float]</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def minutes_to_datetime(minutes: Union[int, float]) -&gt; datetime:\n\"\"\"Convert minutes to datetime.\n    Args:\n        minutes (Union[int, float]): minutes.\n    Returns:\n        datetime: datetime\n    \"\"\"\nreturn START_OF_DAY + minutes_to_timedelta(minutes)\n</code></pre>"},{"location":"api/utils/#pam.utils.minutes_to_timedelta","title":"<code>minutes_to_timedelta(minutes)</code>","text":"<p>Convert minutes to timedelta.</p> PARAMETER  DESCRIPTION <code>minutes</code> <p>minutes.</p> <p> TYPE: <code>Union[int, float]</code> </p> RETURNS DESCRIPTION <code>timedelta</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def minutes_to_timedelta(minutes: Union[int, float]) -&gt; timedelta:\n\"\"\"Convert minutes to timedelta.\n    Args:\n        minutes (Union[int, float]): minutes.\n    Returns:\n        timedelta: timedelta\n    \"\"\"\nreturn timedelta(minutes=float(minutes))\n</code></pre>"},{"location":"api/utils/#pam.utils.parse_elems","title":"<code>parse_elems(target, tag)</code>","text":"<p>Traverse the given XML tree, retrieving the elements of the specified tag.</p> PARAMETER  DESCRIPTION <code>target</code> <p>Target xml, either BytesIO object or string path</p> <p> TYPE: <code>Union[BytesIO, str, Path]</code> </p> <code>tag</code> <p>The tag type to extract , e.g. 'link'</p> <p> TYPE: <code>str</code> </p> YIELDS DESCRIPTION <code>Generator</code> <p>Generator of elements.</p> <p> TYPE:: <code>Generator</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def parse_elems(target: Union[BytesIO, str, Path], tag: str) -&gt; Generator:\n\"\"\"Traverse the given XML tree, retrieving the elements of the specified tag.\n    Args:\n        target (Union[BytesIO, str, Path]): Target xml, either BytesIO object or string path\n        tag (str): The tag type to extract , e.g. 'link'\n    Yields:\n        Generator: Generator of elements.\n    \"\"\"\ndoc = et.iterparse(target, tag=tag)\nfor _, element in doc:\nyield element\nelement.clear()\nwhile element.getprevious() is not None:\ndel element.getparent()[0]\ndel doc\n</code></pre>"},{"location":"api/utils/#pam.utils.parse_time","title":"<code>parse_time(time)</code>","text":"<p>Generic parse time into datetime.</p> <p>Integers are assumed to be minutes. Strings are assumed to be datetime formatted as (%Y-%m-%d %H:%M:%S).</p> PARAMETER  DESCRIPTION <code>time</code> <p>time</p> <p> TYPE: <code>Union[int, str]</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>raised if wrong types provided</p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def parse_time(time: Union[int, str]) -&gt; datetime:\n\"\"\"Generic parse time into datetime.\n    Integers are assumed to be minutes.\n    Strings are assumed to be datetime formatted as (%Y-%m-%d %H:%M:%S).\n    Args:\n        time (Union[int, str]): time\n    Raises:\n        UserWarning: raised if wrong types provided\n    Returns:\n        datetime: datetime\n    \"\"\"\nif isinstance(time, (int, np.integer)) and not isinstance(time, bool):\nreturn minutes_to_datetime(time)\nelif isinstance(time, str):\nreturn datetime_string_to_datetime(time)\nelse:\nraise TypeError(\nf\"Cannot parse {time} of type {type(time)} that is not int (assuming minutes) or str (%Y-%m-%d %H:%M:%S)\"\n)\n</code></pre>"},{"location":"api/utils/#pam.utils.safe_strpdelta","title":"<code>safe_strpdelta(mt)</code>","text":"<p>Parse string into timedelta.</p> <p>Can cope with time strings in format <code>hh:mm:ss</code> or <code>hh:mm</code>.</p> PARAMETER  DESCRIPTION <code>mt</code> <p>MATSim time string (<code>hh:mm:ss</code> or <code>hh:mm</code>)</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Incorrect formatted input</p> RETURNS DESCRIPTION <code>timedelta</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def safe_strpdelta(mt: str) -&gt; timedelta:\n\"\"\"Parse string into timedelta.\n    Can cope with time strings in format `hh:mm:ss` or `hh:mm`.\n    Args:\n        mt (str): MATSim time string (`hh:mm:ss` or `hh:mm`)\n    Raises:\n        UserWarning: Incorrect formatted input\n    Returns:\n        timedelta: timedelta\n    \"\"\"\nunits = mt.split(\":\")\nif len(units) == 3:\nh, m, s = mt.split(\":\")\nreturn timedelta(hours=int(h), minutes=int(m), seconds=int(s))\nif len(units) == 2:\nh, m = mt.split(\":\")\nreturn timedelta(hours=int(h), minutes=int(m))\nraise UserWarning(f\"Unrecognised timedelta format: {mt}\")\n</code></pre>"},{"location":"api/utils/#pam.utils.safe_strptime","title":"<code>safe_strptime(mt)</code>","text":"<p>Safely parse string into datetime.</p> <p>Can cope with time strings in format <code>hh:mm:ss</code> if hh &gt; 24 then adds a day.</p> PARAMETER  DESCRIPTION <code>mt</code> <p>MATSim time string (<code>hh:mm:ss</code> or <code>hh:mm</code>)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>datetime</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def safe_strptime(mt: str) -&gt; datetime:\n\"\"\"Safely parse string into datetime.\n    Can cope with time strings in format `hh:mm:ss` if hh &gt; 24 then adds a day.\n    Args:\n        mt (str): MATSim time string (`hh:mm:ss` or `hh:mm`)\n    Returns:\n        datetime: datetime\n    \"\"\"\nreturn START_OF_DAY + safe_strpdelta(mt)\n</code></pre>"},{"location":"api/utils/#pam.utils.strip_namespace","title":"<code>strip_namespace(elem)</code>","text":"<p>Strips namespaces from given xml element</p> PARAMETER  DESCRIPTION <code>elem</code> <p>xml element</p> <p> TYPE: <code>Element</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def strip_namespace(elem: et.Element):\n\"\"\"Strips namespaces from given xml element\n    Args:\n        elem (et.Element): xml element\n    \"\"\"\nif elem.tag.startswith(\"{\"):\n# strip namespace\nelem.tag = elem.tag.split(\"}\", 1)[1]\nfor k in elem.attrib.keys():\nif k.startswith(\"{\"):\nk2 = k.split(\"}\", 1)[1]\nelem.attrib[k2] = elem.attrib[k]\ndel elem.attrib[k]\nfor child in elem:\nstrip_namespace(child)\n</code></pre>"},{"location":"api/utils/#pam.utils.td_to_s","title":"<code>td_to_s(td)</code>","text":"<p>Convert timedelta to seconds since start of day.</p> PARAMETER  DESCRIPTION <code>td</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>int</code> <p>seconds as integer</p> <p> TYPE: <code>int</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def td_to_s(td: timedelta) -&gt; int:\n\"\"\"Convert timedelta to seconds since start of day.\n    Args:\n        td (timedelta): timedelta\n    Returns:\n        int: seconds as integer\n    \"\"\"\nreturn (td.days * 86400) + td.seconds\n</code></pre>"},{"location":"api/utils/#pam.utils.timedelta_to_hours","title":"<code>timedelta_to_hours(td)</code>","text":"<p>Timedelta to hours.</p> PARAMETER  DESCRIPTION <code>td</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>float</code> <p>hours as float</p> <p> TYPE: <code>float</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def timedelta_to_hours(td: timedelta) -&gt; float:\n\"\"\"Timedelta to hours.\n    Args:\n        td (timedelta): timedelta\n    Returns:\n        float: hours as float\n    \"\"\"\nreturn td.total_seconds() / 3600\n</code></pre>"},{"location":"api/utils/#pam.utils.timedelta_to_matsim_time","title":"<code>timedelta_to_matsim_time(td)</code>","text":"<p>Convert datetime timedelta object to matsim string format (<code>hh:mm:ss</code>).</p> PARAMETER  DESCRIPTION <code>td</code> <p>timedelta</p> <p> TYPE: <code>timedelta</code> </p> RETURNS DESCRIPTION <code>str</code> <p>MATSim time string (<code>hh:mm:ss</code>)</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def timedelta_to_matsim_time(td: timedelta) -&gt; str:\n\"\"\"Convert datetime timedelta object to matsim string format (`hh:mm:ss`).\n    Args:\n        td (timedelta): timedelta\n    Returns:\n        str: MATSim time string (`hh:mm:ss`)\n    \"\"\"\nhours, remainder = divmod(td.total_seconds(), 3600)\nminutes, seconds = divmod(remainder, 60)\nreturn f\"{int(hours):02}:{int(minutes):02}:{int(seconds):02}\"\n</code></pre>"},{"location":"api/utils/#pam.utils.try_unzip","title":"<code>try_unzip(path)</code>","text":"<p>Attempts to unzip xml at given path, if fails, returns path</p> PARAMETER  DESCRIPTION <code>path</code> <p>xml path.</p> <p> TYPE: <code>Union[str, Path]</code> </p> RETURNS DESCRIPTION <code>Union[BytesIO, str, Path]</code> <p>Union[BytesIO, str, Path]: BytesIO object or path if already unzipped.</p> Source code in <code>pam/utils.py</code> <pre><code>def try_unzip(path: Union[str, Path]) -&gt; Union[BytesIO, str, Path]:\n\"\"\"Attempts to unzip xml at given path, if fails, returns path\n    Args:\n        path (Union[str, Path]): xml path.\n    Returns:\n        Union[BytesIO, str, Path]: BytesIO object or path if already unzipped.\n    \"\"\"\ntry:\nwith gzip.open(path) as unzipped:\nxml = unzipped.read()\ntarget = BytesIO(xml)\nreturn target\nexcept OSError:\nreturn path\n</code></pre>"},{"location":"api/utils/#pam.utils.xml_tree","title":"<code>xml_tree(content)</code>","text":"<p>Return pretty formatted string of xml tree.</p> PARAMETER  DESCRIPTION <code>content</code> <p>xml</p> <p> TYPE: <code>Element</code> </p> RETURNS DESCRIPTION <code>str</code> <p>pretty string of xml</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/utils.py</code> <pre><code>def xml_tree(content: et.Element) -&gt; str:\n\"\"\"Return pretty formatted string of xml tree.\n    Args:\n        content (et.Element): xml\n    Returns:\n        str: pretty string of xml\n    \"\"\"\ntree = et.tostring(content, pretty_print=True, xml_declaration=False, encoding=\"UTF-8\")\nreturn tree\n</code></pre>"},{"location":"api/vehicles/","title":"pam.vehicles","text":""},{"location":"api/vehicles/#pam.vehicles.CapacityType","title":"<code>CapacityType</code>  <code>dataclass</code>","text":"<p>Vehicle capacity dataclass with read/write methods.</p> ATTRIBUTE DESCRIPTION <code>seats</code> <p>Seats in/on vehicle.</p> <p> TYPE: <code>int</code> </p> <code>standingRoomInPersons</code> <p>Standing room in/on vehicle.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/vehicles/#pam.vehicles.CapacityType.seats","title":"<code>seats: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.CapacityType.standingRoomInPersons","title":"<code>standingRoomInPersons: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.CapacityType.from_xml_elem","title":"<code>from_xml_elem(elem)</code>  <code>classmethod</code>","text":"Source code in <code>pam/vehicles.py</code> <pre><code>@classmethod\ndef from_xml_elem(cls, elem):\nattribs = {k: int(v) for k, v in elem.attrib.items()}\nreturn cls(**attribs)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.CapacityType.to_xml","title":"<code>to_xml(xf)</code>","text":"Source code in <code>pam/vehicles.py</code> <pre><code>def to_xml(self, xf):\nxf.write(\net.Element(\n\"capacity\",\n{\n\"seats\": str(self.seats),\n\"standingRoomInPersons\": str(self.standingRoomInPersons),\n},\n)\n)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.ElectricVehicle","title":"<code>ElectricVehicle</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Vehicle</code></p> <p>Electric vehicle data representation. Required for MATSim EV extension.</p> ATTRIBUTE DESCRIPTION <code>vid</code> <p>Unique vehicle identifier.</p> <p> TYPE: <code>str</code> </p> <code>type_id</code> <p>Type of vehicle, eg \"default_car\".</p> <p> TYPE: <code>str</code> </p> <code>battery_capacity</code> <p>Charge capacity.</p> <p> TYPE: <code>float</code> </p> <code>initial_soc</code> <p>Initial state of charge.</p> <p> TYPE: <code>float</code> </p> <code>charger_types</code> <p>Types of chargers vehicle may use.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/vehicles/#pam.vehicles.ElectricVehicle.battery_capacity","title":"<code>battery_capacity: float = 60</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.ElectricVehicle.charger_types","title":"<code>charger_types: str = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.ElectricVehicle.initial_soc","title":"<code>initial_soc: float = battery_capacity</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.ElectricVehicle.to_ev_xml","title":"<code>to_ev_xml(xf)</code>","text":"<p>Write vehicle to MATSim formatted xml.</p> PARAMETER  DESCRIPTION <code>xf</code> <p>Parent xml element.</p> <p> TYPE: <code>Element</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_ev_xml(self, xf) -&gt; None:\n\"\"\"Write vehicle to MATSim formatted xml.\n    Args:\n        xf (et.Element): Parent xml element.\n    \"\"\"\nxf.write(\net.Element(\n\"vehicle\",\n{\n\"id\": str(self.vid),\n\"battery_capacity\": str(self.battery_capacity),\n\"initial_soc\": str(self.initial_soc),\n\"charger_types\": str(self.charger_types),\n\"vehicle_type\": str(self.type_id),\n},\n)\n)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.Vehicle","title":"<code>Vehicle</code>  <code>dataclass</code>","text":"<p>Vehicle parent data class, holds required vehicle data (id and type) and read/write methods.</p> ATTRIBUTE DESCRIPTION <code>vid</code> <p>Unique vehicle identifier.</p> <p> TYPE: <code>str</code> </p> <code>type_id</code> <p>Type of vehicle, eg \"default_car\".</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/vehicles/#pam.vehicles.Vehicle.type_id","title":"<code>type_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.Vehicle.vid","title":"<code>vid: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.Vehicle.to_xml","title":"<code>to_xml(xf)</code>","text":"<p>Write vehicle to MATSim formatted xml.</p> PARAMETER  DESCRIPTION <code>xf</code> <p>Parent xml element.</p> <p> TYPE: <code>Element</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_xml(self, xf: et.Element) -&gt; None:\n\"\"\"Write vehicle to MATSim formatted xml.\n    Args:\n        xf (et.Element): Parent xml element.\n    \"\"\"\nxf.write(et.Element(\"vehicle\", {\"id\": str(self.vid), \"type\": str(self.type_id)}))\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager","title":"<code>VehicleManager()</code>","text":"<p>Vehicles and vehicle types representation, responsible for read/write from MATSim vehicles files.</p> ATTRIBUTE DESCRIPTION <code>_veh_types</code> <p>Mapping of type ids to vehicle types data.</p> <p> TYPE: <code>dict[str, VehicleType]</code> </p> <code>_vehicles</code> <p>Mapping of vehicle ids to vehicle data.</p> <p> TYPE: <code>dict[str, Vehicle]</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def __init__(self) -&gt; None:\nself._veh_types = {}\nself._vehicles = {}\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.evs","title":"<code>evs: dict[str, ElectricVehicle]</code>  <code>property</code>","text":"<p>Return dictionary of electric vehicles in manager.</p> RETURNS DESCRIPTION <code>dict[str, ElectricVehicle]</code> <p>dict[str, ElectricVehicle]: Dictionary of electric vehicles.</p>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.add_type","title":"<code>add_type(vehicle_type)</code>","text":"<p>Add vehicle type to manager.</p> PARAMETER  DESCRIPTION <code>vehicle_type</code> <p>Vehicle type dataclass.</p> <p> TYPE: <code>VehicleType</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def add_type(self, vehicle_type: VehicleType) -&gt; None:\n\"\"\"Add vehicle type to manager.\n    Args:\n        vehicle_type (VehicleType): Vehicle type dataclass.\n    \"\"\"\nif vehicle_type.id in self._veh_types:\nlogging.info(f\"Warning, overwriting existing vehicle type '{vehicle_type.id}'.\")\nself._veh_types[vehicle_type.id] = vehicle_type\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.add_veh","title":"<code>add_veh(v)</code>","text":"<p>Add vehicle to manager.</p> PARAMETER  DESCRIPTION <code>v</code> <p>Vehicle dataclass.</p> <p> TYPE: <code>Vehicle</code> </p> RAISES DESCRIPTION <code>PAMVehicleIdError</code> <p>Unknown vehicle type.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def add_veh(self, v: Vehicle):\n\"\"\"Add vehicle to manager.\n    Args:\n        v (Vehicle): Vehicle dataclass.\n    Raises:\n        PAMVehicleIdError: Unknown vehicle type.\n    \"\"\"\nif v.type_id not in self._veh_types:\nraise PAMVehicleTypeError(\nf\"Failed to add vehicle: {v.vid}, the vehicle type '{v.type_id}' is an unknown veh type.\"\n)\nif v.vid in self._vehicles:\nlogging.info(f\"Warning, overwriting existing vehicle: '{v.vid}'.\")\nself._vehicles[v.vid] = v\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.charger_types","title":"<code>charger_types()</code>","text":"<p>Return set of electric charger types used by evs.</p> RETURNS DESCRIPTION <code>set[str]</code> <p>set[str]: Electric charger types.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def charger_types(self) -&gt; set[str]:\n\"\"\"Return set of electric charger types used by evs.\n    Returns:\n        set[str]: Electric charger types.\n    \"\"\"\nchargers = set()\nfor v in self.evs.values():\nchargers |= set(v.charger_types.split(\",\"))\nreturn chargers\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.clear_types","title":"<code>clear_types()</code>","text":"<p>Remove all types from manager.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def clear_types(self):\n\"\"\"Remove all types from manager.\"\"\"\nself._veh_types = {}\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.clear_vehs","title":"<code>clear_vehs()</code>","text":"<p>Remove all vehciles from manager.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def clear_vehs(self):\n\"\"\"Remove all vehciles from manager.\"\"\"\nself._vehicles = {}\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.evs_from_xml","title":"<code>evs_from_xml(path)</code>","text":"<p>Reads vehicles from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).</p> PARAMETER  DESCRIPTION <code>path</code> <p>path to matsim all_vehicles xml file</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def evs_from_xml(self, path):\n\"\"\"Reads vehicles from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).\n    Args:\n        path (str): path to matsim all_vehicles xml file\n    \"\"\"\nevs = {}\nfor vehicle_elem in utils.get_elems(path, \"vehicle\"):\nattribs = dict(vehicle_elem.attrib)\nvid = attribs.pop(\"id\")\nvehicle_type = attribs.pop(\"vehicle_type\")\nattribs[\"battery_capacity\"] = float(attribs[\"battery_capacity\"])\nattribs[\"initial_soc\"] = float(attribs[\"initial_soc\"])\nevs[vid] = ElectricVehicle(vid=vid, type_id=vehicle_type, **attribs)\nkeys = set(evs) &amp; set(self._vehicles)\nif keys:\nPAMVehicleIdError(\nf\"Failed to read evs from xml due to duplicate keys with existing: {keys}\"\n)\nself._vehicles.update(evs)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.from_xml","title":"<code>from_xml(vehs_path, evs_path=None)</code>","text":"<p>Reads MATSim vehicles from https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd and reads electric_vehicles from https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd. Requires a vehicles file to load an evs file because the electric vehicle type is expected to be defined in the vehicles input.</p> PARAMETER  DESCRIPTION <code>vehs_path</code> <p>path to matsim all_vehicles xml file</p> <p> TYPE: <code>str</code> </p> <code>evs_path</code> <p>optional path to matsim electric_vehicles xml file. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>Cannot load evs without a vehs file.</p> <code>UserWarning</code> <p>Fails consistency check.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def from_xml(self, vehs_path: str, evs_path: Optional[str] = None):\n\"\"\"Reads MATSim vehicles from https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd\n    and reads electric_vehicles from https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd.\n    Requires a vehicles file to load an evs file because the electric vehicle type is expected to be defined in\n    the vehicles input.\n    Args:\n        vehs_path (str): path to matsim all_vehicles xml file\n        evs_path (Optional[str], optional): optional path to matsim electric_vehicles xml file. Defaults to None.\n    Raises:\n        UserWarning: Cannot load evs without a vehs file.\n        UserWarning: Fails consistency check.\n    \"\"\"\nif not vehs_path and evs_path:\nraise UserWarning(\"Cannot load an evs file without a vehs file.\")\nself.types_from_xml(vehs_path)\nself.vehs_from_xml(vehs_path)\nif evs_path is not None:\nself.evs_from_xml(evs_path)\nif not self.is_consistent():\nraise UserWarning(\"Inputs not consistent, refer to log.\")\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.get","title":"<code>get(k, default=None)</code>","text":"Source code in <code>pam/vehicles.py</code> <pre><code>def get(self, k: str, default: Optional[Vehicle] = None) -&gt; Optional[Vehicle]:\nreturn self._vehicles.get(k, default)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.is_consistent","title":"<code>is_consistent()</code>","text":"<p>Check that manager vehicle population and types are consistent.</p> RAISES DESCRIPTION <code>PAMVehicleIdError</code> <p>Unknown vehicle type.</p> RETURNS DESCRIPTION <code>bool</code> <p>Manager is consistent. Note that this doesn't check for unused types.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def is_consistent(self) -&gt; bool:\n\"\"\"Check that manager vehicle population and types are consistent.\n    Raises:\n        PAMVehicleIdError: Unknown vehicle type.\n    Returns:\n        bool: Manager is consistent. Note that this doesn't check for unused types.\n    \"\"\"\nveh_types = set(self._veh_types.keys())\nfor k, v in self._vehicles.items():\nif v.type_id not in veh_types:\nraise PAMVehicleIdError(\nf\"Failed to find veh type of id '{v}', specified for veh id '{k}'.\"\n)\nreturn True\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.len","title":"<code>len()</code>","text":"<p>Number of vehicles.</p> Source code in <code>pam/vehicles.py</code> <pre><code>def len(self) -&gt; int:\n\"\"\"Number of vehicles.\"\"\"\nreturn len(self._vehicles)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.pop","title":"<code>pop(vid)</code>","text":"Source code in <code>pam/vehicles.py</code> <pre><code>def pop(self, vid):\nreturn self._vehicles.pop(vid)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.redundant_types","title":"<code>redundant_types()</code>","text":"<p>Check for ununsed vehicle types.</p> RETURNS DESCRIPTION <code>dict</code> <p>unused types.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def redundant_types(self) -&gt; dict:\n\"\"\"Check for ununsed vehicle types.\n    Returns:\n        dict: unused types.\n    \"\"\"\nunused = {}\nveh_types = set(self._veh_types.keys())\nveh_veh_types = set([v.type_id for v in self._vehicles.values()])\nfor t in veh_types:\nif t not in veh_veh_types:\nunused[t] = self._veh_types[t]\nreturn unused\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.remove_type","title":"<code>remove_type(tid)</code>","text":"<p>Remove vehicle type.</p> PARAMETER  DESCRIPTION <code>tid</code> <p>Vehicle type id.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def remove_type(self, tid: str):\n\"\"\"Remove vehicle type.\n    Args:\n        tid (str): Vehicle type id.\n    \"\"\"\nlogging.info(\"Warning, removing a vehicle type may invalidate your vehicles.\")\nif self._veh_types.pop(tid, None) is None:\nraise PAMVehicleTypeError(f\"Failed to remove vehicle type {tid}, id not found.\")\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.to_ev_xml","title":"<code>to_ev_xml(path)</code>","text":"<p>Writes MATSim electric vehciles file as per https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd.</p> PARAMETER  DESCRIPTION <code>path</code> <p>name of output file</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_ev_xml(self, path: str):\n\"\"\"Writes MATSim electric vehciles file as per https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd.\n    Args:\n        path (str): name of output file\n    \"\"\"\nwith et.xmlfile(path, encoding=\"utf-8\") as xf:\nlogging.info(f\"Writing electric vehicles to {path}\")\nxf.write_declaration(\ndoctype='&lt;!DOCTYPE vehicles SYSTEM \"http://matsim.org/files/dtd/electric_vehicles_v1.dtd\"&gt;'\n)\nwith xf.element(\"vehicles\"):\nfor veh in self.evs.values():\nveh.to_ev_xml(xf)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.to_veh_xml","title":"<code>to_veh_xml(path)</code>","text":"<p>Writes MATSim vehicles file as per https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd.</p> PARAMETER  DESCRIPTION <code>path</code> <p>name of output file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_veh_xml(self, path: str):\n\"\"\"Writes MATSim vehicles file as per https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd.\n    Args:\n        path (str): name of output file.\n    \"\"\"\nwith et.xmlfile(path, encoding=\"utf-8\") as xf:\nxf.write_declaration()\nvehicleDefinitions_attribs = {\n\"xmlns\": \"http://www.matsim.org/files/dtd\",\n\"xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n\"xsi:schemaLocation\": \"http://www.matsim.org/files/dtd \"\n\"http://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd\",\n}\nwith xf.element(\"vehicleDefinitions\", vehicleDefinitions_attribs):\nlogging.info(f\"Writing vehicle types to {path}\")\nfor vehicle_type in self._veh_types.values():\nvehicle_type.to_xml(xf)\nlogging.info(f\"Writing vehicles to {path}\")\nfor veh in self._vehicles.values():\nveh.to_xml(xf)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.to_xml","title":"<code>to_xml(vehs_path, evs_path=None)</code>","text":"<p>Write manager to MATSim formatted xml.</p> PARAMETER  DESCRIPTION <code>vehs_path</code> <p>Write path for MATSim vehicles file.</p> <p> TYPE: <code>str</code> </p> <code>evs_path</code> <p>Write path for MATSim electric vehicles file. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_xml(self, vehs_path: str, evs_path: Optional[str] = None):\n\"\"\"Write manager to MATSim formatted xml.\n    Args:\n        vehs_path (str): Write path for MATSim vehicles file.\n        evs_path (Optional[str], optional): Write path for MATSim electric vehicles file. Defaults to None.\n    \"\"\"\nself.to_veh_xml(vehs_path)\nif evs_path:\nself.to_ev_xml(evs_path)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.types_from_xml","title":"<code>types_from_xml(path)</code>","text":"<p>Reads vehicle types from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).</p> PARAMETER  DESCRIPTION <code>path</code> <p>path to matsim all_vehicles xml file</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def types_from_xml(self, path: str):\n\"\"\"Reads vehicle types from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).\n    Args:\n        path (str): path to matsim all_vehicles xml file\n    \"\"\"\nvehs = dict(\n(elem.get(\"id\"), VehicleType.from_xml_elem(elem))\nfor elem in utils.get_elems(path, \"vehicleType\")\n)\nkeys = set(vehs) &amp; set(self._veh_types)\nif keys:\nraise PAMVehicleIdError(\nf\"Failed to read types from xml due to duplicate keys with existing types: {keys}\"\n)\nself._veh_types.update(vehs)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleManager.vehs_from_xml","title":"<code>vehs_from_xml(path)</code>","text":"<p>Reads vehicles from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).</p> PARAMETER  DESCRIPTION <code>path</code> <p>path to matsim all_vehicles xml file</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def vehs_from_xml(self, path: str):\n\"\"\"Reads vehicles from MATSim vehicles file (https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd).\n    Args:\n        path (str): path to matsim all_vehicles xml file\n    \"\"\"\nvehs = {\nelem.get(\"id\"): Vehicle(vid=elem.get(\"id\"), type_id=elem.get(\"type\"))\nfor elem in utils.get_elems(path, \"vehicle\")\n}\nkeys = set(vehs) &amp; set(self._vehicles)\nif keys:\nraise PAMVehicleIdError(\nf\"Failed to read vehs from xml due to duplicate keys with existing: {keys}\"\n)\nself._vehicles.update(vehs)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleType","title":"<code>VehicleType</code>  <code>dataclass</code>","text":"<p>Vehicle type data with read/write methods.</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>type id.</p> <p> TYPE: <code>str</code> </p> <code>length</code> <p>Vehicle length in m.</p> <p> TYPE: <code>float</code> </p> <code>width</code> <p>Vehicle width in m.</p> <p> TYPE: <code>float</code> </p> <code>networkMode</code> <p>MATSim network mode (used for routing).</p> <p> TYPE: <code>str</code> </p> <code>capacity</code> <p>Vehicle seating and standing capacity.</p> <p> TYPE: <code>CapacityType</code> </p> <code>description</code> <p>Vehicle description.</p> <p> TYPE: <code>str</code> </p> <code>passengerCarEquivalents</code> <p>Vehicle size as passenger car equivalents (PCUs).</p> <p> TYPE: <code>float</code> </p> <code>flowEfficiencyFactor</code> <p>Vehicle flow efficiency factor.</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/vehicles/#pam.vehicles.VehicleType.capacity","title":"<code>capacity: CapacityType = field(default_factory=CapacityType)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.VehicleType.description","title":"<code>description: str = 'personal_vehicle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.VehicleType.flowEfficiencyFactor","title":"<code>flowEfficiencyFactor: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.VehicleType.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.VehicleType.length","title":"<code>length: float = 7.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.VehicleType.networkMode","title":"<code>networkMode: str = 'car'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.VehicleType.passengerCarEquivalents","title":"<code>passengerCarEquivalents: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.VehicleType.width","title":"<code>width: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicles/#pam.vehicles.VehicleType.from_xml_elem","title":"<code>from_xml_elem(elem)</code>  <code>classmethod</code>","text":"<p>Construct VehicleType from MATSim xml element.</p> PARAMETER  DESCRIPTION <code>elem</code> <p>MATSim formatted vehicle type xml element.</p> <p> TYPE: <code>Element</code> </p> RETURNS DESCRIPTION <code>VehicleType</code> <p>Vehicle type dataclass.</p> <p> TYPE: <code>VehicleType</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>@classmethod\ndef from_xml_elem(cls, elem: et.Element) -&gt; VehicleType:\n\"\"\"Construct VehicleType from MATSim xml element.\n    Args:\n        elem (et.Element): MATSim formatted vehicle type xml element.\n    Returns:\n        VehicleType: Vehicle type dataclass.\n    \"\"\"\nattribs = {\nattrib.tag.replace(\"{http://www.matsim.org/files/dtd}\", \"\"): attrib for attrib in elem\n}\nreturn cls(\nid=elem.get(\"id\"),\nlength=float(attribs[\"length\"].attrib[\"meter\"]),\nwidth=float(attribs[\"width\"].attrib[\"meter\"]),\npassengerCarEquivalents=float(attribs[\"passengerCarEquivalents\"].attrib[\"pce\"]),\nnetworkMode=attribs[\"networkMode\"].attrib[\"networkMode\"],\nflowEfficiencyFactor=float(attribs[\"flowEfficiencyFactor\"].attrib[\"factor\"]),\ncapacity=CapacityType.from_xml_elem(attribs[\"capacity\"]),\ndescription=attribs[\"description\"].text,\n)\n</code></pre>"},{"location":"api/vehicles/#pam.vehicles.VehicleType.to_xml","title":"<code>to_xml(xf)</code>","text":"<p>Write vehicle type to MATSim formatted xml.</p> PARAMETER  DESCRIPTION <code>xf</code> <p>Parent xml element.</p> <p> TYPE: <code>Element</code> </p> <code>tid</code> <p>Type id.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pam/vehicles.py</code> <pre><code>def to_xml(self, xf: et.Element) -&gt; None:\n\"\"\"Write vehicle type to MATSim formatted xml.\n    Args:\n        xf (et.Element): Parent xml element.\n        tid (str): Type id.\n    \"\"\"\nwith xf.element(\"vehicleType\", {\"id\": self.id}):\nrec = et.Element(\"description\")\nrec.text = self.description\nxf.write(rec)\nself.capacity.to_xml(xf)\nxf.write(et.Element(\"length\", {\"meter\": str(self.length)}))\nxf.write(et.Element(\"width\", {\"meter\": str(self.width)}))\nxf.write(\net.Element(\"passengerCarEquivalents\", {\"pce\": str(self.passengerCarEquivalents)})\n)\nxf.write(et.Element(\"networkMode\", {\"networkMode\": str(self.networkMode)}))\nxf.write(et.Element(\"flowEfficiencyFactor\", {\"factor\": str(self.flowEfficiencyFactor)}))\n</code></pre>"},{"location":"api/write/diary/","title":"pam.write.diary","text":""},{"location":"api/write/diary/#pam.write.diary.dump","title":"<code>dump(population, dir, crs=None, to_crs='EPSG:4326')</code>","text":"<p>Write a population to disk as tabular data in csv format.</p> <p>Outputs saved to file are: - households.csv: household ids and attributes - people.csv: agent ids and attributes - legs.csv: activity plan trip records - activities.csv: corresponding plan activities If activity locs (shapely.Point) data is available then geojsons will also be written.</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> <code>dir</code> <p>path to output directory</p> <p> TYPE: <code>str</code> </p> <code>crs</code> <p>population coordinate system (generally we use local grid systems). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>to_crs</code> <p>output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'EPSG:4326'</code> </p> Source code in <code>pam/write/diary.py</code> <pre><code>def dump(\npopulation: Population, dir: str, crs: Optional[str] = None, to_crs: Optional[str] = \"EPSG:4326\"\n) -&gt; None:\n\"\"\"Write a population to disk as tabular data in csv format.\n    Outputs saved to file are:\n    - households.csv: household ids and attributes\n    - people.csv: agent ids and attributes\n    - legs.csv: activity plan trip records\n    - activities.csv: corresponding plan activities\n    If activity locs (shapely.Point) data is available then geojsons will also be written.\n    Args:\n      population (Population):\n      dir (str): path to output directory\n      crs (Optional[str]): population coordinate system (generally we use local grid systems). Defaults to None.\n      to_crs (Optional[str]): output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".\n    \"\"\"\nto_csv(population=population, dir=dir, crs=crs, to_crs=to_crs)\n</code></pre>"},{"location":"api/write/diary/#pam.write.diary.save_csv","title":"<code>save_csv(df, path)</code>","text":"<p>Write GeoDataFrame as csv by dropping geometry column.</p> Source code in <code>pam/write/diary.py</code> <pre><code>def save_csv(df, path):\n\"\"\"Write GeoDataFrame as csv by dropping geometry column.\"\"\"\nif \"geometry\" in df.columns:\ndf = df.drop(\"geometry\", axis=1)\ndf.to_csv(path)\n</code></pre>"},{"location":"api/write/diary/#pam.write.diary.save_geojson","title":"<code>save_geojson(df, crs, to_crs, path)</code>","text":"Source code in <code>pam/write/diary.py</code> <pre><code>def save_geojson(df, crs, to_crs, path):\nif \"geometry\" in df.columns:\ndf = gp.GeoDataFrame(df, geometry=\"geometry\")\nif crs is not None:\ndf.crs = crs\ndf.to_crs(to_crs, inplace=True)\ndf.to_file(path, driver=\"GeoJSON\")\n</code></pre>"},{"location":"api/write/diary/#pam.write.diary.to_csv","title":"<code>to_csv(population, dir, crs=None, to_crs='EPSG:4326')</code>","text":"<p>Write a population to disk as tabular data in csv format.</p> <p>Outputs saved to file are: - households.csv: household ids and attributes - people.csv: agent ids and attributes - legs.csv: activity plan trip records - activities.csv: corresponding plan activities If activity locs (shapely.Point) data is available then geojsons will also be written.</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> <code>dir</code> <p>path to output directory</p> <p> TYPE: <code>str</code> </p> <code>crs</code> <p>population coordinate system (generally we use local grid systems). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>to_crs</code> <p>output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'EPSG:4326'</code> </p> Source code in <code>pam/write/diary.py</code> <pre><code>def to_csv(\npopulation: Population, dir: str, crs: Optional[str] = None, to_crs: Optional[str] = \"EPSG:4326\"\n) -&gt; None:\n\"\"\"Write a population to disk as tabular data in csv format.\n    Outputs saved to file are:\n    - households.csv: household ids and attributes\n    - people.csv: agent ids and attributes\n    - legs.csv: activity plan trip records\n    - activities.csv: corresponding plan activities\n    If activity locs (shapely.Point) data is available then geojsons will also be written.\n    Args:\n      population (Population):\n      dir (str): path to output directory\n      crs (Optional[str]): population coordinate system (generally we use local grid systems). Defaults to None.\n      to_crs (Optional[str]): output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".\n    \"\"\"\ncreate_local_dir(dir)\nhhs = []\npeople = []\nacts = []\nlegs = []\nfor hid, hh in population.households.items():\nhh_data = {\"hid\": hid, \"freq\": hh.freq, \"hzone\": hh.location.area}\nif isinstance(hh.attributes, dict):\nhh_data.update(hh.attributes)\nif hh.location.loc is not None:\nhh_data[\"geometry\"] = hh.location.loc\nhhs.append(hh_data)\nfor pid, person in hh.people.items():\npeople_data = {\"pid\": pid, \"hid\": hid, \"freq\": person.freq, \"hzone\": hh.location.area}\nif isinstance(person.attributes, dict):\npeople_data.update(person.attributes)\nif hh.location.loc is not None:\npeople_data[\"geometry\"] = hh.location.loc\npeople.append(people_data)\nfor seq, component in enumerate(person.plan):\nif isinstance(component, Leg):\nleg_data = {\n\"pid\": pid,\n\"hid\": hid,\n\"freq\": component.freq,\n\"ozone\": component.start_location.area,\n\"dzone\": component.end_location.area,\n\"purp\": component.purp,\n\"origin activity\": person.plan[seq - 1].act,\n\"destination activity\": person.plan[seq + 1].act,\n\"mode\": component.mode,\n\"seq\": component.seq,\n\"tst\": component.start_time,\n\"tet\": component.end_time,\n\"duration\": str(component.duration),\n}\nif (\ncomponent.start_location.loc is not None\nand component.end_location.loc is not None\n):\nleg_data[\"geometry\"] = LineString(\n(component.start_location.loc, component.end_location.loc)\n)\nlegs.append(leg_data)\nif isinstance(component, Activity):\nact_data = {\n\"pid\": pid,\n\"hid\": hid,\n\"freq\": component.freq,\n\"activity\": component.act,\n\"seq\": component.seq,\n\"start time\": component.start_time,\n\"end time\": component.end_time,\n\"duration\": str(component.duration),\n\"zone\": component.location.area,\n}\nif component.location.loc is not None:\nact_data[\"geometry\"] = component.location.loc\nacts.append(act_data)\nhhs = pd.DataFrame(hhs).set_index(\"hid\")\nsave_geojson(hhs, crs, to_crs, os.path.join(dir, \"households.geojson\"))\nsave_csv(hhs, os.path.join(dir, \"households.csv\"))\npeople = pd.DataFrame(people).set_index(\"pid\")\nsave_geojson(people, crs, to_crs, os.path.join(dir, \"people.geojson\"))\nsave_csv(people, os.path.join(dir, \"people.csv\"))\nlegs = pd.DataFrame(legs)\nsave_geojson(legs, crs, to_crs, os.path.join(dir, \"legs.geojson\"))\nsave_csv(legs, os.path.join(dir, \"legs.csv\"))\nacts = pd.DataFrame(acts)\nsave_geojson(acts, crs, to_crs, os.path.join(dir, \"activities.geojson\"))\nsave_csv(acts, os.path.join(dir, \"activities.csv\"))\n</code></pre>"},{"location":"api/write/diary/#pam.write.diary.write_population_csvs","title":"<code>write_population_csvs(list_of_populations, dir, crs=None, to_crs='EPSG:4326')</code>","text":"<p>Write a list of populations to disk as tabular data in csv format.</p> <p>Outputs saved to file are: - populations.csv: summary of populations - households.csv: household ids and attributes - people.csv: agent ids and attributes - legs.csv: activity plan trip records - activities.csv: corresponding plan activities If activity locs (shapely.Point) data is available then geojsons will also be written.</p> PARAMETER  DESCRIPTION <code>list_of_populations</code> <p> TYPE: <code>list[Population]</code> </p> <code>dir</code> <p>path to output directory</p> <p> TYPE: <code>str</code> </p> <code>crs</code> <p>population coordinate system (generally we use local grid systems). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>to_crs</code> <p>output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'EPSG:4326'</code> </p> Source code in <code>pam/write/diary.py</code> <pre><code>def write_population_csvs(\nlist_of_populations: list[Population],\ndir: str,\ncrs: Optional[str] = None,\nto_crs: Optional[str] = \"EPSG:4326\",\n) -&gt; None:\n\"\"\"Write a list of populations to disk as tabular data in csv format.\n    Outputs saved to file are:\n    - populations.csv: summary of populations\n    - households.csv: household ids and attributes\n    - people.csv: agent ids and attributes\n    - legs.csv: activity plan trip records\n    - activities.csv: corresponding plan activities\n    If activity locs (shapely.Point) data is available then geojsons will also be written.\n    Args:\n      list_of_populations (list[Population]):\n      dir (str): path to output directory\n      crs (Optional[str]): population coordinate system (generally we use local grid systems). Defaults to None.\n      to_crs (Optional[str]): output crs, defaults for use in kepler. Defaults to \"EPSG:4326\".\n    \"\"\"\ncreate_local_dir(dir)\npopulations = []\nfor idx, population in enumerate(list_of_populations):\nif population.name is None:\npopulation.name = idx\npopulations.append({\"population_id\": idx, \"population_name\": population.name})\nto_csv(\npopulation=population, dir=os.path.join(dir, population.name), crs=crs, to_crs=to_crs\n)\npd.DataFrame(populations).to_csv(os.path.join(dir, \"populations.csv\"), index=False)\n</code></pre>"},{"location":"api/write/matrices/","title":"pam.write.matrices","text":""},{"location":"api/write/matrices/#pam.write.matrices.write_od_matrices","title":"<code>write_od_matrices(population, path, leg_filter=None, person_filter=None, time_minutes_filter=None)</code>","text":"<p>Write a core population object to tabular O-D weighted matrices.</p> <p>Optionally segment matrices by leg attributes(mode/ purpose), person attributes or specific time periods. A single filter can be applied each time.</p> <p>TODO include freq (assume hh).</p> PARAMETER  DESCRIPTION <code>population</code> <p> TYPE: <code>Population</code> </p> <code>path</code> <p>directory to write OD matrix files</p> <p> TYPE: <code>str</code> </p> <code>leg_filter</code> <p>select between 'Mode', 'Purpose'. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>person_filter</code> <p>select between given attribute categories (column names) from person attribute data. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>time_minutes_filter</code> <p>a list of tuples to slice times, e.g. [(start_of_slicer_1, end_of_slicer_1), (start_of_slicer_2, end_of_slicer_2), ... ]. Defaults to None.</p> <p> TYPE: <code>Optional[List[Tuple[int]]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/write/matrices.py</code> <pre><code>def write_od_matrices(\npopulation: Population,\npath: str,\nleg_filter: Optional[str] = None,\nperson_filter: Optional[str] = None,\ntime_minutes_filter: Optional[List[Tuple[int]]] = None,\n) -&gt; None:\n\"\"\"Write a core population object to tabular O-D weighted matrices.\n    Optionally segment matrices by leg attributes(mode/ purpose), person attributes or specific time periods.\n    A single filter can be applied each time.\n    TODO include freq (assume hh).\n    Args:\n        population (Population):\n        path (str): directory to write OD matrix files\n        leg_filter (Optional[str], optional): select between 'Mode', 'Purpose'. Defaults to None.\n        person_filter (Optional[str], optional): select between given attribute categories (column names) from person attribute data. Defaults to None.\n        time_minutes_filter (Optional[List[Tuple[int]]], optional): a list of tuples to slice times, e.g. [(start_of_slicer_1, end_of_slicer_1), (start_of_slicer_2, end_of_slicer_2), ... ]. Defaults to None.\n    \"\"\"\ncreate_local_dir(path)\nlegs = []\nfor hid, household in population.households.items():\nfor pid, person in household.people.items():\nfor leg in person.legs:\ndata = {\n\"Household ID\": hid,\n\"Person ID\": pid,\n\"Origin\": leg.start_location.area,\n\"Destination\": leg.end_location.area,\n\"Purpose\": leg.purp,\n\"Mode\": leg.mode,\n\"Sequence\": leg.seq,\n\"Start time\": leg.start_time,\n\"End time\": leg.end_time,\n\"Freq\": household.freq,\n}\nif person_filter:\nlegs.append({**data, **person.attributes})\nelse:\nlegs.append(data)\ndf_total = pd.DataFrame(data=legs, columns=[\"Origin\", \"Destination\"]).set_index(\"Origin\")\nmatrix = df_total.pivot_table(\nvalues=\"Destination\", index=\"Origin\", columns=\"Destination\", fill_value=0, aggfunc=len\n)\nmatrix.to_csv(os.path.join(path, \"total_od.csv\"))\ndata_legs = pd.DataFrame(data=legs)\nif leg_filter:\ndata_legs_grouped = data_legs.groupby(leg_filter)\nfor filter, leg in data_legs_grouped:\ndf = pd.DataFrame(data=leg, columns=[\"Origin\", \"Destination\"]).set_index(\"Origin\")\nmatrix = df.pivot_table(\nvalues=\"Destination\",\nindex=\"Origin\",\ncolumns=\"Destination\",\nfill_value=0,\naggfunc=len,\n)\nmatrix.to_csv(os.path.join(path, filter + \"_od.csv\"))\nreturn None\nelif person_filter:\ndata_legs_grouped = data_legs.groupby(person_filter)\nfor filter, leg in data_legs_grouped:\ndf = pd.DataFrame(data=leg, columns=[\"Origin\", \"Destination\"]).set_index(\"Origin\")\nmatrix = df.pivot_table(\nvalues=\"Destination\",\nindex=\"Origin\",\ncolumns=\"Destination\",\nfill_value=0,\naggfunc=len,\n)\nmatrix.to_csv(os.path.join(path, filter + \"_od.csv\"))\nreturn None\nelif time_minutes_filter:\nperiods = []\nfor time in time_minutes_filter:\nperiods.append(time)\nfor start_time, end_time in periods:\nfile_name = str(start_time) + \"_to_\" + str(end_time)\nstart_time = mtdt(start_time)\nend_time = mtdt(end_time)\ndata_time = data_legs[\n(data_legs[\"Start time\"] &gt;= start_time) &amp; (data_legs[\"Start time\"] &lt; end_time)\n]\ndf = pd.DataFrame(data=data_time, columns=[\"Origin\", \"Destination\"]).set_index(\"Origin\")\nmatrix = df.pivot_table(\nvalues=\"Destination\",\nindex=\"Origin\",\ncolumns=\"Destination\",\nfill_value=0,\naggfunc=len,\n)\nmatrix.to_csv(os.path.join(path, \"time_\" + file_name + \"_od.csv\"))\nreturn None\n</code></pre>"},{"location":"api/write/matsim/","title":"pam.write.matsim","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer","title":"<code>Writer(path, household_key='hid', comment=None, keep_non_selected=False, coordinate_reference_system=None)</code>","text":"<p>Context Manager for writing to xml.</p> <p>Designed to handle the boilerplate xml.</p> Example <pre><code>with pam.write.matsim.Writer(PATH) as writer:\nfor hid, household in population:\nwriter.add_hh(household)\n</code></pre> <pre><code>with pam.write.matsim.Writer(OUT_PATH) as writer:\nfor person in pam.read.matsim.stream_matsim_persons(IN_PATH):\npam.samplers.time.apply_jitter_to_plan(person.plan)\nwriter.add_person(household)\n</code></pre> Source code in <code>pam/write/matsim.py</code> <pre><code>def __init__(\nself,\npath: str,\nhousehold_key: Optional[str] = \"hid\",\ncomment: Optional[str] = None,\nkeep_non_selected: bool = False,\ncoordinate_reference_system: str = None,\n) -&gt; None:\nif os.path.dirname(path):\ncreate_local_dir(os.path.dirname(path))\nself.path = path\nself.household_key = household_key\nself.comment = comment\nself.keep_non_selected = keep_non_selected\nself.coordinate_reference_system = coordinate_reference_system\nself.compression = DEFAULT_GZIP_COMPRESSION if is_gzip(path) else 0\nself.xmlfile = None\nself.writer = None\nself.population_writer = None\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.Writer.comment","title":"<code>comment = comment</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.compression","title":"<code>compression = DEFAULT_GZIP_COMPRESSION if is_gzip(path) else 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.coordinate_reference_system","title":"<code>coordinate_reference_system = coordinate_reference_system</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.household_key","title":"<code>household_key = household_key</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.keep_non_selected","title":"<code>keep_non_selected = keep_non_selected</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.path","title":"<code>path = path</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.population_writer","title":"<code>population_writer = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.writer","title":"<code>writer = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.xmlfile","title":"<code>xmlfile = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.add_hh","title":"<code>add_hh(household)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def add_hh(self, household) -&gt; None:\nfor _, person in household:\nif self.household_key is not None:\n# force add hid as an attribute\nperson.attributes[self.household_key] = household.hid\nself.add_person(person)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.Writer.add_person","title":"<code>add_person(person)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def add_person(self, person) -&gt; None:\ne = create_person_element(person.pid, person, self.keep_non_selected)\nself.writer.write(e, pretty_print=True)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.add_attribute","title":"<code>add_attribute(attributes, k, v)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def add_attribute(attributes, k, v):\nif isinstance(v, str):\nattribute = et.SubElement(\nattributes, \"attribute\", {\"class\": \"java.lang.String\", \"name\": str(k)}\n)\nattribute.text = str(v)\nelif isinstance(v, bool):\nattribute = et.SubElement(\nattributes, \"attribute\", {\"class\": \"java.lang.Boolean\", \"name\": str(k)}\n)\nattribute.text = str(v)\nelif isinstance(v, int):\nattribute = et.SubElement(\nattributes, \"attribute\", {\"class\": \"java.lang.Integer\", \"name\": str(k)}\n)\nattribute.text = str(v)\nelif isinstance(v, float):\nattribute = et.SubElement(\nattributes, \"attribute\", {\"class\": \"java.lang.Double\", \"name\": str(k)}\n)\nattribute.text = str(v)\nelif k == \"vehicles\":\nattribute = et.SubElement(\nattributes,\n\"attribute\",\n{\"class\": \"org.matsim.vehicles.PersonVehicles\", \"name\": str(\"vehicles\")},\n)\nattribute.text = str(v).replace(\"'\", '\"')\nelse:\nattribute = et.SubElement(\nattributes, \"attribute\", {\"class\": \"java.lang.String\", \"name\": str(k)}\n)\nattribute.text = str(v)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.create_person_element","title":"<code>create_person_element(pid, person, keep_non_selected=False)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def create_person_element(pid, person, keep_non_selected: bool = False):\nperson_xml = et.Element(\"person\", {\"id\": str(pid)})\nattributes = et.SubElement(person_xml, \"attributes\", {})\nif person.vehicles:\nattribute = et.SubElement(\nattributes,\n\"attribute\",\n{\"class\": \"org.matsim.vehicles.PersonVehicles\", \"name\": \"vehicles\"},\n)\nattribute.text = str({k: v.vid for k, v in person.vehicles.items()}).replace(\"'\", '\"')\nfor k, v in person.attributes.items():\nadd_attribute(attributes, k, v)\nwrite_plan(person_xml, person.plan, selected=True)\nif keep_non_selected:\nfor plan in person.plans_non_selected:\nwrite_plan(person_xml, plan, selected=False)\nreturn person_xml\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.object_attributes_dtd","title":"<code>object_attributes_dtd()</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def object_attributes_dtd():\ndtd_path = importlib_resources.files(\"pam\") / \"fixtures\" / \"dtd\" / \"objectattributes_v1.dtd\"\nreturn et.DTD(dtd_path)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.population_v6_dtd","title":"<code>population_v6_dtd()</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def population_v6_dtd():\ndtd_path = importlib_resources.files(\"pam\") / \"fixtures\" / \"dtd\" / \"population_v6.dtd\"\nreturn et.DTD(dtd_path)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.write_matsim","title":"<code>write_matsim(population, plans_path, attributes_path=None, vehs_path=None, evs_path=None, version=None, comment=None, household_key='hid', keep_non_selected=False, coordinate_reference_system=None)</code>","text":"<p>Write a core population to matsim population v6 xml format. Note that this requires activity locs to be set (shapely.Point).</p> PARAMETER  DESCRIPTION <code>population</code> <p>population to be writen to disk</p> <p> TYPE: <code>Population</code> </p> <code>plans_path</code> <p>output path (.xml or .xml.gz)</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>attributes_path</code> <p>legacy parameter, does not have an effect. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>vehs_path</code> <p>path to output vehicle file. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>evs_path</code> <p>path to output ev file. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>legacy parameter, does not have an effect. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>comment</code> <p>default None, optionally add a comment string to the xml outputs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>household_key</code> <p>optionally add household id to person attributes. Defaults to \"hid\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'hid'</code> </p> <code>keep_non_selected</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>coordinate_reference_system</code> <p>optionally add CRS attribute to xml outputs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>UserWarning</code> <p>If population includes vehicles, <code>vehicles_dir</code> must be defined.</p> Source code in <code>pam/write/matsim.py</code> <pre><code>def write_matsim(\npopulation,\nplans_path: Union[Path, str],\nattributes_path: Optional[Union[Path, str]] = None,\nvehs_path: Optional[Union[Path, str]] = None,\nevs_path: Optional[Union[Path, str]] = None,\nversion: int = None,\ncomment: Optional[str] = None,\nhousehold_key: Optional[str] = \"hid\",\nkeep_non_selected: bool = False,\ncoordinate_reference_system: Optional[str] = None,\n) -&gt; None:\n\"\"\"Write a core population to matsim population v6 xml format.\n    Note that this requires activity locs to be set (shapely.Point).\n    Args:\n        population (Population): population to be writen to disk\n        plans_path (Union[str, Path]): output path (.xml or .xml.gz)\n        attributes_path (Optional[Union[str, Path]], optional): legacy parameter, does not have an effect. Defaults to None.\n        vehs_path (Optional[Union[str, Path]], optional): path to output vehicle file. Defaults to None.\n        evs_path (Optional[Union[str, Path]], optional): path to output ev file. Defaults to None.\n        version (Optional[int], optional): legacy parameter, does not have an effect. Defaults to None.\n        comment (Optional[str], optional): default None, optionally add a comment string to the xml outputs. Defaults to None.\n        household_key (Optional[str], optional): optionally add household id to person attributes. Defaults to \"hid\".\n        keep_non_selected (bool, optional): Defaults to False.\n        coordinate_reference_system (Optional[str], optional): optionally add CRS attribute to xml outputs. Defaults to None.\n    Raises:\n        UserWarning: If population includes vehicles, `vehicles_dir` must be defined.\n    \"\"\"\nif version is not None:\nwarn(\n'parameter \"version\" is no longer supported by write_matsim(), this will be removed in future release.'\n)\nif attributes_path is not None:\nlogging.warning('parameter \"attributes_path\" is no longer supported by write_matsim()')\nif vehs_path is None and evs_path is not None:\nraise UserWarning(\"You must provide a vehs_path in addition to evs_path.\")\nwrite_matsim_population_v6(\npopulation=population,\npath=plans_path,\ncomment=comment,\nhousehold_key=household_key,\nkeep_non_selected=keep_non_selected,\ncoordinate_reference_system=coordinate_reference_system,\n)\n# write vehicles\nif vehs_path is not None:\nlogging.info(\"Building population vehicles output.\")\n# rebuild vehicles output from population\npopulation.rebuild_vehicles_manager()\npopulation._vehicles_manager.to_xml(vehs_path, evs_path)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.write_matsim_population_v6","title":"<code>write_matsim_population_v6(population, path, household_key='hid', comment=None, keep_non_selected=False, coordinate_reference_system=None)</code>","text":"<p>Write matsim population v6 xml (persons plans and attributes combined).</p> PARAMETER  DESCRIPTION <code>population</code> <p>population to be writen to disk</p> <p> TYPE: <code>Population</code> </p> <code>path</code> <p>output path (.xml or .xml.gz)</p> <p> TYPE: <code>str</code> </p> <code>household_key</code> <p>Defaults to \"hid\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'hid'</code> </p> <code>comment</code> <p>optionally add a comment string to the xml outputs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>keep_non_selected</code> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>coordinate_reference_system</code> <p>Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Source code in <code>pam/write/matsim.py</code> <pre><code>def write_matsim_population_v6(\npopulation: Population,\npath: str,\nhousehold_key: Optional[str] = \"hid\",\ncomment: Optional[str] = None,\nkeep_non_selected: bool = False,\ncoordinate_reference_system: str = None,\n) -&gt; None:\n\"\"\"Write matsim population v6 xml (persons plans and attributes combined).\n    Args:\n        population (Population): population to be writen to disk\n        path (str): output path (.xml or .xml.gz)\n        household_key (Optional[str], optional): Defaults to \"hid\".\n        comment (Optional[str], optional): optionally add a comment string to the xml outputs. Defaults to None.\n        keep_non_selected (bool, optional): Defaults to False.\n        coordinate_reference_system (str, optional): Defaults to None.\n    \"\"\"\nwith Writer(\npath=path,\nhousehold_key=household_key,\ncomment=comment,\nkeep_non_selected=keep_non_selected,\ncoordinate_reference_system=coordinate_reference_system,\n) as writer:\nfor _, household in population:\nwriter.add_hh(household)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.write_plan","title":"<code>write_plan(person_xml, plan, selected=None)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def write_plan(person_xml: et.SubElement, plan: Plan, selected: Optional[bool] = None):\nplan_attributes = {}\nif selected is not None:\nplan_attributes[\"selected\"] = {True: \"yes\", False: \"no\"}[selected]\nif plan.score is not None:\nplan_attributes[\"score\"] = str(plan.score)\nplan_xml = et.SubElement(person_xml, \"plan\", plan_attributes)\nfor component in plan:\nif isinstance(component, Activity):\ncomponent.validate_matsim()\nact_data = {\"type\": component.act}\nif component.start_time is not None:\nact_data[\"start_time\"] = dttm(component.start_time)\nif component.end_time is not None:\nact_data[\"end_time\"] = dttm(component.end_time)\nif component.location.link is not None:\nact_data[\"link\"] = str(component.location.link)\nif component.location.x is not None:\nact_data[\"x\"] = str(component.location.x)\nif component.location.y is not None:\nact_data[\"y\"] = str(component.location.y)\net.SubElement(plan_xml, \"activity\", act_data)\nif isinstance(component, Leg):\nleg = et.SubElement(\nplan_xml, \"leg\", {\"mode\": component.mode, \"trav_time\": tdtm(component.duration)}\n)\nif component.attributes:\nattributes = et.SubElement(leg, \"attributes\")\nfor k, v in component.attributes.items():\nif (\nk == \"enterVehicleTime\"\n):  # todo make something more robust for future 'special' classes\nattribute = et.SubElement(\nattributes, \"attribute\", {\"class\": \"java.lang.Double\", \"name\": str(k)}\n)\nattribute.text = str(v)\nelse:\nadd_attribute(attributes, k, v)\nif component.route.exists:\nleg.append(component.route.xml)\n</code></pre>"}]}