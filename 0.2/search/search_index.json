{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Population Activity Modeller (PAM)","text":"<p>PAM is a python API for activity sequence modelling. Primary features:</p> <ul> <li>common format read/write including MATSim xml</li> <li>sequence inference from travel diary data</li> <li>rules based sequence modification</li> <li>sequence visualisation</li> <li>facility sampling</li> <li>research extensions</li> </ul> <p>PAM was originally called the \"Pandemic Activity Modifier\". It was built in response to COVID-19, to better and more quickly update models for behaviour changes from lockdown policies than existing aggregate models.</p> <p></p> <p>Who is this for? PAM is intended for use by any modeller or planner using trip diary data or activity plans. What can this do? PAM provides an API and examples for modifying activity plans, for example, based on COVID-19 lockdown scenarios.</p> <p>You can read about PAM on medium here.</p>"},{"location":"#features","title":"Features","text":"<p>This project is not a new activity model. Instead it to seeks to adjust existing activity representations, already derived from exiting models or survey data:</p> <p></p> <p>(i) Read/Load input data (eg travel diary) to household and person Activity Plans.</p> <p>(ii) Modify the Activity Plans for new social and government policy scenarios (e.g. remove education activities for non key worker households). Crucially PAM facilitates application of detailed policies at the person and household level, while still respecting the logic of arbitrarily complex activity chains.</p> <p>(iii) Output to useful formats for activity based models or regular transport models. Facilitate preliminary Analysis and Validation of changes.</p> <p>This work is primarily intended for transport modellers, to make quick transport demand scenarios. But it may also be useful for other activity based demand modelling such as for goods supply or utility demand.</p>"},{"location":"#why-activity-plans","title":"Why Activity Plans?","text":"<ol> <li> <p>They are the ideal mechanism for applying changes, allowing for example, consideration of joint dis-aggregate features across an entire day.</p> </li> <li> <p>They can be post processed for many other output formats such as origin-destination matrices or activity diaries. These outputs can the be used in many different applications such as transport, utility demand, social impact and so on.</p> </li> </ol>"},{"location":"activity_plans/","title":"Activity Plans","text":"<p>PAM supports arbitrarily complex chains of activities connected by 'legs' (these are equivalent to 'trips'). The main rules are (i) that plans must consist of sequences of alternate <code>pam.activity.Activity</code> and <code>pam.activity.Leg</code> objects and (ii) that a plan must start and end with an <code>Activity</code>:</p> <pre><code>from pam.core import Person\nfrom pam.activity import Leg, Activity\nfrom pam\n\nperson = Person('Tony', attributes = {'age': 9, 'phylosophy': 'stoicism'})\n\nperson.add(\n    Activity(\n        act='home',\n        area='zone A',\n    )\n)\n\nperson.add(\n    Leg(\n        mode='car',\n        start_time=utils.parse_time(600),  # (minutes)\n        end_time=utils.parse_time(630),\n    )\n)\n\nperson.add(\n    Activity(\n        act='work',\n        area='zone B',\n        )\n    )\n\nperson.add(\n    Leg(\n        mode='car',\n        start_time=utils.parse_time(1800),\n        end_time=utils.parse_time(1830),\n    )\n)\n\n# Continue adding Activities and Legs alternately.\n# A sequence must start and end with an activity.\n# ...\n\nperson.add(\n    Activity(\n        act='home',\n        area='zone B'\n    )\n)\n\nactivities = list(person.plan.activities)\ntrips = list(person.plan.legs)\n\nperson.print()\n</code></pre>"},{"location":"activity_plans/#how-travel-diaries-relate-to-activity-plans","title":"How travel diaries relate to activity plans","text":"<p>A key component of this project is the conversion of Travel Diaries to Activity Plans. We define a Travel Diary as a sequence of travel legs from zone to zone for a given purpose over a single day. The Activity Plan takes these legs and infers the activity types between. Example activity types are <code>home</code>, <code>work</code>, <code>education</code>, <code>excort_education</code> and so on.</p> <p>Activity Plan chains can be pretty complex, consider for example a business person attending meetings in many different locations and stopping to eat and shop. We always require the plan to last 24 hours and start and stop with an activity. We like these start and stop activities to both be the same and ideally <code>home</code>. We think of this as 'looping', but they don't have to. Night shift workers, for example, do not start or end the day at <code>home</code>.</p> <p>When we try to infer activity purpose from trip purpose, we expect a return trip to have the same purpose as the outbound trip, e.g.:</p> <p>trip1(work) + trip2(work) --&gt; activity1(home) + activity2(work) + activity3(home)</p> <p>But this logic is hard to follow for more complex chains, eg:</p> <p>trip1(work) + trip2(shop) + trip3(work) --&gt; activity1(home) + activity2(work) + activity3(shop) + activity4(home)</p> <p>The test cases in <code>test_3_parse_challenge</code> capture some of the difficult and edge cases observed so far.</p> <p>It is important to note that as a consequence of encoding outbound and return purpose as an activity, we never observe a trip purpose as <code>home</code>. Luckily we do know the home area from the travel diary data (<code>hzone</code>). But have to be careful with our logic, as travel between different activities locations can be intra-zonal, e.g.:</p> <p>activity1(home, zoneA) + activity2(shop, zoneA) + activity2(shop, zoneA)</p> <p>Activity Plans are represented in this project as regular python <code>lists()</code>, containing ordered <code>activity.Activity</code> and <code>activity.Leg</code> objects. Plans must start and end with a <code>activity.Activity</code>. Two <code>activity.Actvity</code> objects must be seperated by a <code>core.Leg</code>.</p> <p>Plans belong to <code>core.People</code> which belong to <code>core.Households</code> which belong to a <code>core.Population</code>. For example:</p> <pre><code>from pam.core import Population, Household, Person\nfrom pam.activity import Activity, Leg\n\npopulation = Population()  # init\nhousehold = HouseHold(hid=1)  # hid is household id\nperson = Person(pid=1)  # pid is person id\nperson.add(\n    Activity(seq=1, act='home', area='a', start_time=0, end_time=450)  # time in minutes\n)\nperson.add(\n    Leg(seq=1, mode='car', start_area='a', end_area='b', start_time=450, end_time=480)\n)\nperson.add(\n    Activity(2, 'work', 'b', 480, 880)\n)\nperson.add(\n    Leg(2, 'car', 'b', 'a', 880, 900)\n)\nperson.add(\n    Activity(3, 'home', 'a', 900, 24*60-1)  # last activity must end at 23:59(:59)\n)\nhousehold.add(person)\npopulation.add(household)\n</code></pre>"},{"location":"activity_plans/#a-note-on-the-pain-of-wrapping","title":"A note on the pain of wrapping","text":"<p>Activity Plans often enforce that a plan returns to the same activity (type and location) that they started at. Furthermore they sometimes enforce that this activity be <code>home</code>. Such plans can be thought of as wrapping plans. Where the last and first activity can be though of as linked. This need not be a <code>home</code> activity, for example in the case of night workers.</p> <p>We have encountered many variations of sequences for plans, including wrapping and wrapping. Although they are generally edge cases, they exists and generally represent real people. We are therefore endeavoring to support all these cases in our plan modifiers. This is resulting some difficult to follow logic (eg <code>pam.activity.Plan.fill_plan()</code>).</p>"},{"location":"activity_plans/#plan-cropping","title":"Plan cropping","text":"<p>The <code>pam.cropping</code> module allows to spatially subset populations, by simplifying plan components that take place outside the \"core\" area. Any activities or legs that do not affect that core area are removed from the agents' plans, and agents with fully-external plans are removed from the population. Examples of using the module can be found in the <code>18_plan_cropping.ipynb</code> notebook.</p>"},{"location":"get_involved/","title":"Get involved","text":"<p>Our goals:</p> <ul> <li>Theoretical Quality: Expert driven features with research and open case studies.</li> <li>Feature Quality: Broadly useful and extendable features with good documentation and some testing.</li> </ul> <p>Less abstractly, there are a good number of coding and non-coding tasks to chip in with:</p>"},{"location":"get_involved/#give-feedback","title":"Give feedback","text":"<p>Read through this document, let us know what you think, share. Feedback gladly received as an issue, on slack or you can email fred.shone@arup.com.</p>"},{"location":"get_involved/#literature-review","title":"Literature review","text":"<p>We still need validation of the overall approach. Much of the methodology (detailed in this document) is based on what can pragmatically be done, not what theoretically should be done. We'd appreciate links to relevant papers. Or even better we'd love a lit review - we'll add it to this document.</p>"},{"location":"get_involved/#research","title":"Research","text":"<p>We need help with designing useful features, applying them to real problems. As part of this we need:</p>"},{"location":"get_involved/#evidence-and-data-for-validation","title":"Evidence and data for validation","text":"<p>We know, for example, that many people have removed certain activities from their daily plans, such as to school or university. But we don't know how many. We'd like help finding and eventually applying validation data such as recent change in mobility.</p>"},{"location":"get_involved/#evidence-for-new-features","title":"Evidence for new features","text":"<p>We currently support the following activity plan modifications:</p> <ul> <li>probabilistic removal of all activities, i.e., full quarantine or isolation</li> <li>probabilistic removal of specific activities, i.e., education</li> <li>automatic extension of other (typically staying at home) activities</li> </ul> <p>But we'd like help to find evidence for other modifications that we think are occurring:</p> <ul> <li>changing duration of an activity</li> <li>moving activity closer to home, i.e., shopping trips</li> <li>changing travel choice, i.e., mode</li> <li>moving home location (i.e., national and local emigration)</li> <li>household shared activities/no longer shared activities, such as leisure</li> <li>defining key workers</li> </ul>"},{"location":"get_involved/#evidence-for-technical-methodology","title":"Evidence for technical methodology","text":"<p>Modifying a plan to remove an activity can cascade into other changes. In the case of people with complex chains of activities, the removal of a single activity requires adjustments to the remainder. Do people leave later of earlier if they have more time for example? The methods for this logic is in <code>pam.core.People</code>.</p>"},{"location":"get_involved/#develop","title":"Develop","text":""},{"location":"get_involved/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>If you have followed the recommended installation instructions, all libraries required for development and quality assurance will already be installed. If installing directly with pip, you can install these libraries using the <code>dev</code> option, i.e., <code>pip install -e ./pam[dev]</code></p> <p>If you plan to make changes to the code then please make regular use of the following tools to verify the codebase while you work:</p> <ul> <li><code>pre-commit</code>: run <code>pre-commit install</code> in your command line to load inbuilt checks that will run every time you commit your changes. The checks are: 1. check no large files have been staged, 2. lint python files for major errors, 3. format python files to conform with the pep8 standard. You can also run these checks yourself at any time to ensure staged changes are clean by simple calling <code>pre-commit</code>.</li> <li><code>pytest</code> - run the unit test suite, check test coverage, and test that the example notebooks successfully run.</li> </ul>"},{"location":"get_involved/#contributing","title":"Contributing","text":"<p>To find beginner-friendly existing bugs and feature requests you may like to have a crack at, take a look here.</p> <p>We maintain a backlog of issues, please in touch if you would like to contribute - or raise your own issue.</p> <p>We need help to go faster. We expect to deal with populations in the tens of millions. We would like help with profiling and implementing parallel compute.</p> <p>If you want to dive deeper into development, we recommend you get in touch with us by joining our slack channel.</p>"},{"location":"get_involved/#use-cases","title":"Use cases","text":"<p>We will share open and dummy data where available, we would love people to do some experiments and develop some viz and validation pipelines. Any example notebooks can be added to the example notebooks.</p>"},{"location":"installation/","title":"Installation","text":"<p>It is easiest to install PAM using a mamba environment, as follows:</p> <ol> <li>Install mamba with the [Mambaforge] executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Download (a.k.a., clone) the PAM respository: <code>git clone git@github.com:arup-group/pam.git</code></li> <li>Create the PAM mamba environment: <code>mamba env create -f pam/environment.yml</code></li> <li>Activate the PAM mamba environment: <code>mamba activate pam</code></li> <li>Install the PAM package into the environment, in editible mode and ignoring dependencies (we have dealt with those when creating the mamba environment): <code>pip install --no-deps -e ./pam</code></li> </ol> <p>All together:</p> <pre><code>git clone git@github.com:arup-group/pam.git\nmamba env create -f pam/environment.yml\nmamba activate pam\npip install --no-deps -e ./pam\n</code></pre> <p>We do not recommend trying to install PAM directly with pip (e.g. in a virtual environment) as you need to first install underlying native geospatial libraries, the method for which differs by operating system. If you choose to install into a virtual environment, ensure you have <code>libgdal</code> and <code>libspatialindex</code> installed on your device before installing with pip. </p>"},{"location":"installation/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>For installation instructions specific to developing the PAM codebase, see here</p>"},{"location":"modelling_policy_impact/","title":"Modelling the impact of policies on populations","text":"<p>PAM uses policies to model change to a population. For example, based on social distancing requirements we might want to reflect that people are expected to make less shared shopping trips or tours. We can do this using the following policy: <pre><code>policy_reduce_shopping_activities = HouseholdPolicy(\n        ReduceSharedActivity(['shop', 'shop_food']),\n        ActivityProbability(['shop', 'shop_food'], 1)\n)\n</code></pre> if you want to define the policy from first principles. There exists a convenience class for this policy and an equivalent policy can be defined in the following way: <pre><code>policy_reduce_shopping_activities = ReduceSharedHouseholdActivities(\n        ['shop', 'shop_food'],\n        ActivityProbability(['shop', 'shop_food'], 1)\n)\n</code></pre> This policy removes all but one the household's shared shopping tours:</p> <p></p> <p>In general, a policy is defined in the following way:</p> <ul> <li>You first select the level at which is should be applied:<ul> <li><code>HouseholdPolicy</code></li> <li><code>PersonPolicy</code></li> <li><code>ActivityPolicy</code></li> </ul> </li> <li>You then select the modifier, which performs the actions to a person's activities<ul> <li><code>RemoveActivity</code></li> <li><code>ReduceSharedActivity</code></li> <li><code>MoveActivityTourToHomeLocation</code></li> </ul> </li> <li>Finally, you give a likelihood value with which the policy should be applied with. You have a few choices here:<ul> <li>a number greater than 0 and less or equal to 1. This will be understood to be at the level at which the policy is applied.<ul> <li>E.g. <code>PersonPolicy(RemoveActivity(['work']), 0.5)</code> will give each person a fifty-fifty chance of having their work activities removed.</li> </ul> </li> <li>you can explicitly define at which level a number greater than 0 and less or equal to 1 will be applied by passing:<ul> <li>E.g. <code>HouseholdPolicy(RemoveActivity(['work']), PersonProbability(0.5))</code> will apply a probability of 0.5 per person in a household, and apply the policy to all persons within a household if selected.</li> </ul> </li> <li>you can also pass a function that operates on a <code>core.Household</code>, <code>core.Person</code> or <code>core.Activity</code> object and returns a number between 0 and 1.<ul> <li>E.g. if <pre><code>def sampler(person):\n    if person.attributes['key_worker'] == True:\n        return 0\n    else:\n        return 1\n</code></pre> we can define <code>PersonPolicy(RemoveActivity(['work']), PersonProbability(sampler))</code> which will remove all work activities from anyone who is not a 'key_worker'</li> </ul> </li> <li>you can choose from:<ul> <li><code>HouseholdProbability</code></li> <li><code>PersonProbability</code></li> <li><code>ActivityProbability</code></li> </ul> </li> </ul> </li> </ul> <p>PAM allows multiple of such policies to be combined to build realistic and complex scenarios. Leveraging activity plans means that PAM can implement detailed policies that are dependant on:</p> <ul> <li>person attributes</li> <li>household attributes</li> <li>activity types</li> <li>travel modes</li> <li>times</li> <li>spatial locations</li> <li>sequences such as tours</li> <li>any combination of the above</li> </ul> <p>A full overview of policies and examples of the policies available are detailed in this notebook.</p>"},{"location":"modelling_policy_impact/#example-modifierspolicies","title":"Example modifiers/policies:","text":""},{"location":"modelling_policy_impact/#ill-and-self-quarantined","title":"Ill and self-quarantined","text":"<ul> <li>Person quarantine based on age</li> <li>Household quarantine based on household members</li> </ul>"},{"location":"modelling_policy_impact/#education-activities","title":"Education activities","text":"<p>Remove or reduce education based tours/trips including escorts:</p> <ul> <li>Remove education activities based on age</li> <li>Maintain education for 'care-constrained' households (critical workers)</li> </ul>"},{"location":"modelling_policy_impact/#work-activities","title":"Work activities","text":"<ul> <li>Furlough and unemployment based on sector</li> <li>Work from home based on sector</li> <li>Increase or reduce activities and activity durations based on sector</li> </ul>"},{"location":"modelling_policy_impact/#shopping-activities","title":"Shopping activities","text":"<ul> <li>Remove or reduce discretionary shopping</li> <li>Reduce food shopping</li> <li>Remove shared tours</li> <li>Move tours closer to home</li> </ul>"},{"location":"modelling_policy_impact/#discretionary-activities","title":"Discretionary activities","text":"<ul> <li>Remove or reduce discretionary activities such as leisure</li> <li>Move tours closer to home</li> </ul>"},{"location":"modelling_policy_impact/#in-progress-modifierspolicies","title":"In-progress modifiers/policies","text":"<p>Logic also be added to apply:</p> <ul> <li>mode shift</li> <li>location shift</li> <li>times</li> <li>durations</li> </ul>"},{"location":"read_data/","title":"Reading data","text":""},{"location":"read_data/#populations","title":"Populations","text":"<p>We have some read methods for common input data formats - but first let's take a quick look at the core pam data structure for populations:</p> <pre><code>from pam.core import Population, Household, Person\n\npopulation = Population()  # initialise an empty population\n\nhousehold = Household('hid0', attributes = {'struct': 'A', 'dogs': 2, ...})\npopulation.add(household)\n\nperson = Person('pid0', attributes = {'age': 33, 'height': 'tall', ...})\nhousehold.add(person)\n\nperson = Person('pid1', attributes = {'age': 35, 'cats_or_dogs?': 'dogs', ...})\nhousehold.add(person)\n\npopulation.print()\n</code></pre>"},{"location":"read_data/#read-methods","title":"Read methods","text":"<p>The first step in any application is to load your data into the core pam format (pam.core.Population). We are trying to support comon tabular formats ('travel diaries') using <code>pam.read.load_travel_diary</code>. A travel diary can be composed of three tables:</p> <ul> <li><code>trips</code> (required) -  a trip diary for all people in the population, with rows representing trips</li> <li><code>persons_attributes</code> (optional) - optionally include persons attributes (eg: <code>person income</code>)</li> <li><code>households_attributes</code> (optional) - optionally include households attributes (eg: <code>hh number of cars</code>)</li> </ul> <p>The input tables are expected as pandas.DataFrame, eg: <pre><code>import pandas as pd\nimport pam\n\ntrips_df = pd.read_csv(trips.csv)\npersons_df = pd.read_csv(persons.csv)\n\n# Fix headers and wrangle as required\n# ...\n\npopulation = pam.read.load_travel_diary(\n    trips = trips_df,\n    persons_attributes = persons_df,\n    hhs_attributes = None,\n    )\n\nprint(population.stats)\n\nexample_person = population.random_person\nexample_person.print()\nexample_person.plot()\n</code></pre></p> <p>PAM requires tabular inputs to follow a basic structure. Rows in the <code>trips</code> dataframe represent unique trips by all persons, rows in the <code>persons_attributes</code> dataframe represent unique persons and rows in the <code>hhs_attributes</code> dataframe represent unique households. Fields named <code>pid</code> (person ID) and <code>hid</code> (household ID) are used to provide unique identifiers to people and households.</p> <p>Trips Input:</p> <p>eg:</p> pid hid seq hzone ozone dzone purp mode tst tet freq 0 0 0 Harrow Harrow Camden work pt 444 473 4.54 0 0 1 Harrow Camden Harrow home pt 890 919 4.54 1 0 0 Harrow Harrow Tower Hamlets work car 507 528 2.2 1 0 1 Harrow Tower Hamlets Harrow home car 1065 1086 2.2 2 1 0 Islington Islington Hackney shop pt 422 425 12.33 2 1 1 Islington Hackney Hackney leisure walk 485 500 12.33 2 1 2 Islington Croydon Islington home pt 560 580 12.33 <p>A <code>trips</code> table is composed of rows representing unique trips for all persons in the population. Trips must be correctly ordered according to their sequence unless a numeric <code>seq</code> (trip sequence) field is provided, in which case trips will be ordered accordingly for each person.</p> <p>The <code>trips</code> input must include the following fields: - <code>pid</code> - person ID, used as a unique identifier to associate trips belonging to the same person and to join trips with person attributes if provided. - <code>ozone</code> - trip origin zone ID - <code>dzone</code> - trip destination zone ID - <code>mode</code> - trip mode - note that lower case strings are enforced - <code>tst</code> - trip start time in minutes (integer) or a datetime string (eg: \"2020-01-01 14:00:00\") - <code>tet</code> - trip end time in minutes (integer) or a datetime string (eg: \"2020-01-01 14:00:00\")</p> <p>The <code>trips</code> input must either: - <code>purp</code> - trip or tour purpose, eg 'work' - <code>oact</code> and <code>dact</code> - origin activity type and destination activity type, eg 'home' and 'work'</p> <p>Note that lower case strings are enforced and that 'home' activities should be encoded as <code>home</code>.</p> <p>The <code>trips</code> input may also include the following fields: - <code>hid</code> - household ID, used as a unique identifier to associate persons belonging to the same household and to join with household attributes if provided - <code>freq</code> - trip weighting for representative population - <code>seq</code> - trip sequence number, if omitted pam will assume that trips are already ordered - <code>hzone</code> - household zone</p> <p>'trip purpose' vs 'tour purpose':</p> <p>We've encountered a few different ways that trip purpose can be encoded. The preferred way being to encode a trip purpose as being the activity of the destination, so that a trip home would be encoded as <code>purp = home</code>. However we've also seen the more complex 'tour purpose' encoding, in which case a return trip from work to home is encoded as <code>purp = work</code>. Good news is that the <code>pam.read.load_travel_diary</code> will deal ok with either. But it's worth checking.</p> <p>Using persons_attributes and /or households_attributes</p> <p>eg:</p> <p><code>persons.csv</code></p> pid hid hzone freq income age driver cats or dogs 0 0 Harrow 10.47 high high yes dogs 1 0 Harrow 0.034 low medium no dogs 2 1 Islington 8.9 medium low yes dogs <p><code>households.csv</code></p> hid hzone freq persons cars 0 Harrow 10.47 2 1 1 Islington 0.034 1 1 <p>If you are using persons_attributes (<code>persons_attributes</code>) this table must contain a <code>pid</code> field (person ID). If you are using persons_attributes (<code>households_attributes</code>) this table must contain a <code>hid</code> field (household ID). In both cases, the frequency field <code>freq</code> may be used. All other attributes can be included with column names to suit the attribute. Note that <code>hzone</code> (home zone) can optionally be provided in the attribute tables.</p> <p>A note about 'freq':</p> <p>Frequencies (aka 'weights') for trips, persons or households can optionally be added to the respective input tables using columns called <code>freq</code>. We generally assume a frequency to represent expected occurances in a full population. For example if we use a person frequency (<code>person.freq</code>) the the sum of all these frequencies (<code>population.size</code>), will equal the expected population size.</p> <p>Because it is quite common to provide a person or household <code>freq</code> in the trips table, there are two special options (<code>trip_freq_as_person_freq = True</code> and <code>trip_freq_as_hh_freq = True</code>) that can be used to pass the <code>freq</code> field from the trips table to either the people or households table instead.</p> <p>Generally PAM will assume when you want some weighted output, that it should use household frequencies. If these have not been set then PAM will assume that the household frequency is the average frequency of persons within the household. If person frequencies are not set the PAM will assume that the person frequency is the average frequency of legs within the persons plan. If you wish to adjust frequencies of a population then you should use the <code>set_freq()</code> method, eg:</p> <pre><code>factor = 1.2\nhousehold.set_freq(household.freq * factor)\nfor pid, person in household:\n    person.set_freq(person.freq * factor)\n</code></pre>"},{"location":"read_data/#readwriteother-formats","title":"Read/Write/Other formats","text":"<p>PAM can read/write to tabular formats and MATSim xml (<code>pam.read.read_matsim</code> and <code>pam.write.write_matsim</code>). PAM can also write to segmented OD matrices using <code>pam.write.write_od_matrices</code>.</p> <p>Benchmark or summary data and cross-tabulations can be extracted with the <code>pam.write.write_benchmarks</code> method, passing as arguments the data field(s) to summarise, the dimension(s) to group by, and the aggregation function(s). For example <code>pam.write_benchmarks(population, dimensions = ['duration_category'], data_fields= ['freq'], aggfunc = [sum]</code> returns the frequency breakdown of trips' duration. The <code>write</code> module also provides a number of wrappers for frequently-used bechmarks under the <code>write_*****_benchmark</code> name.</p> <p>Please get in touch if you would like additional support or feel free to add your own.</p>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"api/cli/#examples","title":"Examples","text":"<ul> <li>to get a summary or a MATSim plans file: <code>pam report summary tests/test_data/test_matsim_plansv12.xml</code>.</li> <li>plan cropping: <code>pam crop &lt;path_population_xml&gt; &lt;path_core_area_geojson&gt; &lt;path_output_directory&gt;</code>.</li> <li>down/up-sampling an xml population: <code>pam sample &lt;path_population_xml&gt; &lt;path_output_directory&gt; -s &lt;sample_percentage&gt; -v &lt;matsim_version&gt;</code>. For example, you can use: <code>pam sample tests/test_data/test_matsim_plansv12.xml tests/test_data/output/sampled -s 0.1</code> to create a downsampled (to 10%) version of the input (<code>test_matsim_plansv12.xml</code>) population.</li> <li>combining populations: <code>pam combine &lt;input_population_1&gt; &lt;input_population_2&gt; &lt;input_population_3...etc&gt; -o &lt;outpath_directory&gt; -m &lt;comment&gt; -v &lt;matsim_version&gt;</code>.</li> </ul>"},{"location":"api/cli/#pam","title":"pam","text":"<p>Population Activity Modeller (PAM) Command Line Tool</p> <p>Usage:</p> <pre><code>pam [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-combine","title":"pam combine","text":"<p>Combine multiple populations (e.g. household, freight.. etc).</p> <p>Usage:</p> <pre><code>pam combine [OPTIONS] [POPULATION_PATHS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--population_output</code>, <code>-o</code> path Specify outpath for combined_population.xml, default is cwd <code>combined_population.xml</code> <code>--force</code>, <code>-f</code> boolean Forces overwrite of existing file. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-crop","title":"pam crop","text":"<p>Crop a population's plans outside a core area.</p> <p>Usage:</p> <pre><code>pam crop [OPTIONS] PATH_POPULATION_INPUT PATH_BOUNDARY DIR_POPULATION_OUTPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--buffer</code>, <code>-b</code> integer A buffer distance to (optionally) apply to the core area shapefile. <code>0</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report","title":"pam report","text":"<p>Various reporting for MATSim formatted plans.</p> <p>Usage:</p> <pre><code>pam report [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report-benchmarks","title":"pam report benchmarks","text":"<p>Write batch of benchmarks to directory</p> <p>Usage:</p> <pre><code>pam report benchmarks [OPTIONS] POPULATION_INPUT_PATH OUTPUT_DIRECTORY\n</code></pre> <p>Options:</p> Name Type Description Default <code>--sample_size</code>, <code>-s</code> float Input sample size. Default 1. Required for downsampled populations. eg, use 0.1 for a 10% input population. <code>1</code> <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report-stringify","title":"pam report stringify","text":"<p>ASCII plot activity plans to terminal.</p> <p>Usage:</p> <pre><code>pam report stringify [OPTIONS] PATH_POPULATION_INPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>--colour</code> / <code>--bw</code> boolean Choose a colour or grey-scale (bw) output, default 'colour' <code>True</code> <code>--width</code>, <code>-w</code> integer Target character width for plot, default 72 <code>72</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to crop. <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-report-summary","title":"pam report summary","text":"<p>Summarise a population.</p> <p>Usage:</p> <pre><code>pam report summary [OPTIONS] PATH_POPULATION_INPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--sample_size</code>, <code>-s</code> float Input sample size. Default 1. For example, use 0.1 to apply a 10% weighting to the input population. <code>1</code> <code>--attribute_key</code>, <code>-k</code> text Optional population attribute key to segment output, eg 'subpopulation'. None <code>--rich</code> / <code>--text</code> boolean Formatted (for terminal) or regular text output (for .txt). <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-sample","title":"pam sample","text":"<p>Down- or up-sample a PAM population.</p> <p>Usage:</p> <pre><code>pam sample [OPTIONS] PATH_POPULATION_INPUT DIR_POPULATION_OUTPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--sample_size</code>, <code>-s</code> text The sample size, eg, use 0.1 to produce a 10% version of the input population. None <code>--household_key</code>, <code>-h</code> text Household key, defaults to 'hid'. <code>hid</code> <code>--seed</code> text Random seed. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-wipe-all-links","title":"pam wipe-all-links","text":"<p>Clear all link information from agent plans. Including routes and activity locations.</p> <p>Usage:</p> <pre><code>pam wipe-all-links [OPTIONS] PATH_POPULATION_INPUT PATH_POPULATION_OUTPUT\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#pam-wipe-links","title":"pam wipe-links","text":"<p>Clear selected link information from agent plans. Includes routes and activity locations.</p> <p>eg: <code>pam wipe-links INPUT_PLANS.xml OUTPUT_PLANS.xml link_a link_b link_c</code></p> <p>Usage:</p> <pre><code>pam wipe-links [OPTIONS] PATH_POPULATION_INPUT PATH_POPULATION_OUTPUT\n               [LINKS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-d</code>, <code>--debug</code> boolean Switch on debug verbosity. <code>False</code> <code>--keep_non_selected</code> / <code>--selected_only</code> boolean Optionally keep (read and write) non selected plans. <code>False</code> <code>--leg_route</code> / <code>--no_leg_route</code> boolean Optionally turn off reading of leg_route. <code>True</code> <code>--leg_attributes</code> / <code>--no_leg_attributes</code> boolean Optionally turn of reading of leg_attributes. <code>True</code> <code>--crop</code> / <code>--no_crop</code> boolean Crop or don't crop plans to 24 hours, defaults to no_crop. <code>False</code> <code>--autocomplete</code> / <code>--no_autocomplete</code> boolean Optionally turn off autocomplete, not recommended. <code>True</code> <code>--simplify_pt_trips</code> boolean Optionally simplify transit legs into single trip. <code>False</code> <code>--household_key</code>, <code>-h</code> text Household key, such as 'hid', default None. None <code>--matsim_version</code>, <code>-v</code> integer MATSim plan format, default 12. <code>12</code> <code>--comment</code>, <code>-c</code> text A comment included in the output population. `` <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/","title":"Example Ingest NTS Diaries","text":"In\u00a0[1]: Copied! <pre>use_dummy_data = True\n</pre> use_dummy_data = True In\u00a0[2]: Copied! <pre>import pandas as pd\nimport numpy as np\nimport geopandas as gp\nimport os\nfrom matplotlib import pyplot as plt\n</pre> import pandas as pd import numpy as np import geopandas as gp import os from matplotlib import pyplot as plt In\u00a0[3]: Copied! <pre>out_dir = '../outputs'  # outputs are writen here\n\n# required inputs from the National Travel Survey\nif use_dummy_data:\n    households_csv = './data/dummyNTS/householdeul2017.tab'\n    individuals_csv = './data/dummyNTS/individualeul2017.tab'\n    trips_csv ='./data/dummyNTS/tripeul2017.tab'\n\nelse:\n    households_csv = '~/Data/UKDA-5340-tab/tab/householdeul2017.tab'\n    individuals_csv = '~/Data/UKDA-5340-tab/tab/individualeul2017.tab'\n    trips_csv ='~/Data/UKDA-5340-tab/tab/tripeul2017.tab'\n</pre> out_dir = '../outputs'  # outputs are writen here  # required inputs from the National Travel Survey if use_dummy_data:     households_csv = './data/dummyNTS/householdeul2017.tab'     individuals_csv = './data/dummyNTS/individualeul2017.tab'     trips_csv ='./data/dummyNTS/tripeul2017.tab'  else:     households_csv = '~/Data/UKDA-5340-tab/tab/householdeul2017.tab'     individuals_csv = '~/Data/UKDA-5340-tab/tab/individualeul2017.tab'     trips_csv ='~/Data/UKDA-5340-tab/tab/tripeul2017.tab'  In\u00a0[4]: Copied! <pre>hh_in = pd.read_csv(\n    households_csv,\n    sep='\\t',\n    usecols=['HouseholdID', 'SurveyYear', 'PSUID', 'W2', 'OutCom_B02ID',\n       'HHIncome2002_B02ID', 'AddressType_B01ID', 'Ten1_B02ID',\n       'Landlord_B01ID', 'ResLength_B01ID', 'HHoldCountry_B01ID',\n       'HHoldGOR_B02ID', 'HHoldNumAdults', 'HHoldNumChildren',\n       'HHoldNumPeople', 'HHoldStruct_B02ID', 'NumLicHolders',\n       'HHoldEmploy_B01ID', 'NumVehicles', 'NumBike', 'NumCar', 'NumMCycle',\n       'NumVanLorry', 'NumCarVan', 'WalkBus_B01ID', 'Getbus_B01ID',\n       'WalkRail_B01ID', 'WalkRailAlt_B01ID',\n       'HRPWorkStat_B02ID', 'HRPSEGWorkStat_B01ID', 'HHoldOAClass2011_B03ID',\n       'Settlement2011EW_B03ID', 'Settlement2011EW_B04ID'],\n)\n\nhh_in.HHIncome2002_B02ID = pd.to_numeric(hh_in.HHIncome2002_B02ID, errors='coerce')\nhh_in.NumLicHolders = pd.to_numeric(hh_in.NumLicHolders, errors='coerce')\nhh_in.NumVehicles = pd.to_numeric(hh_in.NumVehicles, errors='coerce')\nhh_in.NumCar = pd.to_numeric(hh_in.NumCar, errors='coerce')\nhh_in.NumMCycle = pd.to_numeric(hh_in.NumMCycle, errors='coerce')\nhh_in.NumVanLorry = pd.to_numeric(hh_in.NumVanLorry, errors='coerce')\nhh_in.NumCarVan = pd.to_numeric(hh_in.NumCarVan, errors='coerce')\nhh_in.Settlement2011EW_B04ID = pd.to_numeric(hh_in.Settlement2011EW_B04ID, errors='coerce')\n\nhh_in.head()\n</pre> hh_in = pd.read_csv(     households_csv,     sep='\\t',     usecols=['HouseholdID', 'SurveyYear', 'PSUID', 'W2', 'OutCom_B02ID',        'HHIncome2002_B02ID', 'AddressType_B01ID', 'Ten1_B02ID',        'Landlord_B01ID', 'ResLength_B01ID', 'HHoldCountry_B01ID',        'HHoldGOR_B02ID', 'HHoldNumAdults', 'HHoldNumChildren',        'HHoldNumPeople', 'HHoldStruct_B02ID', 'NumLicHolders',        'HHoldEmploy_B01ID', 'NumVehicles', 'NumBike', 'NumCar', 'NumMCycle',        'NumVanLorry', 'NumCarVan', 'WalkBus_B01ID', 'Getbus_B01ID',        'WalkRail_B01ID', 'WalkRailAlt_B01ID',        'HRPWorkStat_B02ID', 'HRPSEGWorkStat_B01ID', 'HHoldOAClass2011_B03ID',        'Settlement2011EW_B03ID', 'Settlement2011EW_B04ID'], )  hh_in.HHIncome2002_B02ID = pd.to_numeric(hh_in.HHIncome2002_B02ID, errors='coerce') hh_in.NumLicHolders = pd.to_numeric(hh_in.NumLicHolders, errors='coerce') hh_in.NumVehicles = pd.to_numeric(hh_in.NumVehicles, errors='coerce') hh_in.NumCar = pd.to_numeric(hh_in.NumCar, errors='coerce') hh_in.NumMCycle = pd.to_numeric(hh_in.NumMCycle, errors='coerce') hh_in.NumVanLorry = pd.to_numeric(hh_in.NumVanLorry, errors='coerce') hh_in.NumCarVan = pd.to_numeric(hh_in.NumCarVan, errors='coerce') hh_in.Settlement2011EW_B04ID = pd.to_numeric(hh_in.Settlement2011EW_B04ID, errors='coerce')  hh_in.head() Out[4]: HouseholdID SurveyYear PSUID W2 OutCom_B02ID HHIncome2002_B02ID AddressType_B01ID Ten1_B02ID Landlord_B01ID ResLength_B01ID ... NumCarVan WalkBus_B01ID Getbus_B01ID WalkRail_B01ID WalkRailAlt_B01ID HRPWorkStat_B02ID HRPSEGWorkStat_B01ID HHoldOAClass2011_B03ID Settlement2011EW_B03ID Settlement2011EW_B04ID 0 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1 2 2002 1 1 1 1 3 1 -10 8 ... 0 1 5 2 -9 3 5 -10 1 1 2 3 2002 1 1 1 3 3 1 -10 8 ... 2 1 4 3 -9 1 3 -10 1 1 <p>3 rows \u00d7 33 columns</p> In\u00a0[5]: Copied! <pre>participation_mapping = dict(zip(hh_in.HouseholdID, hh_in.OutCom_B02ID))\nweight_mapping = dict(zip(hh_in.HouseholdID, hh_in.W2))\n</pre> participation_mapping = dict(zip(hh_in.HouseholdID, hh_in.OutCom_B02ID)) weight_mapping = dict(zip(hh_in.HouseholdID, hh_in.W2)) In\u00a0[6]: Copied! <pre>persons_in = pd.read_csv(\n    individuals_csv,\n    sep='\\t',\n    usecols=['SurveyYear', 'IndividualID', 'HouseholdID', 'PSUID', 'VehicleID',\n       'PersNo', 'Age_B01ID', 'OfPenAge_B01ID', 'Sex_B01ID', 'EdAttn1_B01ID',\n       'EdAttn2_B01ID', 'EdAttn3_B01ID', 'DrivLic_B02ID', 'CarAccess_B01ID',\n       'DrivDisable_B01ID', 'WkPlace_B01ID', 'ES2000_B01ID', 'NSSec_B03ID',\n       'SC_B01ID', 'Stat_B01ID', 'SVise_B01ID', 'EcoStat_B02ID',\n       'PossHom_B01ID']\n)\npersons_in.head()\n</pre> persons_in = pd.read_csv(     individuals_csv,     sep='\\t',     usecols=['SurveyYear', 'IndividualID', 'HouseholdID', 'PSUID', 'VehicleID',        'PersNo', 'Age_B01ID', 'OfPenAge_B01ID', 'Sex_B01ID', 'EdAttn1_B01ID',        'EdAttn2_B01ID', 'EdAttn3_B01ID', 'DrivLic_B02ID', 'CarAccess_B01ID',        'DrivDisable_B01ID', 'WkPlace_B01ID', 'ES2000_B01ID', 'NSSec_B03ID',        'SC_B01ID', 'Stat_B01ID', 'SVise_B01ID', 'EcoStat_B02ID',        'PossHom_B01ID'] ) persons_in.head() Out[6]: SurveyYear IndividualID HouseholdID PSUID VehicleID PersNo Age_B01ID OfPenAge_B01ID Sex_B01ID EdAttn1_B01ID ... CarAccess_B01ID DrivDisable_B01ID WkPlace_B01ID ES2000_B01ID NSSec_B03ID SC_B01ID Stat_B01ID SVise_B01ID EcoStat_B02ID PossHom_B01ID 0 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1 2002 2 1 1 2 2 13 2 1 -10 ... 2 -9 1 7 3 4 1 2 1 2 2 2002 3 1 1 3 4 2 1 -10 ... 4 -9 -9 -9 -9 -9 -9 -9 -9 -9 3 2002 4 1 1 4 2 2 2 -10 ... 4 -9 -9 -9 -9 -9 -9 -9 -9 -9 4 2002 5 2 1 1 18 1 2 -10 ... 6 2 -9 6 1 3 1 1 4 -9 <p>5 rows \u00d7 23 columns</p> In\u00a0[7]: Copied! <pre>travel_diaries_in = pd.read_csv(\n    trips_csv,\n    sep='\\t',\n    usecols=['TripID', 'SurveyYear', 'DayID', 'IndividualID', 'HouseholdID', 'PSUID',\n       'PersNo', 'TravDay', 'JourSeq', 'ShortWalkTrip_B01ID', 'NumStages',\n       'MainMode_B04ID', 'TripPurpFrom_B01ID',\n        'TripPurpTo_B01ID', 'TripPurpose_B04ID',\n       'TripStart', 'TripEnd', 'TripOrigUA2009_B01ID', 'TripDestUA2009_B01ID'],\n#     dtype={\"W5\": np.float64,}\n)\n\ntravel_diaries_in.TripStart = pd.to_numeric(travel_diaries_in.TripStart, errors='coerce')\ntravel_diaries_in.TripEnd = pd.to_numeric(travel_diaries_in.TripEnd, errors='coerce')\n\ntravel_diaries_in.head()\n</pre> travel_diaries_in = pd.read_csv(     trips_csv,     sep='\\t',     usecols=['TripID', 'SurveyYear', 'DayID', 'IndividualID', 'HouseholdID', 'PSUID',        'PersNo', 'TravDay', 'JourSeq', 'ShortWalkTrip_B01ID', 'NumStages',        'MainMode_B04ID', 'TripPurpFrom_B01ID',         'TripPurpTo_B01ID', 'TripPurpose_B04ID',        'TripStart', 'TripEnd', 'TripOrigUA2009_B01ID', 'TripDestUA2009_B01ID'], #     dtype={\"W5\": np.float64,} )  travel_diaries_in.TripStart = pd.to_numeric(travel_diaries_in.TripStart, errors='coerce') travel_diaries_in.TripEnd = pd.to_numeric(travel_diaries_in.TripEnd, errors='coerce')  travel_diaries_in.head() Out[7]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay JourSeq ShortWalkTrip_B01ID NumStages MainMode_B04ID TripPurpose_B04ID TripPurpFrom_B01ID TripPurpTo_B01ID TripStart TripEnd TripOrigUA2009_B01ID TripDestUA2009_B01ID 0 1 2002 2 1 1 1 1 2 1 2 1 4 7 23 10 675 683 530 550 1 2 2002 2 1 1 1 1 2 2 2 1 4 6 10 8 720 735 530 550 2 3 2002 2 1 1 1 1 2 3 2 1 4 7 8 10 770 780 530 550 3 4 2002 2 1 1 1 1 2 4 2 1 12 7 10 23 1110 1130 530 550 4 5 2002 3 1 1 1 1 3 1 2 1 4 7 23 10 760 770 530 550 In\u00a0[8]: Copied! <pre>travel_diaries_in['participation'] = travel_diaries_in.HouseholdID.map(participation_mapping)\ntravel_diaries_in['hh_weight'] = travel_diaries_in.HouseholdID.map(weight_mapping)\n</pre> travel_diaries_in['participation'] = travel_diaries_in.HouseholdID.map(participation_mapping) travel_diaries_in['hh_weight'] = travel_diaries_in.HouseholdID.map(weight_mapping) In\u00a0[9]: Copied! <pre>travel_diaries = travel_diaries_in.loc[travel_diaries_in.participation.isin([1,2])]\n</pre> travel_diaries = travel_diaries_in.loc[travel_diaries_in.participation.isin([1,2])] In\u00a0[10]: Copied! <pre>travel_diaries.head()\n</pre> travel_diaries.head() Out[10]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay JourSeq ShortWalkTrip_B01ID ... MainMode_B04ID TripPurpose_B04ID TripPurpFrom_B01ID TripPurpTo_B01ID TripStart TripEnd TripOrigUA2009_B01ID TripDestUA2009_B01ID participation hh_weight 0 1 2002 2 1 1 1 1 2 1 2 ... 4 7 23 10 675 683 530 550 1 1 1 2 2002 2 1 1 1 1 2 2 2 ... 4 6 10 8 720 735 530 550 1 1 2 3 2002 2 1 1 1 1 2 3 2 ... 4 7 8 10 770 780 530 550 1 1 3 4 2002 2 1 1 1 1 2 4 2 ... 12 7 10 23 1110 1130 530 550 1 1 4 5 2002 3 1 1 1 1 3 1 2 ... 4 7 23 10 760 770 530 550 1 1 <p>5 rows \u00d7 21 columns</p> In\u00a0[11]: Copied! <pre>travel_diaries.rename(\n    columns={  # rename data\n        'JourSeq': 'seq',\n        'TripOrigUA2009_B01ID': 'ozone',\n        'TripDestUA2009_B01ID': 'dzone',\n        'TripPurpFrom_B01ID': 'oact',\n        'TripPurpTo_B01ID': 'dact',\n        'MainMode_B04ID': 'mode',\n        'TripStart': 'tst',\n        'TripEnd': 'tet',\n    },\n                inplace=True)\n\ntravel_diaries.head()\n</pre> travel_diaries.rename(     columns={  # rename data         'JourSeq': 'seq',         'TripOrigUA2009_B01ID': 'ozone',         'TripDestUA2009_B01ID': 'dzone',         'TripPurpFrom_B01ID': 'oact',         'TripPurpTo_B01ID': 'dact',         'MainMode_B04ID': 'mode',         'TripStart': 'tst',         'TripEnd': 'tet',     },                 inplace=True)  travel_diaries.head() Out[11]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay seq ShortWalkTrip_B01ID ... mode TripPurpose_B04ID oact dact tst tet ozone dzone participation hh_weight 0 1 2002 2 1 1 1 1 2 1 2 ... 4 7 23 10 675 683 530 550 1 1 1 2 2002 2 1 1 1 1 2 2 2 ... 4 6 10 8 720 735 530 550 1 1 2 3 2002 2 1 1 1 1 2 3 2 ... 4 7 8 10 770 780 530 550 1 1 3 4 2002 2 1 1 1 1 2 4 2 ... 12 7 10 23 1110 1130 530 550 1 1 4 5 2002 3 1 1 1 1 3 1 2 ... 4 7 23 10 760 770 530 550 1 1 <p>5 rows \u00d7 21 columns</p> In\u00a0[12]: Copied! <pre>travel_diaries.dtypes\n</pre> travel_diaries.dtypes Out[12]: <pre>TripID                 int64\nSurveyYear             int64\nDayID                  int64\nIndividualID           int64\nHouseholdID            int64\nPSUID                  int64\nPersNo                 int64\nTravDay                int64\nseq                    int64\nShortWalkTrip_B01ID    int64\nNumStages              int64\nmode                   int64\nTripPurpose_B04ID      int64\noact                   int64\ndact                   int64\ntst                    int64\ntet                    int64\nozone                  int64\ndzone                  int64\nparticipation          int64\nhh_weight              int64\ndtype: object</pre> In\u00a0[13]: Copied! <pre>def check_uniques(df):\n    for c in df.columns:\n        print(c)\n        n = df[c].nunique()\n        if n &lt; 1000:\n            print(df[c].unique())\n</pre> def check_uniques(df):     for c in df.columns:         print(c)         n = df[c].nunique()         if n &lt; 1000:             print(df[c].unique()) In\u00a0[14]: Copied! <pre>check_uniques(travel_diaries)\n</pre> check_uniques(travel_diaries) <pre>TripID\n[  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n 145 146 147 148 149]\nSurveyYear\n[2002]\nDayID\n[ 2  3  5  6  7  8  9 10 11 12 13 14 16 17 19 20 21 23 24 26 27 28 29 30\n 33 35 36 37 38 39 40 41 42 43 44 45 46 47 49]\nIndividualID\n[1 2 3 4 5 6 7]\nHouseholdID\n[1 2 3]\nPSUID\n[1]\nPersNo\n[1 2 3 4]\nTravDay\n[2 3 5 6 7 1 4]\nseq\n[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]\nShortWalkTrip_B01ID\n[2 1]\nNumStages\n[1 4 3 2]\nmode\n[ 4 12  3  1 11  7]\nTripPurpose_B04ID\n[7 6 3 4 5 1 2]\noact\n[23 10  8 20  5  9 22  1 12  4  3  6 14  2 18]\ndact\n[10  8 23 20  5  9 22  1 12  4  3  6 14 18]\ntst\n[ 675  720  770 1110  760  790  810  845  865  908  922  940 1015 1080\n  905  738  755 1050 1220 1270  525  546  745  764 1060  833 1320  530\n 1265  605  620  960  970 1075  360  350  875  898 1310  345  870  900\n  923 1311  990  585  560  840  438 1010 1105 1112  440  965  921  980\n 1115  910  820  853 1013 1023 1298 1306  702  975 1087  495 1070 1052]\ntet\n[ 683  735  780 1130  770  805  825  852  873  914  926  955 1032 1108\n  785  917  752  761 1076 1223 1275  540  556  760  774 1127  836 1325\n  535 1272  608  675  690  962  972 1078  363 1080  355  890  912  931\n 1316  348  887  915  933 1314  855 1020  795  730  750  885  465 1036\n 1110 1120  984  950 1005  471  922  830  862  906 1023 1034 1305 1312\n  627  710  468  986 1085 1091  550 1100 1115  559]\nozone\n[530]\ndzone\n[550]\nparticipation\n[1]\nhh_weight\n[1]\n</pre> In\u00a0[15]: Copied! <pre>area_path = \"./data/dummyNTS/NTSareas.geojson\"\n</pre> area_path = \"./data/dummyNTS/NTSareas.geojson\" In\u00a0[16]: Copied! <pre>areas = gp.read_file(area_path)\nareas.head()\n</pre> areas = gp.read_file(area_path) areas.head() Out[16]: id name geometry 0 530.0 West Midlands POLYGON ((-1.95366 52.66273, -1.95457 52.66264... 1 550.0 West Yorkshire POLYGON ((-1.87994 53.95590, -1.87982 53.95681... In\u00a0[17]: Copied! <pre>areas.plot(figsize=(6,6))\n</pre> areas.plot(figsize=(6,6)) Out[17]: <pre>&lt;AxesSubplot:&gt;</pre> In\u00a0[18]: Copied! <pre>def remove_broken_plans(plan):\n    if plan.isnull().values.any():\n        return None\n    for col in ['ozone', 'dzone']:\n        if -8 in list(plan[col]):\n            return None\n    return plan\n</pre> def remove_broken_plans(plan):     if plan.isnull().values.any():         return None     for col in ['ozone', 'dzone']:         if -8 in list(plan[col]):             return None     return plan In\u00a0[19]: Copied! <pre>clean_travel_diaries = travel_diaries.groupby(\n    ['IndividualID', 'TravDay']\n).apply(\n    remove_broken_plans\n).reset_index(drop=True)\n</pre> clean_travel_diaries = travel_diaries.groupby(     ['IndividualID', 'TravDay'] ).apply(     remove_broken_plans ).reset_index(drop=True) In\u00a0[20]: Copied! <pre>clean_travel_diaries.head()\n</pre> clean_travel_diaries.head() Out[20]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay seq ShortWalkTrip_B01ID ... mode TripPurpose_B04ID oact dact tst tet ozone dzone participation hh_weight 0 1 2002 2 1 1 1 1 2 1 2 ... 4 7 23 10 675 683 530 550 1 1 1 2 2002 2 1 1 1 1 2 2 2 ... 4 6 10 8 720 735 530 550 1 1 2 3 2002 2 1 1 1 1 2 3 2 ... 4 7 8 10 770 780 530 550 1 1 3 4 2002 2 1 1 1 1 2 4 2 ... 12 7 10 23 1110 1130 530 550 1 1 4 5 2002 3 1 1 1 1 3 1 2 ... 4 7 23 10 760 770 530 550 1 1 <p>5 rows \u00d7 21 columns</p> In\u00a0[21]: Copied! <pre>print(len(travel_diaries))\nprint(len(clean_travel_diaries))\n</pre> print(len(travel_diaries)) print(len(clean_travel_diaries)) <pre>149\n149\n</pre> In\u00a0[22]: Copied! <pre>def string_to_dict(string):\n\"\"\"used to build dicts from NTS rtf format dictionaries (cut and paste from the NTS documentation)\"\"\"\n    mapping = {}\n    for line in string.split(\"\\n\"):\n        _, v, l = line.split(\"\\t\")\n        v = v.split(\" = \")[1]\n        l = l.split(\" = \")[1]\n        mapping[float(v)] = str(l)\n    return mapping\n</pre> def string_to_dict(string):     \"\"\"used to build dicts from NTS rtf format dictionaries (cut and paste from the NTS documentation)\"\"\"     mapping = {}     for line in string.split(\"\\n\"):         _, v, l = line.split(\"\\t\")         v = v.split(\" = \")[1]         l = l.split(\" = \")[1]         mapping[float(v)] = str(l)     return mapping In\u00a0[23]: Copied! <pre>mode_mapping = {\n    1: 'walk',\n     2: 'bike',\n     3: 'car',  #'Car/van driver'\n     4: 'car',  #'Car/van driver'\n     5: 'car',  #'Motorcycle',\n     6: 'car',  #'Other private transport',\n     7: 'pt', #Bus in London',\n     8: 'pt', #'Other local bus',\n     9: 'pt', #'Non-local bus',\n     10: 'pt', #'London Underground',\n     11: 'pt', #'Surface Rail',\n     12: 'car',  #'Taxi/minicab',\n     13: 'pt', #'Other public transport',\n     -10: 'DEAD',\n     -8: 'NA'\n}\n\npurp_mapping = {\n    1: 'work',\n     2: 'work',  #'In course of work',\n     3: 'education',\n     4: 'shop',  #'Food shopping',\n     5: 'shop',  #'Non food shopping',\n     6: 'medical', #'Personal business medical',\n     7: 'other',  #'Personal business eat/drink',\n     8: 'other',  #'Personal business other',\n     9: 'other',  #'Eat/drink with friends',\n     10: 'visit',  #'Visit friends',\n     11: 'other',  #'Other social',\n     12: 'other',  #'Entertain/ public activity',\n     13: 'other',  #'Sport: participate',\n     14: 'home',  #'Holiday: base',\n     15: 'other',  #'Day trip/just walk',\n     16: 'other',  #'Other non-escort',\n     17: 'escort',  #'Escort home',\n     18: 'escort',  #'Escort work',\n     19: 'escort',  #'Escort in course of work',\n     20: 'escort',  #'Escort education',\n     21: 'escort',  #'Escort shopping/personal business',\n     22: 'escort',  #'Other escort',\n     23: 'home',  #'Home',\n     -10: 'DEAD',\n     -8: 'NA'\n}\n\nclean_travel_diaries['mode'] = clean_travel_diaries['mode'].map(mode_mapping)\nclean_travel_diaries['oact'] = clean_travel_diaries['oact'].map(purp_mapping)\nclean_travel_diaries['dact'] = clean_travel_diaries['dact'].map(purp_mapping)\n</pre> mode_mapping = {     1: 'walk',      2: 'bike',      3: 'car',  #'Car/van driver'      4: 'car',  #'Car/van driver'      5: 'car',  #'Motorcycle',      6: 'car',  #'Other private transport',      7: 'pt', #Bus in London',      8: 'pt', #'Other local bus',      9: 'pt', #'Non-local bus',      10: 'pt', #'London Underground',      11: 'pt', #'Surface Rail',      12: 'car',  #'Taxi/minicab',      13: 'pt', #'Other public transport',      -10: 'DEAD',      -8: 'NA' }  purp_mapping = {     1: 'work',      2: 'work',  #'In course of work',      3: 'education',      4: 'shop',  #'Food shopping',      5: 'shop',  #'Non food shopping',      6: 'medical', #'Personal business medical',      7: 'other',  #'Personal business eat/drink',      8: 'other',  #'Personal business other',      9: 'other',  #'Eat/drink with friends',      10: 'visit',  #'Visit friends',      11: 'other',  #'Other social',      12: 'other',  #'Entertain/ public activity',      13: 'other',  #'Sport: participate',      14: 'home',  #'Holiday: base',      15: 'other',  #'Day trip/just walk',      16: 'other',  #'Other non-escort',      17: 'escort',  #'Escort home',      18: 'escort',  #'Escort work',      19: 'escort',  #'Escort in course of work',      20: 'escort',  #'Escort education',      21: 'escort',  #'Escort shopping/personal business',      22: 'escort',  #'Other escort',      23: 'home',  #'Home',      -10: 'DEAD',      -8: 'NA' }  clean_travel_diaries['mode'] = clean_travel_diaries['mode'].map(mode_mapping) clean_travel_diaries['oact'] = clean_travel_diaries['oact'].map(purp_mapping) clean_travel_diaries['dact'] = clean_travel_diaries['dact'].map(purp_mapping) In\u00a0[24]: Copied! <pre># reweight and split ids for unique days\n\ndef reweight(group):\n\"\"\"\n    Reweight based on multiple diary days, ie if an agent has two diary days, we will treat these as\n    two unique agents, so we half the original weighting\n    \"\"\"\n    group['freq'] = group.hh_weight / group.DayID.nunique()\n    return group\n\ntrips = clean_travel_diaries.groupby('IndividualID').apply(reweight)\ntrips['pid'] = [f\"{p}_{d}\" for p, d in zip(trips.IndividualID, trips.TravDay)]\ntrips['hid'] = [f\"{h}_{d}\" for h, d in zip(trips.HouseholdID, trips.TravDay)]\n</pre> # reweight and split ids for unique days  def reweight(group):     \"\"\"     Reweight based on multiple diary days, ie if an agent has two diary days, we will treat these as     two unique agents, so we half the original weighting     \"\"\"     group['freq'] = group.hh_weight / group.DayID.nunique()     return group  trips = clean_travel_diaries.groupby('IndividualID').apply(reweight) trips['pid'] = [f\"{p}_{d}\" for p, d in zip(trips.IndividualID, trips.TravDay)] trips['hid'] = [f\"{h}_{d}\" for h, d in zip(trips.HouseholdID, trips.TravDay)] In\u00a0[25]: Copied! <pre>trips.head()\n</pre> trips.head() Out[25]: TripID SurveyYear DayID IndividualID HouseholdID PSUID PersNo TravDay seq ShortWalkTrip_B01ID ... dact tst tet ozone dzone participation hh_weight freq pid hid 0 1 2002 2 1 1 1 1 2 1 2 ... visit 675 683 530 550 1 1 0.2 1_2 1_2 1 2 2002 2 1 1 1 1 2 2 2 ... other 720 735 530 550 1 1 0.2 1_2 1_2 2 3 2002 2 1 1 1 1 2 3 2 ... visit 770 780 530 550 1 1 0.2 1_2 1_2 3 4 2002 2 1 1 1 1 2 4 2 ... home 1110 1130 530 550 1 1 0.2 1_2 1_2 4 5 2002 3 1 1 1 1 3 1 2 ... visit 760 770 530 550 1 1 0.2 1_3 1_3 <p>5 rows \u00d7 24 columns</p> In\u00a0[26]: Copied! <pre>def expand_days(\n    trips,\n    target,\n    trips_on='Diary_number',\n    target_on='Diary_number',\n    new_id='pid',\n    trim=True\n):\n\"\"\"\n    Expand target df based on mapping between trips target_on and new_id.\n    This is so slow. Fix\n    Set index to new_id.\n    \"\"\"\n    print(\"Building mapping.\")\n    mapping = {}\n    for i, person in trips.groupby(target_on):\n        mapping[i] = list(set(person[new_id]))\n    n = len(mapping)\n    \n    if trim:\n        print(\"Trimming target.\")\n        selection = set(trips[trips_on])\n        target = target.loc[target[target_on].isin(selection)]\n    \n    expanded = pd.DataFrame()\n    for p, (i, ids) in enumerate(mapping.items()):\n        if not p % 10:\n            print(f\"Building expanded data {p}/{n}\", end='\\r', flush=True)\n        for idx in ids:\n            split = target.loc[target[target_on] == i]\n            split[new_id] = idx\n            expanded = expanded.append(split)\n    expanded.set_index(new_id, inplace=True)\n    print(f\"Done\")\n    return expanded\n</pre> def expand_days(     trips,     target,     trips_on='Diary_number',     target_on='Diary_number',     new_id='pid',     trim=True ):     \"\"\"     Expand target df based on mapping between trips target_on and new_id.     This is so slow. Fix     Set index to new_id.     \"\"\"     print(\"Building mapping.\")     mapping = {}     for i, person in trips.groupby(target_on):         mapping[i] = list(set(person[new_id]))     n = len(mapping)          if trim:         print(\"Trimming target.\")         selection = set(trips[trips_on])         target = target.loc[target[target_on].isin(selection)]          expanded = pd.DataFrame()     for p, (i, ids) in enumerate(mapping.items()):         if not p % 10:             print(f\"Building expanded data {p}/{n}\", end='\\r', flush=True)         for idx in ids:             split = target.loc[target[target_on] == i]             split[new_id] = idx             expanded = expanded.append(split)     expanded.set_index(new_id, inplace=True)     print(f\"Done\")     return expanded In\u00a0[27]: Copied! <pre>hhs = expand_days(\n    trips,\n    hh_in,\n    trips_on='HouseholdID',\n    target_on='HouseholdID',\n    new_id='hid'\n)\n</pre> hhs = expand_days(     trips,     hh_in,     trips_on='HouseholdID',     target_on='HouseholdID',     new_id='hid' ) <pre>Building mapping.\nTrimming target.\nDone\n</pre> <pre>/Users/fred.shone/.ve/pam/lib/python3.7/site-packages/ipykernel_launcher.py:31: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n</pre> In\u00a0[28]: Copied! <pre>hhs.head()\n</pre> hhs.head() Out[28]: HouseholdID SurveyYear PSUID W2 OutCom_B02ID HHIncome2002_B02ID AddressType_B01ID Ten1_B02ID Landlord_B01ID ResLength_B01ID ... NumCarVan WalkBus_B01ID Getbus_B01ID WalkRail_B01ID WalkRailAlt_B01ID HRPWorkStat_B02ID HRPSEGWorkStat_B01ID HHoldOAClass2011_B03ID Settlement2011EW_B03ID Settlement2011EW_B04ID hid 1_3 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_4 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_7 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_6 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 1_1 1 2002 1 1 1 2 3 1 -10 3 ... 2 1 5 1 -9 1 3 -10 1 1 <p>5 rows \u00d7 33 columns</p> In\u00a0[29]: Copied! <pre>people = expand_days(\n    trips,\n    persons_in,\n    trips_on='IndividualID',\n    target_on='IndividualID',\n    new_id='pid'\n)\n</pre> people = expand_days(     trips,     persons_in,     trips_on='IndividualID',     target_on='IndividualID',     new_id='pid' ) <pre>Building mapping.\nTrimming target.\nDone\n</pre> <pre>/Users/fred.shone/.ve/pam/lib/python3.7/site-packages/ipykernel_launcher.py:31: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n</pre> In\u00a0[30]: Copied! <pre>people.head()\n</pre> people.head() Out[30]: SurveyYear IndividualID HouseholdID PSUID VehicleID PersNo Age_B01ID OfPenAge_B01ID Sex_B01ID EdAttn1_B01ID ... CarAccess_B01ID DrivDisable_B01ID WkPlace_B01ID ES2000_B01ID NSSec_B03ID SC_B01ID Stat_B01ID SVise_B01ID EcoStat_B02ID PossHom_B01ID pid 1_3 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_7 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_6 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_5 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 1_2 2002 1 1 1 1 1 13 2 2 -10 ... 2 -9 1 7 2 3 1 2 2 2 <p>5 rows \u00d7 23 columns</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[31]: Copied! <pre>from pam import write\nfrom pam import read\nfrom pam.plot.stats import plot_activity_times, plot_leg_times\n</pre> from pam import write from pam import read from pam.plot.stats import plot_activity_times, plot_leg_times In\u00a0[32]: Copied! <pre>trips.tst = trips.tst.astype(int)\ntrips.tet = trips.tet.astype(int)\n</pre> trips.tst = trips.tst.astype(int) trips.tet = trips.tet.astype(int) In\u00a0[33]: Copied! <pre>population = read.load_travel_diary(\n    trips=trips,\n    persons_attributes=people,\n    hhs_attributes=hhs,\n    trip_freq_as_person_freq=True\n)\n</pre> population = read.load_travel_diary(     trips=trips,     persons_attributes=people,     hhs_attributes=hhs,     trip_freq_as_person_freq=True ) <pre>Using from-to activity parser using 'oact' and 'dact' columns\nAdding pid-&gt;hh mapping to persons_attributes from trips.\n\n        Unable to load household area ('hzone') - not found in trips_diary or unable to build from attributes.\n        Pam will try to infer home location from activities, but this behaviour is not recommended.\n        \nUsing freq of 'None' for all trips.\nUsing freq of 'None' for all households.\n Person pid:2_5 hid:1_5 plan does not start with 'home' activity: work\n Person pid:2_6 hid:1_6 plan does not start with 'home' activity: work\n Person pid:3_6 hid:1_6 plan does not start with 'home' activity: education\n Person pid:2_7 hid:1_7 plan does not start with 'home' activity: work\n</pre> In\u00a0[34]: Copied! <pre>population.fix_plans()\n</pre> population.fix_plans() In\u00a0[35]: Copied! <pre># this should be replaced with a more direct method\nfor hh in population.households.values():\n    for p in hh.people.values():\n        p.validate()\n</pre> # this should be replaced with a more direct method for hh in population.households.values():     for p in hh.people.values():         p.validate() In\u00a0[36]: Copied! <pre>population.size  # this also accounts for the weighting\n</pre> population.size  # this also accounts for the weighting Out[36]: <pre>3.285714285714285</pre> In\u00a0[37]: Copied! <pre>population.stats\n</pre> population.stats Out[37]: <pre>{'num_households': 18,\n 'num_people': 39,\n 'num_activities': 175,\n 'num_legs': 136}</pre> In\u00a0[38]: Copied! <pre>population.activity_classes\n</pre> population.activity_classes Out[38]: <pre>{'education', 'escort', 'home', 'medical', 'other', 'shop', 'visit', 'work'}</pre> In\u00a0[39]: Copied! <pre>population.mode_classes\n</pre> population.mode_classes Out[39]: <pre>{'car', 'pt', 'walk'}</pre> In\u00a0[40]: Copied! <pre>plot_activity_times(population)\n</pre> plot_activity_times(population) Out[40]: In\u00a0[41]: Copied! <pre>plot_leg_times(population)\n</pre> plot_leg_times(population) Out[41]: In\u00a0[42]: Copied! <pre># night shift @ 2016008863_6\n</pre> # night shift @ 2016008863_6 In\u00a0[43]: Copied! <pre>hh = population.random_household()\nhh.print()\nhh.plot()\n</pre> hh = population.random_household() hh.print() hh.plot() <pre>Household: 3_7\n{'HouseholdID': 3, 'SurveyYear': 2002, 'PSUID': 1, 'W2': 1, 'OutCom_B02ID': 1, 'HHIncome2002_B02ID': 3, 'AddressType_B01ID': 3, 'Ten1_B02ID': 1, 'Landlord_B01ID': -10, 'ResLength_B01ID': 8, 'HHoldCountry_B01ID': 1, 'HHoldGOR_B02ID': 7, 'HHoldNumAdults': 3, 'HHoldNumChildren': 0, 'HHoldNumPeople': 3, 'HHoldStruct_B02ID': 3, 'NumLicHolders': 1, 'HHoldEmploy_B01ID': 1, 'NumVehicles': 2, 'NumBike': 1, 'NumCar': 1, 'NumMCycle': 0, 'NumVanLorry': 1, 'NumCarVan': 2, 'WalkBus_B01ID': 1, 'Getbus_B01ID': 4, 'WalkRail_B01ID': 3, 'WalkRailAlt_B01ID': -9, 'HRPWorkStat_B02ID': 1, 'HRPSEGWorkStat_B01ID': 3, 'HHoldOAClass2011_B03ID': -10, 'Settlement2011EW_B03ID': 1, 'Settlement2011EW_B04ID': 1}\nPerson: 6_7\n{'SurveyYear': 2002, 'IndividualID': 6, 'HouseholdID': 3, 'PSUID': 1, 'VehicleID': '3', 'PersNo': 1, 'Age_B01ID': 14, 'OfPenAge_B01ID': 2, 'Sex_B01ID': 1, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': 1, 'CarAccess_B01ID': 2, 'DrivDisable_B01ID': -9, 'WkPlace_B01ID': 1, 'ES2000_B01ID': 7, 'NSSec_B03ID': 3, 'SC_B01ID': 4, 'Stat_B01ID': 1, 'SVise_B01ID': 2, 'EcoStat_B02ID': 1, 'PossHom_B01ID': 2}\n0:\tActivity(act:home, location:530, time:00:00:00 --&gt; 07:20:00, duration:7:20:00)\n1:\tLeg(mode:car, area:530 --&gt; 550, time:07:20:00 --&gt; 07:48:00, duration:0:28:00)\n2:\tActivity(act:work, location:550, time:07:48:00 --&gt; 16:15:00, duration:8:27:00)\n3:\tLeg(mode:car, area:550 --&gt; 550, time:16:15:00 --&gt; 16:26:00, duration:0:11:00)\n4:\tActivity(act:home, location:550, time:16:26:00 --&gt; 18:00:00, duration:1:34:00)\n5:\tLeg(mode:car, area:550 --&gt; 550, time:18:00:00 --&gt; 18:05:00, duration:0:05:00)\n6:\tActivity(act:escort, location:550, time:18:05:00 --&gt; 18:07:00, duration:0:02:00)\n7:\tLeg(mode:car, area:550 --&gt; 550, time:18:07:00 --&gt; 18:11:00, duration:0:04:00)\n8:\tActivity(act:home, location:550, time:18:11:00 --&gt; 00:00:00, duration:5:49:00)\nPerson: 7_7\n{'SurveyYear': 2002, 'IndividualID': 7, 'HouseholdID': 3, 'PSUID': 1, 'VehicleID': ' ', 'PersNo': 2, 'Age_B01ID': 14, 'OfPenAge_B01ID': 2, 'Sex_B01ID': 2, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': 3, 'CarAccess_B01ID': 4, 'DrivDisable_B01ID': -9, 'WkPlace_B01ID': 1, 'ES2000_B01ID': 7, 'NSSec_B03ID': 2, 'SC_B01ID': 3, 'Stat_B01ID': 1, 'SVise_B01ID': 2, 'EcoStat_B02ID': 1, 'PossHom_B01ID': 2}\n0:\tActivity(act:home, location:530, time:00:00:00 --&gt; 08:15:00, duration:8:15:00)\n1:\tLeg(mode:pt, area:530 --&gt; 550, time:08:15:00 --&gt; 09:19:00, duration:1:04:00)\n2:\tActivity(act:work, location:550, time:09:19:00 --&gt; 17:32:00, duration:8:13:00)\n3:\tLeg(mode:pt, area:550 --&gt; 550, time:17:32:00 --&gt; 18:11:00, duration:0:39:00)\n4:\tActivity(act:home, location:550, time:18:11:00 --&gt; 00:00:00, duration:5:49:00)\n</pre> In\u00a0[44]: Copied! <pre>population.activity_classes\n</pre> population.activity_classes Out[44]: <pre>{'education', 'escort', 'home', 'medical', 'other', 'shop', 'visit', 'work'}</pre> In\u00a0[45]: Copied! <pre>from pam.core import Population\nfrom pam.samplers.basic import freq_sample\nfrom copy import deepcopy\n\npopulation_sample = Population()\n    \nfor hid, household in population.households.items():\n    av_hh_weight = household.freq  # this is currently the av of person freq in the hh\n    freq = freq_sample(av_hh_weight, 10)\n\n    for idx in range(freq):\n        hh = deepcopy(household)\n        hh.hid = f\"{hh.hid}_{idx}\"\n        hh.people = {}\n        for pid, person in household.people.items():\n            p = deepcopy(person)\n            p.pid = f\"{pid}_{idx}\"\n            hh.add(p)\n        population_sample.add(hh)\n</pre> from pam.core import Population from pam.samplers.basic import freq_sample from copy import deepcopy  population_sample = Population()      for hid, household in population.households.items():     av_hh_weight = household.freq  # this is currently the av of person freq in the hh     freq = freq_sample(av_hh_weight, 10)      for idx in range(freq):         hh = deepcopy(household)         hh.hid = f\"{hh.hid}_{idx}\"         hh.people = {}         for pid, person in household.people.items():             p = deepcopy(person)             p.pid = f\"{pid}_{idx}\"             hh.add(p)         population_sample.add(hh)  In\u00a0[46]: Copied! <pre>population_sample.size\n</pre> population_sample.size Out[46]: <pre>6.311904761904766</pre> In\u00a0[47]: Copied! <pre>from pam.samplers import facility\n</pre> from pam.samplers import facility In\u00a0[48]: Copied! <pre>def load_facilities(path, from_crs=\"EPSG:4326\", to_crs=\"EPSG:27700\"):\n    \n    facilities = gp.read_file(facilities_path)\n    facilities.crs = from_crs\n    facilities.to_crs(to_crs, inplace=True)\n    return facilities\n\ndef load_zones(zones_path, from_crs=\"EPSG:27700\", to_crs=\"EPSG:27700\"):\n    \n    zones = gp.read_file(zones_path)\n    zones.set_index('id', inplace=True)\n    if not from_crs == to_crs:\n        zones.crs = from_crs\n        zones.to_crs(to_crs, inplace=True)\n    return zones\n</pre> def load_facilities(path, from_crs=\"EPSG:4326\", to_crs=\"EPSG:27700\"):          facilities = gp.read_file(facilities_path)     facilities.crs = from_crs     facilities.to_crs(to_crs, inplace=True)     return facilities  def load_zones(zones_path, from_crs=\"EPSG:27700\", to_crs=\"EPSG:27700\"):          zones = gp.read_file(zones_path)     zones.set_index('id', inplace=True)     if not from_crs == to_crs:         zones.crs = from_crs         zones.to_crs(to_crs, inplace=True)     return zones In\u00a0[49]: Copied! <pre># facilities_path = '~Data/facilities/NTS_london_facilities.json'\n\n# facilities = load_facilities(facilities_path)\n# zones = load_zones(area_path, from_crs=\"EPSG:4326\")\n\n# facility_sampler = facility.FacilitySampler(\n# facilities=facilities,\n# zones=zones,\n# build_xml=True,\n# fail=False,\n# random_default=True\n# )\n\n# facility_sampler.clear()\n# population_sample.sample_locs(facility_sampler)\n</pre> # facilities_path = '~Data/facilities/NTS_london_facilities.json'  # facilities = load_facilities(facilities_path) # zones = load_zones(area_path, from_crs=\"EPSG:4326\")  # facility_sampler = facility.FacilitySampler( # facilities=facilities, # zones=zones, # build_xml=True, # fail=False, # random_default=True # )  # facility_sampler.clear() # population_sample.sample_locs(facility_sampler) In\u00a0[50]: Copied! <pre>from pam.samplers.spatial import RandomPointSampler\n</pre> from pam.samplers.spatial import RandomPointSampler In\u00a0[51]: Copied! <pre>zones = load_zones(area_path, from_crs=\"EPSG:4326\")\nsampler = RandomPointSampler(geoms=zones)\n</pre> zones = load_zones(area_path, from_crs=\"EPSG:4326\") sampler = RandomPointSampler(geoms=zones) In\u00a0[52]: Copied! <pre>sampler.sample(530, None)\n</pre> sampler.sample(530, None) Out[52]: In\u00a0[53]: Copied! <pre>population_sample.sample_locs(sampler)\n</pre> population_sample.sample_locs(sampler) In\u00a0[54]: Copied! <pre>person = population_sample.random_person()\nperson.plot()\nperson.print()\n</pre> person = population_sample.random_person() person.plot() person.print() <pre>Person: 5_1_1\n{'SurveyYear': 2002, 'IndividualID': 5, 'HouseholdID': 2, 'PSUID': 1, 'VehicleID': ' ', 'PersNo': 1, 'Age_B01ID': 18, 'OfPenAge_B01ID': 1, 'Sex_B01ID': 2, 'EdAttn1_B01ID': -10, 'EdAttn2_B01ID': -10, 'EdAttn3_B01ID': -10, 'DrivLic_B02ID': 3, 'CarAccess_B01ID': 6, 'DrivDisable_B01ID': 2, 'WkPlace_B01ID': -9, 'ES2000_B01ID': 6, 'NSSec_B03ID': 1, 'SC_B01ID': 3, 'Stat_B01ID': 1, 'SVise_B01ID': 1, 'EcoStat_B02ID': 4, 'PossHom_B01ID': -9}\n0:\tActivity(act:home, location:POINT (434540.2215263931 277857.67546040274), time:00:00:00 --&gt; 14:05:00, duration:14:05:00)\n1:\tLeg(mode:car, area:POINT (434540.2215263931 277857.67546040274) --&gt; POINT (429829.848341634 417464.15127698536), time:14:05:00 --&gt; 14:15:00, duration:0:10:00)\n2:\tActivity(act:medical, location:POINT (429829.848341634 417464.15127698536), time:14:15:00 --&gt; 16:30:00, duration:2:15:00)\n3:\tLeg(mode:car, area:POINT (429829.848341634 417464.15127698536) --&gt; POINT (423820.47604598483 424925.4410173426), time:16:30:00 --&gt; 17:00:00, duration:0:30:00)\n4:\tActivity(act:home, location:POINT (423820.47604598483 424925.4410173426), time:17:00:00 --&gt; 00:00:00, duration:7:00:00)\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[55]: Copied! <pre>import pam.write as write\n</pre> import pam.write as write In\u00a0[56]: Copied! <pre>comment = 'NTS london prelim 24nov2020 epsg27700'\n\nwrite.write_matsim(\n        population_sample,\n        plans_path=os.path.join(out_dir, 'plans.xml'),\n        comment=comment\n    )\npopulation_sample.to_csv(out_dir, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\")\n# facility_sampler.write_facilities_xml(os.path.join(out_dir, 'facilities.xml'), comment=comment)\n</pre> comment = 'NTS london prelim 24nov2020 epsg27700'  write.write_matsim(         population_sample,         plans_path=os.path.join(out_dir, 'plans.xml'),         comment=comment     ) population_sample.to_csv(out_dir, crs=\"EPSG:27700\", to_crs=\"EPSG:4326\") # facility_sampler.write_facilities_xml(os.path.join(out_dir, 'facilities.xml'), comment=comment) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#converting-the-national-travel-survey-into-a-simple-matsim-format-population","title":"Converting the National Travel Survey into a Simple MATSim Format Population\u00b6","text":"<p>This notebook demonstrates an example workflow for converting tabular diary data from UK NTS (household attributes, person attributes and trip data) into MATSim formatted xml population data for London households.</p> <p>This includes:</p> <ul> <li>pre-processing of tabular inputs</li> <li>loading data into pam</li> <li>household sampling</li> <li>facility sampling</li> <li>preliminary investigation</li> <li>writing to xml</li> </ul> <p>This example is highly simplified. Of particular note: the diary data used is spatially very aggregate (trip locations are aggregated to inner/outer London). This creates significant variance in the sampled trip lengths. Generally we would expect more precise spatial data to be used. Alternately the complexity of the facility sampling step can be improved to better account for known trip features such as mode and duration.</p> <p>The diary data used is available from the UK Data Service (https://beta.ukdataservice.ac.uk/datacatalogue/studies/study?id=5340) and is described here:http://doc.ukdataservice.ac.uk/doc/5340/mrdoc/pdf/5340_nts_user_guidance_1995-2016.pdf</p>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#load-households-data","title":"Load households data\u00b6","text":"<ol> <li>Load household data into pandas DataFrame.</li> <li>Create some mappings of participation and weighting by household for use later. These are described in http://doc.ukdataservice.ac.uk/doc/5340/mrdoc/pdf/5340_nts_user_guidance_1995-2016.pdf</li> </ol>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#load-person-data","title":"Load person data\u00b6","text":"<p>Load person attributes data into pandas DataFrame.</p>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#load-trip-data","title":"load trip data\u00b6","text":"<ol> <li>Load trip data into pandas DataFrame format.</li> <li>Apply some preliminary formatting</li> <li>Replace headers so that we can use pam read method:</li> </ol> <ul> <li>pid - person ID</li> <li>hid - household ID</li> <li>seq - trip sequence number</li> <li>hzone - household zone</li> <li>ozone - trip origin zone</li> <li>dzone - trip destination zone</li> <li>purp - trip purpose</li> <li>mode - trip mode</li> <li>tst - trip start time (minutes)</li> <li>tet - trip end time (minutes)</li> <li>freq - weighting for representative population</li> </ul>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#area-mapping","title":"Area Mapping\u00b6","text":"<p>The NTS documentation refers to a 'modified' 2009 Unitary Authorities. The Unmodified 2017 UAs are included below for reference. They 2017 UA names are similar but not the same as the NTS mappings.</p> <p>Found here: https://data.gov.uk/dataset/4e1d5b2c-bb91-42ad-b420-f7fcab638389/counties-and-unitary-authorities-december-2017-full-extent-boundaries-in-uk-wgs84.</p> <p>We have built our own geometry:</p>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#clean-out-incomplete-plans","title":"Clean out incomplete plans\u00b6","text":""},{"location":"examples/04_Example_Ingest_NTS_Diaries/#build-mappings-and-apply-to-common-fields","title":"Build Mappings and apply to common fields\u00b6","text":"<p>We simplify key trip variables such as mode and activity.</p>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#reweight-and-split-days","title":"Reweight and Split Days\u00b6","text":"<p>In order to get the most from our small sample we treat individual diary days as new persons. In order to maintain the original household weighting we reduce this accordingly.</p>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#load-into-pam","title":"Load into PAM\u00b6","text":"<p>We load the pandas formatted data into Pam using the <code>pam.read.load_travel_diary_from_to</code> read method. We do some very preliminary validation of plans and assurance.</p>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#sample-the-population","title":"Sample the Population\u00b6","text":"<p>We sample a very small population based on the given NTS household weightings.</p>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#facility-sampling","title":"Facility Sampling\u00b6\u00b6","text":"<p>The facilities input is prepared using a separate project called OSM-Facility Sampler (OSMFS). This project woulbe be better names the OSM Facility Extractor. We use it to extract viable activity locations for each activity type for each zone. This project is not currently open source, but is described below:</p> <p>OSMFS joins osm data with the geographies of an area to create a mapping between zones, acts and facility locations (points). This is output as a geojson:</p> <p>{\"type\": \"FeatureCollection\", \"features\": [{\"id\": \"0\", \"type\": \"Feature\", \"properties\": {\"activity\": \"other\"}, \"geometry\": {\"type\": \"Point\", \"coordinates\": [-4.5235751, 54.1698685]}},</p> <p>todo: the current methodology does not support shared facilities, ie facilities with more than one activity (schools are places of education and work for example).</p> <p>todo: the above json has to be rejoined with the geography to create a spatial sampler. This is a duplicated operation which could be included in the Bench output, eg:</p> <p>zone_id: activity: (id, point)</p>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#random-sampler","title":"Random Sampler\u00b6","text":"<p>Failing a facility sampler - we can use random sampling instead.</p>"},{"location":"examples/04_Example_Ingest_NTS_Diaries/#write-to-disk","title":"Write to Disk\u00b6","text":"<ol> <li>write MATSim formats to disk (plans and attributes)</li> <li>write csv and geojson summaries to disk</li> <li>write MATSim formatted facilities to disk</li> </ol>"},{"location":"examples/07_PAM_Point_Sampling/","title":"PAM Point Sampling","text":"In\u00a0[1]: Copied! <pre>import os\nimport pandas as pd\nfrom copy import deepcopy\nfrom collections import defaultdict\nimport geopandas as gp\nfrom matplotlib import pyplot as plt\nimport numpy as np\n</pre> import os import pandas as pd from copy import deepcopy from collections import defaultdict import geopandas as gp from matplotlib import pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>trips = pd.read_csv(os.path.join('data', 'example_data', 'example_travel_diaries.csv'), index_col=\"uid\")\nattributes = pd.read_csv(os.path.join('data', 'example_data', 'example_attributes.csv'), index_col=\"pid\")\ntrips.head(10)\n</pre> trips = pd.read_csv(os.path.join('data', 'example_data', 'example_travel_diaries.csv'), index_col=\"uid\") attributes = pd.read_csv(os.path.join('data', 'example_data', 'example_attributes.csv'), index_col=\"pid\") trips.head(10) Out[2]: pid hid seq hzone ozone dzone purp mode tst tet freq uid 0 census_0 census_0 0 Harrow Harrow Camden work pt 444 473 1000 1 census_0 census_0 1 Harrow Camden Harrow work pt 890 919 1000 2 census_1 census_1 0 Greenwich Greenwich Tower Hamlets work pt 507 528 1000 3 census_1 census_1 1 Greenwich Tower Hamlets Greenwich work pt 1065 1086 1000 4 census_2 census_2 0 Croydon Croydon Croydon work pt 422 425 1000 5 census_2 census_2 1 Croydon Croydon Croydon work pt 917 920 1000 6 census_3 census_3 0 Haringey Haringey Redbridge work pt 428 447 1000 7 census_3 census_3 1 Haringey Redbridge Haringey work pt 1007 1026 1000 8 census_4 census_4 0 Hounslow Hounslow Westminster,City of London work car 483 516 1000 9 census_4 census_4 1 Hounslow Westminster,City of London Hounslow work car 1017 1050 1000 In\u00a0[3]: Copied! <pre>from pam import read\n\npopulation = read.load_travel_diary(\n    trips, attributes\n)\npopulation.stats\n</pre> from pam import read  population = read.load_travel_diary(     trips, attributes ) population.stats <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all persons.\n</pre> Out[3]: <pre>{'num_households': 51,\n 'num_people': 51,\n 'num_activities': 152,\n 'num_legs': 101}</pre> In\u00a0[4]: Copied! <pre>zones = gp.read_file(os.path.join('data', 'example_data', 'geometry.geojson')).set_index('NAME')\nzones.head()\n</pre> zones = gp.read_file(os.path.join('data', 'example_data', 'geometry.geojson')).set_index('NAME') zones.head() Out[4]: HECTARES NONLD_AREA ONS_INNER SUB_2009 SUB_2006 geometry NAME Kingston upon Thames 3726.117 0.000 F None None POLYGON ((516401.600 160201.800, 516407.300 16... Croydon 8649.441 0.000 F None None POLYGON ((535009.200 159504.700, 535005.500 15... Bromley 15013.487 0.000 F None None POLYGON ((540373.600 157530.400, 540361.200 15... Hounslow 5658.541 60.755 F None None POLYGON ((521975.800 178100.000, 521967.700 17... Ealing 5554.428 0.000 F None None POLYGON ((510253.500 182881.600, 510249.900 18... In\u00a0[5]: Copied! <pre>from pam.samplers.spatial import RandomPointSampler\n\nrandom_sampler = RandomPointSampler(geoms=zones)\n</pre> from pam.samplers.spatial import RandomPointSampler  random_sampler = RandomPointSampler(geoms=zones) In\u00a0[6]: Copied! <pre># test\nfig, ax = plt.subplots(1)\nzones.plot(ax=ax, color=\"grey\")\nzones.loc[[\"Camden\"]].plot(ax=ax)\npoint = random_sampler.sample(\"Camden\", activity=None)\nax.scatter(point.x, point.y, c=\"red\")\n</pre> # test fig, ax = plt.subplots(1) zones.plot(ax=ax, color=\"grey\") zones.loc[[\"Camden\"]].plot(ax=ax) point = random_sampler.sample(\"Camden\", activity=None) ax.scatter(point.x, point.y, c=\"red\") Out[6]: <pre>&lt;matplotlib.collections.PathCollection at 0x11b562668&gt;</pre> In\u00a0[7]: Copied! <pre>population.sample_locs(random_sampler)  # apply to whole population\n</pre> population.sample_locs(random_sampler)  # apply to whole population <p>Let's check out an example Activity Plan and Attributes:</p> In\u00a0[8]: Copied! <pre>person = population['census_0']['census_0']\nperson.print()\nperson.plot()\n</pre> person = population['census_0']['census_0'] person.print() person.plot() <pre>Person: census_0\n{'gender': 'female', 'job': 'work', 'occ': 'white', 'inc': 'low', 'hzone': 'Harrow'}\n0:\tActivity(act:home, location:POINT (512224.4052986615 188356.22336932842), time:00:00:00 --&gt; 07:24:00, duration:7:24:00)\n1:\tLeg(mode:pt, area:POINT (512224.4052986615 188356.22336932842) --&gt; POINT (528709.0867940192 182773.66078482044), time:07:24:00 --&gt; 07:53:00, duration:0:29:00)\n2:\tActivity(act:work, location:POINT (528709.0867940192 182773.66078482044), time:07:53:00 --&gt; 14:50:00, duration:6:57:00)\n3:\tLeg(mode:pt, area:POINT (528709.0867940192 182773.66078482044) --&gt; POINT (512224.4052986615 188356.22336932842), time:14:50:00 --&gt; 15:19:00, duration:0:29:00)\n4:\tActivity(act:home, location:POINT (512224.4052986615 188356.22336932842), time:15:19:00 --&gt; 00:00:00, duration:8:41:00)\n</pre>"},{"location":"examples/07_PAM_Point_Sampling/#pam-geometry-sampling","title":"PAM - Geometry Sampling\u00b6","text":"<p>MATSim requires point locations for all activities and trips. This notebook shows how to sample geometric locations from ozone/dzone regions using a simple random point sampler.</p> <p>More advanced samplers are available in <code>pam.samplers.spatial</code>.</p>"},{"location":"examples/07_PAM_Point_Sampling/#sample-geometries","title":"Sample Geometries\u00b6","text":"<p>Transform trip ozone/dzone to geographically sampled points</p>"},{"location":"examples/14_Advanced_Plan_Cropping/","title":"Advanced Plan Cropping","text":"<pre><code>Simplify any activities happening outside a defined \"core\" area.\n\nMethod:\n 1: Identify which legs touch the core area\n 2: Keep the relevant legs/activities and drop the remaining components\n 3: Infill: create any new legs between external activities as necessary\n 4: Ensure plan consistency: start/end times, sequences, etc\n 5: (optional) : Rename activities to \"external\"\n 6: (optional) : Crop the leg geometries to start/stop at the core area boundaries \n</code></pre> In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport os\nfrom copy import deepcopy\nfrom pam.core import Population, Household, Person\nfrom pam.operations import cropping\nfrom pam.activity import Activity, Leg, Plan\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\nfrom shapely.geometry import Point, Polygon\nimport geopandas as gp\nfrom copy import deepcopy\n</pre> import matplotlib.pyplot as plt import os from copy import deepcopy from pam.core import Population, Household, Person from pam.operations import cropping from pam.activity import Activity, Leg, Plan from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY from shapely.geometry import Point, Polygon import geopandas as gp from copy import deepcopy <p>Create a simple zoning system:</p> In\u00a0[2]: Copied! <pre>def test_zoning_system() -&gt; gp.GeoDataFrame:\n\"\"\"\n    Dummy orthogonal zoning system\n    \"\"\"\n    zones = []\n    labels = [chr(x) for x in range(97, 106)]\n    for x in range(3):\n        for y in range(3):\n            zones.append(\n                Polygon([(x, y), (x, y+1), (x+1, y+1), (x+1, y)])\n            )\n    zones_gdf = gp.GeoDataFrame({'zone': labels}, geometry=zones)\n    zones_gdf.index = zones_gdf.zone\n\n    return zones_gdf\n\nzoning_system = test_zoning_system()\n</pre> def test_zoning_system() -&gt; gp.GeoDataFrame:     \"\"\"     Dummy orthogonal zoning system     \"\"\"     zones = []     labels = [chr(x) for x in range(97, 106)]     for x in range(3):         for y in range(3):             zones.append(                 Polygon([(x, y), (x, y+1), (x+1, y+1), (x+1, y)])             )     zones_gdf = gp.GeoDataFrame({'zone': labels}, geometry=zones)     zones_gdf.index = zones_gdf.zone      return zones_gdf  zoning_system = test_zoning_system() <p>Create a simple plan:</p> In\u00a0[3]: Copied! <pre>plan = Plan()\nplan.day = [\n    Activity(seq=1, act='home', loc=Point(0.31, 0.81),\n             start_time=mtdt(0), end_time=mtdt(420)),\n    Leg(seq=1, mode='car', start_loc=Point(0.31, 0.81), end_loc=Point(0.12, 1.45),\n        start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(seq=2, act='shop', loc=Point(0.12, 1.45),\n             start_time=mtdt(480), end_time=mtdt(510)),\n    Leg(seq=2, mode='car', start_loc=Point(0.12, 1.45), end_loc=Point(0.84, 2.12),\n        start_time=mtdt(510), end_time=mtdt(540), distance=1000),\n    Activity(seq=3, act='work', loc=Point(0.84, 2.12),\n             start_time=mtdt(540), end_time=mtdt(800)),\n    Leg(seq=3, mode='walk', start_loc=Point(0.84, 2.12), end_loc=Point(1.90, 0.23),\n        start_time=mtdt(800), end_time=mtdt(900), distance=1000),\n    Activity(seq=4, act='medical', loc=Point(1.90, 0.23),\n             start_time=mtdt(900), end_time=mtdt(960)),\n    Leg(seq=4, mode='walk', start_loc=Point(1.90, 0.23), end_loc=Point(2.26, 0.24),\n        start_time=mtdt(960), end_time=mtdt(990), distance=1000),\n    Activity(seq=5, act='other', loc=Point(2.26, 0.24),\n             start_time=mtdt(990), end_time=mtdt(1010)),\n    Leg(seq=5, mode='walk', start_loc=Point(2.26, 0.24), end_loc=Point(2.77, 1.82),\n        start_time=mtdt(1010), end_time=mtdt(1030), distance=1000),\n    Activity(seq=6, act='other', loc=Point(2.77, 1.82),\n             start_time=mtdt(1030), end_time=mtdt(1060)),\n    Leg(seq=6, mode='walk', start_loc=Point(2.77, 1.82), end_loc=Point(1.88, 1.72),\n        start_time=mtdt(1060), end_time=mtdt(1100), distance=1000),\n    Activity(seq=7, act='other', loc=Point(1.88, 1.72),\n             start_time=mtdt(1100), end_time=mtdt(1200)),\n    Leg(seq=7, mode='car', start_loc=Point(1.88, 1.72), end_loc=Point(0.23, 0.10),\n        start_time=mtdt(1200), end_time=mtdt(1210), distance=1000),\n    Activity(seq=8, act='home', loc=Point(0.23, 0.10),\n             start_time=mtdt(1210), end_time=END_OF_DAY)\n]\n    \nhh = Household(1, loc=Point(0.31, 0.81))\npopulation = Population()\nperson = Person(1)\nperson.plan = plan\nhh.add(person)\npopulation.add(hh)\n</pre> plan = Plan() plan.day = [     Activity(seq=1, act='home', loc=Point(0.31, 0.81),              start_time=mtdt(0), end_time=mtdt(420)),     Leg(seq=1, mode='car', start_loc=Point(0.31, 0.81), end_loc=Point(0.12, 1.45),         start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(seq=2, act='shop', loc=Point(0.12, 1.45),              start_time=mtdt(480), end_time=mtdt(510)),     Leg(seq=2, mode='car', start_loc=Point(0.12, 1.45), end_loc=Point(0.84, 2.12),         start_time=mtdt(510), end_time=mtdt(540), distance=1000),     Activity(seq=3, act='work', loc=Point(0.84, 2.12),              start_time=mtdt(540), end_time=mtdt(800)),     Leg(seq=3, mode='walk', start_loc=Point(0.84, 2.12), end_loc=Point(1.90, 0.23),         start_time=mtdt(800), end_time=mtdt(900), distance=1000),     Activity(seq=4, act='medical', loc=Point(1.90, 0.23),              start_time=mtdt(900), end_time=mtdt(960)),     Leg(seq=4, mode='walk', start_loc=Point(1.90, 0.23), end_loc=Point(2.26, 0.24),         start_time=mtdt(960), end_time=mtdt(990), distance=1000),     Activity(seq=5, act='other', loc=Point(2.26, 0.24),              start_time=mtdt(990), end_time=mtdt(1010)),     Leg(seq=5, mode='walk', start_loc=Point(2.26, 0.24), end_loc=Point(2.77, 1.82),         start_time=mtdt(1010), end_time=mtdt(1030), distance=1000),     Activity(seq=6, act='other', loc=Point(2.77, 1.82),              start_time=mtdt(1030), end_time=mtdt(1060)),     Leg(seq=6, mode='walk', start_loc=Point(2.77, 1.82), end_loc=Point(1.88, 1.72),         start_time=mtdt(1060), end_time=mtdt(1100), distance=1000),     Activity(seq=7, act='other', loc=Point(1.88, 1.72),              start_time=mtdt(1100), end_time=mtdt(1200)),     Leg(seq=7, mode='car', start_loc=Point(1.88, 1.72), end_loc=Point(0.23, 0.10),         start_time=mtdt(1200), end_time=mtdt(1210), distance=1000),     Activity(seq=8, act='home', loc=Point(0.23, 0.10),              start_time=mtdt(1210), end_time=END_OF_DAY) ]      hh = Household(1, loc=Point(0.31, 0.81)) population = Population() person = Person(1) person.plan = plan hh.add(person) population.add(hh) <p>The core area scope is defined as a geometry:</p> In\u00a0[4]: Copied! <pre>def plot_legs(plan: Plan):\n    for i, leg in enumerate(plan.legs):\n        path = cropping.get_leg_path(leg)\n        plt.annotate(\n            i,\n            xy=(path.xy[0][1], path.xy[1][1]),\n            xytext=(path.xy[0][0], path.xy[1][0]),\n            arrowprops={\"arrowstyle\": \"-&gt;\", \"color\": \"gray\"}\n        )\n</pre> def plot_legs(plan: Plan):     for i, leg in enumerate(plan.legs):         path = cropping.get_leg_path(leg)         plt.annotate(             i,             xy=(path.xy[0][1], path.xy[1][1]),             xytext=(path.xy[0][0], path.xy[1][0]),             arrowprops={\"arrowstyle\": \"-&gt;\", \"color\": \"gray\"}         ) In\u00a0[5]: Copied! <pre>fig, ax = plt.subplots(1,1, figsize=(10,10))\nzoning_system.boundary.plot(ax=ax)\nfor i, irow in zoning_system.iterrows():\n    x = irow.geometry.centroid.x\n    y = irow.geometry.centroid.y\n    plt.annotate(irow.zone, xy=(x, y))\nplot_legs(plan)\n\nplan.plot()\n</pre> fig, ax = plt.subplots(1,1, figsize=(10,10)) zoning_system.boundary.plot(ax=ax) for i, irow in zoning_system.iterrows():     x = irow.geometry.centroid.x     y = irow.geometry.centroid.y     plt.annotate(irow.zone, xy=(x, y)) plot_legs(plan)  plan.plot() <p>Trips that enter or exit the core area (here, zone <code>h</code>) are kept in the agent's plan:</p> In\u00a0[6]: Copied! <pre>boundary = zoning_system.loc['h'].geometry\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n</pre> boundary = zoning_system.loc['h'].geometry  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)  In\u00a0[7]: Copied! <pre>def plot_results(plan: Plan, boundary: gp.GeoDataFrame):\n    fig, ax = plt.subplots(1,1, figsize=(10,10))\n    zoning_system.boundary.plot(ax=ax)\n    for i, irow in zoning_system.iterrows():\n        x = irow.geometry.centroid.x\n        y = irow.geometry.centroid.y\n        plt.annotate(irow.zone, xy=(x, y))\n    gp.GeoSeries([boundary]).boundary.plot(ax=ax, color='red')\n    plot_legs(plan)\n    plt.title('Cropped plan')\n\n    plan.plot()\n\nplot_results(plan_cropped, boundary)\n</pre> def plot_results(plan: Plan, boundary: gp.GeoDataFrame):     fig, ax = plt.subplots(1,1, figsize=(10,10))     zoning_system.boundary.plot(ax=ax)     for i, irow in zoning_system.iterrows():         x = irow.geometry.centroid.x         y = irow.geometry.centroid.y         plt.annotate(irow.zone, xy=(x, y))     gp.GeoSeries([boundary]).boundary.plot(ax=ax, color='red')     plot_legs(plan)     plt.title('Cropped plan')      plan.plot()  plot_results(plan_cropped, boundary) <p>Any trips that are expected to go through the core area (as a straight-line path) are retained in the plan:</p> In\u00a0[8]: Copied! <pre># define boundary\nboundary = zoning_system.loc['e'].geometry\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n\n\nplot_results(plan_cropped, boundary)\n</pre> # define boundary boundary = zoning_system.loc['e'].geometry  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)   plot_results(plan_cropped, boundary) <p>By passing the <code>snap_to_boundary=True</code> argument, we can completely remove any leg parts that fall outside the core area:</p> In\u00a0[9]: Copied! <pre># crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary, snap_to_boundary=True)\n\n# plot\nplot_results(plan_cropped, boundary)\n</pre> # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary, snap_to_boundary=True)  # plot plot_results(plan_cropped, boundary) <p>If no leg crosses the core area (here, zone i), then an empty plan is returned, and the person is removed from the population:</p> In\u00a0[10]: Copied! <pre>boundary = zoning_system.loc['i'].geometry\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n\n# plot\nplot_results(plan_cropped, boundary)\n</pre> boundary = zoning_system.loc['i'].geometry  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)  # plot plot_results(plan_cropped, boundary) <p>Any agents with fully external plans are dropped entirely:</p> In\u00a0[11]: Copied! <pre>population_cropped = deepcopy(population)\nassert len(population_cropped) == 1\n\n# after simplification, there are no agents left\ncropping.simplify_population(population_cropped, boundary)\nassert len(population_cropped) == 0\n</pre> population_cropped = deepcopy(population) assert len(population_cropped) == 1  # after simplification, there are no agents left cropping.simplify_population(population_cropped, boundary) assert len(population_cropped) == 0 <p>If all activities fall within the core area, plans remain unchanged:</p> In\u00a0[12]: Copied! <pre>boundary = zoning_system.dissolve().geometry[0]\n\n# crop\nplan_cropped = deepcopy(plan)\ncropping.simplify_external_plans(plan_cropped, boundary)\n\n# plot\nplot_results(plan_cropped, boundary)\n</pre> boundary = zoning_system.dissolve().geometry[0]  # crop plan_cropped = deepcopy(plan) cropping.simplify_external_plans(plan_cropped, boundary)  # plot plot_results(plan_cropped, boundary)"},{"location":"examples/14_Advanced_Plan_Cropping/#introduction","title":"Introduction\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#data","title":"Data\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#examples","title":"Examples\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-1-internal-external-trips","title":"Example 1 - Internal-external trips\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-2-through-trips","title":"Example 2 - Through trips\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-3-snap-trip-ends-to-zone-boundaries","title":"Example 3 - Snap trip ends to zone boundaries\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-3-fully-external-plan","title":"Example 3 - Fully external plan\u00b6","text":""},{"location":"examples/14_Advanced_Plan_Cropping/#example-4-fully-internal-plan","title":"Example 4 - Fully internal plan\u00b6","text":""},{"location":"examples/01_PAM_Getting_Started/","title":"PAM Getting Started","text":"In\u00a0[1]: Copied! <pre>import os\nimport pandas as pd\nfrom copy import deepcopy\nfrom collections import defaultdict\nimport geopandas as gp\nfrom matplotlib import pyplot as plt\n%matplotlib inline\n</pre> import os import pandas as pd from copy import deepcopy from collections import defaultdict import geopandas as gp from matplotlib import pyplot as plt %matplotlib inline In\u00a0[2]: Copied! <pre># these paths assume you are running this notebook from the 'examples' directory\ntrips = pd.read_csv(os.path.join(\"data\", \"example_data\", 'example_travel_diaries.csv'), index_col = \"uid\")\nattributes = pd.read_csv(os.path.join(\"data\", \"example_data\", 'example_attributes.csv'), index_col = \"pid\")\n</pre> # these paths assume you are running this notebook from the 'examples' directory trips = pd.read_csv(os.path.join(\"data\", \"example_data\", 'example_travel_diaries.csv'), index_col = \"uid\") attributes = pd.read_csv(os.path.join(\"data\", \"example_data\", 'example_attributes.csv'), index_col = \"pid\") In\u00a0[3]: Copied! <pre>trips.head(10)\n</pre> trips.head(10) Out[3]: pid hid seq hzone ozone dzone purp mode tst tet freq uid 0 census_0 census_0 0 Harrow Harrow Camden work pt 444 473 1000 1 census_0 census_0 1 Harrow Camden Harrow work pt 890 919 1000 2 census_1 census_1 0 Greenwich Greenwich Tower Hamlets work pt 507 528 1000 3 census_1 census_1 1 Greenwich Tower Hamlets Greenwich work pt 1065 1086 1000 4 census_2 census_2 0 Croydon Croydon Croydon work pt 422 425 1000 5 census_2 census_2 1 Croydon Croydon Croydon work pt 917 920 1000 6 census_3 census_3 0 Haringey Haringey Redbridge work pt 428 447 1000 7 census_3 census_3 1 Haringey Redbridge Haringey work pt 1007 1026 1000 8 census_4 census_4 0 Hounslow Hounslow Westminster,City of London work car 483 516 1000 9 census_4 census_4 1 Hounslow Westminster,City of London Hounslow work car 1017 1050 1000 In\u00a0[4]: Copied! <pre>from pam import read\npopulation = read.load_travel_diary(trips, attributes, trip_freq_as_person_freq=True)\n</pre> from pam import read population = read.load_travel_diary(trips, attributes, trip_freq_as_person_freq=True) <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all trips.\n</pre> <p>Let's check out an example Activity Plan and Attributes:</p> In\u00a0[5]: Copied! <pre>household = population.households['census_12']\nperson = household.people['census_12']\nperson.print()\n</pre> household = population.households['census_12'] person = household.people['census_12'] person.print() <pre>Person: census_12\n{'gender': 'female', 'job': 'education', 'occ': 'white', 'inc': 'high', 'hzone': 'Croydon'}\n0:\tActivity(act:home, location:Croydon, time:00:00:00 --&gt; 07:06:00, duration:7:06:00)\n1:\tLeg(mode:pt, area:Croydon --&gt; Tower Hamlets, time:07:06:00 --&gt; 07:45:00, duration:0:39:00)\n2:\tActivity(act:education, location:Tower Hamlets, time:07:45:00 --&gt; 15:54:00, duration:8:09:00)\n3:\tLeg(mode:pt, area:Tower Hamlets --&gt; Croydon, time:15:54:00 --&gt; 16:33:00, duration:0:39:00)\n4:\tActivity(act:home, location:Croydon, time:16:33:00 --&gt; 00:00:00, duration:7:27:00)\n</pre> <p>Before we do any activity modification - we create a simple function to extract some example statistics. We include this as a simple demo, but would love to add more.</p> <p>Note that activity plans allow us to consider detailed joint segmentations, such as socio-economic, spatial, temporal, modal, activity sequence and so on.</p> In\u00a0[6]: Copied! <pre>def print_simple_stats(population):\n\"\"\"\n    Print some simple population statistics.\n    \"\"\"\n    time_at_home = 0\n    travel_time = 0 \n    low_income_central_trips = 0\n    high_income_central_trips = 0\n    \n    for hid, hh in population.households.items():\n        for pid, person in hh.people.items():\n            freq = person.freq\n            \n            for p in person.plan:\n                if p.act == 'travel':\n                    duration = p.duration.seconds * freq / 3600\n                    travel_time += duration\n                    \n                    if p.end_location.area == \"Westminster,City of London\":\n                        if person.attributes['inc'] == \"low\":\n                            low_income_central_trips += freq\n                            \n                        elif person.attributes['inc'] == \"high\":\n                            high_income_central_trips += freq\n                    \n                else:  # activity\n                    if p.act == 'home':\n                        duration = p.duration.seconds * freq / 3600\n                        time_at_home += duration\n                        \n    print(f\"Population total time at home: {time_at_home/1000000:.2f} million hours\")\n    print(f\"Population total travel time: {travel_time/1000000:.2f} million hours\")\n    print(f\"Low income trips to Central London: {low_income_central_trips} trips\")\n    print(f\"High income trips to Central London: {high_income_central_trips} trips\")\n</pre> def print_simple_stats(population):     \"\"\"     Print some simple population statistics.     \"\"\"     time_at_home = 0     travel_time = 0      low_income_central_trips = 0     high_income_central_trips = 0          for hid, hh in population.households.items():         for pid, person in hh.people.items():             freq = person.freq                          for p in person.plan:                 if p.act == 'travel':                     duration = p.duration.seconds * freq / 3600                     travel_time += duration                                          if p.end_location.area == \"Westminster,City of London\":                         if person.attributes['inc'] == \"low\":                             low_income_central_trips += freq                                                      elif person.attributes['inc'] == \"high\":                             high_income_central_trips += freq                                      else:  # activity                     if p.act == 'home':                         duration = p.duration.seconds * freq / 3600                         time_at_home += duration                              print(f\"Population total time at home: {time_at_home/1000000:.2f} million hours\")     print(f\"Population total travel time: {travel_time/1000000:.2f} million hours\")     print(f\"Low income trips to Central London: {low_income_central_trips} trips\")     print(f\"High income trips to Central London: {high_income_central_trips} trips\")                          In\u00a0[7]: Copied! <pre>print_simple_stats(population)\n</pre> print_simple_stats(population) <pre>Population total time at home: 0.76 million hours\nPopulation total travel time: 0.03 million hours\nLow income trips to Central London: 3000 trips\nHigh income trips to Central London: 4000 trips\n</pre> In\u00a0[8]: Copied! <pre>def plot_simple_stats(population):\n\"\"\"\n    Plot some simple population statistics.\n    \"\"\"\n    geoms = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\"))\n\n    departures = defaultdict(int)\n    arrivals = defaultdict(int)\n    \n    for hid, hh in population.households.items():\n        for pid, person in hh.people.items():\n            freq = person.freq\n            \n            for p in person.plan:\n                if p.act == 'travel':\n                    departures[p.start_location.area] += freq\n                    arrivals[p.end_location.area] += freq\n    geoms['departures'] = geoms.NAME.map(departures)\n    geoms['arrivals'] = geoms.NAME.map(arrivals)\n        \n    fig, ax = plt.subplots(1,2, figsize=(16,6))\n    for i, name in enumerate(['departures', 'arrivals']):\n        \n        ax[i].title.set_text(name)\n        geoms.plot(name, ax=ax[i])\n        ax[i].axis('off')\n</pre> def plot_simple_stats(population):     \"\"\"     Plot some simple population statistics.     \"\"\"     geoms = gp.read_file(os.path.join(\"data\", \"example_data\", \"geometry.geojson\"))      departures = defaultdict(int)     arrivals = defaultdict(int)          for hid, hh in population.households.items():         for pid, person in hh.people.items():             freq = person.freq                          for p in person.plan:                 if p.act == 'travel':                     departures[p.start_location.area] += freq                     arrivals[p.end_location.area] += freq     geoms['departures'] = geoms.NAME.map(departures)     geoms['arrivals'] = geoms.NAME.map(arrivals)              fig, ax = plt.subplots(1,2, figsize=(16,6))     for i, name in enumerate(['departures', 'arrivals']):                  ax[i].title.set_text(name)         geoms.plot(name, ax=ax[i])         ax[i].axis('off')  In\u00a0[9]: Copied! <pre>plot_simple_stats(population)\n</pre> plot_simple_stats(population) In\u00a0[10]: Copied! <pre>from pam import policy\nfrom pam.policy import apply_policies\n\npolicy1 = policy.HouseholdQuarantined(probability=0.025)\npolicy2 = policy.PersonStayAtHome(probability=0.1)\npolicy3 = policy.RemoveHouseholdActivities(['education', 'work'], probability=0.9)\n\ndo_minimum = apply_policies(population, [policy1, policy2])\nlockdown = apply_policies(population, [policy1, policy2, policy3])\n</pre> from pam import policy from pam.policy import apply_policies  policy1 = policy.HouseholdQuarantined(probability=0.025) policy2 = policy.PersonStayAtHome(probability=0.1) policy3 = policy.RemoveHouseholdActivities(['education', 'work'], probability=0.9)  do_minimum = apply_policies(population, [policy1, policy2]) lockdown = apply_policies(population, [policy1, policy2, policy3]) In\u00a0[11]: Copied! <pre>print_simple_stats(do_minimum)\nplot_simple_stats(do_minimum)\n</pre> print_simple_stats(do_minimum) plot_simple_stats(do_minimum) <pre>Population total time at home: 0.67 million hours\nPopulation total travel time: 0.02 million hours\nLow income trips to Central London: 1000 trips\nHigh income trips to Central London: 4000 trips\n</pre> In\u00a0[12]: Copied! <pre>print_simple_stats(lockdown)\nplot_simple_stats(lockdown)\n</pre> print_simple_stats(lockdown) plot_simple_stats(lockdown) <pre>Population total time at home: 0.04 million hours\nPopulation total travel time: 0.00 million hours\nLow income trips to Central London: 1000 trips\nHigh income trips to Central London: 0 trips\n</pre>"},{"location":"examples/01_PAM_Getting_Started/#pam-getting-started","title":"PAM - Getting Started\u00b6","text":"<p>Pandemic Activity Modelling/Modifying</p> <p>This notebook is a quick spin through PAM. Intended to provide a technical overview and inspire further research and development.</p>"},{"location":"examples/01_PAM_Getting_Started/#load-data","title":"Load Data\u00b6","text":"<p>Here we load simple travel diary data of London commuters. This is a very simple 0.1% sample of data about work and education commutes from the 2011 census. Because we're sharing this date - we've aggregated locations to borough level and randomized personal attributes - so don't get too excited about the results.</p> <p>The data is available in <code>pam/example_data</code>.</p>"},{"location":"examples/01_PAM_Getting_Started/#build-activity-plans","title":"Build Activity Plans\u00b6","text":"<p>First we convert the travel diary data to Activity Plans:</p>"},{"location":"examples/01_PAM_Getting_Started/#scenarios","title":"Scenarios\u00b6","text":"<p>Our 2011 baseline London population of commuters seems sensible, they spend about 50 million hours at home and 1.6 million hours travelling.</p> <p>But what if we want to try and build some more up to date scenarios?</p> <p>We consider two scenarios from a combination of policies:</p> <p>Scenario A - Do Minimum:</p> <ol> <li>A household will be quarantined with p=0.025 (for example due to a possitive virus test within the household)</li> <li>A person will be staying at home (self isolating) with p=0.1 (for example due to being a vulnerable person)</li> </ol> <p>Scenario B - Lockdown:</p> <ol> <li>As above plus education and work activities will be removed and plans adjusted with p=0.9 (for example because schools and work places are closed)</li> </ol>"},{"location":"examples/01_PAM_Getting_Started/#review","title":"Review\u00b6","text":"<p>So this has been a pretty quick and dirty demo. But we can still take a look at our new population scenario stats below. Obviously we'd like to add some more analytics... some viz... some validation... then output new travel plans and OD matrices for use in other models.</p>"},{"location":"examples/02_Population_Basics/","title":"Population Basics","text":"<p>This notebook demonstrates an example workflow for creating a sample population manually. In most applications this is not required (you are more likelly to inject a travel diary or a MATSim plans file)but the exercide is useful to understand the underlying data structure.</p> In\u00a0[1]: Copied! <pre>from pam.core import Population, Household, Person\n\npopulation = Population()  # initialise an empty population\n\nhousehold = Household(\n    hid=0,\n    attributes={\"cars\": 1}\n    )\n\nperson = Person(\n    pid=0,\n    attributes={\"income\": \"medium\"}\n    )\n\nhousehold.add(person)\npopulation.add(household)\n\npopulation.stats\n</pre> from pam.core import Population, Household, Person  population = Population()  # initialise an empty population  household = Household(     hid=0,     attributes={\"cars\": 1}     )  person = Person(     pid=0,     attributes={\"income\": \"medium\"}     )  household.add(person) population.add(household)  population.stats Out[1]: <pre>{'num_households': 1, 'num_people': 1, 'num_activities': 0, 'num_legs': 0}</pre> In\u00a0[2]: Copied! <pre>from pam.activity import Activity, Trip\nfrom pam.utils import minutes_to_datetime as mtdt\n\nactivity = Activity(\n    act='home',\n    area=\"A\",\n    start_time=mtdt(0),\n    end_time=mtdt(445)\n)\n\ntrip = Trip(\n    mode='car',\n    start_area=\"A\",\n    end_area=\"B\",\n    start_time=mtdt(445),\n    end_time=mtdt(505)\n)\n\nprint(activity)\nprint(trip)\n</pre> from pam.activity import Activity, Trip from pam.utils import minutes_to_datetime as mtdt  activity = Activity(     act='home',     area=\"A\",     start_time=mtdt(0),     end_time=mtdt(445) )  trip = Trip(     mode='car',     start_area=\"A\",     end_area=\"B\",     start_time=mtdt(445),     end_time=mtdt(505) )  print(activity) print(trip) <pre>Activity(act:home, location:A, time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\nLeg(mode:car, area:A --&gt; B, time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n</pre> <p>Activities and Trips can be added to a Person object using <code>Person.add</code>:</p> In\u00a0[3]: Copied! <pre>person = Person(pid=0, attributes={\"type\": \"example\"})\n\nperson.add(Activity(\n    act='home',\n    area=\"A\",\n    start_time=mtdt(0),\n    end_time=mtdt(445)\n))\nperson.add(Trip(\n    mode='car',\n    start_area=\"A\",\n    end_area=\"B\",\n    start_time=mtdt(445),\n    end_time=mtdt(505)\n))\nperson.add(Activity(\n    act='hotel',\n    area=\"B\",\n    start_time=mtdt(505),\n    end_time=mtdt(1000)\n))\n\nperson.validate()  # the validate method check for consistency in the sequence of locations and times\nperson.print()\n</pre> person = Person(pid=0, attributes={\"type\": \"example\"})  person.add(Activity(     act='home',     area=\"A\",     start_time=mtdt(0),     end_time=mtdt(445) )) person.add(Trip(     mode='car',     start_area=\"A\",     end_area=\"B\",     start_time=mtdt(445),     end_time=mtdt(505) )) person.add(Activity(     act='hotel',     area=\"B\",     start_time=mtdt(505),     end_time=mtdt(1000) ))  person.validate()  # the validate method check for consistency in the sequence of locations and times person.print() <pre>Person: 0\n{'type': 'example'}\n0:\tActivity(act:home, location:A, time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\n1:\tLeg(mode:car, area:A --&gt; B, time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n2:\tActivity(act:hotel, location:B, time:08:25:00 --&gt; 16:40:00, duration:8:15:00)\n</pre> In\u00a0[4]: Copied! <pre>from shapely.geometry import Point\n\nperson = Person(pid=0, attributes={\"type\": \"example\"})\n\nperson.add(Activity(\n    act='home',\n    area=\"A\",\n    loc=Point((0,0)),\n    start_time=mtdt(0),\n    end_time=mtdt(445)\n))\nperson.add(Trip(\n    mode='car',\n    start_area=\"A\",\n    end_area=\"B\",\n    start_loc=Point((0,0)),\n    end_loc=Point((1234,1234)),\n    start_time=mtdt(445),\n    end_time=mtdt(505)\n))\nperson.add(Activity(\n    act='hotel',\n    area=\"B\",\n    start_time=mtdt(505),\n    end_time=mtdt(1000)\n))\n\nperson.validate()  # the validate method check for consistency in the sequence of locations and times\nperson.print()\n</pre> from shapely.geometry import Point  person = Person(pid=0, attributes={\"type\": \"example\"})  person.add(Activity(     act='home',     area=\"A\",     loc=Point((0,0)),     start_time=mtdt(0),     end_time=mtdt(445) )) person.add(Trip(     mode='car',     start_area=\"A\",     end_area=\"B\",     start_loc=Point((0,0)),     end_loc=Point((1234,1234)),     start_time=mtdt(445),     end_time=mtdt(505) )) person.add(Activity(     act='hotel',     area=\"B\",     start_time=mtdt(505),     end_time=mtdt(1000) ))  person.validate()  # the validate method check for consistency in the sequence of locations and times person.print() <pre>Person: 0\n{'type': 'example'}\n0:\tActivity(act:home, location:POINT (0 0), time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\n1:\tLeg(mode:car, area:POINT (0 0) --&gt; POINT (1234 1234), time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n2:\tActivity(act:hotel, location:B, time:08:25:00 --&gt; 16:40:00, duration:8:15:00)\n</pre> In\u00a0[5]: Copied! <pre>population = Population()  # create a new empty population\n</pre> population = Population()  # create a new empty population In\u00a0[6]: Copied! <pre>the_smiths = Household(\"Smiths\")\n\ntom = Person(\"Tom\", attributes = {\"age\": \"low\"})\ntammy = Person(\"Tammy\", attributes = {\"age\": \"low\"})\nthe_smiths.add([tom, tammy])\n\npopulation.add(the_smiths)  # and add the household to the population\n\ntammy.add([\n    Activity(\n        act='home',\n        area=\"A\",\n        loc=Point((0,0)),\n        start_time=mtdt(0),\n        end_time=mtdt(445)\n    ),\n    Trip(\n        mode='car',\n        start_area=\"A\",\n        end_area=\"B\",\n        start_loc=Point((0,0)),\n        end_loc=Point((1234,1234)),\n        start_time=mtdt(445),\n        end_time=mtdt(505)\n    ),\n    Activity(\n        act='work',\n        area=\"B\",\n        loc=Point((1233,1234)),\n        start_time=mtdt(505),\n        end_time=mtdt(990)\n    ),\n    Trip(\n        mode='car',\n        start_area=\"B\",\n        end_area=\"A\",\n        start_loc=Point((1234,1234)),\n        end_loc=Point((0,0)),\n        start_time=mtdt(990),\n        end_time=mtdt(1050)\n    ),\n    Activity(\n        act='home',\n        area=\"A\",\n        loc=Point((0,0)),\n        start_time=mtdt(1050),\n        end_time=mtdt(24*60)  # assuming a 24 hour day\n    )\n])\n\ntom.add([\n    Activity(\n        act='home',\n        area=\"A\",\n        loc=Point((0,0)),\n        start_time=mtdt(0),\n        end_time=mtdt(24*60)  # assuming a 24 hour day\n    )\n])\n</pre> the_smiths = Household(\"Smiths\")  tom = Person(\"Tom\", attributes = {\"age\": \"low\"}) tammy = Person(\"Tammy\", attributes = {\"age\": \"low\"}) the_smiths.add([tom, tammy])  population.add(the_smiths)  # and add the household to the population  tammy.add([     Activity(         act='home',         area=\"A\",         loc=Point((0,0)),         start_time=mtdt(0),         end_time=mtdt(445)     ),     Trip(         mode='car',         start_area=\"A\",         end_area=\"B\",         start_loc=Point((0,0)),         end_loc=Point((1234,1234)),         start_time=mtdt(445),         end_time=mtdt(505)     ),     Activity(         act='work',         area=\"B\",         loc=Point((1233,1234)),         start_time=mtdt(505),         end_time=mtdt(990)     ),     Trip(         mode='car',         start_area=\"B\",         end_area=\"A\",         start_loc=Point((1234,1234)),         end_loc=Point((0,0)),         start_time=mtdt(990),         end_time=mtdt(1050)     ),     Activity(         act='home',         area=\"A\",         loc=Point((0,0)),         start_time=mtdt(1050),         end_time=mtdt(24*60)  # assuming a 24 hour day     ) ])  tom.add([     Activity(         act='home',         area=\"A\",         loc=Point((0,0)),         start_time=mtdt(0),         end_time=mtdt(24*60)  # assuming a 24 hour day     ) ]) In\u00a0[7]: Copied! <pre>the_smiths.plot()\n</pre> the_smiths.plot() In\u00a0[8]: Copied! <pre>milkman = Person(0, attributes = {\"bot\": \"yes\", \"electric vehicle\": \"yes\"})\n\npopulation.add(milkman)  # adding a person directly to the population is possible but a household with the same id will be auto generated\n\nmilkman.add([\n    Activity(\n        act='depot',\n        area=\"A\",\n        loc=Point((0,0)),\n        start_time=mtdt(0),\n        end_time=mtdt(300)\n    ),\n    Trip(\n        mode='car',\n        start_area=\"A\",\n        end_area=\"A\",\n        start_loc=Point((0,0)),\n        end_loc=Point((1000,1000)),\n        start_time=mtdt(300),\n        end_time=mtdt(310)\n    ),\n    Activity(\n        act='delivery',\n        area=\"A\",\n        loc=Point((1000,1000)),\n        start_time=mtdt(310),\n        end_time=mtdt(320)\n    ),\n    Trip(\n        mode='car',\n        start_area=\"A\",\n        end_area=\"A\",\n        start_loc=Point((1000,1000)),\n        end_loc=Point((0,1000)),\n        start_time=mtdt(320),\n        end_time=mtdt(330)\n    ),\n    Activity(\n        act='delivery',\n        area=\"A\",\n        loc=Point((0,1000)),\n        start_time=mtdt(330),\n        end_time=mtdt(340)\n    ),\n    Trip(\n        mode='car',\n        start_area=\"A\",\n        start_loc=Point((0,1000)),\n        end_loc=Point((0,0)),\n        end_area=\"A\",\n        start_time=mtdt(340),\n        end_time=mtdt(350)\n    ),\n    Activity(\n        act='depot',\n        area=\"A\",\n        loc=Point((0,0)),\n        start_time=mtdt(350),\n        end_time=mtdt(24*60)  # assuming a 24 hour day\n    )\n])\n</pre> milkman = Person(0, attributes = {\"bot\": \"yes\", \"electric vehicle\": \"yes\"})  population.add(milkman)  # adding a person directly to the population is possible but a household with the same id will be auto generated  milkman.add([     Activity(         act='depot',         area=\"A\",         loc=Point((0,0)),         start_time=mtdt(0),         end_time=mtdt(300)     ),     Trip(         mode='car',         start_area=\"A\",         end_area=\"A\",         start_loc=Point((0,0)),         end_loc=Point((1000,1000)),         start_time=mtdt(300),         end_time=mtdt(310)     ),     Activity(         act='delivery',         area=\"A\",         loc=Point((1000,1000)),         start_time=mtdt(310),         end_time=mtdt(320)     ),     Trip(         mode='car',         start_area=\"A\",         end_area=\"A\",         start_loc=Point((1000,1000)),         end_loc=Point((0,1000)),         start_time=mtdt(320),         end_time=mtdt(330)     ),     Activity(         act='delivery',         area=\"A\",         loc=Point((0,1000)),         start_time=mtdt(330),         end_time=mtdt(340)     ),     Trip(         mode='car',         start_area=\"A\",         start_loc=Point((0,1000)),         end_loc=Point((0,0)),         end_area=\"A\",         start_time=mtdt(340),         end_time=mtdt(350)     ),     Activity(         act='depot',         area=\"A\",         loc=Point((0,0)),         start_time=mtdt(350),         end_time=mtdt(24*60)  # assuming a 24 hour day     ) ]) <pre>('Directly adding a Person to a Population requires a Household.', 'Auto creating a household 0 for person 0, check this is intended.')\n</pre> In\u00a0[9]: Copied! <pre>milkman.plot()\n</pre> milkman.plot() In\u00a0[10]: Copied! <pre>population.print()\n</pre> population.print() <pre>Population: 3 people in 2 households.\nHousehold: Smiths\n{}\nPerson: Tom\n{'age': 'low'}\n0:\tActivity(act:home, location:POINT (0 0), time:00:00:00 --&gt; 00:00:00, duration:1 day, 0:00:00)\nPerson: Tammy\n{'age': 'low'}\n0:\tActivity(act:home, location:POINT (0 0), time:00:00:00 --&gt; 07:25:00, duration:7:25:00)\n1:\tLeg(mode:car, area:POINT (0 0) --&gt; POINT (1234 1234), time:07:25:00 --&gt; 08:25:00, duration:1:00:00)\n2:\tActivity(act:work, location:POINT (1233 1234), time:08:25:00 --&gt; 16:30:00, duration:8:05:00)\n3:\tLeg(mode:car, area:POINT (1234 1234) --&gt; POINT (0 0), time:16:30:00 --&gt; 17:30:00, duration:1:00:00)\n4:\tActivity(act:home, location:POINT (0 0), time:17:30:00 --&gt; 00:00:00, duration:6:30:00)\nHousehold: 0\n{}\nPerson: 0\n{'bot': 'yes', 'electric vehicle': 'yes'}\n0:\tActivity(act:depot, location:POINT (0 0), time:00:00:00 --&gt; 05:00:00, duration:5:00:00)\n1:\tLeg(mode:car, area:POINT (0 0) --&gt; POINT (1000 1000), time:05:00:00 --&gt; 05:10:00, duration:0:10:00)\n2:\tActivity(act:delivery, location:POINT (1000 1000), time:05:10:00 --&gt; 05:20:00, duration:0:10:00)\n3:\tLeg(mode:car, area:POINT (1000 1000) --&gt; POINT (0 1000), time:05:20:00 --&gt; 05:30:00, duration:0:10:00)\n4:\tActivity(act:delivery, location:POINT (0 1000), time:05:30:00 --&gt; 05:40:00, duration:0:10:00)\n5:\tLeg(mode:car, area:POINT (0 1000) --&gt; POINT (0 0), time:05:40:00 --&gt; 05:50:00, duration:0:10:00)\n6:\tActivity(act:depot, location:POINT (0 0), time:05:50:00 --&gt; 00:00:00, duration:18:10:00)\n</pre> In\u00a0[11]: Copied! <pre>from pam.write.diary import to_csv\n\nto_csv(population=population, dir=\"tmp\")\n</pre> from pam.write.diary import to_csv  to_csv(population=population, dir=\"tmp\") <pre>Missing person weight in hh Smiths, returning None.\nMissing person weight in hh 0, returning None.\n</pre> In\u00a0[12]: Copied! <pre>from pam.write import write_matsim\n\nwrite_matsim(population=population, plans_path=\"tmp/plans.xml\")\n</pre> from pam.write import write_matsim  write_matsim(population=population, plans_path=\"tmp/plans.xml\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/02_Population_Basics/#population-basics","title":"Population Basics\u00b6","text":""},{"location":"examples/02_Population_Basics/#the-core-objects","title":"The Core Objects\u00b6","text":"<p>pam populations are built from three core objects:</p> <p><code>Population</code>, <code>Household</code> and <code>Person</code> objects. Persons belong to a <code>Household</code> and households belong to a <code>Population</code>. This relationship can be created using the <code>Population.add</code> and <code>Household.add</code> methods.</p> <p>Note that <code>Household</code> and <code>Person</code> objects require unique identifiers. households require a <code>hid</code> (household id) and persons a <code>pid</code> (person id).</p> <p>Households and Persons can also be given attributes as a simple dictionary. Attributes can include useful features such as income or car ownership.</p>"},{"location":"examples/02_Population_Basics/#activity-plans-or-sequences","title":"Activity Plans (or \"Sequences\")\u00b6","text":"<p><code>Person</code> activity plans are held by the <code>pam.activity.Plan</code> object. All Persons have a <code>Plan</code>, even if it is empty. A <code>Plan</code> is simply a sequence of <code>Activity</code> and <code>Trip</code> (or <code>Leg</code>if you prefer - they are equivalent) objects.</p> <p>Plans must start and end with an <code>Activity</code> and the two objects must alternate, for example; <code>Activity(\"home\")</code>, <code>Trip()</code>, <code>Activity(\"work\")</code>, <code>Trip()</code>, <code>Activity(\"home\")</code>.</p> <p>Both Activities and Trips can have start and end times (using datetime objects). Activities have locations whereas Trips have start and end locations. When manually creating your own sequences care should be taken to make these times and locations consistent. Such that, for example, a trip ends when the next activity starts and a trip start is at the same location as the preceding activity.</p> <p>Activities are expected to have a type, for example, <code>'work'</code> or <code>'golf'</code>. Trips are expected to have a mode, for example <code>'car'</code> etc. These examples generally use strings for these features but this is not a requirement.</p>"},{"location":"examples/02_Population_Basics/#locations","title":"Locations\u00b6","text":"<p>Pam uses <code>pam.location.Location</code> objects to keep track of <code>Activity</code> and <code>Trip</code> locations.</p> <p>These locations can be any combination of <code>area</code> or <code>loc</code> or <code>link</code>. Area is assumed to be spatial zone id, for example, \"City of London\".</p> <p><code>Loc</code> must be a coordinate (using a <code>shapely.geometry.Point</code>). <code>Link</code> is a network id. Locs and Links are only required for specific applications such as MATSim and can be added or sampled later, so are not covered further here.</p>"},{"location":"examples/02_Population_Basics/#all-togther-now","title":"All Togther Now\u00b6","text":"<p>Pam has read methods for common travel diary data formats and for MATSim. We are also creating simple tour based generators, for example for freight. But below we show how you might create a completely synthetic population from scratch.</p> <p>Note that for conveneince the <code>add</code> methods will also try to unpack lists.</p>"},{"location":"examples/02_Population_Basics/#export","title":"Export\u00b6","text":"<p>Exports plans to csv or xml format for MATSim.</p>"},{"location":"examples/09_Travel_Plots/","title":"Travel Plots","text":"In\u00a0[1]: Copied! <pre>import os\n\nfrom pam import read\n</pre> import os  from pam import read In\u00a0[2]: Copied! <pre>pop = read.read_matsim(os.path.join('data', 'example_data', 'example_plans.xml'))  # load small sample from the test suite\n</pre> pop = read.read_matsim(os.path.join('data', 'example_data', 'example_plans.xml'))  # load small sample from the test suite <p>You can generate <code>geopandas.GeoDataFrames</code> for <code>Population</code>'s, <code>Household</code>'s or <code>Person</code>'s travel. the <code>route_id</code>, <code>service_id</code> and <code>network_route</code> refer to the network used for running the simulation. <code>GeoDataFrame</code>s are very useful, they let you to generate geojsons simply and quickly, which you can then load up in kepler.</p> <pre><code>gdf.to_file('path/to/file/gdf.geojson'), driver='GeoJSON')\n</code></pre> <p>note that to use this geojson with kepler you will need the geometry to be in <code>'epsg:4326'</code>. You can do this with the method below.</p> In\u00a0[3]: Copied! <pre>pop.build_travel_geodataframe(from_epsg='epsg:27700', to_epsg='epsg:4326').head()\n</pre> pop.build_travel_geodataframe(from_epsg='epsg:27700', to_epsg='epsg:4326').head() Out[3]: mode purp seq freq start_time end_time start_location end_location geometry distance service_id route_id o_stop d_stop network_route pid hid 0 pt work 1.0 None 1900-01-01 07:24:52 1900-01-01 07:24:52 (515226.0, 188222.0) (529652.0, 183897.0) LINESTRING (-0.33843 51.58109, -0.13193 51.53909) 15060.381834 None None None None [] census_0 census_0 1 pt None 2.0 None 1900-01-01 14:50:52 1900-01-01 14:50:52 (529652.0, 183897.0) (515226.0, 188222.0) LINESTRING (-0.13193 51.53909, -0.33843 51.58109) 15060.381834 None None None None [] census_0 census_0 2 pt work 1.0 None 1900-01-01 08:27:33 1900-01-01 08:27:33 (542920.0, 174494.0) (534457.0, 181724.0) LINESTRING (0.05545 51.45140, -0.06352 51.51844) 11130.825172 None None None None [] census_1 census_1 3 pt None 2.0 None 1900-01-01 17:45:33 1900-01-01 17:45:33 (534457.0, 181724.0) (542920.0, 174494.0) LINESTRING (-0.06352 51.51844, 0.05545 51.45140) 11130.825172 None None None None [] census_1 census_1 4 pt work 1.0 None 1900-01-01 07:01:09 1900-01-01 07:01:09 (535063.0, 163365.0) (531998.0, 166080.0) LINESTRING (-0.06179 51.35332, -0.10477 51.37843) 4094.563469 None None None None [] census_10 census_10 <p>You can also plot travel using plotly. You will need a mapbox token, which you can get here: https://docs.mapbox.com/help/how-mapbox-works/access-tokens/. Be careful not to commit your token in the repo.</p> In\u00a0[4]: Copied! <pre>mapbox_access_token='token'\n</pre> mapbox_access_token='token' <p>You need to specify the coordinate system to plot it on a map. By default the plot will colour by mode:</p> pop.plot_travel_plotly(     epsg='epsg:27700',      mapbox_access_token=mapbox_access_token )  <p></p> <p>You can also colour by any column you see in the <code>GeoDataFrame</code> (see above). E.g. to colour by agent id (<code>pid</code>)</p> pop.plot_travel_plotly(     epsg='epsg:27700',     mapbox_access_token=mapbox_access_token,      colour_by='pid' )  <p></p>"},{"location":"examples/09_Travel_Plots/#plot-activity-plan-travel","title":"Plot Activity Plan Travel\u00b6","text":""},{"location":"examples/13_Advanced_Freight_Synthesis/","title":"Advanced Freight Synthesis","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport geopandas as gp\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport random\nfrom datetime import date\nimport numpy as np\nimport os\n\nfrom pam.core import Population, Household, Person\nfrom pam.plot.stats import plot_activity_times, plot_leg_times\nfrom pam.samplers.facility import FacilitySampler\nfrom pam.samplers import tour\nfrom pam.variables import END_OF_DAY\nfrom pam.write import write_matsim, write_od_matrices\n\nmatplotlib.style.use('ggplot')\n</pre> import pandas as pd import geopandas as gp import matplotlib from matplotlib import pyplot as plt import random from datetime import date import numpy as np import os  from pam.core import Population, Household, Person from pam.plot.stats import plot_activity_times, plot_leg_times from pam.samplers.facility import FacilitySampler from pam.samplers import tour from pam.variables import END_OF_DAY from pam.write import write_matsim, write_od_matrices  matplotlib.style.use('ggplot') In\u00a0[2]: Copied! <pre>output_path = './data/outputs'\n</pre> output_path = './data/outputs' In\u00a0[3]: Copied! <pre>zones = gp.read_file('./data/lsoas/LSOA_2004_London_Low_Resolution.shp')\nzones.set_crs('EPSG:27700', allow_override=True, inplace=True)\nzones.rename(columns={'LSOA_CODE':'zone'}, inplace=True)\nzones.plot()\nplt.show()\n</pre> zones = gp.read_file('./data/lsoas/LSOA_2004_London_Low_Resolution.shp') zones.set_crs('EPSG:27700', allow_override=True, inplace=True) zones.rename(columns={'LSOA_CODE':'zone'}, inplace=True) zones.plot() plt.show() In\u00a0[4]: Copied! <pre># load facilities\nfacilities = gp.read_file('./data/londinium_facilities_sample.geojson')\nfacilities.set_crs('EPSG:27700', allow_override=True, inplace=True)\n\n# dummy create depots and deliveries\nfacilities['activity'] = np.where(facilities['activity']=='shop', 'depot', facilities['activity'])\nfacilities['activity'] = np.where(facilities['activity']=='leisure', 'delivery', facilities['activity'])\n\nfacilities.plot()\n</pre> # load facilities facilities = gp.read_file('./data/londinium_facilities_sample.geojson') facilities.set_crs('EPSG:27700', allow_override=True, inplace=True)  # dummy create depots and deliveries facilities['activity'] = np.where(facilities['activity']=='shop', 'depot', facilities['activity']) facilities['activity'] = np.where(facilities['activity']=='leisure', 'delivery', facilities['activity'])  facilities.plot() Out[4]: <pre>&lt;AxesSubplot:&gt;</pre> <p>The zones data is for all of London, below, we crop the zones data to the Londinium study area.</p> In\u00a0[5]: Copied! <pre>cols = list(zones.columns)\n\nzones_londinium = gp.sjoin(zones, facilities, how='inner', predicate='intersects')\nzones_londinium = zones_londinium[cols]\nzones = zones_londinium.drop_duplicates()\nzones = zones.set_index('zone')\n</pre> cols = list(zones.columns)  zones_londinium = gp.sjoin(zones, facilities, how='inner', predicate='intersects') zones_londinium = zones_londinium[cols] zones = zones_londinium.drop_duplicates() zones = zones.set_index('zone') In\u00a0[6]: Copied! <pre>facility_sampler = FacilitySampler(\n    facilities=facilities,\n    zones=zones,\n    build_xml=True,\n    fail=False,\n    random_default=True\n)\n\nfacility_sampler.activities\n</pre> facility_sampler = FacilitySampler(     facilities=facilities,     zones=zones,     build_xml=True,     fail=False,     random_default=True )  facility_sampler.activities <pre>Joining facilities data to zones, this may take a while.\n/Users/fred.shone/.ve/pam/lib/python3.7/site-packages/ipykernel_launcher.py:6: FutureWarning:\n\nThe `op` parameter is deprecated and will be removed in a future release. Please use the `predicate` parameter instead.\n\nBuilding sampler, this may take a while.\n</pre> Out[6]: <pre>['medical',\n 'work',\n 'delivery',\n 'home',\n 'gym',\n 'transit',\n 'depot',\n 'park',\n 'education',\n 'pub',\n 'other']</pre> In\u00a0[7]: Copied! <pre># Create a facility zone dataset to be used in samplers\nfacility_zone = gp.sjoin(facilities, zones, how='inner', predicate='intersects')\nfacility_zone.rename(columns={'index_right':'zone'}, inplace = True)\nfacility_zone.set_index('zone', inplace = True)\n</pre> # Create a facility zone dataset to be used in samplers facility_zone = gp.sjoin(facilities, zones, how='inner', predicate='intersects') facility_zone.rename(columns={'index_right':'zone'}, inplace = True) facility_zone.set_index('zone', inplace = True) In\u00a0[8]: Copied! <pre>bins = range(3,12)\npivots = {3: 36.0, 4: 28.0, 5: 15.0, 6: 7.0, 7: 4.0, 8: 2.5, 9: 2.5, 10: 1.0, 11: 4.0}\nstop_sampler = tour.PivotDistributionSampler(bins=bins,pivots=pivots)\nstop_sampler.plot(plot_title='Stops Distribution', x_label='Stops', y_label='Frequency')\n</pre> bins = range(3,12) pivots = {3: 36.0, 4: 28.0, 5: 15.0, 6: 7.0, 7: 4.0, 8: 2.5, 9: 2.5, 10: 1.0, 11: 4.0} stop_sampler = tour.PivotDistributionSampler(bins=bins,pivots=pivots) stop_sampler.plot(plot_title='Stops Distribution', x_label='Stops', y_label='Frequency') In\u00a0[9]: Copied! <pre># Set up freight params for both LGV and HGV movements\nlgv_params = {'total':2500,\n              'pivots': {7: 14, 8 :9, 9: 13, 10: 16, 11: 18, 12: 13, 13: 15, 14: 16, 15: 14, 16: 13, 17: 9, 18: 5, 19: 3, 20: 3, 21: 3, 22: 2},\n              'agent_id': 'LGV',\n              'agent_attributes': 'lgv'\n              }\n</pre> # Set up freight params for both LGV and HGV movements lgv_params = {'total':2500,               'pivots': {7: 14, 8 :9, 9: 13, 10: 16, 11: 18, 12: 13, 13: 15, 14: 16, 15: 14, 16: 13, 17: 9, 18: 5, 19: 3, 20: 3, 21: 3, 22: 2},               'agent_id': 'LGV',               'agent_attributes': 'lgv'               } <p>Below, we decide if we will use the LGV or HGV parameters defined above.</p> In\u00a0[10]: Copied! <pre>freight_params = lgv_params.copy()\n</pre> freight_params = lgv_params.copy() In\u00a0[11]: Copied! <pre># Create Distribution\nbins = range(0,24)\n\nhour_sampler = tour.PivotDistributionSampler(bins=bins, pivots=freight_params['pivots'], total=freight_params['total'])\nhour_sampler.plot(plot_title=f\"{freight_params['agent_id']} Distribution\", x_label='Hour', y_label='Frequency')\n</pre> # Create Distribution bins = range(0,24)  hour_sampler = tour.PivotDistributionSampler(bins=bins, pivots=freight_params['pivots'], total=freight_params['total']) hour_sampler.plot(plot_title=f\"{freight_params['agent_id']} Distribution\", x_label='Hour', y_label='Frequency') In\u00a0[12]: Copied! <pre># Create a minute sampler\nminute_sampler = tour.FrequencySampler(range(60))\nminute_sampler.sample()\n</pre> # Create a minute sampler minute_sampler = tour.FrequencySampler(range(60)) minute_sampler.sample() Out[12]: <pre>22</pre> In\u00a0[13]: Copied! <pre>origin_density = tour.create_density_gdf(facility_zone=facility_zone, zone=zones, activity=['depot'])\ndestination_density = tour.create_density_gdf(facility_zone=facility_zone, zone=zones, activity=['delivery'])\n</pre> origin_density = tour.create_density_gdf(facility_zone=facility_zone, zone=zones, activity=['depot']) destination_density = tour.create_density_gdf(facility_zone=facility_zone, zone=zones, activity=['delivery']) In\u00a0[14]: Copied! <pre># Input Demand, in this case defined as facility density location\ndepot_sampler = tour.FrequencySampler(origin_density.index, origin_density.density)\n</pre> # Input Demand, in this case defined as facility density location depot_sampler = tour.FrequencySampler(origin_density.index, origin_density.density) In\u00a0[15]: Copied! <pre># Constraint, defined as distance between origin and destination centroids. This dataframe will be filtered based on threshold values defined later.                                                                    \nzones_list = np.array(zones.centroid.apply(lambda x: [x.x, x.y]).to_list())\nod_matrix = np.linalg.norm(zones_list[:, None, :] - zones_list[None, :, :], axis=-1)\ndf_od = pd.DataFrame(od_matrix, index=zones.index, columns=zones.index)\n</pre> # Constraint, defined as distance between origin and destination centroids. This dataframe will be filtered based on threshold values defined later.                                                                     zones_list = np.array(zones.centroid.apply(lambda x: [x.x, x.y]).to_list()) od_matrix = np.linalg.norm(zones_list[:, None, :] - zones_list[None, :, :], axis=-1) df_od = pd.DataFrame(od_matrix, index=zones.index, columns=zones.index) In\u00a0[16]: Copied! <pre># Factor to scale trips (To better match validation counts when needed)\nfactor = 1\n\n# Sample Size\nsamples = [0.01]  # increase\n\n# Set Distance threshold, in this case arbitrarily set to median distance of od dataframe.\nthreshold_value = df_od.median().agg('median')\n\n# used for fnames\ntoday = date.today().strftime('%d%b%y')\ntoday\n</pre> # Factor to scale trips (To better match validation counts when needed) factor = 1  # Sample Size samples = [0.01]  # increase  # Set Distance threshold, in this case arbitrarily set to median distance of od dataframe. threshold_value = df_od.median().agg('median')  # used for fnames today = date.today().strftime('%d%b%y') today Out[16]: <pre>'05Oct22'</pre> In\u00a0[17]: Copied! <pre>#### Sample Agents\ndef sample_agents(size):\n    \n    facility_sampler.clear()\n    population = Population()\n    \n    for i in range(size):\n\n        agent_id = f\"{freight_params['agent_id']}_{i}\"\n        \n        hh = Household(agent_id)\n        \n        agent = Person(\n            agent_id,\n            freq=100,\n            attributes={\n                'subpopulation': freight_params['agent_attributes'],\n                'CarType': freight_params['agent_attributes'],\n                'CarCO2': freight_params['agent_attributes']\n            }\n        )\n        \n        hh.add(agent)\n        population.add(hh)\n\n        hour = hour_sampler.sample()\n        minute = minute_sampler.sample()\n        o_zone = depot_sampler.sample()\n\n        if freight_params['agent_id']=='LGV':\n            stops = stop_sampler.sample()\n        else:\n            stops = 1\n\n        agent_plan = tour.TourPlanner(stops=stops,\n                                      hour=hour,\n                                      minute=minute,\n                                      o_zone=o_zone,\n                                      d_dist=destination_density,\n                                      d_freq='density', \n                                      threshold_matrix=df_od,\n                                      threshold_value=threshold_value, \n                                      facility_sampler=facility_sampler,\n                                      activity_params={'o_activity':'depot', 'd_activity':'delivery'})\n        \n        o_loc, d_zones, d_locs = agent_plan.sequence_stops()\n        agent_plan.apply(agent=agent,o_loc=o_loc, d_zones=d_zones, d_locs=d_locs)\n      \n    return population\n</pre> #### Sample Agents def sample_agents(size):          facility_sampler.clear()     population = Population()          for i in range(size):          agent_id = f\"{freight_params['agent_id']}_{i}\"                  hh = Household(agent_id)                  agent = Person(             agent_id,             freq=100,             attributes={                 'subpopulation': freight_params['agent_attributes'],                 'CarType': freight_params['agent_attributes'],                 'CarCO2': freight_params['agent_attributes']             }         )                  hh.add(agent)         population.add(hh)          hour = hour_sampler.sample()         minute = minute_sampler.sample()         o_zone = depot_sampler.sample()          if freight_params['agent_id']=='LGV':             stops = stop_sampler.sample()         else:             stops = 1          agent_plan = tour.TourPlanner(stops=stops,                                       hour=hour,                                       minute=minute,                                       o_zone=o_zone,                                       d_dist=destination_density,                                       d_freq='density',                                        threshold_matrix=df_od,                                       threshold_value=threshold_value,                                        facility_sampler=facility_sampler,                                       activity_params={'o_activity':'depot', 'd_activity':'delivery'})                  o_loc, d_zones, d_locs = agent_plan.sequence_stops()         agent_plan.apply(agent=agent,o_loc=o_loc, d_zones=d_zones, d_locs=d_locs)            return population  In\u00a0[18]: Copied! <pre># Function to build population \n\ndef build_population(sample, factor):\n    population = sample_agents(int(factor * int(freight_params['total'] * sample)))\n    \n    return population\n</pre> # Function to build population   def build_population(sample, factor):     population = sample_agents(int(factor * int(freight_params['total'] * sample)))          return population In\u00a0[19]: Copied! <pre># Build + Crop + Write Population for samples\nfor s in samples:\n    \n    #build\n    population = build_population(s, factor)\n        \n    #Crop and Validate Plans\n    population.fix_plans()\n    population.validate()\n\n    # Write to Disk\n    xml_comment = f\"prelim {s*100}% {freight_params['agent_id']} {today}\"\n    output_path = os.path.join(output_path)\n    \n    write_matsim(\n        population,\n        os.path.join(output_path, \"plans.xml\"),\n        os.path.join(output_path, \"attributes.xml\"),\n        comment=xml_comment\n    )\n\n    population.to_csv(output_path, crs = \"EPSG:27700\", to_crs=\"EPSG:4326\")\n\n    facility_sampler.write_facilities_xml(\n       os.path.join(output_path, \"facilities.xml\"),\n       comment=xml_comment\n    )\n</pre> # Build + Crop + Write Population for samples for s in samples:          #build     population = build_population(s, factor)              #Crop and Validate Plans     population.fix_plans()     population.validate()      # Write to Disk     xml_comment = f\"prelim {s*100}% {freight_params['agent_id']} {today}\"     output_path = os.path.join(output_path)          write_matsim(         population,         os.path.join(output_path, \"plans.xml\"),         os.path.join(output_path, \"attributes.xml\"),         comment=xml_comment     )      population.to_csv(output_path, crs = \"EPSG:27700\", to_crs=\"EPSG:4326\")      facility_sampler.write_facilities_xml(        os.path.join(output_path, \"facilities.xml\"),        comment=xml_comment     ) In\u00a0[20]: Copied! <pre>trips = pd.read_csv(os.path.join(output_path,\"legs.csv\"))\n\ndef get_hour(dt):\n    return int(dt.split(\" \")[1].split(\":\")[0])\n\ntrips[\"start_hour\"] = trips[\"tst\"].apply(get_hour)\n</pre> trips = pd.read_csv(os.path.join(output_path,\"legs.csv\"))  def get_hour(dt):     return int(dt.split(\" \")[1].split(\":\")[0])  trips[\"start_hour\"] = trips[\"tst\"].apply(get_hour) In\u00a0[21]: Copied! <pre>freight_density = tour.ValidateTourOD(trips=trips,\n                                      zone=zones,\n                                      o_dist=origin_density,\n                                      d_dist=destination_density,\n                                      o_activity='depot',\n                                      d_activity='delivery',\n                                      o_freq='density',\n                                      d_freq='density'\n                                      )\n</pre> freight_density = tour.ValidateTourOD(trips=trips,                                       zone=zones,                                       o_dist=origin_density,                                       d_dist=destination_density,                                       o_activity='depot',                                       d_activity='delivery',                                       o_freq='density',                                       d_freq='density'                                       ) In\u00a0[22]: Copied! <pre>freight_density.plot_validate_spatial_density(title_1='Depot Density (origin)',\n                                              title_2='Trips from Depot (origin)',\n                                              density_metric='depot_density',\n                                              density_trips='origin_trips'\n                                              )\n</pre> freight_density.plot_validate_spatial_density(title_1='Depot Density (origin)',                                               title_2='Trips from Depot (origin)',                                               density_metric='depot_density',                                               density_trips='origin_trips'                                               ) In\u00a0[23]: Copied! <pre>freight_density.plot_validate_spatial_density(title_1='Delivery Density (destination)',\n                                              title_2='Trips to Delivery (destination)',\n                                              density_metric='delivery_density',\n                                              density_trips='destination_trips'\n                                              )\n</pre> freight_density.plot_validate_spatial_density(title_1='Delivery Density (destination)',                                               title_2='Trips to Delivery (destination)',                                               density_metric='delivery_density',                                               density_trips='destination_trips'                                               ) In\u00a0[24]: Copied! <pre>freight_density.plot_compare_density(title_1='Depot Density vs. Origin Trips',\n                                     title_2='Delivery Density vs. Destination Trips',\n                                     o_activity='depot_density',\n                                     d_activity='delivery_density')\n</pre> freight_density.plot_compare_density(title_1='Depot Density vs. Origin Trips',                                      title_2='Delivery Density vs. Destination Trips',                                      o_activity='depot_density',                                      d_activity='delivery_density')"},{"location":"examples/13_Advanced_Freight_Synthesis/#introduction","title":"Introduction\u00b6","text":"<p>This notebook simulates freight trips and generates a freight population file.</p> <p>The following steps are undertaken:</p> <ol> <li>Read, process, and plot data.</li> <li>Input Assumptions &amp; Sampler Creation</li> <li>Create Activity Model &amp; Population</li> <li>Validation</li> </ol>"},{"location":"examples/13_Advanced_Freight_Synthesis/#1-read-process-plot-data","title":"1. Read, process, plot Data\u00b6","text":"<p>Below, we load in data required to build a tour plan: zones and facilities data.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#2-input-assumptions","title":"2. Input Assumptions\u00b6","text":"<p>We create a series of samplers that will serve as inputs into the activity model. These samplers include:</p> <ul> <li>Number of Stops</li> <li>Freight Hourly Demand</li> <li>Origin (in this case, Depot) location</li> </ul>"},{"location":"examples/13_Advanced_Freight_Synthesis/#number-of-stops","title":"Number of Stops\u00b6","text":"<p>Build a Stop Number distribution and corresponding sampler.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#freight-hourly-demand","title":"Freight Hourly Demand\u00b6","text":"<p>Hourly demand is a distribution created based on the pivots input. We use the class PivotDistributionSampler to translate 'pivots' into a distribution, plot, and sampler.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#input-demand-constraints","title":"Input Demand &amp; Constraints\u00b6","text":"<p>We calculate the density of depots and deliveries across all zones. This information will be utilised by the class FrequencySampler to create a distribution. We also create an origin/destination matrix of distances between centroids that will be used to selected the destination locations.</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#3-activity-modeller","title":"3. Activity Modeller\u00b6","text":"<p>Parameters are defined to model a population of activity plans. Activities are encoded as \"car\". Subpopulation is encoded as \"lgv\" or \"hgv\".</p>"},{"location":"examples/13_Advanced_Freight_Synthesis/#population-parameters","title":"Population Parameters\u00b6","text":""},{"location":"examples/13_Advanced_Freight_Synthesis/#activity-modeller","title":"Activity Modeller\u00b6","text":""},{"location":"examples/13_Advanced_Freight_Synthesis/#4-validation","title":"4. Validation\u00b6","text":""},{"location":"examples/15_Advanced_Choice/","title":"Advanced Choice","text":"<p>This notebook applies a simple location and mode choice model to a PAM population.</p> <p>The <code>pam.planner.choice.ChoiceMNL</code> class allows the user to apply an MNL specification for selecting the location of activities and the mode for accessing them, given person characteristics, network conditions and/or zone attraction data.</p> <p>The typical workflow goes as follows:</p> <pre><code>choice_model = ChoiceMNL(population, od, zones) # initialize the model and point to the data objects \nchoice_model.configure(u, scope) # configure the model by specifying a utility function and the scope of application.\nchoice_model.apply() # apply the model and update the population with the results.\n\n</code></pre> In\u00a0[1]: Copied! <pre>import pandas as pd\nfrom pam.read import read_matsim\nfrom pam.planner import choice_location as choice\nfrom pam.operations.cropping import link_population\nfrom pam.planner.od import OD, Labels, ODMatrix, ODFactory\nimport random\nimport numpy as np\nimport os\nfrom prettytable import PrettyTable\n\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\nrandom.seed(0)\n</pre> import pandas as pd from pam.read import read_matsim from pam.planner import choice_location as choice from pam.operations.cropping import link_population from pam.planner.od import OD, Labels, ODMatrix, ODFactory import random import numpy as np import os from prettytable import PrettyTable  import logging logging.basicConfig(level=logging.DEBUG) random.seed(0) In\u00a0[2]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 <p>We read an example population, and set the location of all activities to zone <code>a</code>:</p> In\u00a0[3]: Copied! <pre>population = read_matsim(os.path.join('..', 'tests', 'test_data', 'test_matsim_plansv12.xml'))\nlink_population(population)\nfor hid, pid, person in population.people():\n    for act in person.activities:\n        act.location.area = 'a'\n</pre> population = read_matsim(os.path.join('..', 'tests', 'test_data', 'test_matsim_plansv12.xml')) link_population(population) for hid, pid, person in population.people():     for act in person.activities:         act.location.area = 'a'  In\u00a0[4]: Copied! <pre>def print_activity_locs(population, act_scope='work'):\n    summary = PrettyTable(['pid', 'seq', 'location', 'mode'])\n    for hid, pid, person in population.people():\n        for seq, act in enumerate(person.plan.activities):\n            if (act.act==act_scope) or (act_scope=='all'):\n                trmode = act.previous.mode if act.previous is not None else 'NA'\n                summary.add_row([pid, seq, act.location.area, trmode])\n                \n    print(summary)\n\nprint('Work locations and travel modes:')\nprint_activity_locs(population, act_scope='work')\n</pre> def print_activity_locs(population, act_scope='work'):     summary = PrettyTable(['pid', 'seq', 'location', 'mode'])     for hid, pid, person in population.people():         for seq, act in enumerate(person.plan.activities):             if (act.act==act_scope) or (act_scope=='all'):                 trmode = act.previous.mode if act.previous is not None else 'NA'                 summary.add_row([pid, seq, act.location.area, trmode])                      print(summary)  print('Work locations and travel modes:') print_activity_locs(population, act_scope='work') <pre>Work locations and travel modes:\n+--------+-----+----------+------+\n|  pid   | seq | location | mode |\n+--------+-----+----------+------+\n| chris  |  1  |    a     | car  |\n| fatema |  1  |    a     | bike |\n|  fred  |  3  |    a     | walk |\n| gerry  |  3  |    a     | walk |\n|  nick  |  1  |    a     | car  |\n+--------+-----+----------+------+\n</pre> <p>Our <code>zones</code> dataset includes destination attraction data, for example the number of jobs or schools in each likely destination zone:</p> In\u00a0[5]: Copied! <pre>data_zones = pd.DataFrame(\n    {\n        'zone': ['a', 'b'],\n        'jobs': [100, 200],\n        'schools': [3, 1]\n    }\n).set_index('zone')\ndata_zones\n</pre> data_zones = pd.DataFrame(     {         'zone': ['a', 'b'],         'jobs': [100, 200],         'schools': [3, 1]     } ).set_index('zone') data_zones Out[5]: jobs schools zone a 100 3 b 200 1 <p>The <code>od</code> object holds origin-destination data, for example travel time and travel distance between each origin and destination, for each travel mode:</p> In\u00a0[6]: Copied! <pre>zone_labels = ('a', 'b')\nod = ODFactory.from_matrices([\n    ODMatrix('time', 'car', zone_labels, zone_labels, np.array([[20, 40], [40, 20]])),\n    ODMatrix('time', 'bus', zone_labels, zone_labels, np.array([[30, 45], [45, 30]])),\n    ODMatrix('distance', 'car', zone_labels, zone_labels, np.array([[5, 8], [8, 5]])),\n    ODMatrix('distance', 'bus', zone_labels, zone_labels, np.array([[5, 9], [9, 5]]))    \n])\nod\n</pre> zone_labels = ('a', 'b') od = ODFactory.from_matrices([     ODMatrix('time', 'car', zone_labels, zone_labels, np.array([[20, 40], [40, 20]])),     ODMatrix('time', 'bus', zone_labels, zone_labels, np.array([[30, 45], [45, 30]])),     ODMatrix('distance', 'car', zone_labels, zone_labels, np.array([[5, 8], [8, 5]])),     ODMatrix('distance', 'bus', zone_labels, zone_labels, np.array([[5, 9], [9, 5]]))     ]) od Out[6]: <pre>Origin-destination dataset \n--------------------------------------------------\nLabels(vars=['time', 'distance'], origin_zones=('a', 'b'), destination_zones=('a', 'b'), mode=['car', 'bus'])\n--------------------------------------------------\ntime - car:\n[[20. 40.]\n [40. 20.]]\n--------------------------------------------------\ntime - bus:\n[[30. 45.]\n [45. 30.]]\n--------------------------------------------------\ndistance - car:\n[[5. 8.]\n [8. 5.]]\n--------------------------------------------------\ndistance - bus:\n[[5. 9.]\n [9. 5.]]\n--------------------------------------------------</pre> <p>The dimensions of the <code>od</code> object are always (in order): <code>variables</code>, <code>origin zone</code>, <code>destination zone</code>, and <code>mode</code>. It can be sliced using the respective labels under <code>od.labels</code>, for example:</p> In\u00a0[7]: Copied! <pre>od['time', 'a', 'b', 'bus']\n</pre> od['time', 'a', 'b', 'bus'] Out[7]: <pre>45.0</pre> In\u00a0[8]: Copied! <pre>planner = choice.ChoiceMNL(population, od, data_zones)\n</pre> planner = choice.ChoiceMNL(population, od, data_zones) <pre>INFO:pam.planner.choice_location:Updated model configuration\nINFO:pam.planner.choice_location:ChoiceConfiguration(u=None, scope=None, func_probabilities=&lt;function calculate_mnl_probabilities at 0x7f7a192acca0&gt;, func_sampling=&lt;function sample_weighted at 0x7f7a192acd30&gt;)\n</pre> <p>We configure the model by specifying:</p> <ul> <li>the scope of the model. For example, work activities.</li> <li>the utility formulation of each alternative.</li> </ul> <p>Both settings are defined as strings. The stings may comprise mathematical operators, coefficients, planner data objects (<code>od</code> / <code>zones</code>), and/or PAM population objects (<code>person</code>/ <code>act</code>).</p> <p>Coefficients can be passed either as a number, or as a list, with each element in the list corresponding to one of the modes in the <code>od</code> object.</p> In\u00a0[9]: Copied! <pre>scope = \"act.act=='work'\"\nasc = [0, -1] # one value for each mode, 0-&gt;car, -1-&gt;\nasc_shift_poor = [0, 2] # one value for each mode\nbeta_time = [-0.05, -0.07] # one value for each mode\nbeta_zones = 0.4\nu = f\"\"\" \\\n{asc} + \\\n    (np.array({asc_shift_poor}) * (person.attributes['subpopulation']=='poor')) + \\\n    ({beta_time} * od['time', person.home.area]) + \\\n    ({beta_zones} * np.log(zones['jobs']))\n\"\"\"\n\nplanner.configure(u=u, scope=scope)\n# print('Utility specification: \\n', planner.u)\n</pre> scope = \"act.act=='work'\" asc = [0, -1] # one value for each mode, 0-&gt;car, -1-&gt; asc_shift_poor = [0, 2] # one value for each mode beta_time = [-0.05, -0.07] # one value for each mode beta_zones = 0.4 u = f\"\"\" \\     {asc} + \\     (np.array({asc_shift_poor}) * (person.attributes['subpopulation']=='poor')) + \\     ({beta_time} * od['time', person.home.area]) + \\     ({beta_zones} * np.log(zones['jobs'])) \"\"\"  planner.configure(u=u, scope=scope) # print('Utility specification: \\n', planner.u) <pre>INFO:pam.planner.choice_location:Updated model configuration\nINFO:pam.planner.choice_location:ChoiceConfiguration(u=\"[0,-1]+(np.array([0,2])*(person.attributes['subpopulation']=='poor'))+([-0.05,-0.07]*od['time',person.home.area])+(0.4*np.log(zones['jobs']))\\n\", scope=\"act.act=='work'\", func_probabilities=&lt;function calculate_mnl_probabilities at 0x7f7a192acca0&gt;, func_sampling=&lt;function sample_weighted at 0x7f7a192acd30&gt;)\n</pre> <p>The <code>.get_choice_set()</code> provides with with the utilities of each alternative, as perceived by each agent.</p> In\u00a0[10]: Copied! <pre>choice_set = planner.get_choice_set()\nprint('Activities in scope: \\n', choice_set.idxs)\nprint('\\nAlternatives: \\n', choice_set.choice_labels)\nprint('\\nChoice set utilities: \\n', choice_set.u_choices)\n</pre> choice_set = planner.get_choice_set() print('Activities in scope: \\n', choice_set.idxs) print('\\nAlternatives: \\n', choice_set.choice_labels) print('\\nChoice set utilities: \\n', choice_set.u_choices) <pre>Activities in scope: \n [ChoiceIdx(pid='chris', hid='chris', seq=1, act=&lt;pam.activity.Activity object at 0x7f7a193248b0&gt;), ChoiceIdx(pid='fatema', hid='fatema', seq=1, act=&lt;pam.activity.Activity object at 0x7f7a19324f40&gt;), ChoiceIdx(pid='fred', hid='fred', seq=3, act=&lt;pam.activity.Activity object at 0x7f7a1926c8e0&gt;), ChoiceIdx(pid='gerry', hid='gerry', seq=3, act=&lt;pam.activity.Activity object at 0x7f7a19270520&gt;), ChoiceIdx(pid='nick', hid='nick', seq=1, act=&lt;pam.activity.Activity object at 0x7f7a192702b0&gt;)]\n\nAlternatives: \n [ChoiceLabel(destination='a', mode='car'), ChoiceLabel(destination='a', mode='bus'), ChoiceLabel(destination='b', mode='car'), ChoiceLabel(destination='b', mode='bus')]\n\nChoice set utilities: \n [[ 0.84206807 -1.25793193  0.11932695 -2.03067305]\n [ 0.84206807  0.74206807  0.11932695 -0.03067305]\n [ 0.84206807  0.74206807  0.11932695 -0.03067305]\n [ 0.84206807  0.74206807  0.11932695 -0.03067305]\n [ 0.84206807 -1.25793193  0.11932695 -2.03067305]]\n</pre> <p>The <code>.apply()</code> method samples from the alternatives, and updates the location and mode of each activity accordingly:</p> In\u00a0[11]: Copied! <pre>planner.apply()\nprint('Sampled choices: \\n', planner._selections.selections)\n</pre> planner.apply() print('Sampled choices: \\n', planner._selections.selections) <pre>INFO:pam.planner.choice_location:Applying choice model...\nINFO:pam.planner.choice_location:Configuration: \nChoiceConfiguration(u=\"[0,-1]+(np.array([0,2])*(person.attributes['subpopulation']=='poor'))+([-0.05,-0.07]*od['time',person.home.area])+(0.4*np.log(zones['jobs']))\\n\", scope=\"act.act=='work'\", func_probabilities=&lt;function calculate_mnl_probabilities at 0x7f7a192acca0&gt;, func_sampling=&lt;function sample_weighted at 0x7f7a192acd30&gt;)\nINFO:pam.planner.choice_location:Choice model application complete.\n</pre> <pre>Sampled choices: \n [ChoiceLabel(destination='b', mode='car'), ChoiceLabel(destination='b', mode='car'), ChoiceLabel(destination='a', mode='bus'), ChoiceLabel(destination='a', mode='car'), ChoiceLabel(destination='a', mode='car')]\n</pre> <p>The population's activity locations and travel modes have now been updated accordingly:</p> In\u00a0[12]: Copied! <pre>print_activity_locs(planner.population)\n</pre> print_activity_locs(planner.population) <pre>+--------+-----+----------+------+\n|  pid   | seq | location | mode |\n+--------+-----+----------+------+\n| chris  |  1  |    b     | car  |\n| fatema |  1  |    b     | car  |\n|  fred  |  3  |    a     | bus  |\n| gerry  |  3  |    a     | car  |\n|  nick  |  1  |    a     | car  |\n+--------+-----+----------+------+\n</pre>"},{"location":"examples/15_Advanced_Choice/#introduction","title":"Introduction\u00b6","text":""},{"location":"examples/15_Advanced_Choice/#dependencies","title":"Dependencies\u00b6","text":""},{"location":"examples/15_Advanced_Choice/#data","title":"Data\u00b6","text":""},{"location":"examples/15_Advanced_Choice/#choice-model","title":"Choice model\u00b6","text":""},{"location":"examples/12_Advanced_Adding_Vehicles/","title":"Advanced Adding Vehicles","text":"In\u00a0[1]: Copied! <pre>from pam import read\nimport pam.vehicle\nimport pandas as pd\nfrom pprint import pprint\nimport os\n\n# load up population\ndata_path = os.path.join(\"data\", \"example_data\")\ntrips = pd.read_csv(os.path.join(data_path, 'example_travel_diaries.csv'))\nattributes = pd.read_csv(os.path.join(data_path, 'example_attributes.csv'))\nattributes.set_index('pid', inplace=True)\npop = read.load_travel_diary(trips, attributes)\n</pre> from pam import read import pam.vehicle import pandas as pd from pprint import pprint import os  # load up population data_path = os.path.join(\"data\", \"example_data\") trips = pd.read_csv(os.path.join(data_path, 'example_travel_diaries.csv')) attributes = pd.read_csv(os.path.join(data_path, 'example_attributes.csv')) attributes.set_index('pid', inplace=True) pop = read.load_travel_diary(trips, attributes) <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all persons.\n</pre> In\u00a0[2]: Copied! <pre>pop = pam.read.read_matsim(\n    os.path.join(data_path, 'example_plans.xml'),\n    version = 12)\n</pre> pop = pam.read.read_matsim(     os.path.join(data_path, 'example_plans.xml'),     version = 12) In\u00a0[3]: Copied! <pre>pop.stats\n</pre> pop.stats Out[3]: <pre>{'num_households': 51,\n 'num_people': 51,\n 'num_activities': 153,\n 'num_legs': 102}</pre> In\u00a0[4]: Copied! <pre># let's define some vehicles\n\ndefault_ev_vehicle_type = pam.vehicle.VehicleType('default_EV')\nbig_ev_vehicle_type = pam.vehicle.VehicleType('big_EV', length=15, width=2)\ndefault_vehicle_type = pam.vehicle.VehicleType('default_car')\n</pre> # let's define some vehicles  default_ev_vehicle_type = pam.vehicle.VehicleType('default_EV') big_ev_vehicle_type = pam.vehicle.VehicleType('big_EV', length=15, width=2) default_vehicle_type = pam.vehicle.VehicleType('default_car') In\u00a0[5]: Copied! <pre>import random\n\nfor hid, pid, p in pop.people():\n    if 'car' in p.mode_classes:\n        if random.random() &lt; 0.5:\n            # let's give a vehicle to this person\n            if random.random() &lt; 0.5:\n                p.assign_vehicle(pam.vehicle.ElectricVehicle(pid, vehicle_type=default_ev_vehicle_type))\n            else:\n                p.assign_vehicle(pam.vehicle.Vehicle(pid, default_vehicle_type))\n</pre> import random  for hid, pid, p in pop.people():     if 'car' in p.mode_classes:         if random.random() &lt; 0.5:             # let's give a vehicle to this person             if random.random() &lt; 0.5:                 p.assign_vehicle(pam.vehicle.ElectricVehicle(pid, vehicle_type=default_ev_vehicle_type))             else:                 p.assign_vehicle(pam.vehicle.Vehicle(pid, default_vehicle_type)) <p>You can also change default parameters for ElectricVehicles too. You can set their <code>battery_capacity</code> and initial state of charge <code>initial_soc</code> and the charger types allowed <code>charger_types</code>.</p> In\u00a0[6]: Copied! <pre>pprint(pam.vehicle.ElectricVehicle('id').__dict__)\n</pre> pprint(pam.vehicle.ElectricVehicle('id').__dict__) <pre>{'battery_capacity': 60,\n 'charger_types': 'default',\n 'id': 'id',\n 'initial_soc': 60,\n 'vehicle_type': VehicleType(id='defaultElectricVehicleType', length=7.5, width=1.0, networkMode='car', capacity=CapacityType(seats=4, standingRoomInPersons=0), description='personal_vehicle', passengerCarEquivalents=1.0, flowEfficiencyFactor=1.0)}\n</pre> In\u00a0[7]: Copied! <pre>len(set(pop.electric_vehicles()))\n</pre> len(set(pop.electric_vehicles())) Out[7]: <pre>2</pre> In\u00a0[8]: Copied! <pre>pop.electric_vehicle_charger_types()\n</pre> pop.electric_vehicle_charger_types() Out[8]: <pre>{'default'}</pre> In\u00a0[9]: Copied! <pre>import logging\nfrom pam import write\n\nlogging.basicConfig()\nlogging.getLogger().setLevel(logging.INFO)\n\nwrite.write_matsim(\n    pop,\n    plans_path='./tmp/plans.xml',\n    vehicles_dir='./tmp',\n)\n</pre> import logging from pam import write  logging.basicConfig() logging.getLogger().setLevel(logging.INFO)  write.write_matsim(     pop,     plans_path='./tmp/plans.xml',     vehicles_dir='./tmp', ) <pre>INFO:root:Population includes vehicles\nINFO:root:Saving vehicles to ./tmp\nINFO:root:Writing all vehicles to ./tmp/all_vehicles.xml\nINFO:root:Population includes electric vehicles\nINFO:root:Writing electric vehicles to ./tmp/electric_vehicles.xml\nINFO:root:Found 2 electric vehicles with unique charger types: {'default'}. Ensure you generate a chargers xml file: https://www.matsim.org/files/dtd/chargers_v1.dtd if you're running a simulation using org.matsim.contrib.ev\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/12_Advanced_Adding_Vehicles/#simple-example-of-vehicle-assignment","title":"Simple example of vehicle assignment\u00b6","text":"<p>Below we assign vehicles to agents with a car mode in their plans. We give default vehicles or default electric vehicles to random agents. Defaults follow the same defaults as defined in MATSim's dtd files: vehicleDefinitions_v2.0.xsd and electric_vehicles_v1.dtd. Saving this population to matsim files will produce these files.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/","title":"Advanced Plan Rescheduling","text":"In\u00a0[1]: Copied! <pre>from copy import deepcopy\n</pre> from copy import deepcopy In\u00a0[2]: Copied! <pre>from pam.read import read_matsim\nfrom pam.core import Population, Household, Person\nfrom pam.activity import Plan, Activity, Leg\nfrom pam.utils import minutes_to_datetime as mtdt, matsim_duration_to_hours\nfrom pam.variables import END_OF_DAY\n%matplotlib inline\n</pre> from pam.read import read_matsim from pam.core import Population, Household, Person from pam.activity import Plan, Activity, Leg from pam.utils import minutes_to_datetime as mtdt, matsim_duration_to_hours from pam.variables import END_OF_DAY %matplotlib inline In\u00a0[3]: Copied! <pre>from pam.scoring import CharyparNagelPlanScorer\n\ndefault_config = {\n    'mUM': 1,\n    'utilityOfLineSwitch': -1,\n    'performing': 6,\n    'waiting': 0,\n    'waitingPt': -2,\n    'lateArrival': -18,\n    'earlyDeparture': -0,\n    'work': {\n        'typicalDuration': '08:30:00',\n        # 'openingTime': '06:00:00',\n        # 'closingTime': '20:00:00',\n        # 'latestStartTime': '09:30:00',\n        # 'earliestEndTime': '16:00:00',\n        \"minimalDuration\": \"08:00:00\"\n        },\n    'home': {\n        'typicalDuration': '12:00:00',\n        \"minimalDuration\": \"08:00:00\"\n        },\n    'shop': {\n        'typicalDuration': '00:30:00',\n        \"minimalDuration\": \"00:10:00\"\n        },\n    'education': {\n        'typicalDuration': '08:30:00',\n        \"minimalDuration\": \"06:00:00\"\n        },\n    'car': {\n        # 'constant': -0,\n        # 'dailyMonetaryConstant': -0,\n        # 'dailyUtilityConstant': -0,\n        # 'marginalUtilityOfDistance': -0,\n        'marginalUtilityOfTravelling': -5,\n        'monetaryDistanceRate': -0.0005\n        },\n    'pt': {\n        'marginalUtilityOfTravelling': -5,\n        'monetaryDistanceRate': -0.001\n        },\n    'bus': {\n        'marginalUtilityOfTravelling': -5,\n        'monetaryDistanceRate': -0.001\n        },\n    'train': {\n        'marginalUtilityOfTravelling': -5,\n        'monetaryDistanceRate': -0.001\n        },\n    'walk': {\n        'marginalUtilityOfTravelling': -12,\n        },\n    'bike': {\n        'marginalUtilityOfTravelling': -12,\n        }\n    }\n\nconfig = {subpop: default_config for subpop in [\n    \"default\", \"high income\", \"medium income\", \"low income\", \"freight\"\n    ]}\n\nscorer = CharyparNagelPlanScorer(cnfg=config)\n</pre> from pam.scoring import CharyparNagelPlanScorer  default_config = {     'mUM': 1,     'utilityOfLineSwitch': -1,     'performing': 6,     'waiting': 0,     'waitingPt': -2,     'lateArrival': -18,     'earlyDeparture': -0,     'work': {         'typicalDuration': '08:30:00',         # 'openingTime': '06:00:00',         # 'closingTime': '20:00:00',         # 'latestStartTime': '09:30:00',         # 'earliestEndTime': '16:00:00',         \"minimalDuration\": \"08:00:00\"         },     'home': {         'typicalDuration': '12:00:00',         \"minimalDuration\": \"08:00:00\"         },     'shop': {         'typicalDuration': '00:30:00',         \"minimalDuration\": \"00:10:00\"         },     'education': {         'typicalDuration': '08:30:00',         \"minimalDuration\": \"06:00:00\"         },     'car': {         # 'constant': -0,         # 'dailyMonetaryConstant': -0,         # 'dailyUtilityConstant': -0,         # 'marginalUtilityOfDistance': -0,         'marginalUtilityOfTravelling': -5,         'monetaryDistanceRate': -0.0005         },     'pt': {         'marginalUtilityOfTravelling': -5,         'monetaryDistanceRate': -0.001         },     'bus': {         'marginalUtilityOfTravelling': -5,         'monetaryDistanceRate': -0.001         },     'train': {         'marginalUtilityOfTravelling': -5,         'monetaryDistanceRate': -0.001         },     'walk': {         'marginalUtilityOfTravelling': -12,         },     'bike': {         'marginalUtilityOfTravelling': -12,         }     }  config = {subpop: default_config for subpop in [     \"default\", \"high income\", \"medium income\", \"low income\", \"freight\"     ]}  scorer = CharyparNagelPlanScorer(cnfg=config) In\u00a0[4]: Copied! <pre>default_config = {\n    'mUM': 1,\n    'utilityOfLineSwitch': -1,\n    'performing': 6,\n    'waiting': -1,\n    'waitingPt': -2,\n    'lateArrival': -18,\n    'earlyDeparture': -6,\n    'work': {\n        'typicalDuration': '08:30:00',\n        'openingTime': '06:00:00',\n        'closingTime': '20:00:00',\n        'latestStartTime': '09:30:00',\n        'earliestEndTime': '16:00:00',\n        \"minimalDuration\": \"08:00:00\"\n        },\n    'home': {\n        'typicalDuration': '09:00:00',\n        \"minimalDuration\": \"06:00:00\",\n        'earliestEndTime': '06:00:00',\n        },\n    'shop': {\n        'openingTime': '06:00:00',\n        'closingTime': '20:00:00',\n        'typicalDuration': '00:30:00',\n        \"minimalDuration\": \"00:30:00\"\n        },\n    'education': {\n        'openingTime': '09:00:00',\n        'closingTime': '16:00:00',\n        'typicalDuration': '07:00:00',\n        \"minimalDuration\": \"06:00:00\",\n        'latestStartTime': '09:00:00',\n        'earliestEndTime': '15:30:00',\n        },\n    'car': {\n        'constant': -5,\n        'dailyMonetaryConstant': -0,\n        'dailyUtilityConstant': -0,\n        'marginalUtilityOfDistance': -0,\n        'marginalUtilityOfTravelling': -0,\n        'monetaryDistanceRate': -0.0005\n        },\n    'bus': {\n        'dailyMonetaryConstant': -5,\n        'marginalUtilityOfTravelling': -5,\n        'monetaryDistanceRate': -0.001\n        },\n    'train': {\n        'dailyMonetaryConstant': -5,\n        'marginalUtilityOfTravelling': -5,\n        'monetaryDistanceRate': -0.001\n        },\n    'walk': {\n        'marginalUtilityOfTravelling': -12,\n        },\n    'bike': {\n        'marginalUtilityOfTravelling': -12,\n        }\n    }\n\nconfig = {subpop: default_config for subpop in [\n    \"default\"\n    ]}\n\nscorer = CharyparNagelPlanScorer(cnfg=config)\n</pre> default_config = {     'mUM': 1,     'utilityOfLineSwitch': -1,     'performing': 6,     'waiting': -1,     'waitingPt': -2,     'lateArrival': -18,     'earlyDeparture': -6,     'work': {         'typicalDuration': '08:30:00',         'openingTime': '06:00:00',         'closingTime': '20:00:00',         'latestStartTime': '09:30:00',         'earliestEndTime': '16:00:00',         \"minimalDuration\": \"08:00:00\"         },     'home': {         'typicalDuration': '09:00:00',         \"minimalDuration\": \"06:00:00\",         'earliestEndTime': '06:00:00',         },     'shop': {         'openingTime': '06:00:00',         'closingTime': '20:00:00',         'typicalDuration': '00:30:00',         \"minimalDuration\": \"00:30:00\"         },     'education': {         'openingTime': '09:00:00',         'closingTime': '16:00:00',         'typicalDuration': '07:00:00',         \"minimalDuration\": \"06:00:00\",         'latestStartTime': '09:00:00',         'earliestEndTime': '15:30:00',         },     'car': {         'constant': -5,         'dailyMonetaryConstant': -0,         'dailyUtilityConstant': -0,         'marginalUtilityOfDistance': -0,         'marginalUtilityOfTravelling': -0,         'monetaryDistanceRate': -0.0005         },     'bus': {         'dailyMonetaryConstant': -5,         'marginalUtilityOfTravelling': -5,         'monetaryDistanceRate': -0.001         },     'train': {         'dailyMonetaryConstant': -5,         'marginalUtilityOfTravelling': -5,         'monetaryDistanceRate': -0.001         },     'walk': {         'marginalUtilityOfTravelling': -12,         },     'bike': {         'marginalUtilityOfTravelling': -12,         }     }  config = {subpop: default_config for subpop in [     \"default\"     ]}  scorer = CharyparNagelPlanScorer(cnfg=config) In\u00a0[5]: Copied! <pre>personA = Person('Ahmed', attributes={'age': 20, 'subpopulation': 'default'})\npersonA.plan.day = [\n    Activity(act='home', area=1, start_time=mtdt(0), end_time=mtdt(420)),\n    Leg(mode='car', start_area=1, end_area=2, start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(act='shop', area=2, start_time=mtdt(480), end_time=mtdt(510)),\n    Leg(mode='walk', start_area=2, end_area=3, start_time=mtdt(510), end_time=mtdt(570), distance=1000),\n    Activity(act='work', area=3, start_time=mtdt(570), end_time=mtdt(960)),\n    Leg(mode='car', start_area=3, end_area=1, start_time=mtdt(960), end_time=mtdt(1020), distance=1000),\n    Activity(act='home', area=1, start_time=mtdt(1020), end_time=END_OF_DAY)\n]\n\npersonB = Person('Brenda', attributes={'age': 20, 'subpopulation': 'default'})\npersonB.plan.day = [\n    Activity(act='home', area=1, start_time=mtdt(0), end_time=mtdt(300)),\n    Leg(mode='car', start_area=1, end_area=2, start_time=mtdt(300), end_time=mtdt(360), distance=1000),\n    Activity(act='shop', area=2, start_time=mtdt(360), end_time=mtdt(420)),\n    Leg(mode='walk', start_area=2, end_area=3, start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(act='work', area=3, start_time=mtdt(480), end_time=mtdt(1320)),\n    Leg(mode='car', start_area=3, end_area=1, start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),\n    Activity(act='home', area=1, start_time=mtdt(1380), end_time=END_OF_DAY)\n]\n\npersonC = Person('Cookie', attributes={'age': 20, 'subpopulation': 'default'})\npersonC.plan.day = [\n    Activity(act='home', area=1, start_time=mtdt(0), end_time=mtdt(120)),\n    Leg(mode='car', start_area=1, end_area=2, start_time=mtdt(120), end_time=mtdt(180), distance=1000),\n    Activity(act='shop', area=2, start_time=mtdt(180), end_time=mtdt(420)),\n    Leg(mode='walk', start_area=2, end_area=3, start_time=mtdt(420), end_time=mtdt(480), distance=1000),\n    Activity(act='work', area=3, start_time=mtdt(480), end_time=mtdt(1320)),\n    Leg(mode='car', start_area=3, end_area=1, start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),\n    Activity(act='home', area=1, start_time=mtdt(1380), end_time=END_OF_DAY)\n]\n\npersonA.validate()\npersonB.validate()\npersonC.validate()\n</pre> personA = Person('Ahmed', attributes={'age': 20, 'subpopulation': 'default'}) personA.plan.day = [     Activity(act='home', area=1, start_time=mtdt(0), end_time=mtdt(420)),     Leg(mode='car', start_area=1, end_area=2, start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(act='shop', area=2, start_time=mtdt(480), end_time=mtdt(510)),     Leg(mode='walk', start_area=2, end_area=3, start_time=mtdt(510), end_time=mtdt(570), distance=1000),     Activity(act='work', area=3, start_time=mtdt(570), end_time=mtdt(960)),     Leg(mode='car', start_area=3, end_area=1, start_time=mtdt(960), end_time=mtdt(1020), distance=1000),     Activity(act='home', area=1, start_time=mtdt(1020), end_time=END_OF_DAY) ]  personB = Person('Brenda', attributes={'age': 20, 'subpopulation': 'default'}) personB.plan.day = [     Activity(act='home', area=1, start_time=mtdt(0), end_time=mtdt(300)),     Leg(mode='car', start_area=1, end_area=2, start_time=mtdt(300), end_time=mtdt(360), distance=1000),     Activity(act='shop', area=2, start_time=mtdt(360), end_time=mtdt(420)),     Leg(mode='walk', start_area=2, end_area=3, start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(act='work', area=3, start_time=mtdt(480), end_time=mtdt(1320)),     Leg(mode='car', start_area=3, end_area=1, start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),     Activity(act='home', area=1, start_time=mtdt(1380), end_time=END_OF_DAY) ]  personC = Person('Cookie', attributes={'age': 20, 'subpopulation': 'default'}) personC.plan.day = [     Activity(act='home', area=1, start_time=mtdt(0), end_time=mtdt(120)),     Leg(mode='car', start_area=1, end_area=2, start_time=mtdt(120), end_time=mtdt(180), distance=1000),     Activity(act='shop', area=2, start_time=mtdt(180), end_time=mtdt(420)),     Leg(mode='walk', start_area=2, end_area=3, start_time=mtdt(420), end_time=mtdt(480), distance=1000),     Activity(act='work', area=3, start_time=mtdt(480), end_time=mtdt(1320)),     Leg(mode='car', start_area=3, end_area=1, start_time=mtdt(1320), end_time=mtdt(1380), distance=1000),     Activity(act='home', area=1, start_time=mtdt(1380), end_time=END_OF_DAY) ]  personA.validate() personB.validate() personC.validate() Out[5]: <pre>True</pre> In\u00a0[6]: Copied! <pre>print(f\"{personA.pid}'s score = {scorer.score_person(personA)}\")\npersonA.plot()\nprint(f\"{personB.pid}'s score = {scorer.score_person(personB)}\")\npersonB.plot()\nprint(f\"{personC.pid}'s score = {scorer.score_person(personC)}\")\npersonC.plot()\n</pre> print(f\"{personA.pid}'s score = {scorer.score_person(personA)}\") personA.plot() print(f\"{personB.pid}'s score = {scorer.score_person(personB)}\") personB.plot() print(f\"{personC.pid}'s score = {scorer.score_person(personC)}\") personC.plot() <pre>BT None\nBT None\nBT None\nAhmed's score = 95.17750530673948\nBT None\nBT None\nBT None\nBrenda's score = 220.77119050471717\nBT None\nBT None\nBT None\nCookie's score = 162.59537925482084\n</pre> In\u00a0[7]: Copied! <pre>from matplotlib import pyplot as plt\nfrom pam.optimise.random import reschedule\nfrom pam.optimise.grid import grid_search\n</pre> from matplotlib import pyplot as plt from pam.optimise.random import reschedule from pam.optimise.grid import grid_search In\u00a0[8]: Copied! <pre>def optimise(plan):\n    plan, log = reschedule(\n        plan,\n        plans_scorer=scorer,\n        config=config['default'],\n        patience=1000\n        )\n    # plt.plot(list(log.keys()), list(log.values()))\n    return plan\n</pre> def optimise(plan):     plan, log = reschedule(         plan,         plans_scorer=scorer,         config=config['default'],         patience=1000         )     # plt.plot(list(log.keys()), list(log.values()))     return plan In\u00a0[9]: Copied! <pre>plans = [personA.plan, personB.plan, personC.plan]\nproposed = []\nfor plan in plans:\n    proposed.append(optimise(plan))\n</pre> plans = [personA.plan, personB.plan, personC.plan] proposed = [] for plan in plans:     proposed.append(optimise(plan))  <pre>BT None\nBT None\nBT None\nInitial best score at iteration 0: 95.17750530673948\nBT None\nBT None\nBT None\nNew best score at iteration 0: 113.58213153773093\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 2: 175.4605998780295\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 9: 179.18836997666924\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 22: 199.08574941439016\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 190: 200.8661119876337\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 236: 215.22850819332848\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 259: 216.62553823837615\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nInitial best score at iteration 0: 220.77119050471717\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nInitial best score at iteration 0: 162.59537925482084\nBT None\nBT None\nBT None\nNew best score at iteration 0: 167.75309591638145\nBT None\nBT None\nBT None\nNew best score at iteration 1: 185.11751789411377\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 19: 202.86580234562976\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 78: 204.06753614142625\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 434: 211.18724612921523\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nNew best score at iteration 531: 211.94089956753658\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\nBT None\n</pre> In\u00a0[10]: Copied! <pre>from pam.array import encode, decode, distance\n</pre> from pam.array import encode, decode, distance In\u00a0[11]: Copied! <pre>encode.plan_to_one_hot(\n    plans[0],\n    mapping = {\"home\":0, \"travel\":1, \"shop\":2, \"work\":3}\n)\n</pre> encode.plan_to_one_hot(     plans[0],     mapping = {\"home\":0, \"travel\":1, \"shop\":2, \"work\":3} ) Out[11]: <pre>array([[1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 0., 0., 1.],\n       [0., 1., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.],\n       [1., 0., 0., 0.]])</pre> In\u00a0[12]: Copied! <pre>ranked = {}\nfor i, p in zip(plans, proposed):\n    i_encoded = encode.plan_to_one_hot(\n        i,\n        mapping = {\"home\":0, \"travel\":1, \"shop\":2, \"work\":3},\n        bin_size=900\n    )\n    p_encoded = encode.plan_to_one_hot(\n        p,\n        mapping = {\"home\":0, \"travel\":1, \"shop\":2, \"work\":3},\n        bin_size=900\n    )\n    difference = distance.accuracy(i_encoded, p_encoded)\n    ranked[difference] = i\n</pre> ranked = {} for i, p in zip(plans, proposed):     i_encoded = encode.plan_to_one_hot(         i,         mapping = {\"home\":0, \"travel\":1, \"shop\":2, \"work\":3},         bin_size=900     )     p_encoded = encode.plan_to_one_hot(         p,         mapping = {\"home\":0, \"travel\":1, \"shop\":2, \"work\":3},         bin_size=900     )     difference = distance.accuracy(i_encoded, p_encoded)     ranked[difference] = i  In\u00a0[13]: Copied! <pre>ranked = dict(sorted(ranked.items()))\n</pre> ranked = dict(sorted(ranked.items())) In\u00a0[14]: Copied! <pre>for score, plan in ranked.items():\n    print(score)\n    plan.plot()\n</pre> for score, plan in ranked.items():     print(score)     plan.plot() <pre>0.40625\n0.78125\n1.0\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#toy-data","title":"Toy Data\u00b6","text":""},{"location":"examples/11_Advanced_Plan_Rescheduling/#calibration","title":"Calibration\u00b6","text":""},{"location":"examples/11_Advanced_Plan_Rescheduling/#optimising-utility-score-sans-matsim","title":"Optimising utility score sans MATSim\u00b6","text":"<p>Note that we are not messing with the sequence or the trips, or locations - so trips distances and times do not vary.</p>"},{"location":"examples/11_Advanced_Plan_Rescheduling/#random-search-for-optima","title":"Random Search for Optima\u00b6","text":""},{"location":"examples/06_PAM_Complex_Policies/","title":"PAM Complex Policies","text":"In\u00a0[1]: Copied! <pre>import os\nimport pandas as pd\nimport random\nfrom copy import deepcopy\nfrom collections import defaultdict\nimport geopandas as gp\nfrom matplotlib import pyplot as plt\nfrom pam.core import Population, Household, Person\nfrom pam.activity import Plan, Activity, Leg\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\nimport pam.plot as plot\n\nfrom pam.policy import *\n</pre> import os import pandas as pd import random from copy import deepcopy from collections import defaultdict import geopandas as gp from matplotlib import pyplot as plt from pam.core import Population, Household, Person from pam.activity import Plan, Activity, Leg from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY import pam.plot as plot  from pam.policy import * In\u00a0[2]: Copied! <pre>def print_simple_stats(population):\n\"\"\"\n    Print some simple population statistics.\n    \"\"\"\n    time_at_home = 0\n    travel_time = 0 \n    low_income_central_trips = 0\n    high_income_central_trips = 0\n    \n    for hid, hh in population.households.items():\n        for pid, person in hh.people.items():\n            freq = person.freq\n            \n            for p in person.plan:\n                if p.act == 'travel':\n                    duration = p.duration.seconds * freq / 3600\n                    travel_time += duration\n                    \n                    if p.end_location.area == \"Westminster,City of London\":\n                        if person.attributes['inc'] == \"low\":\n                            low_income_central_trips += freq\n                            \n                        elif person.attributes['inc'] == \"high\":\n                            high_income_central_trips += freq\n                    \n                else:  # activity\n                    if p.act == 'home':\n                        duration = p.duration.seconds * freq / 3600\n                        time_at_home += duration\n                        \n    print(f\"Population total time at home: {time_at_home:.2f} hours\")\n    print(f\"Population total travel time: {travel_time:.2f} hours\")\n</pre> def print_simple_stats(population):     \"\"\"     Print some simple population statistics.     \"\"\"     time_at_home = 0     travel_time = 0      low_income_central_trips = 0     high_income_central_trips = 0          for hid, hh in population.households.items():         for pid, person in hh.people.items():             freq = person.freq                          for p in person.plan:                 if p.act == 'travel':                     duration = p.duration.seconds * freq / 3600                     travel_time += duration                                          if p.end_location.area == \"Westminster,City of London\":                         if person.attributes['inc'] == \"low\":                             low_income_central_trips += freq                                                      elif person.attributes['inc'] == \"high\":                             high_income_central_trips += freq                                      else:  # activity                     if p.act == 'home':                         duration = p.duration.seconds * freq / 3600                         time_at_home += duration                              print(f\"Population total time at home: {time_at_home:.2f} hours\")     print(f\"Population total travel time: {travel_time:.2f} hours\") In\u00a0[3]: Copied! <pre>population = Population()\n</pre> population = Population() In\u00a0[4]: Copied! <pre>smith_id = 'Smith'\n\nBilly = Person('Billy', freq=1, attributes={'age': 26, 'job': 'employed', 'gender': 'female', 'key_worker': False})\n\nBilly.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))\nBilly.add(Leg(1, 'car', start_area='a', end_area='g', start_time=mtdt(8 * 60),end_time=mtdt(8 * 60 + 20)))\nBilly.add(Activity(2, 'work', 'g', start_time=mtdt(8 * 60 + 20),end_time=mtdt(17 * 60)))\nBilly.add(Leg(2, 'car', start_area='g', end_area='a', start_time=mtdt(17 * 60), end_time=mtdt(17 * 60 + 25)))\nBilly.add(Activity(3,'home', 'a',start_time=mtdt(17 * 60 + 25),end_time=END_OF_DAY))\n\n\nBobby = Person('Bobby', freq=1, attributes={'age': 6, 'job': 'education', 'gender': 'male', 'key_worker': False})\nBobby.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))\nBobby.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30)))\nBobby.add(Activity(2, 'education', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60)))\nBobby.add(Leg(2, 'walk', 'b', 'c', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 35)))\nBobby.add(Activity(3, 'home', 'a', start_time=mtdt(16 * 60 + 30), end_time=mtdt(18 * 60)))\nBobby.add(Leg(3, 'car', 'a', 'b', start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))\nBobby.add(Activity(4, 'shop_1', 'b', start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50)))\nBobby.add(Leg(4, 'car', 'b', 'b', start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60)))\nBobby.add(Activity(5, 'shop_2', 'b', start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50)))\nBobby.add(Leg(5, 'car', 'b', 'a', start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10)))\nBobby.add(Activity(6, 'home', 'a', start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))\n\nBradly = Person('Bradly', freq=1, attributes={'age': 40, 'job': 'employed', 'gender': 'male', 'key_worker': True})\nBradly.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))\n\nBradly.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20)))\nBradly.add(Activity(2, 'escort', 'b', start_time=mtdt(8 * 60 + 20), end_time=mtdt(8 * 60 + 30)))\nBradly.add(Leg(2, 'pt', 'b', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(9 * 60)))\n\nBradly.add(Activity(4, 'work', 'b', start_time=mtdt(9 * 60), end_time=mtdt(10 * 60)))\nBradly.add(Leg(3, 'pt', 'b', 'c', start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 20)))\nBradly.add(Activity(4, 'work', 'b', start_time=mtdt(10 * 60 + 20), end_time=mtdt(12 * 60)))\nBradly.add(Leg(4, 'pt', 'b', 'c', start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 20)))\nBradly.add(Activity(5, 'work', 'b', start_time=mtdt(12 * 60 + 20), end_time=mtdt(14 * 60)))\nBradly.add(Leg(5, 'pt', 'b', 'c', start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))\n\nBradly.add(Activity(6, 'leisure', 'c', start_time=mtdt(14 * 60 + 20), end_time=mtdt(15 * 60 + 30)))\nBradly.add(Leg(4, 'pt', 'c', 'b', start_time=mtdt(15 * 60 + 30), end_time=mtdt(16 * 60 - 10)))\nBradly.add(Activity(5, 'escort', 'b', start_time=mtdt(16 * 60 - 10), end_time=mtdt(16 * 60)))\nBradly.add(Leg(5, 'walk', 'b', 'a', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20)))\n\nBradly.add(Activity(8, 'home', 'a', start_time=mtdt(16 * 60 + 20), end_time=mtdt(18 * 60)))\nBradly.add(Leg(8, 'car', 'a', 'b', start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))\nBradly.add(Activity(9, 'shop_1', 'b', start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50)))\nBradly.add(Leg(9, 'car', 'b', 'b', start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60)))\nBradly.add(Activity(10, 'shop_2', 'b', start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50)))\nBradly.add(Leg(10, 'car', 'b', 'a', start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10)))\nBradly.add(Activity(11, 'home', 'a', start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))\n\nsmiths = Household(smith_id)\nfor person in [Billy, Bradly, Bobby]:\n    smiths.add(person)\n\nsmiths.people\n</pre> smith_id = 'Smith'  Billy = Person('Billy', freq=1, attributes={'age': 26, 'job': 'employed', 'gender': 'female', 'key_worker': False})  Billy.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60))) Billy.add(Leg(1, 'car', start_area='a', end_area='g', start_time=mtdt(8 * 60),end_time=mtdt(8 * 60 + 20))) Billy.add(Activity(2, 'work', 'g', start_time=mtdt(8 * 60 + 20),end_time=mtdt(17 * 60))) Billy.add(Leg(2, 'car', start_area='g', end_area='a', start_time=mtdt(17 * 60), end_time=mtdt(17 * 60 + 25))) Billy.add(Activity(3,'home', 'a',start_time=mtdt(17 * 60 + 25),end_time=END_OF_DAY))   Bobby = Person('Bobby', freq=1, attributes={'age': 6, 'job': 'education', 'gender': 'male', 'key_worker': False}) Bobby.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60))) Bobby.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30))) Bobby.add(Activity(2, 'education', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60))) Bobby.add(Leg(2, 'walk', 'b', 'c', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 35))) Bobby.add(Activity(3, 'home', 'a', start_time=mtdt(16 * 60 + 30), end_time=mtdt(18 * 60))) Bobby.add(Leg(3, 'car', 'a', 'b', start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20))) Bobby.add(Activity(4, 'shop_1', 'b', start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50))) Bobby.add(Leg(4, 'car', 'b', 'b', start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60))) Bobby.add(Activity(5, 'shop_2', 'b', start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50))) Bobby.add(Leg(5, 'car', 'b', 'a', start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10))) Bobby.add(Activity(6, 'home', 'a', start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))  Bradly = Person('Bradly', freq=1, attributes={'age': 40, 'job': 'employed', 'gender': 'male', 'key_worker': True}) Bradly.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))  Bradly.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 20))) Bradly.add(Activity(2, 'escort', 'b', start_time=mtdt(8 * 60 + 20), end_time=mtdt(8 * 60 + 30))) Bradly.add(Leg(2, 'pt', 'b', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(9 * 60)))  Bradly.add(Activity(4, 'work', 'b', start_time=mtdt(9 * 60), end_time=mtdt(10 * 60))) Bradly.add(Leg(3, 'pt', 'b', 'c', start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 20))) Bradly.add(Activity(4, 'work', 'b', start_time=mtdt(10 * 60 + 20), end_time=mtdt(12 * 60))) Bradly.add(Leg(4, 'pt', 'b', 'c', start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 20))) Bradly.add(Activity(5, 'work', 'b', start_time=mtdt(12 * 60 + 20), end_time=mtdt(14 * 60))) Bradly.add(Leg(5, 'pt', 'b', 'c', start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))  Bradly.add(Activity(6, 'leisure', 'c', start_time=mtdt(14 * 60 + 20), end_time=mtdt(15 * 60 + 30))) Bradly.add(Leg(4, 'pt', 'c', 'b', start_time=mtdt(15 * 60 + 30), end_time=mtdt(16 * 60 - 10))) Bradly.add(Activity(5, 'escort', 'b', start_time=mtdt(16 * 60 - 10), end_time=mtdt(16 * 60))) Bradly.add(Leg(5, 'walk', 'b', 'a', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20)))  Bradly.add(Activity(8, 'home', 'a', start_time=mtdt(16 * 60 + 20), end_time=mtdt(18 * 60))) Bradly.add(Leg(8, 'car', 'a', 'b', start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20))) Bradly.add(Activity(9, 'shop_1', 'b', start_time=mtdt(18 * 60 + 20), end_time=mtdt(18 * 60 + 50))) Bradly.add(Leg(9, 'car', 'b', 'b', start_time=mtdt(18 * 60 + 50), end_time=mtdt(19 * 60))) Bradly.add(Activity(10, 'shop_2', 'b', start_time=mtdt(19 * 60), end_time=mtdt(19 * 60 + 50))) Bradly.add(Leg(10, 'car', 'b', 'a', start_time=mtdt(19 * 60 + 50), end_time=mtdt(20 * 60 + 10))) Bradly.add(Activity(11, 'home', 'a', start_time=mtdt(20 * 60 + 10), end_time=END_OF_DAY))  smiths = Household(smith_id) for person in [Billy, Bradly, Bobby]:     smiths.add(person)  smiths.people Out[4]: <pre>{'Billy': &lt;pam.core.Person at 0x11e40e5f8&gt;,\n 'Bradly': &lt;pam.core.Person at 0x11e410198&gt;,\n 'Bobby': &lt;pam.core.Person at 0x11e40e9b0&gt;}</pre> In\u00a0[5]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[6]: Copied! <pre>population.add(smiths)\n</pre> population.add(smiths) In\u00a0[7]: Copied! <pre>jones_id = 'Jones'\n\nHugh = Person('Hugh', freq=1, attributes={'age': 100, 'job': 'unemployed', 'gender': 'male', 'key_worker': False})\nHugh.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))\nHugh.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))\nHugh.add(Activity(2, 'health', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(10 * 60)))\nHugh.add(Leg(2, 'walk', 'b', 'a', start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 30)))\nHugh.add(Activity(3, 'home', 'a', start_time=mtdt(10 * 60 + 30), end_time=mtdt(14 * 60)))\nHugh.add(Leg(3, 'walk', 'a', 'b', start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 30)))\nHugh.add(Activity(4, 'health', 'b', start_time=mtdt(14 * 60 + 30), end_time=mtdt(16 * 60)))\nHugh.add(Leg(4, 'walk', 'b', 'a', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))\nHugh.add(Activity(5, 'home', 'a', start_time=mtdt(16 * 60 + 30), end_time=END_OF_DAY))\n\nBridget = Person('Bridget', freq=1, attributes={'age': 35, 'job': 'employed', 'gender': 'female', 'key_worker': False})\nBridget.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))\nBridget.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))\nBridget.add(Activity(2, 'escort', 'b', start_time=mtdt(8 * 60 + 5), end_time=mtdt(10 * 60 + 30)))\nBridget.add(Leg(2, 'pt', 'b', 'c', start_time=mtdt(10 * 60 + 30), end_time=mtdt(11 * 60)))\nBridget.add(Activity(3, 'work', 'c', start_time=mtdt(11 * 60), end_time=mtdt(16 * 60)))\nBridget.add(Leg(3, 'pt', 'c', 'a', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20)))\nBridget.add(Activity(4, 'home', 'a', start_time=mtdt(16 * 60 + 20), end_time=mtdt(17 * 60 + 20)))\nBridget.add(Leg(4, 'pt', 'c', 'a', start_time=mtdt(17 * 60 + 20), end_time=mtdt(17 * 60 + 50)))\nBridget.add(Activity(5, 'shop', 'a', start_time=mtdt(17 * 60 + 50), end_time=mtdt(18 * 60 + 30)))\nBridget.add(Leg(5, 'pt', 'c', 'a', start_time=mtdt(18 * 60 + 30), end_time=mtdt(18 * 60 + 50)))\nBridget.add(Activity(6, 'home', 'a', start_time=mtdt(18 * 60 + 50), end_time=END_OF_DAY))\n\njones = Household(jones_id)\nfor person in [Hugh, Bridget]:\n    jones.add(person)\n\njones.people\n</pre> jones_id = 'Jones'  Hugh = Person('Hugh', freq=1, attributes={'age': 100, 'job': 'unemployed', 'gender': 'male', 'key_worker': False}) Hugh.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60))) Hugh.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30))) Hugh.add(Activity(2, 'health', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(10 * 60))) Hugh.add(Leg(2, 'walk', 'b', 'a', start_time=mtdt(10 * 60), end_time=mtdt(10 * 60 + 30))) Hugh.add(Activity(3, 'home', 'a', start_time=mtdt(10 * 60 + 30), end_time=mtdt(14 * 60))) Hugh.add(Leg(3, 'walk', 'a', 'b', start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 30))) Hugh.add(Activity(4, 'health', 'b', start_time=mtdt(14 * 60 + 30), end_time=mtdt(16 * 60))) Hugh.add(Leg(4, 'walk', 'b', 'a', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30))) Hugh.add(Activity(5, 'home', 'a', start_time=mtdt(16 * 60 + 30), end_time=END_OF_DAY))  Bridget = Person('Bridget', freq=1, attributes={'age': 35, 'job': 'employed', 'gender': 'female', 'key_worker': False}) Bridget.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60))) Bridget.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5))) Bridget.add(Activity(2, 'escort', 'b', start_time=mtdt(8 * 60 + 5), end_time=mtdt(10 * 60 + 30))) Bridget.add(Leg(2, 'pt', 'b', 'c', start_time=mtdt(10 * 60 + 30), end_time=mtdt(11 * 60))) Bridget.add(Activity(3, 'work', 'c', start_time=mtdt(11 * 60), end_time=mtdt(16 * 60))) Bridget.add(Leg(3, 'pt', 'c', 'a', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 20))) Bridget.add(Activity(4, 'home', 'a', start_time=mtdt(16 * 60 + 20), end_time=mtdt(17 * 60 + 20))) Bridget.add(Leg(4, 'pt', 'c', 'a', start_time=mtdt(17 * 60 + 20), end_time=mtdt(17 * 60 + 50))) Bridget.add(Activity(5, 'shop', 'a', start_time=mtdt(17 * 60 + 50), end_time=mtdt(18 * 60 + 30))) Bridget.add(Leg(5, 'pt', 'c', 'a', start_time=mtdt(18 * 60 + 30), end_time=mtdt(18 * 60 + 50))) Bridget.add(Activity(6, 'home', 'a', start_time=mtdt(18 * 60 + 50), end_time=END_OF_DAY))  jones = Household(jones_id) for person in [Hugh, Bridget]:     jones.add(person)  jones.people Out[7]: <pre>{'Hugh': &lt;pam.core.Person at 0x11ed39588&gt;,\n 'Bridget': &lt;pam.core.Person at 0x11ed39ba8&gt;}</pre> In\u00a0[8]: Copied! <pre>jones.plot()\n</pre> jones.plot() In\u00a0[9]: Copied! <pre>population.add(jones)\n</pre> population.add(jones) In\u00a0[10]: Copied! <pre>print_simple_stats(population)\n</pre> print_simple_stats(population) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[11]: Copied! <pre>def discrete_joint_distribution_sampler(obj, mapping, distribution):\n\"\"\"\n    Randomly sample from a joint distribution based some discrete features.\n    Where features are a dictionary structure of features, eg: {'gender':'female'}\n    Distribution is a nested dict of probabilities based on possible features, eg:\n    {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': 1}}\n    Mapping provides the feature name for each level of the distribution, eg:\n    ['age', 'gender']\n    \"\"\"\n    p = distribution\n    for key in mapping:\n        value = obj.attributes.get(key)\n        if value is None:\n            raise KeyError(f\"Cannot find mapping: {key} in sampling features: {features}\")\n        p = p.get(value)\n        if p is None:\n            raise KeyError(f\"Cannot find feature for {key}: {value} in distribution: {p}\")\n\n    return p\n</pre> def discrete_joint_distribution_sampler(obj, mapping, distribution):     \"\"\"     Randomly sample from a joint distribution based some discrete features.     Where features are a dictionary structure of features, eg: {'gender':'female'}     Distribution is a nested dict of probabilities based on possible features, eg:     {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': 1}}     Mapping provides the feature name for each level of the distribution, eg:     ['age', 'gender']     \"\"\"     p = distribution     for key in mapping:         value = obj.attributes.get(key)         if value is None:             raise KeyError(f\"Cannot find mapping: {key} in sampling features: {features}\")         p = p.get(value)         if p is None:             raise KeyError(f\"Cannot find feature for {key}: {value} in distribution: {p}\")      return p In\u00a0[12]: Copied! <pre>vulnerable_mapping = ['age', 'gender']\nvulnerable_distribution = dict(zip(list(range(101)), [{'male': i/100, 'female': i/100, 'other': i/100} for i in range(101)]))\n</pre> vulnerable_mapping = ['age', 'gender'] vulnerable_distribution = dict(zip(list(range(101)), [{'male': i/100, 'female': i/100, 'other': i/100} for i in range(101)])) In\u00a0[13]: Copied! <pre>dict(list(vulnerable_distribution.items())[0:15])\n</pre> dict(list(vulnerable_distribution.items())[0:15]) Out[13]: <pre>{0: {'male': 0.0, 'female': 0.0, 'other': 0.0},\n 1: {'male': 0.01, 'female': 0.01, 'other': 0.01},\n 2: {'male': 0.02, 'female': 0.02, 'other': 0.02},\n 3: {'male': 0.03, 'female': 0.03, 'other': 0.03},\n 4: {'male': 0.04, 'female': 0.04, 'other': 0.04},\n 5: {'male': 0.05, 'female': 0.05, 'other': 0.05},\n 6: {'male': 0.06, 'female': 0.06, 'other': 0.06},\n 7: {'male': 0.07, 'female': 0.07, 'other': 0.07},\n 8: {'male': 0.08, 'female': 0.08, 'other': 0.08},\n 9: {'male': 0.09, 'female': 0.09, 'other': 0.09},\n 10: {'male': 0.1, 'female': 0.1, 'other': 0.1},\n 11: {'male': 0.11, 'female': 0.11, 'other': 0.11},\n 12: {'male': 0.12, 'female': 0.12, 'other': 0.12},\n 13: {'male': 0.13, 'female': 0.13, 'other': 0.13},\n 14: {'male': 0.14, 'female': 0.14, 'other': 0.14}}</pre> In\u00a0[14]: Copied! <pre>discrete_joint_distribution_sampler(Bobby, vulnerable_mapping, vulnerable_distribution)\n</pre> discrete_joint_distribution_sampler(Bobby, vulnerable_mapping, vulnerable_distribution) Out[14]: <pre>0.06</pre> In\u00a0[15]: Copied! <pre>policy_quarantine = \\\n    HouseholdPolicy(\n        RemoveActivity(['work', 'health', 'leisure', 'escort', 'shop', 'education']), \n        PersonProbability(0.0000000000001)\n)\n</pre> policy_quarantine = \\     HouseholdPolicy(         RemoveActivity(['work', 'health', 'leisure', 'escort', 'shop', 'education']),          PersonProbability(0.0000000000001) ) In\u00a0[16]: Copied! <pre>q_pop = apply_policies(population, [policy_quarantine])\nprint_simple_stats(q_pop)\n</pre> q_pop = apply_policies(population, [policy_quarantine]) print_simple_stats(q_pop) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[17]: Copied! <pre>q_pop.households['Smith'].plot()\n</pre> q_pop.households['Smith'].plot() In\u00a0[18]: Copied! <pre>q_pop.households['Jones'].plot()\n</pre> q_pop.households['Jones'].plot() In\u00a0[19]: Copied! <pre>policy_quarantine = \\\n    HouseholdPolicy(\n        RemoveActivity(['work', 'health', 'escort', 'leisure', 'shop', 'education']), \n        PersonProbability(\n             discrete_joint_distribution_sampler, \n             dict(mapping=vulnerable_mapping, distribution=vulnerable_distribution))\n)\n</pre> policy_quarantine = \\     HouseholdPolicy(         RemoveActivity(['work', 'health', 'escort', 'leisure', 'shop', 'education']),          PersonProbability(              discrete_joint_distribution_sampler,               dict(mapping=vulnerable_mapping, distribution=vulnerable_distribution)) ) In\u00a0[20]: Copied! <pre>q_pop = apply_policies(population, [policy_quarantine])\nprint_simple_stats(q_pop)\n</pre> q_pop = apply_policies(population, [policy_quarantine]) print_simple_stats(q_pop) <pre>Population total time at home: 43.67 hours\nPopulation total travel time: 1.67 hours\n</pre> In\u00a0[21]: Copied! <pre>q_pop.households['Jones'].plot()\n</pre> q_pop.households['Jones'].plot() In\u00a0[22]: Copied! <pre>policy_quarantine = \\\n    HouseholdPolicy(\n        RemoveActivity(['work', 'health', 'escort', 'leisure', 'shop', 'education']), \n        [PersonProbability(0.5), \n         PersonProbability(\n             discrete_joint_distribution_sampler, \n             dict(mapping=vulnerable_mapping, distribution=vulnerable_distribution))]\n)\n</pre> policy_quarantine = \\     HouseholdPolicy(         RemoveActivity(['work', 'health', 'escort', 'leisure', 'shop', 'education']),          [PersonProbability(0.5),           PersonProbability(              discrete_joint_distribution_sampler,               dict(mapping=vulnerable_mapping, distribution=vulnerable_distribution))] ) In\u00a0[23]: Copied! <pre>q_pop = apply_policies(population, [policy_quarantine])\nprint_simple_stats(q_pop)\n</pre> q_pop = apply_policies(population, [policy_quarantine]) print_simple_stats(q_pop) <pre>Population total time at home: 41.42 hours\nPopulation total travel time: 5.92 hours\n</pre> In\u00a0[24]: Copied! <pre>q_pop.households['Jones'].plot()\n</pre> q_pop.households['Jones'].plot() In\u00a0[25]: Copied! <pre>edu_mapping = ['job']\nedu_distribution = {'employed': 0, 'unemployed': 0, 'education': 1}\n</pre> edu_mapping = ['job'] edu_distribution = {'employed': 0, 'unemployed': 0, 'education': 1} In\u00a0[26]: Copied! <pre>key_mapping = ['key_worker']\nkey_distribution = {True: 0, False: 1}\n</pre> key_mapping = ['key_worker'] key_distribution = {True: 0, False: 1} In\u00a0[27]: Copied! <pre>edu_distribution, key_distribution\n</pre> edu_distribution, key_distribution Out[27]: <pre>({'employed': 0, 'unemployed': 0, 'education': 1}, {True: 0, False: 1})</pre> In\u00a0[28]: Copied! <pre>policy_remove_education_and_escort = \\\n    HouseholdPolicy(\n        RemoveActivity(['education', 'escort']), \n        [PersonProbability(\n             discrete_joint_distribution_sampler, \n             dict(mapping=edu_mapping, distribution=edu_distribution)),\n         PersonProbability(\n             discrete_joint_distribution_sampler, \n             dict(mapping=key_mapping, distribution=key_distribution))])\n</pre> policy_remove_education_and_escort = \\     HouseholdPolicy(         RemoveActivity(['education', 'escort']),          [PersonProbability(              discrete_joint_distribution_sampler,               dict(mapping=edu_mapping, distribution=edu_distribution)),          PersonProbability(              discrete_joint_distribution_sampler,               dict(mapping=key_mapping, distribution=key_distribution))]) In\u00a0[29]: Copied! <pre>edu_pop = apply_policies(population, [policy_remove_education_and_escort])\nprint_simple_stats(edu_pop)\n</pre> edu_pop = apply_policies(population, [policy_remove_education_and_escort]) print_simple_stats(edu_pop) <pre>Population total time at home: 84.25 hours\nPopulation total travel time: 7.83 hours\n</pre> In\u00a0[30]: Copied! <pre>edu_pop.households['Smith'].people['Bradly'].plan.print()\n</pre> edu_pop.households['Smith'].people['Bradly'].plan.print() <pre>0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:20:00, duration:0:20:00)\n2:\tActivity(act:work, location:b, time:08:20:00 --&gt; 09:20:00, duration:1:00:00)\n3:\tLeg(mode:pt, area:b --&gt; c, time:09:20:00 --&gt; 09:40:00, duration:0:20:00)\n4:\tActivity(act:work, location:b, time:09:40:00 --&gt; 11:20:00, duration:1:40:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:11:20:00 --&gt; 11:40:00, duration:0:20:00)\n6:\tActivity(act:work, location:b, time:11:40:00 --&gt; 13:20:00, duration:1:40:00)\n7:\tLeg(mode:pt, area:b --&gt; c, time:13:20:00 --&gt; 13:40:00, duration:0:20:00)\n8:\tActivity(act:leisure, location:c, time:13:40:00 --&gt; 14:50:00, duration:1:10:00)\n9:\tLeg(mode:pt, area:c --&gt; a, time:14:50:00 --&gt; 15:10:00, duration:0:20:00)\n10:\tActivity(act:home, location:a, time:15:10:00 --&gt; 16:50:00, duration:1:40:00)\n11:\tLeg(mode:car, area:a --&gt; b, time:16:50:00 --&gt; 17:10:00, duration:0:20:00)\n12:\tActivity(act:shop_1, location:b, time:17:10:00 --&gt; 17:40:00, duration:0:30:00)\n13:\tLeg(mode:car, area:b --&gt; b, time:17:40:00 --&gt; 17:50:00, duration:0:10:00)\n14:\tActivity(act:shop_2, location:b, time:17:50:00 --&gt; 18:40:00, duration:0:50:00)\n15:\tLeg(mode:car, area:b --&gt; a, time:18:40:00 --&gt; 19:00:00, duration:0:20:00)\n16:\tActivity(act:home, location:a, time:19:00:00 --&gt; 00:00:00, duration:5:00:00)\n</pre> In\u00a0[31]: Copied! <pre>q_pop.households['Smith'].plot()\n</pre> q_pop.households['Smith'].plot() In\u00a0[32]: Copied! <pre>edu_pop.households['Smith'].plot()\n</pre> edu_pop.households['Smith'].plot() In\u00a0[33]: Copied! <pre>edu_pop.households['Jones'].plot()\n</pre> edu_pop.households['Jones'].plot() In\u00a0[34]: Copied! <pre>edu_pop.households['Jones'].people['Bridget'].plan.print()\n</pre> edu_pop.households['Jones'].people['Bridget'].plan.print() <pre>0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:escort, location:b, time:08:05:00 --&gt; 10:30:00, duration:2:25:00)\n3:\tLeg(mode:pt, area:b --&gt; c, time:10:30:00 --&gt; 11:00:00, duration:0:30:00)\n4:\tActivity(act:work, location:c, time:11:00:00 --&gt; 16:00:00, duration:5:00:00)\n5:\tLeg(mode:pt, area:c --&gt; a, time:16:00:00 --&gt; 16:20:00, duration:0:20:00)\n6:\tActivity(act:home, location:a, time:16:20:00 --&gt; 17:20:00, duration:1:00:00)\n7:\tLeg(mode:pt, area:c --&gt; a, time:17:20:00 --&gt; 17:50:00, duration:0:30:00)\n8:\tActivity(act:shop, location:a, time:17:50:00 --&gt; 18:30:00, duration:0:40:00)\n9:\tLeg(mode:pt, area:c --&gt; a, time:18:30:00 --&gt; 18:50:00, duration:0:20:00)\n10:\tActivity(act:home, location:a, time:18:50:00 --&gt; 00:00:00, duration:5:10:00)\n</pre> In\u00a0[35]: Copied! <pre>def condition_job_education(val):\n    return val == 'education'\n\npolicy_remove_education_and_escort = \\\n    HouseholdPolicy(\n        RemoveActivity(['education', 'escort']), \n        PersonProbability(\n             discrete_joint_distribution_sampler, \n             dict(mapping=key_mapping, distribution=key_distribution)),\n        PersonAttributeFilter({'job': condition_job_education})\n)\n</pre> def condition_job_education(val):     return val == 'education'  policy_remove_education_and_escort = \\     HouseholdPolicy(         RemoveActivity(['education', 'escort']),          PersonProbability(              discrete_joint_distribution_sampler,               dict(mapping=key_mapping, distribution=key_distribution)),         PersonAttributeFilter({'job': condition_job_education}) ) In\u00a0[36]: Copied! <pre>apply_policies(population, [policy_remove_education_and_escort]).households['Smith'].plot()\n</pre> apply_policies(population, [policy_remove_education_and_escort]).households['Smith'].plot() In\u00a0[37]: Copied! <pre>policy_remove_education_and_escort = \\\n    HouseholdPolicy(\n        RemoveActivity(['education', 'escort']), \n        [ActivityProbability(['education'], 0.9999),\n         PersonProbability(\n             discrete_joint_distribution_sampler, \n             dict(mapping=edu_mapping, distribution=edu_distribution)),\n         PersonProbability(\n             discrete_joint_distribution_sampler, \n             dict(mapping=key_mapping, distribution=key_distribution))])\n</pre> policy_remove_education_and_escort = \\     HouseholdPolicy(         RemoveActivity(['education', 'escort']),          [ActivityProbability(['education'], 0.9999),          PersonProbability(              discrete_joint_distribution_sampler,               dict(mapping=edu_mapping, distribution=edu_distribution)),          PersonProbability(              discrete_joint_distribution_sampler,               dict(mapping=key_mapping, distribution=key_distribution))]) In\u00a0[38]: Copied! <pre>apply_policies(population, [policy_remove_education_and_escort]).households['Smith'].plot()\n</pre> apply_policies(population, [policy_remove_education_and_escort]).households['Smith'].plot() In\u00a0[39]: Copied! <pre>policy_remove_leisure = \\\n    PersonPolicy(\n        RemoveActivity(['leisure']), \n        PersonProbability(1.))\n</pre> policy_remove_leisure = \\     PersonPolicy(         RemoveActivity(['leisure']),          PersonProbability(1.)) In\u00a0[40]: Copied! <pre>lei_pop = apply_policies(population, [policy_remove_leisure])\nprint_simple_stats(lei_pop)\n</pre> lei_pop = apply_policies(population, [policy_remove_leisure]) print_simple_stats(lei_pop) <pre>Population total time at home: 76.08 hours\nPopulation total travel time: 9.33 hours\n</pre> In\u00a0[41]: Copied! <pre>lei_pop.households['Smith'].plot()\n</pre> lei_pop.households['Smith'].plot() In\u00a0[42]: Copied! <pre>key_mapping = ['key_worker']\nkey_distribution = {True: 0, False: 1}\n</pre> key_mapping = ['key_worker'] key_distribution = {True: 0, False: 1} In\u00a0[43]: Copied! <pre>policy_unemployment_and_furlough = \\\n    PersonPolicy(\n        RemoveActivity(['work']), \n        [PersonProbability(\n             discrete_joint_distribution_sampler, \n             dict(mapping=key_mapping, distribution=key_distribution)),\n#          PersonProbability(0.1)\n        ])\n</pre> policy_unemployment_and_furlough = \\     PersonPolicy(         RemoveActivity(['work']),          [PersonProbability(              discrete_joint_distribution_sampler,               dict(mapping=key_mapping, distribution=key_distribution)), #          PersonProbability(0.1)         ]) In\u00a0[44]: Copied! <pre>fur_pop = apply_policies(population, [policy_unemployment_and_furlough])\nprint_simple_stats(fur_pop)\n</pre> fur_pop = apply_policies(population, [policy_unemployment_and_furlough]) print_simple_stats(fur_pop) <pre>Population total time at home: 65.33 hours\nPopulation total travel time: 8.58 hours\n</pre> In\u00a0[45]: Copied! <pre>fur_pop.households['Smith'].plot()\n</pre> fur_pop.households['Smith'].plot() In\u00a0[46]: Copied! <pre>fur_pop.households['Jones'].plot()\n</pre> fur_pop.households['Jones'].plot() In\u00a0[47]: Copied! <pre>policy_reduced_work = \\\n    ActivityPolicy(\n        RemoveActivity(['work']), \n        ActivityProbability(['work'], 0.5))\n\napply_policies(population, [policy_reduced_work]).households['Smith'].plot()\n</pre> policy_reduced_work = \\     ActivityPolicy(         RemoveActivity(['work']),          ActivityProbability(['work'], 0.5))  apply_policies(population, [policy_reduced_work]).households['Smith'].plot() In\u00a0[48]: Copied! <pre>policy_remove_shopping = \\\n    PersonPolicy(\n        RemoveActivity(['shop']),\n        ActivityProbability(['shop'], 1.))\n</pre> policy_remove_shopping = \\     PersonPolicy(         RemoveActivity(['shop']),         ActivityProbability(['shop'], 1.)) In\u00a0[49]: Copied! <pre>shop_pop = apply_policies(population, [policy_remove_shopping])\nprint_simple_stats(shop_pop)\n</pre> shop_pop = apply_policies(population, [policy_remove_shopping]) print_simple_stats(shop_pop) <pre>Population total time at home: 76.08 hours\nPopulation total travel time: 8.83 hours\n</pre> In\u00a0[50]: Copied! <pre>shop_pop.households['Jones'].people['Bridget'].plot()\n</pre> shop_pop.households['Jones'].people['Bridget'].plot() In\u00a0[51]: Copied! <pre>policy_reduce_shopping_activities = \\\n    HouseholdPolicy(\n        ReduceSharedActivity(['shop_1', 'shop_2', 'shop']),\n        ActivityProbability(['shop_1', 'shop_2', 'shop'], 1.)\n)\n</pre> policy_reduce_shopping_activities = \\     HouseholdPolicy(         ReduceSharedActivity(['shop_1', 'shop_2', 'shop']),         ActivityProbability(['shop_1', 'shop_2', 'shop'], 1.) ) In\u00a0[52]: Copied! <pre>population['Smith'].shared_activities()\n</pre> population['Smith'].shared_activities() Out[52]: <pre>[&lt;pam.activity.Activity at 0x11e410208&gt;,\n &lt;pam.activity.Activity at 0x11e40ea20&gt;,\n &lt;pam.activity.Activity at 0x11e40edd8&gt;,\n &lt;pam.activity.Activity at 0x11e40ef28&gt;,\n &lt;pam.activity.Activity at 0x11e4100b8&gt;]</pre> In\u00a0[53]: Copied! <pre>shop_reduce_pop = apply_policies(population, [policy_reduce_shopping_activities])\nprint_simple_stats(shop_reduce_pop)\n</pre> shop_reduce_pop = apply_policies(population, [policy_reduce_shopping_activities]) print_simple_stats(shop_reduce_pop) <pre>Population total time at home: 76.75 hours\nPopulation total travel time: 8.83 hours\n</pre> In\u00a0[54]: Copied! <pre>shop_reduce_pop.households['Smith'].plot()\n</pre> shop_reduce_pop.households['Smith'].plot() In\u00a0[55]: Copied! <pre>shop_reduce_pop.households['Smith'].people['Bobby'].print()\n</pre> shop_reduce_pop.households['Smith'].people['Bobby'].print() <pre>Person: Bobby\n{'age': 6, 'job': 'education', 'gender': 'male', 'key_worker': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:25:00, duration:0:25:00)\n2:\tActivity(act:education, location:b, time:08:25:00 --&gt; 15:55:00, duration:7:30:00)\n3:\tLeg(mode:walk, area:b --&gt; c, time:15:55:00 --&gt; 16:30:00, duration:0:35:00)\n4:\tActivity(act:home, location:a, time:16:30:00 --&gt; 00:00:00, duration:7:30:00)\n</pre> In\u00a0[56]: Copied! <pre>policy_move_shopping_tours = \\\n    PersonPolicy(\n        MoveActivityTourToHomeLocation(['shop_1', 'shop_2']),\n        [ActivityProbability(['shop_1', 'shop_2'], 1.)]\n)\n</pre> policy_move_shopping_tours = \\     PersonPolicy(         MoveActivityTourToHomeLocation(['shop_1', 'shop_2']),         [ActivityProbability(['shop_1', 'shop_2'], 1.)] ) In\u00a0[57]: Copied! <pre>shop_tour_pop = apply_policies(population, [policy_move_shopping_tours])\nprint_simple_stats(shop_tour_pop)\n</pre> shop_tour_pop = apply_policies(population, [policy_move_shopping_tours]) print_simple_stats(shop_tour_pop) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[58]: Copied! <pre>shop_tour_pop.households['Smith'].plot()\n</pre> shop_tour_pop.households['Smith'].plot() In\u00a0[59]: Copied! <pre># above is equivalent to\npolicy_move_shopping_tours = \\\n    PersonPolicy(\n        MoveActivityTourToHomeLocation(['shop_1', 'shop_2']),\n        [ActivityProbability(['shop_1'], 1.), ActivityProbability(['shop_2'], 1.)]\n)\n</pre> # above is equivalent to policy_move_shopping_tours = \\     PersonPolicy(         MoveActivityTourToHomeLocation(['shop_1', 'shop_2']),         [ActivityProbability(['shop_1'], 1.), ActivityProbability(['shop_2'], 1.)] ) In\u00a0[60]: Copied! <pre>shop_tour_pop = apply_policies(population, [policy_move_shopping_tours])\nprint_simple_stats(shop_tour_pop)\n</pre> shop_tour_pop = apply_policies(population, [policy_move_shopping_tours]) print_simple_stats(shop_tour_pop) <pre>Population total time at home: 74.58 hours\nPopulation total travel time: 9.67 hours\n</pre> In\u00a0[61]: Copied! <pre>shop_tour_pop.households['Smith'].plot()\n</pre> shop_tour_pop.households['Smith'].plot() In\u00a0[62]: Copied! <pre>shop_tour_pop.households['Smith'].people['Bradly'].print()\n</pre> shop_tour_pop.households['Smith'].people['Bradly'].print() <pre>Person: Bradly\n{'age': 40, 'job': 'employed', 'gender': 'male', 'key_worker': True}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:20:00, duration:0:20:00)\n2:\tActivity(act:escort, location:b, time:08:20:00 --&gt; 08:30:00, duration:0:10:00)\n3:\tLeg(mode:pt, area:b --&gt; b, time:08:30:00 --&gt; 09:00:00, duration:0:30:00)\n4:\tActivity(act:work, location:b, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:10:00:00 --&gt; 10:20:00, duration:0:20:00)\n6:\tActivity(act:work, location:b, time:10:20:00 --&gt; 12:00:00, duration:1:40:00)\n7:\tLeg(mode:pt, area:b --&gt; c, time:12:00:00 --&gt; 12:20:00, duration:0:20:00)\n8:\tActivity(act:work, location:b, time:12:20:00 --&gt; 14:00:00, duration:1:40:00)\n9:\tLeg(mode:pt, area:b --&gt; c, time:14:00:00 --&gt; 14:20:00, duration:0:20:00)\n10:\tActivity(act:leisure, location:c, time:14:20:00 --&gt; 15:30:00, duration:1:10:00)\n11:\tLeg(mode:pt, area:c --&gt; b, time:15:30:00 --&gt; 15:50:00, duration:0:20:00)\n12:\tActivity(act:escort, location:b, time:15:50:00 --&gt; 16:00:00, duration:0:10:00)\n13:\tLeg(mode:walk, area:b --&gt; a, time:16:00:00 --&gt; 16:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:16:20:00 --&gt; 18:00:00, duration:1:40:00)\n15:\tLeg(mode:walk, area:a --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:a, time:18:20:00 --&gt; 18:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:a --&gt; a, time:18:50:00 --&gt; 19:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:a, time:19:00:00 --&gt; 19:50:00, duration:0:50:00)\n19:\tLeg(mode:walk, area:a --&gt; a, time:19:50:00 --&gt; 20:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:20:10:00 --&gt; 00:00:00, duration:3:50:00)\n</pre> In\u00a0[63]: Copied! <pre>all_together_pop = apply_policies(\n    population, \n    [policy_quarantine, \n     policy_remove_education_and_escort, \n     policy_remove_leisure, \n     policy_unemployment_and_furlough, \n     policy_remove_shopping])\n\nprint_simple_stats(all_together_pop)\n</pre> all_together_pop = apply_policies(     population,      [policy_quarantine,       policy_remove_education_and_escort,       policy_remove_leisure,       policy_unemployment_and_furlough,       policy_remove_shopping])  print_simple_stats(all_together_pop) <pre>Population total time at home: 38.00 hours\nPopulation total travel time: 3.00 hours\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/06_PAM_Complex_Policies/#create-example-population","title":"Create example Population\u00b6","text":""},{"location":"examples/06_PAM_Complex_Policies/#add-smith-household","title":"Add Smith household\u00b6","text":""},{"location":"examples/06_PAM_Complex_Policies/#add-jones-household","title":"Add Jones household\u00b6","text":""},{"location":"examples/06_PAM_Complex_Policies/#pam-complex-policies","title":"PAM Complex Policies\u00b6","text":"<p>Based on link</p>"},{"location":"examples/06_PAM_Complex_Policies/#household-quarantine","title":"Household Quarantine\u00b6","text":"<p>Probabilistically apply quarantine to a household (remove all activities - stay at home)</p>"},{"location":"examples/06_PAM_Complex_Policies/#person-based-all-people-equal","title":"Person-based, all people equal\u00b6","text":"<p>If you have a probability of any person having to be quarantined</p>"},{"location":"examples/06_PAM_Complex_Policies/#using-joint-distribution","title":"Using joint distribution\u00b6","text":""},{"location":"examples/06_PAM_Complex_Policies/#chaining-probabilities","title":"Chaining probabilities\u00b6","text":""},{"location":"examples/06_PAM_Complex_Policies/#remove-education","title":"Remove Education\u00b6","text":"<p>Probabilistically remove education activities from a person and escort from people in the same household</p>"},{"location":"examples/06_PAM_Complex_Policies/#personattributefilter","title":"PersonAttributeFilter\u00b6","text":"<p>You can also use the <code>modify.PersonAttributeFilter</code> to only affect people with certain attributes.</p>"},{"location":"examples/06_PAM_Complex_Policies/#remove-leisure-activities","title":"Remove Leisure Activities\u00b6","text":"<p>Remove all leisure activities</p>"},{"location":"examples/06_PAM_Complex_Policies/#unemploymentfurlough","title":"Unemployment/Furlough\u00b6","text":"<p>Probabilistically remove all work activities from a person</p>"},{"location":"examples/06_PAM_Complex_Policies/#remove-shopping","title":"Remove Shopping\u00b6","text":"<p>Probabilistically remove individual shopping activities from a person</p>"},{"location":"examples/06_PAM_Complex_Policies/#reducing-shared-activities","title":"Reducing shared activities\u00b6","text":""},{"location":"examples/06_PAM_Complex_Policies/#moving-shopping-tours","title":"Moving Shopping tours\u00b6","text":""},{"location":"examples/06_PAM_Complex_Policies/#all-together-now","title":"All together now!\u00b6","text":""},{"location":"examples/10_Advanced_Spatial-Sampling_Demo/","title":"Advanced Spatial-Sampling Demo","text":"<p>The purpose of this notebook is to demonstrate weighted and rule-based facility sampling methods.</p> <p>PAM offers a facility sampler, which can be called wtih <code>pam.samplers.facility.FacilitySampler(facilities, zones, ...)</code>, where <code>facilities</code> and <code>zones</code> are geodataframes containing the available activity locations and the model zoning system respectively.</p> <p>The <code>weight_on</code> option of the sampler allows to specify a column of the facilities dataset to be used for weighting the candidate locations (for example, by floorspace). nb: weighted sampling here samples with replacement, while the default (unweighted) option iterates across a shuffled list of the candidate locations instead).</p> <p>By providing a <code>max_walk</code> argument, we constrain activity locations accessed with PT modes (named as <code>bus</code>, <code>rail</code>, or <code>pt</code>) to be located within that distance (crow's fly) from a PT stop. The distance of each facility from a PT stop should be provided in the <code>facilities</code> dataset (under the <code>transit</code> field).</p> <p>We can sample facility locations for a PAM population, with the <code>population.sample_locs(sampler)</code> method, where sampler is an instance of <code>pam.samplers.facility.FacilitySampler</code>. Depending whether we <code>weight_on</code> option was activated for the sampler, it will undertake simple or weighted sampling.</p> <p>To accommodate more complex sampling techniques, we have introduced <code>population.sample_locs_complex(sampler)</code>. This method passes additional information to the sampler, such as the duration and mode of arriving trip and the previous activity location. The sampler then applies some extra rules:</p> <ul> <li>distance-weighted sampling: for the given trip duration, try to adjust candidate facility weights so that their distance from the previous location is consistent with the trip duration and mode speed. The weights are adjusted as $ adjusted\\_weight_j =  \\frac{weight_j}{expected\\_distance_{ij}^2}$, where $ expected\\_distance_{ij} = \\lvert{distance_{ij} - (duration * speed)}\\rvert $. The mode speeds (expressed in euclidean distance terms) are defined in <code>pam.variables.EXPECTED_EUCLIDEAN_SPEEDS</code> dictionary.</li> <li>distance from PT stop rule: if the mode is PT and <code>max_walk</code> has been provided, contrain the options within the specified radius from a stop</li> </ul> <p>Caveats</p> <ul> <li>The complex sampler is experimental at this stage and should be used with care.</li> <li>All distance units are calculated as euclidean distances. Expected speeds should also be expressed in euclidean measures. Distance calculations assume a linear-unit (meters) coordinate system. In the future, we should try to integrate model skims in the calculation.</li> <li>Distance-based weighting can be used to help better align sampled durations with locations. However, it only looks one trip ahead, and it is likely to be inconsistent for the last trip (ie the path doesn't necessarily \"close\" well).</li> </ul> In\u00a0[1]: Copied! <pre>import pandas as pd\nimport numpy as np\nimport os\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon, Point\n\nimport pam\nfrom pam.samplers import facility\nfrom pam import read, write\n\n%load_ext autoreload\n%autoreload 2\n</pre> import pandas as pd import numpy as np import os import geopandas as gp import matplotlib.pyplot as plt from shapely.geometry import Polygon, Point  import pam from pam.samplers import facility from pam import read, write  %load_ext autoreload %autoreload 2 <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> <p>Create a dummy dataset of facilities and their locations:</p> In\u00a0[2]: Copied! <pre># create random spatial data\n\n# create zones\nl = 10000 # square length in meters\npolygon_list = []\nzone_list = ['a','b','c','d','e','f','g','h','i']\nactivities_list = ['home','work', 'other', 'shop', 'escort','education']\n\nfor y in [2*l,l,0]:\n    for x in [0,l,2*l]:\n        polygon_list.append(Polygon([[x,y],[x+l,y],[x+l,y+l],[x,y+l],[x,y]]))\n        \nzones = gp.GeoDataFrame(geometry = polygon_list)\nzones['zone'] = zone_list\nzones.set_index('zone', inplace = True)\n\n# create facilities\npoint_list = []\nfor activity in activities_list:\n    for i in range(1000):\n        point = Point(np.random.rand() * 3 * l, np.random.rand() * 3 * l)\n        point_list.append({'activity':activity,\n                           'floors': np.random.randint(1,4),\n                           'units': np.random.randint(1,20),\n                           'area': np.random.randint(1,100),\n                           'transit': np.random.randint(1,10000),                           \n                           'geometry':point})\n            \nfacilities = gp.GeoDataFrame(point_list)\nfacilities = gp.sjoin(facilities, zones.reset_index()).drop(columns='index_right')\n\n\n# plot\nfig, ax = plt.subplots(1,1, figsize = (10,7))\nzones.boundary.plot(ax = ax)\nfacilities.plot(ax=ax, markersize=2, color='purple')\nfor zone, centroid in zip(zones.index, zones.centroid):\n    ax.annotate(zone, xy = (centroid.x, centroid.y), size = 15)\nax.axis('off')\nplt.show()\n</pre> # create random spatial data  # create zones l = 10000 # square length in meters polygon_list = [] zone_list = ['a','b','c','d','e','f','g','h','i'] activities_list = ['home','work', 'other', 'shop', 'escort','education']  for y in [2*l,l,0]:     for x in [0,l,2*l]:         polygon_list.append(Polygon([[x,y],[x+l,y],[x+l,y+l],[x,y+l],[x,y]]))          zones = gp.GeoDataFrame(geometry = polygon_list) zones['zone'] = zone_list zones.set_index('zone', inplace = True)  # create facilities point_list = [] for activity in activities_list:     for i in range(1000):         point = Point(np.random.rand() * 3 * l, np.random.rand() * 3 * l)         point_list.append({'activity':activity,                            'floors': np.random.randint(1,4),                            'units': np.random.randint(1,20),                            'area': np.random.randint(1,100),                            'transit': np.random.randint(1,10000),                                                       'geometry':point})              facilities = gp.GeoDataFrame(point_list) facilities = gp.sjoin(facilities, zones.reset_index()).drop(columns='index_right')   # plot fig, ax = plt.subplots(1,1, figsize = (10,7)) zones.boundary.plot(ax = ax) facilities.plot(ax=ax, markersize=2, color='purple') for zone, centroid in zip(zones.index, zones.centroid):     ax.annotate(zone, xy = (centroid.x, centroid.y), size = 15) ax.axis('off') plt.show() In\u00a0[3]: Copied! <pre># facilities dataset:\nfacilities.head()\n</pre> # facilities dataset: facilities.head() Out[3]: activity floors units area transit geometry zone 0 home 1 19 24 7070 POINT (29242.634 27824.496) c 3 home 2 5 91 9817 POINT (29804.785 21254.881) c 17 home 1 6 16 2917 POINT (27002.096 24332.130) c 24 home 1 5 81 4398 POINT (25114.389 20819.129) c 32 home 1 19 66 8988 POINT (21096.073 20772.556) c In\u00a0[4]: Copied! <pre>from pam.core import Person, Household, Population\nfrom pam.activity import Activity, Leg\nfrom pam.utils import minutes_to_datetime\n</pre> from pam.core import Person, Household, Population from pam.activity import Activity, Leg from pam.utils import minutes_to_datetime <p>Let's assume a 30-min walking commute trip from home.</p> <p>The expected straight-line speed for the trip is:</p> In\u00a0[5]: Copied! <pre>print('The expected straight-line speed for the trip is: {} kph'.format(\npam.variables.EXPECTED_EUCLIDEAN_SPEEDS['walk']\n))\n</pre> print('The expected straight-line speed for the trip is: {} kph'.format( pam.variables.EXPECTED_EUCLIDEAN_SPEEDS['walk'] )) <pre>The expected straight-line speed for the trip is: 1.3888888888888888 kph\n</pre> <p>Therefore, we expect the sampler to pick a workplace location approx 5 * 0.5=2.5km from home.</p> In\u00a0[6]: Copied! <pre>p1 =  Person('p1', attributes={'age': 40})\np1.add(Activity(seq=1,act='home',area='a',start_time=minutes_to_datetime(0),end_time=minutes_to_datetime(60)))\np1.add(Leg(seq=1,mode='walk',start_area='a',end_area='a',\n           start_time=minutes_to_datetime(60),end_time=minutes_to_datetime(90)))\np1.add(Activity(seq=2,act='work',area='a',start_time=minutes_to_datetime(90),end_time=minutes_to_datetime(120)))\n\nhh1 = Household(0)\nhh1.add(p1)\n\npopulation = Population()\npopulation.add(hh1)\n</pre> p1 =  Person('p1', attributes={'age': 40}) p1.add(Activity(seq=1,act='home',area='a',start_time=minutes_to_datetime(0),end_time=minutes_to_datetime(60))) p1.add(Leg(seq=1,mode='walk',start_area='a',end_area='a',            start_time=minutes_to_datetime(60),end_time=minutes_to_datetime(90))) p1.add(Activity(seq=2,act='work',area='a',start_time=minutes_to_datetime(90),end_time=minutes_to_datetime(120)))  hh1 = Household(0) hh1.add(p1)  population = Population() population.add(hh1) In\u00a0[7]: Copied! <pre># supress logger warnings\nimport logging\nlogger = logging.getLogger()\nlogger.setLevel(logging.CRITICAL)\n</pre> # supress logger warnings import logging logger = logging.getLogger() logger.setLevel(logging.CRITICAL) In\u00a0[8]: Copied! <pre>def test_sampler_distance(\n    population,\n    sampler,\n    n_iterations = 20,  # increase this\n    complex_sampler = False,\n    title=None\n    ):\n    distance_commute = []\n    \n    for i in range(n_iterations):\n        if complex_sampler:\n            population.sample_locs_complex(sampler)\n        else:\n            population.sample_locs(sampler)\n        distance_commute.append(population.trips_df()['euclidean_distance'][0])\n\n    pd.Series(distance_commute).hist(bins = 20)\n    if title!=None:\n        plt.title(title)\n    plt.xlabel('distance')\n    plt.ylabel('frequency')\n    plt.show()\n</pre> def test_sampler_distance(     population,     sampler,     n_iterations = 20,  # increase this     complex_sampler = False,     title=None     ):     distance_commute = []          for i in range(n_iterations):         if complex_sampler:             population.sample_locs_complex(sampler)         else:             population.sample_locs(sampler)         distance_commute.append(population.trips_df()['euclidean_distance'][0])      pd.Series(distance_commute).hist(bins = 20)     if title!=None:         plt.title(title)     plt.xlabel('distance')     plt.ylabel('frequency')     plt.show() In\u00a0[9]: Copied! <pre>#simple sampling \n\nfacility_sampler_nonweighted = facility.FacilitySampler(\n    facilities=facilities,\n    zones=zones,\n    build_xml=True,\n    fail=False,\n    random_default=True\n    )\n\ntest_sampler_distance(population, facility_sampler_nonweighted, complex_sampler=False,\n                     title = 'Commute distance, simple sampling')\n</pre> #simple sampling   facility_sampler_nonweighted = facility.FacilitySampler(     facilities=facilities,     zones=zones,     build_xml=True,     fail=False,     random_default=True     )  test_sampler_distance(population, facility_sampler_nonweighted, complex_sampler=False,                      title = 'Commute distance, simple sampling')  <pre>/Users/fred.shone/.ve/pam/lib/python3.7/site-packages/ipykernel_launcher.py:8: FutureWarning:\n\nThe `op` parameter is deprecated and will be removed in a future release. Please use the `predicate` parameter instead.\n\n</pre> In\u00a0[10]: Copied! <pre># distance-weighted sampling \n\ndistance_commute_weighted = []\n\nfacility_sampler_weighted = facility.FacilitySampler(\n    facilities=facilities.assign(weight1=1),\n    zones=zones,\n    build_xml=True,\n    fail=False,\n    random_default=True,\n    weight_on='weight1'\n)\n\ntest_sampler_distance(population, facility_sampler_weighted, complex_sampler=True,\n                     title='Commute distance, distance-weighted sampling')\n</pre> # distance-weighted sampling   distance_commute_weighted = []  facility_sampler_weighted = facility.FacilitySampler(     facilities=facilities.assign(weight1=1),     zones=zones,     build_xml=True,     fail=False,     random_default=True,     weight_on='weight1' )  test_sampler_distance(population, facility_sampler_weighted, complex_sampler=True,                      title='Commute distance, distance-weighted sampling') <pre>/Users/fred.shone/.ve/pam/lib/python3.7/site-packages/ipykernel_launcher.py:11: FutureWarning:\n\nThe `op` parameter is deprecated and will be removed in a future release. Please use the `predicate` parameter instead.\n\n</pre> <p>Similar experiment to above, with a 30-min car trip from zone a to zone b:</p> In\u00a0[11]: Copied! <pre>print('The expected straight-line speed for the trip is: {} kph'.format(\npam.variables.EXPECTED_EUCLIDEAN_SPEEDS['car']\n))\n</pre> print('The expected straight-line speed for the trip is: {} kph'.format( pam.variables.EXPECTED_EUCLIDEAN_SPEEDS['car'] )) <pre>The expected straight-line speed for the trip is: 5.555555555555555 kph\n</pre> <p>--&gt; we should expect higher sampling of locations in a radius closer to 20 * 0.5= 10km.</p> In\u00a0[12]: Copied! <pre>p2 =  Person('p2', attributes={'age': 40})\np2.add(Activity(seq=1,act='home',area='a',start_time=minutes_to_datetime(0),end_time=minutes_to_datetime(60)))\np2.add(Leg(seq=1,mode='car',start_area='a',end_area='b',\n        start_time=minutes_to_datetime(60),end_time=minutes_to_datetime(90)))\np2.add(Activity(seq=2,act='work',area='b',start_time=minutes_to_datetime(90),end_time=minutes_to_datetime(120)))\n\nhh2 = Household(0)\nhh2.add(p2)\n\npopulation2 = Population()\npopulation2.add(hh2)\n\ntest_sampler_distance(population2, facility_sampler_nonweighted, complex_sampler=False,\n                     title = 'Commute distance, simple sampling, car')\ntest_sampler_distance(population2, facility_sampler_weighted, complex_sampler=True, \n                      title = 'Commute distance, distance-weighted sampling, car')\n</pre> p2 =  Person('p2', attributes={'age': 40}) p2.add(Activity(seq=1,act='home',area='a',start_time=minutes_to_datetime(0),end_time=minutes_to_datetime(60))) p2.add(Leg(seq=1,mode='car',start_area='a',end_area='b',         start_time=minutes_to_datetime(60),end_time=minutes_to_datetime(90))) p2.add(Activity(seq=2,act='work',area='b',start_time=minutes_to_datetime(90),end_time=minutes_to_datetime(120)))  hh2 = Household(0) hh2.add(p2)  population2 = Population() population2.add(hh2)  test_sampler_distance(population2, facility_sampler_nonweighted, complex_sampler=False,                      title = 'Commute distance, simple sampling, car') test_sampler_distance(population2, facility_sampler_weighted, complex_sampler=True,                        title = 'Commute distance, distance-weighted sampling, car') <p>As expected, between long-distance alternatives (ie from zone a to zone i), deviation from expected distance makes less difference (but does slightly shift the distribution towards the correct direction).</p> In\u00a0[13]: Copied! <pre>p3 =  Person('p3', attributes={'age': 40})\np3.add(Activity(seq=1,act='home',area='a',start_time=minutes_to_datetime(0),end_time=minutes_to_datetime(60)))\np3.add(Leg(seq=1,mode='car',start_area='a',end_area='c',\n        start_time=minutes_to_datetime(60),end_time=minutes_to_datetime(90)))\np3.add(Activity(seq=2,act='work',area='c',start_time=minutes_to_datetime(90),end_time=minutes_to_datetime(120)))\n\nhh3 = Household(0)\nhh3.add(p3)\n\npopulation3 = Population()\npopulation3.add(hh3)\n\ntest_sampler_distance(population3, facility_sampler_nonweighted, complex_sampler=False,\n                     title = 'Commute distance, simple sampling, car')\ntest_sampler_distance(population3, facility_sampler_weighted, complex_sampler=True, \n                      title = 'Commute distance, distance-weighted sampling, car')\n</pre> p3 =  Person('p3', attributes={'age': 40}) p3.add(Activity(seq=1,act='home',area='a',start_time=minutes_to_datetime(0),end_time=minutes_to_datetime(60))) p3.add(Leg(seq=1,mode='car',start_area='a',end_area='c',         start_time=minutes_to_datetime(60),end_time=minutes_to_datetime(90))) p3.add(Activity(seq=2,act='work',area='c',start_time=minutes_to_datetime(90),end_time=minutes_to_datetime(120)))  hh3 = Household(0) hh3.add(p3)  population3 = Population() population3.add(hh3)  test_sampler_distance(population3, facility_sampler_nonweighted, complex_sampler=False,                      title = 'Commute distance, simple sampling, car') test_sampler_distance(population3, facility_sampler_weighted, complex_sampler=True,                        title = 'Commute distance, distance-weighted sampling, car')"},{"location":"examples/10_Advanced_Spatial-Sampling_Demo/#introduction","title":"Introduction\u00b6","text":""},{"location":"examples/10_Advanced_Spatial-Sampling_Demo/#generate-data","title":"Generate Data\u00b6","text":""},{"location":"examples/10_Advanced_Spatial-Sampling_Demo/#geography","title":"Geography\u00b6","text":""},{"location":"examples/10_Advanced_Spatial-Sampling_Demo/#population","title":"Population\u00b6","text":""},{"location":"examples/10_Advanced_Spatial-Sampling_Demo/#distance-based-sampling","title":"Distance-based sampling\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/","title":"PAM Policies Walk Through","text":"In\u00a0[1]: Copied! <pre>import pickle\nimport os\nimport pandas as pd\nimport random\nfrom copy import deepcopy\nfrom collections import defaultdict\nimport geopandas as gp\nfrom matplotlib import pyplot as plt\nfrom pam.core import Population, Household, Person\nfrom pam.activity import Plan, Activity, Leg\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\n\nfrom pam.policy import *\n</pre> import pickle import os import pandas as pd import random from copy import deepcopy from collections import defaultdict import geopandas as gp from matplotlib import pyplot as plt from pam.core import Population, Household, Person from pam.activity import Plan, Activity, Leg from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY  from pam.policy import * In\u00a0[2]: Copied! <pre>def hhld_apply(household, policy):\n    new_hhld = deepcopy(household) \n    policy.apply_to(new_hhld)\n    return new_hhld\n\ndef print_attributes(hhld, attribs=None):\n    if attribs is not None:\n        print(f\"Household: {hhld}\")\n        for pid, person in hhld.people.items():\n            print(f\"Person: {pid}\")\n            print(f\"Attributes:\")\n            for attrib in attribs:\n                print(f\"\\t{attrib}: {person.attributes[attrib]}\")\n    else:\n        print(f\"Household: {hhld}\")\n        for pid, person in hhld.people.items():\n            print(f\"Person: {pid}\")\n            print(f\"Attributes:\")\n            pp.pprint(person.attributes)\n            \ndef instantiate_household_with(persons: list):\n    household = Household(1)\n    for person in persons:\n        household.add(person)\n    return household\n\ndef Steve():\n    Steve = Person('Steve', attributes={'age': 50, 'job': 'work', 'gender': 'male'})\n    Steve.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(5 * 60)))\n    Steve.add(Leg(1, 'car', 'a', 'b', start_time=mtdt(5 * 60), end_time=mtdt(6 * 60)))\n    Steve.add(Activity(2, 'work', 'b', start_time=mtdt(6 * 60), end_time=mtdt(12 * 60)))\n    Steve.add(Leg(2, 'walk', 'b', 'c', start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 10)))\n    Steve.add(Activity(3, 'leisure', 'c', start_time=mtdt(12 * 60 + 10), end_time=mtdt(13 * 60 - 10)))\n    Steve.add(Leg(3, 'walk', 'c', 'b', start_time=mtdt(13 * 60 - 10), end_time=mtdt(13 * 60)))\n    Steve.add(Activity(4, 'work', 'b', start_time=mtdt(13 * 60), end_time=mtdt(18 * 60)))\n    Steve.add(Leg(4, 'car', 'b', 'a', start_time=mtdt(18 * 60), end_time=mtdt(19 * 60)))\n    Steve.add(Activity(5, 'home', 'a', start_time=mtdt(19 * 60), end_time=mtdt(20 * 60)))\n    Steve.add(Leg(5, 'car', 'a', 'b', start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Steve.add(Activity(6, 'shop_1', 'b', start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50)))\n    Steve.add(Leg(6, 'walk', 'b', 'b', start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Steve.add(Activity(7, 'shop_2', 'b', start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Steve.add(Leg(7, 'car', 'b', 'a', start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Steve.add(Activity(8, 'home', 'a', start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Steve\n\ndef Hilda():\n    Hilda = Person('Hilda', attributes={'age': 45, 'job': 'influencer', 'gender': 'female'})\n    Hilda.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))\n    Hilda.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))\n    Hilda.add(Activity(2, 'escort', 'b', start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30)))\n    Hilda.add(Leg(1, 'pt', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))\n    Hilda.add(Activity(2, 'shop', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(14 * 60)))\n    Hilda.add(Leg(2, 'pt', 'b', 'c', start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))\n    Hilda.add(Activity(3, 'leisure', 'c', start_time=mtdt(14 * 60 + 20), end_time=mtdt(16 * 60 - 20)))\n    Hilda.add(Leg(3, 'pt', 'c', 'b', start_time=mtdt(16 * 60 - 20), end_time=mtdt(16 * 60)))\n    Hilda.add(Activity(4, 'escort', 'b', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))\n    Hilda.add(Leg(4, 'walk', 'a', 'b', start_time=mtdt(16 * 60 + 30), end_time=mtdt(17 * 60)))\n    Hilda.add(Activity(5, 'home', 'a', start_time=mtdt(17 * 60), end_time=mtdt(20 * 60)))\n    Hilda.add(Leg(5, 'car', 'a', 'b', start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Hilda.add(Activity(6, 'shop_1', 'b', start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50)))\n    Hilda.add(Leg(6, 'walk', 'b', 'b', start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Hilda.add(Activity(7, 'shop_2', 'b', start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Hilda.add(Leg(7, 'car', 'b', 'a', start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Hilda.add(Activity(8, 'home', 'a', start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Hilda\n\ndef Timmy():\n    Timmy = Person('Timmy', attributes={'age': 18, 'job': 'education', 'gender': 'male'})\n    Timmy.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))\n    Timmy.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))\n    Timmy.add(Activity(2, 'sport', 'b', start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 55)))\n    Timmy.add(Leg(2, 'walk', 'b', 'a', start_time=mtdt(8 * 60 + 55), end_time=mtdt(9 * 60)))\n    Timmy.add(Activity(3, 'home', 'a', start_time=mtdt(9 * 60), end_time=mtdt(10 * 60)))\n    Timmy.add(Leg(3, 'bike', 'a', 'b', start_time=mtdt(10 * 60), end_time=mtdt(11 * 60)))\n    Timmy.add(Activity(4, 'education', 'b', start_time=mtdt(11 * 60), end_time=mtdt(13 * 60)))\n    Timmy.add(Leg(4, 'bike', 'b', 'c', start_time=mtdt(13 * 60), end_time=mtdt(13 * 60 + 5)))\n    Timmy.add(Activity(5, 'shop', 'c', start_time=mtdt(13 * 60 + 5), end_time=mtdt(13 * 60 + 30)))\n    Timmy.add(Leg(5, 'bike', 'c', 'b', start_time=mtdt(13 * 60 + 30), end_time=mtdt(13 * 60 + 35)))\n    Timmy.add(Activity(6, 'education', 'b', start_time=mtdt(13 * 60 + 35), end_time=mtdt(15 * 60)))\n    Timmy.add(Leg(6, 'bike', 'b', 'd', start_time=mtdt(15 * 60), end_time=mtdt(15 * 60 + 10)))\n    Timmy.add(Activity(7, 'leisure', 'd', start_time=mtdt(15 * 60 + 10), end_time=mtdt(18 * 60)))\n    Timmy.add(Leg(7, 'bike', 'd', 'a', start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))\n    Timmy.add(Activity(8, 'home', 'a', start_time=mtdt(18 * 60 + 20), end_time=mtdt(20 * 60)))\n    Timmy.add(Leg(8, 'car', 'a', 'b', start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Timmy.add(Activity(9, 'shop_1', 'b', start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50)))\n    Timmy.add(Leg(9, 'walk', 'b', 'b', start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Timmy.add(Activity(10, 'shop_2', 'b', start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Timmy.add(Leg(10, 'car', 'b', 'a', start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Timmy.add(Activity(11, 'home', 'a', start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Timmy\n\ndef Bobby():\n    Bobby = Person('Bobby', attributes={'age': 6, 'job': 'education', 'gender': 'female'})\n    Bobby.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))\n    Bobby.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))\n    Bobby.add(Activity(2, 'education', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60)))\n    Bobby.add(Leg(2, 'walk', 'b', 'c', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))\n    Bobby.add(Activity(3, 'home', 'a', start_time=mtdt(16 * 60 + 30), end_time=mtdt(20 * 60)))\n    Bobby.add(Leg(3, 'car', 'a', 'b', start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))\n    Bobby.add(Activity(4, 'shop_1', 'b', start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50)))\n    Bobby.add(Leg(4, 'walk', 'b', 'b', start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))\n    Bobby.add(Activity(5, 'shop_2', 'b', start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))\n    Bobby.add(Leg(5, 'car', 'b', 'a', start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))\n    Bobby.add(Activity(6, 'home', 'a', start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))\n    return Bobby\n</pre> def hhld_apply(household, policy):     new_hhld = deepcopy(household)      policy.apply_to(new_hhld)     return new_hhld  def print_attributes(hhld, attribs=None):     if attribs is not None:         print(f\"Household: {hhld}\")         for pid, person in hhld.people.items():             print(f\"Person: {pid}\")             print(f\"Attributes:\")             for attrib in attribs:                 print(f\"\\t{attrib}: {person.attributes[attrib]}\")     else:         print(f\"Household: {hhld}\")         for pid, person in hhld.people.items():             print(f\"Person: {pid}\")             print(f\"Attributes:\")             pp.pprint(person.attributes)              def instantiate_household_with(persons: list):     household = Household(1)     for person in persons:         household.add(person)     return household  def Steve():     Steve = Person('Steve', attributes={'age': 50, 'job': 'work', 'gender': 'male'})     Steve.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(5 * 60)))     Steve.add(Leg(1, 'car', 'a', 'b', start_time=mtdt(5 * 60), end_time=mtdt(6 * 60)))     Steve.add(Activity(2, 'work', 'b', start_time=mtdt(6 * 60), end_time=mtdt(12 * 60)))     Steve.add(Leg(2, 'walk', 'b', 'c', start_time=mtdt(12 * 60), end_time=mtdt(12 * 60 + 10)))     Steve.add(Activity(3, 'leisure', 'c', start_time=mtdt(12 * 60 + 10), end_time=mtdt(13 * 60 - 10)))     Steve.add(Leg(3, 'walk', 'c', 'b', start_time=mtdt(13 * 60 - 10), end_time=mtdt(13 * 60)))     Steve.add(Activity(4, 'work', 'b', start_time=mtdt(13 * 60), end_time=mtdt(18 * 60)))     Steve.add(Leg(4, 'car', 'b', 'a', start_time=mtdt(18 * 60), end_time=mtdt(19 * 60)))     Steve.add(Activity(5, 'home', 'a', start_time=mtdt(19 * 60), end_time=mtdt(20 * 60)))     Steve.add(Leg(5, 'car', 'a', 'b', start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Steve.add(Activity(6, 'shop_1', 'b', start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50)))     Steve.add(Leg(6, 'walk', 'b', 'b', start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Steve.add(Activity(7, 'shop_2', 'b', start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Steve.add(Leg(7, 'car', 'b', 'a', start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Steve.add(Activity(8, 'home', 'a', start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Steve  def Hilda():     Hilda = Person('Hilda', attributes={'age': 45, 'job': 'influencer', 'gender': 'female'})     Hilda.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))     Hilda.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))     Hilda.add(Activity(2, 'escort', 'b', start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 30)))     Hilda.add(Leg(1, 'pt', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))     Hilda.add(Activity(2, 'shop', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(14 * 60)))     Hilda.add(Leg(2, 'pt', 'b', 'c', start_time=mtdt(14 * 60), end_time=mtdt(14 * 60 + 20)))     Hilda.add(Activity(3, 'leisure', 'c', start_time=mtdt(14 * 60 + 20), end_time=mtdt(16 * 60 - 20)))     Hilda.add(Leg(3, 'pt', 'c', 'b', start_time=mtdt(16 * 60 - 20), end_time=mtdt(16 * 60)))     Hilda.add(Activity(4, 'escort', 'b', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))     Hilda.add(Leg(4, 'walk', 'a', 'b', start_time=mtdt(16 * 60 + 30), end_time=mtdt(17 * 60)))     Hilda.add(Activity(5, 'home', 'a', start_time=mtdt(17 * 60), end_time=mtdt(20 * 60)))     Hilda.add(Leg(5, 'car', 'a', 'b', start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Hilda.add(Activity(6, 'shop_1', 'b', start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50)))     Hilda.add(Leg(6, 'walk', 'b', 'b', start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Hilda.add(Activity(7, 'shop_2', 'b', start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Hilda.add(Leg(7, 'car', 'b', 'a', start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Hilda.add(Activity(8, 'home', 'a', start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Hilda  def Timmy():     Timmy = Person('Timmy', attributes={'age': 18, 'job': 'education', 'gender': 'male'})     Timmy.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))     Timmy.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 5)))     Timmy.add(Activity(2, 'sport', 'b', start_time=mtdt(8 * 60 + 5), end_time=mtdt(8 * 60 + 55)))     Timmy.add(Leg(2, 'walk', 'b', 'a', start_time=mtdt(8 * 60 + 55), end_time=mtdt(9 * 60)))     Timmy.add(Activity(3, 'home', 'a', start_time=mtdt(9 * 60), end_time=mtdt(10 * 60)))     Timmy.add(Leg(3, 'bike', 'a', 'b', start_time=mtdt(10 * 60), end_time=mtdt(11 * 60)))     Timmy.add(Activity(4, 'education', 'b', start_time=mtdt(11 * 60), end_time=mtdt(13 * 60)))     Timmy.add(Leg(4, 'bike', 'b', 'c', start_time=mtdt(13 * 60), end_time=mtdt(13 * 60 + 5)))     Timmy.add(Activity(5, 'shop', 'c', start_time=mtdt(13 * 60 + 5), end_time=mtdt(13 * 60 + 30)))     Timmy.add(Leg(5, 'bike', 'c', 'b', start_time=mtdt(13 * 60 + 30), end_time=mtdt(13 * 60 + 35)))     Timmy.add(Activity(6, 'education', 'b', start_time=mtdt(13 * 60 + 35), end_time=mtdt(15 * 60)))     Timmy.add(Leg(6, 'bike', 'b', 'd', start_time=mtdt(15 * 60), end_time=mtdt(15 * 60 + 10)))     Timmy.add(Activity(7, 'leisure', 'd', start_time=mtdt(15 * 60 + 10), end_time=mtdt(18 * 60)))     Timmy.add(Leg(7, 'bike', 'd', 'a', start_time=mtdt(18 * 60), end_time=mtdt(18 * 60 + 20)))     Timmy.add(Activity(8, 'home', 'a', start_time=mtdt(18 * 60 + 20), end_time=mtdt(20 * 60)))     Timmy.add(Leg(8, 'car', 'a', 'b', start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Timmy.add(Activity(9, 'shop_1', 'b', start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50)))     Timmy.add(Leg(9, 'walk', 'b', 'b', start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Timmy.add(Activity(10, 'shop_2', 'b', start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Timmy.add(Leg(10, 'car', 'b', 'a', start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Timmy.add(Activity(11, 'home', 'a', start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Timmy  def Bobby():     Bobby = Person('Bobby', attributes={'age': 6, 'job': 'education', 'gender': 'female'})     Bobby.add(Activity(1, 'home', 'a', start_time=mtdt(0), end_time=mtdt(8 * 60)))     Bobby.add(Leg(1, 'walk', 'a', 'b', start_time=mtdt(8 * 60), end_time=mtdt(8 * 60 + 30)))     Bobby.add(Activity(2, 'education', 'b', start_time=mtdt(8 * 60 + 30), end_time=mtdt(16 * 60)))     Bobby.add(Leg(2, 'walk', 'b', 'c', start_time=mtdt(16 * 60), end_time=mtdt(16 * 60 + 30)))     Bobby.add(Activity(3, 'home', 'a', start_time=mtdt(16 * 60 + 30), end_time=mtdt(20 * 60)))     Bobby.add(Leg(3, 'car', 'a', 'b', start_time=mtdt(20 * 60), end_time=mtdt(20 * 60 + 20)))     Bobby.add(Activity(4, 'shop_1', 'b', start_time=mtdt(20 * 60 + 20), end_time=mtdt(20 * 60 + 50)))     Bobby.add(Leg(4, 'walk', 'b', 'b', start_time=mtdt(20 * 60 + 50), end_time=mtdt(21 * 60)))     Bobby.add(Activity(5, 'shop_2', 'b', start_time=mtdt(21 * 60), end_time=mtdt(21 * 60 + 50)))     Bobby.add(Leg(5, 'car', 'b', 'a', start_time=mtdt(21 * 60 + 50), end_time=mtdt(22 * 60 + 10)))     Bobby.add(Activity(6, 'home', 'a', start_time=mtdt(22 * 60 + 10), end_time=END_OF_DAY))     return Bobby  In\u00a0[3]: Copied! <pre>smiths = instantiate_household_with([Steve(), Hilda(), Timmy(), Bobby()])\n</pre> smiths = instantiate_household_with([Steve(), Hilda(), Timmy(), Bobby()]) In\u00a0[4]: Copied! <pre>smiths.plot()\n</pre> smiths.plot()  $$P_{household} = 1 - (1-P_{person})^n$$  <p>If you have a probability that drives of any one person living in the household.</p> <p>The probability of the household being chosen is then  $$1 - (1-P)^n$$ where $P$ is the probability any one person being chosen and $n$ is the number of people in the household; $(1-P)^n$ is the probability of no one being picked.</p> In\u00a0[5]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(RemoveActivity(['education']),1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(RemoveActivity(['education']),1)).plot() <p>If you have a probability that drives of any one activity a person does.</p> <p>The probability of the person being chosen is then  $$1 - (1-P)^n$$ where $P$ is the probability any one (relevant) activity being chosen and $n$ is the number of (relevant) activities in the person's plan; $(1-P)^n$ is the probability of no relevant activities being picked.</p> In\u00a0[6]: Copied! <pre>hhld_apply(smiths, PersonPolicy(RemoveActivity(['shop_1', 'shop_2']),0.5)).plot()\n</pre> hhld_apply(smiths, PersonPolicy(RemoveActivity(['shop_1', 'shop_2']),0.5)).plot() <p>If you have a probability that drives of any one activity a person does and you want to affect particular activities with no consequence to the person or household.</p> <p>Notice that given a probability $P$ for an activity you can affect the whole household. The probability of the household being chosen is then  $$1 - (1-P)^n$$ where $P$ is the probability any one (relevant) activity being chosen and $n$ is then the number of all (relevant) activities in all of the persons plans within a household; $(1-P)^n$ is the probability of no relevant activities being picked for the household.</p> In\u00a0[7]: Copied! <pre>hhld_apply(smiths, ActivityPolicy(RemoveActivity(['shop_1', 'shop_2']),0.5)).plot()\n</pre> hhld_apply(smiths, ActivityPolicy(RemoveActivity(['shop_1', 'shop_2']),0.5)).plot() <p>The Policies expect certain levels of probability. For example, performing a <code>HouseholdPolicy</code> is easy, you can affect a whole household using a probability at any level, <code>household</code>, <code>person</code> or <code>activity</code>. Performing an <code>ActivityPolicy</code> however means you need information at the level of the activities you want to affect.</p> HouseholdProbability PersonProbability ActivityProbability HouseholdPolicy Yes Yes Yes PersonPolicy --- Yes Yes ActivityPolicy --- --- Yes In\u00a0[8]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(RemoveActivity(['education']),1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(RemoveActivity(['education']),1)).plot() In\u00a0[9]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(ReduceSharedActivity(['shop_1']),1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(ReduceSharedActivity(['shop_1']),1)).plot() In\u00a0[10]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation(['shop_1', 'shop_2']),1)).plot()\n</pre> hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation(['shop_1', 'shop_2']),1)).plot() <p>The result of this modifier do not show up on the plot. Below are the details of Hilda's original plan.</p> In\u00a0[11]: Copied! <pre>smiths['Hilda'].print()\n</pre> smiths['Hilda'].print() <pre>Person: Hilda\n{'age': 45, 'job': 'influencer', 'gender': 'female'}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:escort, location:b, time:08:05:00 --&gt; 08:30:00, duration:0:25:00)\n3:\tLeg(mode:pt, area:a --&gt; b, time:08:00:00 --&gt; 08:30:00, duration:0:30:00)\n4:\tActivity(act:shop, location:b, time:08:30:00 --&gt; 14:00:00, duration:5:30:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:14:00:00 --&gt; 14:20:00, duration:0:20:00)\n6:\tActivity(act:leisure, location:c, time:14:20:00 --&gt; 15:40:00, duration:1:20:00)\n7:\tLeg(mode:pt, area:c --&gt; b, time:15:40:00 --&gt; 16:00:00, duration:0:20:00)\n8:\tActivity(act:escort, location:b, time:16:00:00 --&gt; 16:30:00, duration:0:30:00)\n9:\tLeg(mode:walk, area:a --&gt; b, time:16:30:00 --&gt; 17:00:00, duration:0:30:00)\n10:\tActivity(act:home, location:a, time:17:00:00 --&gt; 20:00:00, duration:3:00:00)\n11:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n12:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n13:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n14:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n15:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n16:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> <p>Here are details of Hilda's plan post application of.<code>MoveActivityTourToHomeLocation</code> to <code>'shop'</code> activities. Compare the location of Activities 6 and 7 with the ones above. At the moment only the Leg's destination and origin get updated, the mode choice and duration remains unchanged.</p> In\u00a0[12]: Copied! <pre>hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation(['shop_1', 'shop_2']),1))['Hilda'].print()\n</pre> hhld_apply(smiths, HouseholdPolicy(MoveActivityTourToHomeLocation(['shop_1', 'shop_2']),1))['Hilda'].print() <pre>Person: Hilda\n{'age': 45, 'job': 'influencer', 'gender': 'female'}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:escort, location:b, time:08:05:00 --&gt; 08:30:00, duration:0:25:00)\n3:\tLeg(mode:pt, area:a --&gt; b, time:08:00:00 --&gt; 08:30:00, duration:0:30:00)\n4:\tActivity(act:shop, location:b, time:08:30:00 --&gt; 14:00:00, duration:5:30:00)\n5:\tLeg(mode:pt, area:b --&gt; c, time:14:00:00 --&gt; 14:20:00, duration:0:20:00)\n6:\tActivity(act:leisure, location:c, time:14:20:00 --&gt; 15:40:00, duration:1:20:00)\n7:\tLeg(mode:pt, area:c --&gt; b, time:15:40:00 --&gt; 16:00:00, duration:0:20:00)\n8:\tActivity(act:escort, location:b, time:16:00:00 --&gt; 16:30:00, duration:0:30:00)\n9:\tLeg(mode:walk, area:a --&gt; b, time:16:30:00 --&gt; 17:00:00, duration:0:30:00)\n10:\tActivity(act:home, location:a, time:17:00:00 --&gt; 20:00:00, duration:3:00:00)\n11:\tLeg(mode:walk, area:a --&gt; a, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n12:\tActivity(act:shop_1, location:a, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n13:\tLeg(mode:walk, area:a --&gt; a, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n14:\tActivity(act:shop_2, location:a, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n15:\tLeg(mode:walk, area:a --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n16:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[13]: Copied! <pre>print_attributes(smiths, ['gender', 'age', 'job'])\n</pre> print_attributes(smiths, ['gender', 'age', 'job']) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\tgender: male\n\tage: 50\n\tjob: work\nPerson: Hilda\nAttributes:\n\tgender: female\n\tage: 45\n\tjob: influencer\nPerson: Timmy\nAttributes:\n\tgender: male\n\tage: 18\n\tjob: education\nPerson: Bobby\nAttributes:\n\tgender: female\n\tage: 6\n\tjob: education\n</pre> In\u00a0[14]: Copied! <pre>def is_male(attribute_value):\n    return attribute_value == 'male'\ncondition = {'gender': is_male}\n\nhhld_apply(smiths, PersonPolicy(RemoveActivity(['shop_1', 'shop_2']),1,PersonAttributeFilter(condition))).plot()\n</pre> def is_male(attribute_value):     return attribute_value == 'male' condition = {'gender': is_male}  hhld_apply(smiths, PersonPolicy(RemoveActivity(['shop_1', 'shop_2']),1,PersonAttributeFilter(condition))).plot() In\u00a0[15]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[16]: Copied! <pre>policy_household_quarantine_per_person = \\\n    HouseholdQuarantined(\n        PersonProbability(0.01)\n)\n</pre> policy_household_quarantine_per_person = \\     HouseholdQuarantined(         PersonProbability(0.01) ) In\u00a0[17]: Copied! <pre>hhld_apply(smiths, policy_household_quarantine_per_person).plot()\n</pre> hhld_apply(smiths, policy_household_quarantine_per_person).plot() In\u00a0[18]: Copied! <pre>hhld_apply(smiths, HouseholdQuarantined(1)).plot()\n</pre> hhld_apply(smiths, HouseholdQuarantined(1)).plot() In\u00a0[19]: Copied! <pre>print_attributes(smiths, ['age', 'job'])\n</pre> print_attributes(smiths, ['age', 'job']) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\tage: 50\n\tjob: work\nPerson: Hilda\nAttributes:\n\tage: 45\n\tjob: influencer\nPerson: Timmy\nAttributes:\n\tage: 18\n\tjob: education\nPerson: Bobby\nAttributes:\n\tage: 6\n\tjob: education\n</pre> In\u00a0[20]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[21]: Copied! <pre>def over_17(attribute_value):\n    return attribute_value &gt; 17\n\npolicy_remove_higher_education = \\\n    PersonPolicy(\n        RemoveActivity(['education']),\n        PersonProbability(1),\n        PersonAttributeFilter({'age': over_17}, how='all')\n)\n</pre> def over_17(attribute_value):     return attribute_value &gt; 17  policy_remove_higher_education = \\     PersonPolicy(         RemoveActivity(['education']),         PersonProbability(1),         PersonAttributeFilter({'age': over_17}, how='all') ) In\u00a0[22]: Copied! <pre>hhld_apply(smiths, policy_remove_higher_education).plot()\n</pre> hhld_apply(smiths, policy_remove_higher_education).plot() In\u00a0[23]: Copied! <pre>smiths['Steve'].attributes['wfh'] = True\nsmiths['Steve'].attributes['care_constrained'] = False\nsmiths['Hilda'].attributes['wfh'] = True\nsmiths['Hilda'].attributes['care_constrained'] = False\nsmiths['Timmy'].attributes['wfh'] = False\nsmiths['Timmy'].attributes['care_constrained'] = False\nsmiths['Bobby'].attributes['wfh'] = False\nsmiths['Bobby'].attributes['care_constrained'] = False\n</pre> smiths['Steve'].attributes['wfh'] = True smiths['Steve'].attributes['care_constrained'] = False smiths['Hilda'].attributes['wfh'] = True smiths['Hilda'].attributes['care_constrained'] = False smiths['Timmy'].attributes['wfh'] = False smiths['Timmy'].attributes['care_constrained'] = False smiths['Bobby'].attributes['wfh'] = False smiths['Bobby'].attributes['care_constrained'] = False In\u00a0[24]: Copied! <pre>print_attributes(smiths, ['wfh', 'care_constrained'])\n</pre> print_attributes(smiths, ['wfh', 'care_constrained']) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: True\n\tcare_constrained: False\nPerson: Hilda\nAttributes:\n\twfh: True\n\tcare_constrained: False\nPerson: Timmy\nAttributes:\n\twfh: False\n\tcare_constrained: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tcare_constrained: False\n</pre> In\u00a0[25]: Copied! <pre>def attribute_False(attribute_value):\n    return not bool(attribute_value)\n\ndef attribute_True(attribute_value):\n    return bool(attribute_value)\n\nconditions = {\n    'care_constrained': attribute_False,\n    'wfh': attribute_True\n}\n\n# notice that the probability of the household (`HouseholdPolicy`) being chosen is driven\n# by the presence of education activities (`ActivityProbability(['education'], 0.95)`)\n# in the end the policy removes both education and escort (`RemoveActivity(['education', 'escort'])`)\n# but the presence of escort doesn't affect the likelihood\npolicy_remove_any_education = \\\n    HouseholdPolicy(\n        RemoveActivity(['education', 'escort']), \n        ActivityProbability(['education'], 0.95),\n        PersonAttributeFilter(conditions)\n)\n</pre> def attribute_False(attribute_value):     return not bool(attribute_value)  def attribute_True(attribute_value):     return bool(attribute_value)  conditions = {     'care_constrained': attribute_False,     'wfh': attribute_True }  # notice that the probability of the household (`HouseholdPolicy`) being chosen is driven # by the presence of education activities (`ActivityProbability(['education'], 0.95)`) # in the end the policy removes both education and escort (`RemoveActivity(['education', 'escort'])`) # but the presence of escort doesn't affect the likelihood policy_remove_any_education = \\     HouseholdPolicy(         RemoveActivity(['education', 'escort']),          ActivityProbability(['education'], 0.95),         PersonAttributeFilter(conditions) ) In\u00a0[26]: Copied! <pre>hhld_apply(smiths, policy_remove_any_education).plot()\n</pre> hhld_apply(smiths, policy_remove_any_education).plot() In\u00a0[27]: Copied! <pre>smiths['Steve'].attributes['wfh'] = False\nsmiths['Steve'].attributes['care_constrained'] = True\nsmiths['Hilda'].attributes['wfh'] = False\nsmiths['Hilda'].attributes['care_constrained'] = True\nsmiths['Timmy'].attributes['wfh'] = False\nsmiths['Timmy'].attributes['care_constrained'] = False\nsmiths['Bobby'].attributes['wfh'] = False\nsmiths['Bobby'].attributes['care_constrained'] = False\n\nprint_attributes(smiths, ['wfh', 'care_constrained'])\n</pre> smiths['Steve'].attributes['wfh'] = False smiths['Steve'].attributes['care_constrained'] = True smiths['Hilda'].attributes['wfh'] = False smiths['Hilda'].attributes['care_constrained'] = True smiths['Timmy'].attributes['wfh'] = False smiths['Timmy'].attributes['care_constrained'] = False smiths['Bobby'].attributes['wfh'] = False smiths['Bobby'].attributes['care_constrained'] = False  print_attributes(smiths, ['wfh', 'care_constrained']) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: False\n\tcare_constrained: True\nPerson: Hilda\nAttributes:\n\twfh: False\n\tcare_constrained: True\nPerson: Timmy\nAttributes:\n\twfh: False\n\tcare_constrained: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tcare_constrained: False\n</pre> In\u00a0[28]: Copied! <pre>hhld_apply(smiths, policy_remove_any_education).plot()\n</pre> hhld_apply(smiths, policy_remove_any_education).plot() In\u00a0[29]: Copied! <pre>policy_remove_leisure = \\\n    PersonPolicy(\n        RemoveActivity(['leisure']), \n        PersonProbability(1)\n)\n</pre> policy_remove_leisure = \\     PersonPolicy(         RemoveActivity(['leisure']),          PersonProbability(1) ) In\u00a0[30]: Copied! <pre>hhld_apply(smiths, policy_remove_leisure).plot()\n</pre> hhld_apply(smiths, policy_remove_leisure).plot() In\u00a0[31]: Copied! <pre>smiths['Timmy'].print()\n</pre> smiths['Timmy'].print() <pre>Person: Timmy\n{'age': 18, 'job': 'education', 'gender': 'male', 'wfh': False, 'care_constrained': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; b, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:sport, location:b, time:08:05:00 --&gt; 08:55:00, duration:0:50:00)\n3:\tLeg(mode:walk, area:b --&gt; a, time:08:55:00 --&gt; 09:00:00, duration:0:05:00)\n4:\tActivity(act:home, location:a, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:a --&gt; b, time:10:00:00 --&gt; 11:00:00, duration:1:00:00)\n6:\tActivity(act:education, location:b, time:11:00:00 --&gt; 13:00:00, duration:2:00:00)\n7:\tLeg(mode:bike, area:b --&gt; c, time:13:00:00 --&gt; 13:05:00, duration:0:05:00)\n8:\tActivity(act:shop, location:c, time:13:05:00 --&gt; 13:30:00, duration:0:25:00)\n9:\tLeg(mode:bike, area:c --&gt; b, time:13:30:00 --&gt; 13:35:00, duration:0:05:00)\n10:\tActivity(act:education, location:b, time:13:35:00 --&gt; 15:00:00, duration:1:25:00)\n11:\tLeg(mode:bike, area:b --&gt; d, time:15:00:00 --&gt; 15:10:00, duration:0:10:00)\n12:\tActivity(act:leisure, location:d, time:15:10:00 --&gt; 18:00:00, duration:2:50:00)\n13:\tLeg(mode:bike, area:d --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:18:20:00 --&gt; 20:00:00, duration:1:40:00)\n15:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n19:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[32]: Copied! <pre>policy_move_sport = \\\n    PersonPolicy(\n        MoveActivityTourToHomeLocation(['sport']), \n        PersonProbability(1)\n)\n</pre> policy_move_sport = \\     PersonPolicy(         MoveActivityTourToHomeLocation(['sport']),          PersonProbability(1) ) In\u00a0[33]: Copied! <pre>hhld_apply(smiths, policy_move_sport)['Timmy'].print()\n</pre> hhld_apply(smiths, policy_move_sport)['Timmy'].print() <pre>Person: Timmy\n{'age': 18, 'job': 'education', 'gender': 'male', 'wfh': False, 'care_constrained': False}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 08:00:00, duration:8:00:00)\n1:\tLeg(mode:walk, area:a --&gt; a, time:08:00:00 --&gt; 08:05:00, duration:0:05:00)\n2:\tActivity(act:sport, location:a, time:08:05:00 --&gt; 08:55:00, duration:0:50:00)\n3:\tLeg(mode:walk, area:a --&gt; a, time:08:55:00 --&gt; 09:00:00, duration:0:05:00)\n4:\tActivity(act:home, location:a, time:09:00:00 --&gt; 10:00:00, duration:1:00:00)\n5:\tLeg(mode:bike, area:a --&gt; b, time:10:00:00 --&gt; 11:00:00, duration:1:00:00)\n6:\tActivity(act:education, location:b, time:11:00:00 --&gt; 13:00:00, duration:2:00:00)\n7:\tLeg(mode:bike, area:b --&gt; c, time:13:00:00 --&gt; 13:05:00, duration:0:05:00)\n8:\tActivity(act:shop, location:c, time:13:05:00 --&gt; 13:30:00, duration:0:25:00)\n9:\tLeg(mode:bike, area:c --&gt; b, time:13:30:00 --&gt; 13:35:00, duration:0:05:00)\n10:\tActivity(act:education, location:b, time:13:35:00 --&gt; 15:00:00, duration:1:25:00)\n11:\tLeg(mode:bike, area:b --&gt; d, time:15:00:00 --&gt; 15:10:00, duration:0:10:00)\n12:\tActivity(act:leisure, location:d, time:15:10:00 --&gt; 18:00:00, duration:2:50:00)\n13:\tLeg(mode:bike, area:d --&gt; a, time:18:00:00 --&gt; 18:20:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:18:20:00 --&gt; 20:00:00, duration:1:40:00)\n15:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n16:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n17:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n18:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n19:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n20:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[34]: Copied! <pre>def discrete_joint_distribution_sampler(person, mapping, distribution):\n    p = distribution\n    for key in mapping:\n        value = person.attributes.get(key)\n        if value is None:\n            raise KeyError(f\"Cannot find mapping: {key} in sampling features: {features}\")\n        p = p.get(value)\n        if p is None:\n            raise KeyError(f\"Cannot find feature for {key}: {value} in distribution: {p}\")\n    return p\n</pre> def discrete_joint_distribution_sampler(person, mapping, distribution):     p = distribution     for key in mapping:         value = person.attributes.get(key)         if value is None:             raise KeyError(f\"Cannot find mapping: {key} in sampling features: {features}\")         p = p.get(value)         if p is None:             raise KeyError(f\"Cannot find feature for {key}: {value} in distribution: {p}\")     return p In\u00a0[35]: Copied! <pre>vulnerable_mapping = ['age', 'gender']\nvulnerable_distribution = dict(zip(list(range(101)), [{'male': i/100, 'female': i/100, 'other': i/100} for i in range(101)]))\n</pre> vulnerable_mapping = ['age', 'gender'] vulnerable_distribution = dict(zip(list(range(101)), [{'male': i/100, 'female': i/100, 'other': i/100} for i in range(101)])) In\u00a0[36]: Copied! <pre>dict(list(vulnerable_distribution.items())[0:15])\n</pre> dict(list(vulnerable_distribution.items())[0:15]) Out[36]: <pre>{0: {'male': 0.0, 'female': 0.0, 'other': 0.0},\n 1: {'male': 0.01, 'female': 0.01, 'other': 0.01},\n 2: {'male': 0.02, 'female': 0.02, 'other': 0.02},\n 3: {'male': 0.03, 'female': 0.03, 'other': 0.03},\n 4: {'male': 0.04, 'female': 0.04, 'other': 0.04},\n 5: {'male': 0.05, 'female': 0.05, 'other': 0.05},\n 6: {'male': 0.06, 'female': 0.06, 'other': 0.06},\n 7: {'male': 0.07, 'female': 0.07, 'other': 0.07},\n 8: {'male': 0.08, 'female': 0.08, 'other': 0.08},\n 9: {'male': 0.09, 'female': 0.09, 'other': 0.09},\n 10: {'male': 0.1, 'female': 0.1, 'other': 0.1},\n 11: {'male': 0.11, 'female': 0.11, 'other': 0.11},\n 12: {'male': 0.12, 'female': 0.12, 'other': 0.12},\n 13: {'male': 0.13, 'female': 0.13, 'other': 0.13},\n 14: {'male': 0.14, 'female': 0.14, 'other': 0.14}}</pre> In\u00a0[37]: Copied! <pre>policy_remove_health = \\\n    PersonPolicy(\n        RemoveActivity(['medical']), \n        [PersonProbability(discrete_joint_distribution_sampler, \n                           {'mapping':vulnerable_mapping, 'distribution':vulnerable_distribution}),\n         ActivityProbability(['medical'], 0.5)]\n)\n</pre> policy_remove_health = \\     PersonPolicy(         RemoveActivity(['medical']),          [PersonProbability(discrete_joint_distribution_sampler,                             {'mapping':vulnerable_mapping, 'distribution':vulnerable_distribution}),          ActivityProbability(['medical'], 0.5)] ) In\u00a0[38]: Copied! <pre>print_attributes(smiths, ['age', 'gender'])\n</pre> print_attributes(smiths, ['age', 'gender']) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\tage: 50\n\tgender: male\nPerson: Hilda\nAttributes:\n\tage: 45\n\tgender: female\nPerson: Timmy\nAttributes:\n\tage: 18\n\tgender: male\nPerson: Bobby\nAttributes:\n\tage: 6\n\tgender: female\n</pre> In\u00a0[39]: Copied! <pre>smiths.plot()\n</pre> smiths.plot() In\u00a0[40]: Copied! <pre>hhld_apply(smiths, policy_remove_health).plot()\n</pre> hhld_apply(smiths, policy_remove_health).plot() In\u00a0[41]: Copied! <pre>policy_unemployment_and_furlough = \\\n    PersonPolicy(\n        RemoveActivity(['work']), \n        PersonProbability(0.1)\n)\n</pre> policy_unemployment_and_furlough = \\     PersonPolicy(         RemoveActivity(['work']),          PersonProbability(0.1) ) In\u00a0[42]: Copied! <pre>hhld_apply(smiths, PersonPolicy(RemoveActivity(['work']), 1)).plot()\n</pre> hhld_apply(smiths, PersonPolicy(RemoveActivity(['work']), 1)).plot() In\u00a0[43]: Copied! <pre>smiths['Steve'].attributes['wfh'] = True\nsmiths['Steve'].attributes['key_worker'] = False\nsmiths['Hilda'].attributes['wfh'] = False\nsmiths['Hilda'].attributes['key_worker'] = False\nsmiths['Timmy'].attributes['wfh'] = False\nsmiths['Timmy'].attributes['key_worker'] = False\nsmiths['Bobby'].attributes['wfh'] = False\nsmiths['Bobby'].attributes['key_worker'] = False\n\nprint_attributes(smiths, ['wfh', 'key_worker'])\n</pre> smiths['Steve'].attributes['wfh'] = True smiths['Steve'].attributes['key_worker'] = False smiths['Hilda'].attributes['wfh'] = False smiths['Hilda'].attributes['key_worker'] = False smiths['Timmy'].attributes['wfh'] = False smiths['Timmy'].attributes['key_worker'] = False smiths['Bobby'].attributes['wfh'] = False smiths['Bobby'].attributes['key_worker'] = False  print_attributes(smiths, ['wfh', 'key_worker']) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: True\n\tkey_worker: False\nPerson: Hilda\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Timmy\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tkey_worker: False\n</pre> In\u00a0[44]: Copied! <pre>conditions = {\n    'key_worker': attribute_False,\n    'wfh': attribute_True\n}\n</pre> conditions = {     'key_worker': attribute_False,     'wfh': attribute_True } In\u00a0[45]: Copied! <pre>policy_work_from_home = \\\n    PersonPolicy(\n        RemoveActivity(['work']), \n        PersonProbability(0.5),\n        PersonAttributeFilter(conditions)\n)\n</pre> policy_work_from_home = \\     PersonPolicy(         RemoveActivity(['work']),          PersonProbability(0.5),         PersonAttributeFilter(conditions) ) In\u00a0[46]: Copied! <pre>hhld_apply(smiths, PersonPolicy(RemoveActivity(['work']), 1, \n                                PersonAttributeFilter(conditions))).plot()\n</pre> hhld_apply(smiths, PersonPolicy(RemoveActivity(['work']), 1,                                  PersonAttributeFilter(conditions))).plot() In\u00a0[47]: Copied! <pre>smiths['Steve'].attributes['wfh'] = False\nsmiths['Steve'].attributes['key_worker'] = True\nsmiths['Hilda'].attributes['wfh'] = False\nsmiths['Hilda'].attributes['key_worker'] = False\nsmiths['Timmy'].attributes['wfh'] = False\nsmiths['Timmy'].attributes['key_worker'] = False\nsmiths['Bobby'].attributes['wfh'] = False\nsmiths['Bobby'].attributes['key_worker'] = False\n\nprint_attributes(smiths, ['wfh', 'key_worker'])\n</pre> smiths['Steve'].attributes['wfh'] = False smiths['Steve'].attributes['key_worker'] = True smiths['Hilda'].attributes['wfh'] = False smiths['Hilda'].attributes['key_worker'] = False smiths['Timmy'].attributes['wfh'] = False smiths['Timmy'].attributes['key_worker'] = False smiths['Bobby'].attributes['wfh'] = False smiths['Bobby'].attributes['key_worker'] = False  print_attributes(smiths, ['wfh', 'key_worker']) <pre>Household: Household: 1\nPerson: Steve\nAttributes:\n\twfh: False\n\tkey_worker: True\nPerson: Hilda\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Timmy\nAttributes:\n\twfh: False\n\tkey_worker: False\nPerson: Bobby\nAttributes:\n\twfh: False\n\tkey_worker: False\n</pre> In\u00a0[48]: Copied! <pre>hhld_apply(smiths, PersonPolicy(RemoveActivity(['work']), 1, \n                                               PersonAttributeFilter(conditions))).plot()\n</pre> hhld_apply(smiths, PersonPolicy(RemoveActivity(['work']), 1,                                                 PersonAttributeFilter(conditions))).plot() In\u00a0[49]: Copied! <pre>policy_reduced_work_activity = \\\n    ActivityPolicy(\n        RemoveActivity(['work']), \n        ActivityProbability(['work'], 0.2)\n)\n</pre> policy_reduced_work_activity = \\     ActivityPolicy(         RemoveActivity(['work']),          ActivityProbability(['work'], 0.2) ) In\u00a0[50]: Copied! <pre>hhld_apply(smiths, policy_reduced_work_activity).plot()\n</pre> hhld_apply(smiths, policy_reduced_work_activity).plot() In\u00a0[51]: Copied! <pre>policy_reduce_shopping_activities = \\\n    HouseholdPolicy(\n        ReduceSharedActivity(['shop', 'shop_1', 'shop_2']), \n        ActivityProbability(['shop', 'shop_1', 'shop_2'], 1)\n)\n</pre> policy_reduce_shopping_activities = \\     HouseholdPolicy(         ReduceSharedActivity(['shop', 'shop_1', 'shop_2']),          ActivityProbability(['shop', 'shop_1', 'shop_2'], 1) ) In\u00a0[52]: Copied! <pre>smiths_shop = hhld_apply(smiths, policy_reduce_shopping_activities)\n</pre> smiths_shop = hhld_apply(smiths, policy_reduce_shopping_activities) In\u00a0[53]: Copied! <pre>smiths_shop.plot()\n</pre> smiths_shop.plot() In\u00a0[54]: Copied! <pre>person_with_shopping = [p for p in smiths_shop.people.values() if 'shop_1' in [act.act for act in p.activities]][0].pid\n</pre> person_with_shopping = [p for p in smiths_shop.people.values() if 'shop_1' in [act.act for act in p.activities]][0].pid In\u00a0[55]: Copied! <pre>smiths_shop.people[person_with_shopping].print()\n</pre> smiths_shop.people[person_with_shopping].print() <pre>Person: Steve\n{'age': 50, 'job': 'work', 'gender': 'male', 'wfh': False, 'care_constrained': True, 'key_worker': True}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 05:00:00, duration:5:00:00)\n1:\tLeg(mode:car, area:a --&gt; b, time:05:00:00 --&gt; 06:00:00, duration:1:00:00)\n2:\tActivity(act:work, location:b, time:06:00:00 --&gt; 12:00:00, duration:6:00:00)\n3:\tLeg(mode:walk, area:b --&gt; c, time:12:00:00 --&gt; 12:10:00, duration:0:10:00)\n4:\tActivity(act:leisure, location:c, time:12:10:00 --&gt; 12:50:00, duration:0:40:00)\n5:\tLeg(mode:walk, area:c --&gt; b, time:12:50:00 --&gt; 13:00:00, duration:0:10:00)\n6:\tActivity(act:work, location:b, time:13:00:00 --&gt; 18:00:00, duration:5:00:00)\n7:\tLeg(mode:car, area:b --&gt; a, time:18:00:00 --&gt; 19:00:00, duration:1:00:00)\n8:\tActivity(act:home, location:a, time:19:00:00 --&gt; 20:00:00, duration:1:00:00)\n9:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n10:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n11:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n12:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n13:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[56]: Copied! <pre>policy_move_shopping = \\\n    PersonPolicy(\n        MoveActivityTourToHomeLocation(['shop_1', 'shop', 'shop_2']), \n        ActivityProbability(['shop_1', 'shop', 'shop_2'], 1.)\n)\n</pre> policy_move_shopping = \\     PersonPolicy(         MoveActivityTourToHomeLocation(['shop_1', 'shop', 'shop_2']),          ActivityProbability(['shop_1', 'shop', 'shop_2'], 1.) ) In\u00a0[57]: Copied! <pre>smiths_shop = hhld_apply(smiths_shop, policy_move_shopping)\n</pre> smiths_shop = hhld_apply(smiths_shop, policy_move_shopping) In\u00a0[58]: Copied! <pre>smiths_shop.plot()\n</pre> smiths_shop.plot() In\u00a0[59]: Copied! <pre>smiths.people[person_with_shopping].print()\n</pre> smiths.people[person_with_shopping].print() <pre>Person: Steve\n{'age': 50, 'job': 'work', 'gender': 'male', 'wfh': False, 'care_constrained': True, 'key_worker': True}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 05:00:00, duration:5:00:00)\n1:\tLeg(mode:car, area:a --&gt; b, time:05:00:00 --&gt; 06:00:00, duration:1:00:00)\n2:\tActivity(act:work, location:b, time:06:00:00 --&gt; 12:00:00, duration:6:00:00)\n3:\tLeg(mode:walk, area:b --&gt; c, time:12:00:00 --&gt; 12:10:00, duration:0:10:00)\n4:\tActivity(act:leisure, location:c, time:12:10:00 --&gt; 12:50:00, duration:0:40:00)\n5:\tLeg(mode:walk, area:c --&gt; b, time:12:50:00 --&gt; 13:00:00, duration:0:10:00)\n6:\tActivity(act:work, location:b, time:13:00:00 --&gt; 18:00:00, duration:5:00:00)\n7:\tLeg(mode:car, area:b --&gt; a, time:18:00:00 --&gt; 19:00:00, duration:1:00:00)\n8:\tActivity(act:home, location:a, time:19:00:00 --&gt; 20:00:00, duration:1:00:00)\n9:\tLeg(mode:car, area:a --&gt; b, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n10:\tActivity(act:shop_1, location:b, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n11:\tLeg(mode:walk, area:b --&gt; b, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n12:\tActivity(act:shop_2, location:b, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n13:\tLeg(mode:car, area:b --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[60]: Copied! <pre>smiths_shop.people[person_with_shopping].print()\n</pre> smiths_shop.people[person_with_shopping].print() <pre>Person: Steve\n{'age': 50, 'job': 'work', 'gender': 'male', 'wfh': False, 'care_constrained': True, 'key_worker': True}\n0:\tActivity(act:home, location:a, time:00:00:00 --&gt; 05:00:00, duration:5:00:00)\n1:\tLeg(mode:car, area:a --&gt; b, time:05:00:00 --&gt; 06:00:00, duration:1:00:00)\n2:\tActivity(act:work, location:b, time:06:00:00 --&gt; 12:00:00, duration:6:00:00)\n3:\tLeg(mode:walk, area:b --&gt; c, time:12:00:00 --&gt; 12:10:00, duration:0:10:00)\n4:\tActivity(act:leisure, location:c, time:12:10:00 --&gt; 12:50:00, duration:0:40:00)\n5:\tLeg(mode:walk, area:c --&gt; b, time:12:50:00 --&gt; 13:00:00, duration:0:10:00)\n6:\tActivity(act:work, location:b, time:13:00:00 --&gt; 18:00:00, duration:5:00:00)\n7:\tLeg(mode:car, area:b --&gt; a, time:18:00:00 --&gt; 19:00:00, duration:1:00:00)\n8:\tActivity(act:home, location:a, time:19:00:00 --&gt; 20:00:00, duration:1:00:00)\n9:\tLeg(mode:walk, area:a --&gt; a, time:20:00:00 --&gt; 20:20:00, duration:0:20:00)\n10:\tActivity(act:shop_1, location:a, time:20:20:00 --&gt; 20:50:00, duration:0:30:00)\n11:\tLeg(mode:walk, area:a --&gt; a, time:20:50:00 --&gt; 21:00:00, duration:0:10:00)\n12:\tActivity(act:shop_2, location:a, time:21:00:00 --&gt; 21:50:00, duration:0:50:00)\n13:\tLeg(mode:walk, area:a --&gt; a, time:21:50:00 --&gt; 22:10:00, duration:0:20:00)\n14:\tActivity(act:home, location:a, time:22:10:00 --&gt; 00:00:00, duration:1:50:00)\n</pre> In\u00a0[61]: Copied! <pre>population = Population(1)\npopulation.add(smiths)\n\nall_together_pop = apply_policies(\n    population, \n    [policy_household_quarantine_per_person, \n     policy_remove_higher_education, \n     policy_remove_any_education, \n     policy_remove_leisure, \n     policy_move_sport,\n     policy_remove_health, \n     policy_unemployment_and_furlough, \n     policy_work_from_home, \n     policy_reduced_work_activity, \n     policy_reduce_shopping_activities,\n     policy_move_shopping\n    ])\n</pre> population = Population(1) population.add(smiths)  all_together_pop = apply_policies(     population,      [policy_household_quarantine_per_person,       policy_remove_higher_education,       policy_remove_any_education,       policy_remove_leisure,       policy_move_sport,      policy_remove_health,       policy_unemployment_and_furlough,       policy_work_from_home,       policy_reduced_work_activity,       policy_reduce_shopping_activities,      policy_move_shopping     ]) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/05_PAM_Policies_Walk_Through/#sampling-and-policy-levels","title":"Sampling and Policy Levels\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#household","title":"Household\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#person","title":"Person\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#activity","title":"Activity\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#joint-distributions","title":"Joint distributions\u00b6","text":"<p>You can give the <code>SamplingProbability</code> classes custom samplers with joint (or not) distributions. That changes the following table</p> HouseholdProbability PersonProbability ActivityProbability HouseholdPolicy $$p$$ $$1-(1-p)^{n_p}$$ $$1-(1-p)^{n_{a,h}}$$ PersonPolicy $$-$$ $$p$$ $$1-(1-p)^{n_{a,p}}$$ ActivityPolicy $$-$$ $$-$$ $$p$$ <p>where</p> <ul> <li>$n_p$ is the number of people in a household</li> <li>$n_{a,p}$ is the number of (relevant) activities in a person's plan</li> <li>$n_{a,h}$ is the number of (relevant) activities in a household</li> </ul> <p>to</p> HouseholdProbability PersonProbability ActivityProbability HouseholdPolicy $$p$$ $$1-\\prod_x (1-p_x)^{n_x}$$ $$1-\\prod_{x,a}(1-p_{x,a})^{n_{x,a}}$$ PersonPolicy $$-$$ $$p_x$$ $$1-\\prod_a (1-p_a)^{n_a}$$ ActivityPolicy $$-$$ $$-$$ $$p_a, p_{x,a}$$ <p>where</p> <ul> <li>$p_x$ is the probability for person $x$</li> <li>$n_x$ is the number of people with probability $p_x$</li> <li>$p_a$ is the probability for activity $a$</li> <li>$n_a$ is the number of activities $a$ in a person's plan</li> <li>$p_{x,a}$ is the probability for activity $a$ for person $x$</li> <li>$n_{x,a}$ is the number of activities $a$ in a person $x$ plan</li> </ul>"},{"location":"examples/05_PAM_Policies_Walk_Through/#modifiers","title":"Modifiers\u00b6","text":"<p>Modifier perform the actions of removing or moving activities on the chosen Policy Level and sampled using the chosen Sampling Level.</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#removeactivity","title":"<code>RemoveActivity</code>\u00b6","text":"<p>Takes a list of activities to be removed.</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#reducesharedactivity","title":"<code>ReduceSharedActivity</code>\u00b6","text":"<p>This is a <code>HouseholdPolicy</code> level modifier which takes a list of activities, checks the household for those being shared (like going shopping together) and selects a person at random to still perform those activities. Those activities will be deleted for everyone else in the household.</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#moveactivitytourtohomelocation","title":"<code>MoveActivityTourToHomeLocation</code>\u00b6","text":"<p>Takes a list of activities and moves those to the home location if they form a tour. A tour is a chain of activities sandwiched by two home activities (or boundary of persons plan e.g. if person's activities are: <code>'work', 'home', 'shop', 'work', 'home'</code> (in that order), their tours are: <code>['work']</code>and <code>['shop', work']</code>).</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#attribute-filters","title":"Attribute Filters\u00b6","text":"<p><code>PersonAttributeFilter</code> is a conveniece class to apply policies to selected people in the population which satisfy given attributes.</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#policies","title":"Policies\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#person-based-household-quarantine","title":"Person-based Household Quarantine\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#remove-higher-education","title":"Remove Higher Education\u00b6","text":"<p>Remove all education activity for persons over age of 17</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#remove-education","title":"Remove Education\u00b6","text":"<p>Probabilistically remove education activities from a person, and escort from people who share the household. Contraint based on the house not being care constrainted and people being able to work from home.</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#example-of-non-care-constrained-household","title":"Example of non care constrained household\u00b6","text":"<p>Let's make the Smiths household a non care constrained household with at least one adult is able to work from home and the household is not care constrained.</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#non-care-constrained-household-is-affected","title":"Non care constrained household is affected\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#example-of-care-constrained-household","title":"Example of care constrained household\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#care-constrained-household-is-not-affected","title":"Care constrained household is not affected\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#remove-leisure-activities","title":"Remove Leisure Activities\u00b6","text":"<p>Remove all leisure activities</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#move-sport-activities","title":"Move Sport Activities\u00b6","text":"<p>Probabilistically move Sport activities to home location</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#remove-health-activities","title":"Remove Health Activities\u00b6","text":"<p>Probabilistically remove individual health activities from a person. Make vulnerable people more likely to have their health activities removed.</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#unemploymentfurlough","title":"Unemployment/Furlough\u00b6","text":"<p>Probabilistically remove all work activities from a person</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#work-from-home","title":"Work from Home\u00b6","text":"<p>Probabilistically remove all work activities from a person</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#reduced-work-activity","title":"Reduced Work Activity\u00b6","text":"<p>Probabilistically remove individual work activities from a person</p>"},{"location":"examples/05_PAM_Policies_Walk_Through/#shopping","title":"Shopping\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#reduce-shared-shopping-activities","title":"Reduce Shared Shopping Activities\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#move-shopping-activities-closer-to-home","title":"Move Shopping Activities closer to home\u00b6","text":""},{"location":"examples/05_PAM_Policies_Walk_Through/#all-together-now","title":"All together now!\u00b6","text":""},{"location":"examples/08_PAM_Population_Activity_Plots/","title":"PAM Population Activity Plots","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport pam\nimport os\n</pre> import pandas as pd import pam import os In\u00a0[2]: Copied! <pre>data_path = os.path.join(\"data\", \"example_data\")\ntrips = pd.read_csv(os.path.join(data_path, 'example_travel_diaries.csv'))\nattributes = pd.read_csv(os.path.join(data_path, 'example_attributes.csv'))\nattributes.set_index('pid', inplace=True)\n</pre> data_path = os.path.join(\"data\", \"example_data\") trips = pd.read_csv(os.path.join(data_path, 'example_travel_diaries.csv')) attributes = pd.read_csv(os.path.join(data_path, 'example_attributes.csv')) attributes.set_index('pid', inplace=True) In\u00a0[3]: Copied! <pre>from pam import read\npopulation = read.load_travel_diary(trips, attributes)\n</pre> from pam import read population = read.load_travel_diary(trips, attributes) <pre>Using tour based purpose parser (recommended)\nAdding pid-&gt;hh mapping to persons_attributes from trips.\nAdding home locations to persons attributes using trips attributes.\nUsing freq of 'None' for all persons.\n</pre> In\u00a0[4]: Copied! <pre>from pam.plot.stats import plot_activity_times, plot_leg_times, extract_activity_log\n</pre> from pam.plot.stats import plot_activity_times, plot_leg_times, extract_activity_log In\u00a0[5]: Copied! <pre>fig1 = plot_activity_times(population)\n</pre> fig1 = plot_activity_times(population) In\u00a0[6]: Copied! <pre>fig2 = plot_leg_times(population)\n</pre> fig2 = plot_leg_times(population) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/03_Example_Generate_Random_Population/","title":"Example Generate Random Population","text":"<p>This notebook demonstrates an complex example workflow for creating a sample population for an area in West London. It creates agent plans for people and households using a random process.</p> <ul> <li>Import geographic data of Londinium.</li> <li>Activity generation model with home based tours. Expand agents with different personal attributes, activities and trips.</li> <li>Perform Data Visualization and validation. Plot the activity plan, distance and duration of population</li> <li>Export intermediate CSV tables of the population</li> </ul> In\u00a0[1]: Copied! <pre>import os\nimport numpy as np\nfrom random import choice\nimport pandas as pd\nimport geopandas as gp\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom shapely.geometry import Point\n\nfrom pam.core import Population, Household, Person\nfrom pam.activity import Plan, Activity, Leg\nfrom pam.utils import minutes_to_datetime as mtdt\nfrom pam.variables import END_OF_DAY\nfrom pam.write import write_matsim, write_od_matrices, to_csv\nfrom pam.report.benchmarks import duration_counts, distance_counts\nfrom pam.plot.stats import plot_activity_times, plot_leg_times\nfrom pam.read import load_travel_diary, read_matsim\nfrom pam.samplers import facility\nfrom pam.write import write_matsim\n</pre> import os import numpy as np from random import choice import pandas as pd import geopandas as gp from matplotlib import pyplot as plt %matplotlib inline from shapely.geometry import Point  from pam.core import Population, Household, Person from pam.activity import Plan, Activity, Leg from pam.utils import minutes_to_datetime as mtdt from pam.variables import END_OF_DAY from pam.write import write_matsim, write_od_matrices, to_csv from pam.report.benchmarks import duration_counts, distance_counts from pam.plot.stats import plot_activity_times, plot_leg_times from pam.read import load_travel_diary, read_matsim from pam.samplers import facility from pam.write import write_matsim In\u00a0[2]: Copied! <pre># Import geographic data of west london area\nnetwork_bb_path = os.path.join(\"data\", \"network_bounding_box.geojson\")\nlsoas_path = os.path.join(\"data\", \"lsoas\") # lsoas: lower layer super output areas\n</pre> # Import geographic data of west london area network_bb_path = os.path.join(\"data\", \"network_bounding_box.geojson\") lsoas_path = os.path.join(\"data\", \"lsoas\") # lsoas: lower layer super output areas  <p>We will start by plotting Londinium boundary</p> In\u00a0[3]: Copied! <pre># Read the file and plot the boundary\nboundary = gp.read_file(network_bb_path)\n\n# Transform to epsg:27700\nboundary = boundary.to_crs(\"epsg:27700\")\nboundary.plot()\n</pre> # Read the file and plot the boundary boundary = gp.read_file(network_bb_path)  # Transform to epsg:27700 boundary = boundary.to_crs(\"epsg:27700\") boundary.plot() Out[3]: <pre>&lt;AxesSubplot:&gt;</pre> <p>Next we will plot Londinium outline shown above over a map of London to see where exactly it is located.</p> In\u00a0[4]: Copied! <pre># Plot boundary area in lsoas\nlsoas = gp.read_file(lsoas_path)\nlsoas.crs = 'EPSG:27700'\nprint(lsoas.crs)\nlsoas = lsoas.set_index(\"LSOA_CODE\")\n\nfig, ax = plt.subplots(figsize=(10,10))\nlsoas.plot(ax = ax)\nboundary.plot(ax = ax, color='red')\n</pre> # Plot boundary area in lsoas lsoas = gp.read_file(lsoas_path) lsoas.crs = 'EPSG:27700' print(lsoas.crs) lsoas = lsoas.set_index(\"LSOA_CODE\")  fig, ax = plt.subplots(figsize=(10,10)) lsoas.plot(ax = ax) boundary.plot(ax = ax, color='red') <pre>EPSG:27700\n</pre> Out[4]: <pre>&lt;AxesSubplot:&gt;</pre> <p>Finally, we will plot Londinium with LSOA boundaries included.</p> In\u00a0[5]: Copied! <pre># Overlay the area using geopandas package\nlsoas_clipped = gp.overlay(lsoas, boundary, how='intersection')\nlsoas_clipped.plot()\n</pre> # Overlay the area using geopandas package lsoas_clipped = gp.overlay(lsoas, boundary, how='intersection') lsoas_clipped.plot() Out[5]: <pre>&lt;AxesSubplot:&gt;</pre> In\u00a0[6]: Copied! <pre>lsoas_clipped.head()\n</pre> lsoas_clipped.head() Out[6]: LSOA_NAME MSOA_CODE MSOA_NAME STWARDCODE STWARDNAME LA_CODE LA_NAME geometry 0 Hammersmith and Fulham 010A E02000381 Hammersmith and Fulham 010 00ANGA Addison 00AN Hammersmith and Fulham POLYGON ((523932.247 179242.842, 523959.439 17... 1 Hammersmith and Fulham 010B E02000381 Hammersmith and Fulham 010 00ANGA Addison 00AN Hammersmith and Fulham POLYGON ((524171.272 179363.077, 524212.654 17... 2 Hammersmith and Fulham 012A E02000383 Hammersmith and Fulham 012 00ANGC Avonmore and Brook Green 00AN Hammersmith and Fulham POLYGON ((524167.660 178997.302, 524060.845 17... 3 Hammersmith and Fulham 012B E02000383 Hammersmith and Fulham 012 00ANGC Avonmore and Brook Green 00AN Hammersmith and Fulham POLYGON ((523774.000 178714.003, 523831.847 17... 4 Hammersmith and Fulham 012C E02000383 Hammersmith and Fulham 012 00ANGC Avonmore and Brook Green 00AN Hammersmith and Fulham MULTIPOLYGON (((524422.688 178825.081, 524379.... In\u00a0[7]: Copied! <pre>facilities_path = 'data/londinium_facilities_sample.geojson'\nfacilities = gp.read_file(facilities_path)\nfacilities = facilities.rename({'activities': 'activity'}, axis=1)\nfacilities.crs = 'EPSG:27700'\nfacilities.head()\n</pre> facilities_path = 'data/londinium_facilities_sample.geojson' facilities = gp.read_file(facilities_path) facilities = facilities.rename({'activities': 'activity'}, axis=1) facilities.crs = 'EPSG:27700' facilities.head() Out[7]: activity area distance_to_nearest_education distance_to_nearest_medical distance_to_nearest_shop distance_to_nearest_transit floor_area id levels units geometry 0 home 574 617.965594 516.743962 77.712882 466.059745 1148.0 1084822608 2.0 1.0 POINT (524877.659 179721.080) 1 home 66 143.055807 115.674294 125.537224 286.017738 198.0 368319574 3.0 1.0 POINT (527830.357 174758.729) 2 home 103 54.946075 214.532285 41.572871 93.975944 412.0 1640220880 4.0 1.0 POINT (526060.994 178970.515) 3 home 192 164.455318 216.217139 111.674214 180.452314 768.0 1741392588 4.0 1.0 POINT (526698.625 178513.841) 4 home 123 173.648285 249.190465 188.276309 139.258340 246.0 984446626 2.0 1.0 POINT (526369.238 179166.396) <p>Start by plotting different facility types, e.g. educational and medical facilities</p> In\u00a0[8]: Copied! <pre>education = facilities[facilities['activity']=='education']\nmedical = facilities[facilities['activity']=='medical']\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,12))\n\nboundary.plot(ax = ax1, color='steelblue')\neducation.plot(ax = ax1, color='orange', label = 'Educational facilities')\n#lsoas_clipped.plot(ax = ax1)\nax1.legend()\n\nboundary.plot(ax = ax2, color='steelblue')\nmedical.plot(ax = ax2, color='red', label = 'Medical facilities')\n#lsoas_clipped.plot(ax = ax2)\nax2.legend()\n</pre> education = facilities[facilities['activity']=='education'] medical = facilities[facilities['activity']=='medical']  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,12))  boundary.plot(ax = ax1, color='steelblue') education.plot(ax = ax1, color='orange', label = 'Educational facilities') #lsoas_clipped.plot(ax = ax1) ax1.legend()  boundary.plot(ax = ax2, color='steelblue') medical.plot(ax = ax2, color='red', label = 'Medical facilities') #lsoas_clipped.plot(ax = ax2) ax2.legend() Out[8]: <pre>&lt;matplotlib.legend.Legend at 0x11e682a58&gt;</pre> In\u00a0[9]: Copied! <pre># zones = lsoas_clipped\nlsoas_clipped.crs = 'EPSG:27700'\nlen(lsoas_clipped)\n</pre> # zones = lsoas_clipped lsoas_clipped.crs = 'EPSG:27700' len(lsoas_clipped) Out[9]: <pre>306</pre> In\u00a0[10]: Copied! <pre>lsoas_clipped = lsoas_clipped.set_index(\"LSOA_NAME\")\n</pre> lsoas_clipped = lsoas_clipped.set_index(\"LSOA_NAME\") In\u00a0[11]: Copied! <pre># build the sampler\nfacility_sampler = facility.FacilitySampler(\n    facilities=facilities,\n    zones=lsoas_clipped,\n    build_xml=True,\n    fail=False,\n    random_default=True)\n</pre> # build the sampler facility_sampler = facility.FacilitySampler(     facilities=facilities,     zones=lsoas_clipped,     build_xml=True,     fail=False,     random_default=True) <pre>Joining facilities data to zones, this may take a while.\n/Users/fred.shone/.ve/pam/lib/python3.7/site-packages/ipykernel_launcher.py:7: FutureWarning:\n\nThe `op` parameter is deprecated and will be removed in a future release. Please use the `predicate` parameter instead.\n\nBuilding sampler, this may take a while.\n</pre> In\u00a0[12]: Copied! <pre># Create random area sample\ndef random_area_sampler():\n    indexes = list(lsoas_clipped.index)\n    return np.random.choice(indexes)\n\nrandom_area_sampler()  # test\n</pre> # Create random area sample def random_area_sampler():     indexes = list(lsoas_clipped.index)     return np.random.choice(indexes)  random_area_sampler()  # test Out[12]: <pre>'Kensington and Chelsea 012C'</pre> <ul> <li>It is a simple home based tours within 24 hours.</li> <li>We create different activity types: work, leisure, education, shopping, etc. Different transport model types: car, bus, subway, etc.</li> <li>Random number is assigned to the duration for each activity and transport mode</li> </ul> In\u00a0[13]: Copied! <pre>#mapping the MSOA and LAD with index\nmapping_dict = dict(zip(lsoas_clipped.index, lsoas_clipped.MSOA_CODE))\nmapping_dict1 = dict(zip(lsoas_clipped.index, lsoas_clipped.LA_NAME))\n</pre> #mapping the MSOA and LAD with index mapping_dict = dict(zip(lsoas_clipped.index, lsoas_clipped.MSOA_CODE)) mapping_dict1 = dict(zip(lsoas_clipped.index, lsoas_clipped.LA_NAME)) In\u00a0[14]: Copied! <pre># Generate agents in west london area\ndef generate_agents(no_of_agents):\n\"\"\"\n    Randomly create agents with simple home-based tours. \n    The trip starts from home, has a random number of various acitivites, tranport modes would be added. \n    The trip finally ends at home.\n    \"\"\"\n    \n    population = Population() # Initialise an empty population\n    \n    # Create simple personal attributes\n    income = [\"low\", \"medium\", \"high\"]\n    gender = [\"male\", \"female\"]\n    sort_age = ['0 to 4', '5 to 10', '11 to 15', '16 to 20', '21 to 25', '26 to 29',\n                '30 to 39', '40 to 49', '50 to 59', '60 to 64',\n                '65 to 69', '70 to 74', '75 to 79', '80 to 84', '85  and over']\n    \n    # Create mode and activities\n    transport = ['car', 'bus', 'ferry', 'rail', 'subway', 'bike', 'walk']\n    # Removed gym and park due to osmox problem\n    activity = ['leisure', 'work', 'shop', 'medical','education', 'park', 'pub', 'gym'] # Primary activity\n    sub_activity = [\"shop\", \"medical\", \"pub\", \"gym\"] # People usually spend less time on sub activity\n    \n    # Add activity plan for each person\n    for i in range(no_of_agents):\n\n        # Create different agents and household\n        agent_id = f\"agent_{i}\"\n        hh_id = f\"hh_{i}\"\n        hh = Household(hh_id, freq=1)\n        \n        # Adding Activities and Legs alternately to different agents\n        # Activity 1 - home\n        leaves_home = (np.random.randint(6, 8) * 60) + np.random.randint(0, 100)  # minutes\n        location1 = random_area_sampler()\n        location1_loc = facility_sampler.sample(location1, 'home')\n        lsoa_name = mapping_dict.get(location1)\n        lad_name = mapping_dict1.get(location1)\n\n                \n        agent = Person(agent_id, \n                       freq = 1,\n                       attributes = {\"subpopulation\": np.random.choice(income) + \" income\",\n                                     \"gender\" : np.random.choice(gender),\n                                     \"age\": np.random.choice(sort_age),\n                                     \"household_zone\": location1,\n                                     \"household_LSOA\":lsoa_name,\n                                     \"household_LAD\": lad_name} )\n        \n        \n        hh.add(agent)\n        population.add(hh)\n        \n        # Trip duration\n        trip_duration_main_activity = (np.random.randint(3, 6) * 60) \n        trip_duration_sub_activity = (np.random.randint(1, 3) * 60)\n        \n        agent.add(Activity(\n            seq = 1,\n            act ='home',\n            area = location1,\n            loc = location1_loc,\n            start_time = mtdt(0),\n            end_time = mtdt(leaves_home)\n        ))\n    \n        # Initiated parameters\n        location_prev = location1\n        location_prev_loc = location1_loc\n        leave_time = leaves_home\n    \n        # Add random numbers of activities\n        no_of_activities = np.random.randint(1,5)\n        \n        for i in range(no_of_activities):\n            \n            arrives_primary = leave_time + np.random.randint(10, 90)  # minutes\n            \n            # Activity 2.  \n            if i &lt; 2: # Start with main activity\n                random_act = np.random.choice(activity)\n            else: \n                random_act = np.random.choice(sub_activity)\n                \n            if random_act == (\"work\" or \"education\" or \"leisure\"):\n                leaves_primary = arrives_primary + trip_duration_main_activity\n            else:\n                leaves_primary = arrives_primary + trip_duration_sub_activity\n                \n            # Outbound leg\n            location_next = random_area_sampler()\n            location_next_loc = facility_sampler.sample(location_next, random_act)\n            \n     \n            agent.add(Leg(\n                seq = i + 1,\n                mode = np.random.choice(transport),\n                start_area = location_prev,\n                start_loc = location_prev_loc,\n                end_area = location_next,\n                end_loc = location_next_loc,\n                start_time = mtdt(leave_time),\n                end_time = mtdt(arrives_primary), \n            ))\n    \n            agent.add(Activity(\n                seq = i + 2,\n                act = random_act,\n                area = location_next,\n                loc = location_next_loc,\n                start_time = mtdt(arrives_primary),\n                end_time = mtdt(leaves_primary)\n            ))     \n        \n            # Update parameters\n            leave_time = leaves_primary\n            location_prev = location_next\n            location_prev_loc = location_next_loc\n            \n        \n        # Inbound leg\n        arrives_home = leave_time + np.random.randint(10,90)  # minutes\n        agent.add(Leg(\n                seq = no_of_activities + 1,\n                mode = np.random.choice(transport),\n                start_area = location_next,\n                start_loc = location_next_loc,\n                end_area = location1,\n                end_loc = location1_loc,\n                start_time = mtdt(leave_time),\n                end_time = mtdt(arrives_home), \n            ))\n\n        # Activity\n        agent.add(Activity(\n                seq = no_of_activities + 2,\n                act ='home',\n                area = location1,\n                loc = location1_loc,\n                start_time = mtdt(arrives_home),\n                end_time = END_OF_DAY\n            ))\n\n    return population\n</pre> # Generate agents in west london area def generate_agents(no_of_agents):     \"\"\"     Randomly create agents with simple home-based tours.      The trip starts from home, has a random number of various acitivites, tranport modes would be added.      The trip finally ends at home.          \"\"\"          population = Population() # Initialise an empty population          # Create simple personal attributes     income = [\"low\", \"medium\", \"high\"]     gender = [\"male\", \"female\"]     sort_age = ['0 to 4', '5 to 10', '11 to 15', '16 to 20', '21 to 25', '26 to 29',                 '30 to 39', '40 to 49', '50 to 59', '60 to 64',                 '65 to 69', '70 to 74', '75 to 79', '80 to 84', '85  and over']          # Create mode and activities     transport = ['car', 'bus', 'ferry', 'rail', 'subway', 'bike', 'walk']     # Removed gym and park due to osmox problem     activity = ['leisure', 'work', 'shop', 'medical','education', 'park', 'pub', 'gym'] # Primary activity     sub_activity = [\"shop\", \"medical\", \"pub\", \"gym\"] # People usually spend less time on sub activity          # Add activity plan for each person     for i in range(no_of_agents):          # Create different agents and household         agent_id = f\"agent_{i}\"         hh_id = f\"hh_{i}\"         hh = Household(hh_id, freq=1)                  # Adding Activities and Legs alternately to different agents         # Activity 1 - home         leaves_home = (np.random.randint(6, 8) * 60) + np.random.randint(0, 100)  # minutes         location1 = random_area_sampler()         location1_loc = facility_sampler.sample(location1, 'home')         lsoa_name = mapping_dict.get(location1)         lad_name = mapping_dict1.get(location1)                           agent = Person(agent_id,                         freq = 1,                        attributes = {\"subpopulation\": np.random.choice(income) + \" income\",                                      \"gender\" : np.random.choice(gender),                                      \"age\": np.random.choice(sort_age),                                      \"household_zone\": location1,                                      \"household_LSOA\":lsoa_name,                                      \"household_LAD\": lad_name} )                           hh.add(agent)         population.add(hh)                  # Trip duration         trip_duration_main_activity = (np.random.randint(3, 6) * 60)          trip_duration_sub_activity = (np.random.randint(1, 3) * 60)                  agent.add(Activity(             seq = 1,             act ='home',             area = location1,             loc = location1_loc,             start_time = mtdt(0),             end_time = mtdt(leaves_home)         ))              # Initiated parameters         location_prev = location1         location_prev_loc = location1_loc         leave_time = leaves_home              # Add random numbers of activities         no_of_activities = np.random.randint(1,5)                  for i in range(no_of_activities):                          arrives_primary = leave_time + np.random.randint(10, 90)  # minutes                          # Activity 2.               if i &lt; 2: # Start with main activity                 random_act = np.random.choice(activity)             else:                  random_act = np.random.choice(sub_activity)                              if random_act == (\"work\" or \"education\" or \"leisure\"):                 leaves_primary = arrives_primary + trip_duration_main_activity             else:                 leaves_primary = arrives_primary + trip_duration_sub_activity                              # Outbound leg             location_next = random_area_sampler()             location_next_loc = facility_sampler.sample(location_next, random_act)                                agent.add(Leg(                 seq = i + 1,                 mode = np.random.choice(transport),                 start_area = location_prev,                 start_loc = location_prev_loc,                 end_area = location_next,                 end_loc = location_next_loc,                 start_time = mtdt(leave_time),                 end_time = mtdt(arrives_primary),              ))                  agent.add(Activity(                 seq = i + 2,                 act = random_act,                 area = location_next,                 loc = location_next_loc,                 start_time = mtdt(arrives_primary),                 end_time = mtdt(leaves_primary)             ))                           # Update parameters             leave_time = leaves_primary             location_prev = location_next             location_prev_loc = location_next_loc                               # Inbound leg         arrives_home = leave_time + np.random.randint(10,90)  # minutes         agent.add(Leg(                 seq = no_of_activities + 1,                 mode = np.random.choice(transport),                 start_area = location_next,                 start_loc = location_next_loc,                 end_area = location1,                 end_loc = location1_loc,                 start_time = mtdt(leave_time),                 end_time = mtdt(arrives_home),              ))          # Activity         agent.add(Activity(                 seq = no_of_activities + 2,                 act ='home',                 area = location1,                 loc = location1_loc,                 start_time = mtdt(arrives_home),                 end_time = END_OF_DAY             ))      return population In\u00a0[15]: Copied! <pre># Create 100 agents and check the population statistics\npopulation = generate_agents(20)\nprint(population.stats)\n</pre> # Create 100 agents and check the population statistics population = generate_agents(20) print(population.stats) <pre>Using random sample for zone:Kensington and Chelsea 009C:leisure\nUsing random sample for zone:Kensington and Chelsea 008C:pub\nUsing random sample for zone:Lambeth 007A:home\nUsing random sample for zone:Wandsworth 008B:education\nUsing random sample for zone:Hammersmith and Fulham 016A:medical\nUsing random sample for zone:Hammersmith and Fulham 017E:pub\nUsing random sample for zone:Hammersmith and Fulham 021A:leisure\nUsing random sample for zone:Kensington and Chelsea 017D:medical\nUsing random sample for zone:Kensington and Chelsea 010A:work\nUsing random sample for zone:Westminster 024E:shop\nUsing random sample for zone:Kensington and Chelsea 011C:medical\nUsing random sample for zone:Westminster 021E:shop\nUsing random sample for zone:Lambeth 010B:park\nUsing random sample for zone:Kensington and Chelsea 015A:pub\nUsing random sample for zone:Wandsworth 003D:medical\nUsing random sample for zone:Lambeth 010C:leisure\nUsing random sample for zone:Wandsworth 004D:leisure\nUsing random sample for zone:Westminster 022E:shop\nUsing random sample for zone:Lambeth 005C:medical\nUsing random sample for zone:Lambeth 008D:medical\nUsing random sample for zone:Wandsworth 005B:medical\nUsing random sample for zone:Hammersmith and Fulham 010B:park\nUsing random sample for zone:Wandsworth 015A:medical\nUsing random sample for zone:Wandsworth 014B:pub\nUsing random sample for zone:Lambeth 005B:park\nUsing random sample for zone:Westminster 023C:education\nUsing random sample for zone:Wandsworth 020B:medical\nUsing random sample for zone:Westminster 020E:gym\nUsing random sample for zone:Hammersmith and Fulham 023B:park\nUsing random sample for zone:Kensington and Chelsea 017C:work\nUsing random sample for zone:Hammersmith and Fulham 025A:shop\nUsing random sample for zone:Kensington and Chelsea 008A:work\nUsing random sample for zone:Wandsworth 010C:leisure\nUsing random sample for zone:Hammersmith and Fulham 012B:shop\nUsing random sample for zone:Lambeth 010D:pub\nUsing random sample for zone:Wandsworth 001C:education\nUsing random sample for zone:Lambeth 004E:education\nUsing random sample for zone:Wandsworth 017E:pub\nUsing random sample for zone:Hammersmith and Fulham 018D:work\nUsing random sample for zone:Kensington and Chelsea 009A:pub\nUsing random sample for zone:Kensington and Chelsea 010A:work\n</pre> <pre>{'num_households': 20, 'num_people': 20, 'num_activities': 90, 'num_legs': 70}\n</pre> In\u00a0[16]: Copied! <pre>population.random_person().print()\n</pre> population.random_person().print() <pre>Person: agent_9\n{'subpopulation': 'high income', 'gender': 'female', 'age': '80 to 84', 'household_zone': 'Hammersmith and Fulham 023A', 'household_LSOA': 'E02000394', 'household_LAD': 'Hammersmith and Fulham'}\n0:\tActivity(act:home, location:POINT (526011.9104858561 176416.38891429675), time:00:00:00 --&gt; 08:27:00, duration:8:27:00)\n1:\tLeg(mode:ferry, area:POINT (526011.9104858561 176416.38891429675) --&gt; POINT (526859.1481541477 176604.7407805284), time:08:27:00 --&gt; 08:37:00, duration:0:10:00)\n2:\tActivity(act:leisure, location:POINT (526859.1481541477 176604.7407805284), time:08:37:00 --&gt; 10:37:00, duration:2:00:00)\n3:\tLeg(mode:subway, area:POINT (526859.1481541477 176604.7407805284) --&gt; POINT (529081.1874450683 178280.12585411986), time:10:37:00 --&gt; 10:48:00, duration:0:11:00)\n4:\tActivity(act:shop, location:POINT (529081.1874450683 178280.12585411986), time:10:48:00 --&gt; 12:48:00, duration:2:00:00)\n5:\tLeg(mode:subway, area:POINT (529081.1874450683 178280.12585411986) --&gt; POINT (526011.9104858561 176416.38891429675), time:12:48:00 --&gt; 13:06:00, duration:0:18:00)\n6:\tActivity(act:home, location:POINT (526011.9104858561 176416.38891429675), time:13:06:00 --&gt; 00:00:00, duration:10:54:00)\n</pre> In\u00a0[17]: Copied! <pre>population.random_person().attributes\n</pre> population.random_person().attributes Out[17]: <pre>{'subpopulation': 'high income',\n 'gender': 'female',\n 'age': '60 to 64',\n 'household_zone': 'Lambeth 003B',\n 'household_LSOA': 'E02000620',\n 'household_LAD': 'Lambeth'}</pre> In\u00a0[18]: Copied! <pre># Validation if it works\npopulation.validate()\n</pre> # Validation if it works population.validate() In\u00a0[19]: Copied! <pre># Print random person activity plan\npopulation.random_person().print()\n</pre> # Print random person activity plan population.random_person().print() <pre>Person: agent_7\n{'subpopulation': 'medium income', 'gender': 'male', 'age': '75 to 79', 'household_zone': 'Westminster 020C', 'household_LSOA': 'E02000979', 'household_LAD': 'Westminster'}\n0:\tActivity(act:home, location:POINT (530025.7262240043 179234.94124139557), time:00:00:00 --&gt; 07:20:00, duration:7:20:00)\n1:\tLeg(mode:car, area:POINT (530025.7262240043 179234.94124139557) --&gt; POINT (530421.0701527973 176357.41637773014), time:07:20:00 --&gt; 07:48:00, duration:0:28:00)\n2:\tActivity(act:park, location:POINT (530421.0701527973 176357.41637773014), time:07:48:00 --&gt; 09:48:00, duration:2:00:00)\n3:\tLeg(mode:bus, area:POINT (530421.0701527973 176357.41637773014) --&gt; POINT (524894.1777043933 178668.57429431175), time:09:48:00 --&gt; 11:03:00, duration:1:15:00)\n4:\tActivity(act:pub, location:POINT (524894.1777043933 178668.57429431175), time:11:03:00 --&gt; 13:03:00, duration:2:00:00)\n5:\tLeg(mode:bus, area:POINT (524894.1777043933 178668.57429431175) --&gt; POINT (527211.6948213538 176747.3446664569), time:13:03:00 --&gt; 13:24:00, duration:0:21:00)\n6:\tActivity(act:medical, location:POINT (527211.6948213538 176747.3446664569), time:13:24:00 --&gt; 15:24:00, duration:2:00:00)\n7:\tLeg(mode:rail, area:POINT (527211.6948213538 176747.3446664569) --&gt; POINT (530025.7262240043 179234.94124139557), time:15:24:00 --&gt; 16:49:00, duration:1:25:00)\n8:\tActivity(act:home, location:POINT (530025.7262240043 179234.94124139557), time:16:49:00 --&gt; 00:00:00, duration:7:11:00)\n</pre> <p>Plot the activities as a 24-hour diary schedules for 5 randomly chosen agents</p> In\u00a0[20]: Copied! <pre>for i in range(5):\n    p = population.random_person()\n    p.plot()\n</pre> for i in range(5):     p = population.random_person()     p.plot() <p>Plot the frequency with which each of the activity types happens throughout the 24-hour period.</p> In\u00a0[21]: Copied! <pre>fig = plot_activity_times(population)\n</pre> fig = plot_activity_times(population) In\u00a0[22]: Copied! <pre># Check the duration of trips\ndurations = duration_counts(population)\ndurations\n</pre> # Check the duration of trips durations = duration_counts(population) durations Out[22]: duration trips 0 0 to 5 min 0 1 5 to 10 min 2 2 10 to 15 min 4 3 15 to 30 min 22 4 30 to 45 min 11 5 45 to 60 min 8 6 60 to 90 min 23 7 90 to 120 min 0 8 120+ min 0 <p>Now plot a histogram for duration of the trips.</p> In\u00a0[23]: Copied! <pre>plt.barh(durations[\"duration\"], durations[\"trips\"])\nplt.xlabel(\"Counts\")\nplt.ylabel(\"Duration for trips\")\nplt.title(\"Duration for different trips\")\nplt.ylim(ymax = \"90 to 120 min\")\n</pre> plt.barh(durations[\"duration\"], durations[\"trips\"]) plt.xlabel(\"Counts\") plt.ylabel(\"Duration for trips\") plt.title(\"Duration for different trips\") plt.ylim(ymax = \"90 to 120 min\") Out[23]: <pre>(-0.8400000000000001, 7.0)</pre> In\u00a0[24]: Copied! <pre># Check the distance of trips\ndistances  = distance_counts(population)\ndistances\n</pre> # Check the distance of trips distances  = distance_counts(population) distances Out[24]: distance trips 0 0 to 1 km 4 1 1 to 5 km 44 2 5 to 10 km 22 3 10 to 25 km 0 4 25 to 50 km 0 5 50 to 100 km 0 6 100 to 200 km 0 7 200+ km 0 <p>Next we plot the distribution of trip distances.</p> In\u00a0[25]: Copied! <pre>plt.barh(distances[\"distance\"], distances[\"trips\"])\nplt.xlabel(\"Counts\")\nplt.ylabel(\"distance, km\")\nplt.title(\"distance for different trips\")\nplt.ylim(ymax = \"25 to 50 km\")\n</pre> plt.barh(distances[\"distance\"], distances[\"trips\"]) plt.xlabel(\"Counts\") plt.ylabel(\"distance, km\") plt.title(\"distance for different trips\") plt.ylim(ymax = \"25 to 50 km\") Out[25]: <pre>(-0.79, 4.0)</pre> In\u00a0[26]: Copied! <pre>to_csv(population, dir = \"outputs\", crs = \"epsg:27700\")\n</pre> to_csv(population, dir = \"outputs\", crs = \"epsg:27700\") <p>Plot the distribution of activities by type</p> In\u00a0[27]: Copied! <pre>df_activity = pd.read_csv(os.path.join(\"outputs\", \"activities.csv\"))\ntotals = df_activity.activity.value_counts()\nplt.barh(totals.index, totals)\nplt.title(\"activities count\")\n</pre> df_activity = pd.read_csv(os.path.join(\"outputs\", \"activities.csv\")) totals = df_activity.activity.value_counts() plt.barh(totals.index, totals) plt.title(\"activities count\") Out[27]: <pre>Text(0.5, 1.0, 'activities count')</pre> In\u00a0[28]: Copied! <pre>write_od_matrices(population, path = \"outputs\")\nod_matrices = pd.read_csv(os.path.join(\"outputs\", \"total_od.csv\"))  # we should change this method to be consistent with other - ie return a dataframe\nod_matrices[\"total origins\"] = od_matrices.drop(\"Origin\", axis=1).sum(axis=1)\nod_matrices\n</pre> write_od_matrices(population, path = \"outputs\") od_matrices = pd.read_csv(os.path.join(\"outputs\", \"total_od.csv\"))  # we should change this method to be consistent with other - ie return a dataframe od_matrices[\"total origins\"] = od_matrices.drop(\"Origin\", axis=1).sum(axis=1) od_matrices Out[28]: Origin Hammersmith and Fulham 010B Hammersmith and Fulham 012B Hammersmith and Fulham 013E Hammersmith and Fulham 014B Hammersmith and Fulham 016A Hammersmith and Fulham 016D Hammersmith and Fulham 017E Hammersmith and Fulham 018D Hammersmith and Fulham 021A ... Wandsworth 020B Westminster 020A Westminster 020C Westminster 020E Westminster 021E Westminster 022E Westminster 023B Westminster 023C Westminster 024E total origins 0 Hammersmith and Fulham 010B 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 1 Hammersmith and Fulham 012B 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 2 Hammersmith and Fulham 013E 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 3 Hammersmith and Fulham 014B 0 0 0 0 0 0 0 0 0 ... 0 1 0 0 0 0 0 0 0 1 4 Hammersmith and Fulham 016A 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 60 Westminster 021E 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 61 Westminster 022E 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 62 Westminster 023B 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 63 Westminster 023C 0 0 0 0 0 0 0 0 0 ... 1 0 0 0 0 0 0 0 0 1 64 Westminster 024E 0 0 1 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 1 <p>65 rows \u00d7 67 columns</p> <p>Plot the number of trips originating from each LSOA</p> In\u00a0[29]: Copied! <pre>lsoas_clipped = lsoas_clipped.reset_index()\norigins_heat_map = lsoas_clipped.join(od_matrices[\"total origins\"])\n\nfig, ax = plt.subplots(figsize=(18,10))    \norigins_heat_map.plot(\"total origins\", legend=True, ax=ax)\nax.set_title(\"Total Origins\")\n</pre> lsoas_clipped = lsoas_clipped.reset_index() origins_heat_map = lsoas_clipped.join(od_matrices[\"total origins\"])  fig, ax = plt.subplots(figsize=(18,10))     origins_heat_map.plot(\"total origins\", legend=True, ax=ax) ax.set_title(\"Total Origins\") Out[29]: <pre>Text(0.5, 1.0, 'Total Origins')</pre> In\u00a0[30]: Copied! <pre>people = pd.read_csv(os.path.join(\"outputs\", \"people.csv\")).set_index('pid')\nhhs = pd.read_csv(os.path.join(\"outputs\", \"households.csv\")).set_index('hid')\ntrips = pd.read_csv(os.path.join(\"outputs\", \"legs.csv\")).drop(['Unnamed: 0'],axis=1)\n\ntrips.rename(columns={'origin activity': 'oact', 'destination activity': 'dact'}, inplace=True)\ntrips.head()\n</pre> people = pd.read_csv(os.path.join(\"outputs\", \"people.csv\")).set_index('pid') hhs = pd.read_csv(os.path.join(\"outputs\", \"households.csv\")).set_index('hid') trips = pd.read_csv(os.path.join(\"outputs\", \"legs.csv\")).drop(['Unnamed: 0'],axis=1)  trips.rename(columns={'origin activity': 'oact', 'destination activity': 'dact'}, inplace=True) trips.head() Out[30]: pid hid freq ozone dzone purp oact dact mode seq tst tet duration 0 agent_0 hh_0 NaN Westminster 023B Kensington and Chelsea 020B NaN home leisure rail 1 1900-01-01 07:11:00 1900-01-01 07:26:00 0:15:00 1 agent_0 hh_0 NaN Kensington and Chelsea 020B Kensington and Chelsea 009C NaN leisure leisure bike 2 1900-01-01 08:26:00 1900-01-01 09:55:00 1:29:00 2 agent_0 hh_0 NaN Kensington and Chelsea 009C Westminster 023B NaN leisure home car 3 1900-01-01 10:55:00 1900-01-01 11:30:00 0:35:00 3 agent_1 hh_1 NaN Hammersmith and Fulham 016D Kensington and Chelsea 008C NaN home pub rail 1 1900-01-01 06:52:00 1900-01-01 07:26:00 0:34:00 4 agent_1 hh_1 NaN Kensington and Chelsea 008C Hammersmith and Fulham 016D NaN pub home bus 2 1900-01-01 09:26:00 1900-01-01 09:49:00 0:23:00 In\u00a0[31]: Copied! <pre>population_reloaded = load_travel_diary(\n    trips=trips,\n    persons_attributes=people,\n    hhs_attributes=hhs,\n)\n</pre> population_reloaded = load_travel_diary(     trips=trips,     persons_attributes=people,     hhs_attributes=hhs, ) <pre>Using from-to activity parser using 'oact' and 'dact' columns\n</pre> <p>Plot the activities as a 24-hour diary schedules</p> In\u00a0[32]: Copied! <pre>population[\"hh_0\"][\"agent_0\"].plot()\n</pre> population[\"hh_0\"][\"agent_0\"].plot() In\u00a0[33]: Copied! <pre>population_reloaded[\"hh_0\"][\"agent_0\"].plot()\n</pre> population_reloaded[\"hh_0\"][\"agent_0\"].plot() In\u00a0[34]: Copied! <pre>population == population_reloaded\n</pre> population == population_reloaded Out[34]: <pre>False</pre> <p>The populations are not the same because the csv files did not preserve the coordinates that we previously sampled, so we will sample them again. But the reloaded population will be different as for each location a new coordinate is sampled.</p> In\u00a0[35]: Copied! <pre>write_matsim(population=population, plans_path=os.path.join(\"outputs\", \"population.xml\"))\n</pre> write_matsim(population=population, plans_path=os.path.join(\"outputs\", \"population.xml\")) In\u00a0[36]: Copied! <pre>population_reloaded = read_matsim(\n    plans_path=os.path.join(\"outputs\", \"population.xml\"),\n    household_key=\"hid\",\n    version=12\n)\n</pre> population_reloaded = read_matsim(     plans_path=os.path.join(\"outputs\", \"population.xml\"),     household_key=\"hid\",     version=12 )"},{"location":"examples/03_Example_Generate_Random_Population/#example-create-population-for-west-london","title":"Example: Create Population for West London\u00b6","text":""},{"location":"examples/03_Example_Generate_Random_Population/#aim","title":"Aim:\u00b6","text":"<p>Create a bigger and more realistic sample population automatically for the West London area called Londinium. The sample population includes various activities, personal attributes and modes; the population would be used as input for MATSim transport simulation.</p>"},{"location":"examples/03_Example_Generate_Random_Population/#import-geographic-data-of-londinium","title":"Import geographic data of Londinium\u00b6","text":""},{"location":"examples/03_Example_Generate_Random_Population/#facility-sampler","title":"Facility sampler\u00b6","text":""},{"location":"examples/03_Example_Generate_Random_Population/#activity-generation-model","title":"Activity generation model\u00b6","text":""},{"location":"examples/03_Example_Generate_Random_Population/#data-visulazation-and-validation","title":"Data Visulazation and validation\u00b6","text":""},{"location":"examples/03_Example_Generate_Random_Population/#export-intermediate-csv-tables-of-population","title":"Export intermediate CSV tables of population\u00b6","text":""},{"location":"examples/03_Example_Generate_Random_Population/#reload-tabular-data","title":"Reload Tabular Data\u00b6","text":"<p>We load in the csv files we previously wrote to disk. This replicates a simple synthesis process we might typically use for travel diary survey data.</p>"},{"location":"examples/03_Example_Generate_Random_Population/#write-output-to-matsim-xml","title":"Write output to MATSim xml\u00b6","text":""},{"location":"api/scoring/","title":"pam.scoring","text":""},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer","title":"<code>CharyparNagelPlanScorer(cnfg) -&gt; None</code>","text":"<p>Charypar-Nagel plan scorer.</p> Source code in <code>pam/scoring.py</code> <pre><code>def __init__(self, cnfg) -&gt; None:\n\"\"\"\n    Charypar-Nagel plan scorer.\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.cnfg = cnfg\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.cnfg","title":"<code>cnfg = cnfg</code>  <code>instance-attribute</code>","text":""},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.example_config","title":"<code>example_config = {'default': {'mUM': 10, 'utilityOfLineSwitch': -1, 'performing': 6, 'waiting': -0, 'waitingPt': -1, 'lateArrival': -18, 'earlyDeparture': -10, 'work': {'typicalDuration': '08:00:00', 'openingTime': '06:00:00', 'closingTime': '20:00:00', 'latestStartTime': '09:30:00', 'earliestEndTime': '16:00:00', 'minimalDuration': '01:00:00'}, 'home': {'typicalDuration': '12:00:00', 'minimalDuration': '05:00:00'}, 'shop': {'typicalDuration': '00:30:00', 'openingTime': '06:00:00', 'closingTime': '20:00:00'}, 'car': {'constant': -10, 'dailyMonetaryConstant': -1, 'dailyUtilityConstant': -1, 'marginalUtilityOfDistance': -0.001, 'marginalUtilityOfTravelling': -1, 'monetaryDistanceRate': -0.0001}, 'walk': {'constant': -20}}}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.activities_wrapper","title":"<code>activities_wrapper(activities)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def activities_wrapper(self, activities):\n    non_wrapped = activities[1:-1]\n    wrapped_act = Activity(\n        act=activities[0].act,\n        start_time=activities[-1].start_time,\n        end_time=activities[0].end_time + td(days=1)\n    )\n    return wrapped_act, non_wrapped\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.duration_score","title":"<code>duration_score(activity, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def duration_score(self, activity, cnfg) -&gt; float:\n    prio = 1\n    performing = cnfg[\"performing\"]\n    typical_dur = utils.matsim_duration_to_hours(cnfg[activity.act][\"typicalDuration\"])\n\n    opening_time = cnfg[activity.act].get(\"openingTime\")\n    if opening_time is not None:\n        opening_time = utils.matsim_time_to_datetime(opening_time)\n        if opening_time.time() &gt; activity.start_time.time():\n            actual_start_time = opening_time\n        else:\n            actual_start_time = activity.start_time\n    else:\n        actual_start_time = activity.start_time\n\n    closing_time = cnfg[activity.act].get(\"closingTime\")\n    if closing_time is not None:\n        closing_time = utils.matsim_time_to_datetime(closing_time)\n        if closing_time.time() &lt; activity.end_time.time():\n            actual_end_time = closing_time\n        else:\n            actual_end_time = activity.end_time\n    else:\n        actual_end_time = activity.end_time\n\n    if actual_end_time &lt; actual_start_time or actual_start_time &gt; actual_end_time:\n        duration = 0\n    else:\n        duration = (actual_end_time - actual_start_time) / td(hours = 1)\n\n    if duration &lt; typical_dur / np.e:\n        return (duration * np.e - typical_dur) * performing\n\n    return performing * typical_dur * (np.log(duration / typical_dur) + (1 / prio))\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.early_departure_score","title":"<code>early_departure_score(activity, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def early_departure_score(self, activity, cnfg) -&gt; float:\n    if cnfg[activity.act].get(\"earliestEndTime\") is not None \\\n    and cnfg.get(\"earlyDeparture\"):\n        earliest_end_time = utils.matsim_time_to_datetime(\n            cnfg[activity.act][\"earliestEndTime\"]\n            )\n        if activity.end_time.time() &lt; earliest_end_time.time():\n            return cnfg[\"earlyDeparture\"] \\\n                * ((earliest_end_time - activity.end_time) / td(hours = 1))\n    return 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.late_arrival_score","title":"<code>late_arrival_score(activity, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def late_arrival_score(self, activity, cnfg) -&gt; float:\n    if cnfg[activity.act].get(\"latestStartTime\") is not None and cnfg.get(\"lateArrival\"):\n        latest_start_time = utils.matsim_time_to_datetime(\n            cnfg[activity.act][\"latestStartTime\"]\n            )\n        if activity.start_time.time() &gt; latest_start_time.time():\n            return cnfg[\"lateArrival\"] \\\n                * ((activity.start_time - latest_start_time) / td(hours = 1))\n    return 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.mode_constant_score","title":"<code>mode_constant_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def mode_constant_score(self, leg, cnfg):\n    return cnfg[leg.mode].get(\"constant\", 0.0)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.pt_waiting_time_score","title":"<code>pt_waiting_time_score(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def pt_waiting_time_score(self, leg, cnfg):\n    print(\"BT\", leg.boarding_time)\n    if cnfg.get(\"waitingPt\") and leg.boarding_time:\n        waiting = (leg.boarding_time - leg.start_time) / td(hours = 1)\n        if waiting &gt; 0:\n            return cnfg[\"waitingPt\"] * waiting\n    return 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_activity","title":"<code>score_activity(activity, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_activity(self, activity, cnfg):\n    return sum([\n        self.duration_score(activity, cnfg),\n        self.waiting_score(activity, cnfg),\n        self.late_arrival_score(activity, cnfg),\n        self.early_departure_score(activity, cnfg)\n    ])\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_day_mode_use","title":"<code>score_day_mode_use(mode, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_day_mode_use(self, mode, cnfg) -&gt; float:\n    return cnfg[mode].get(\"dailyUtilityConstant\", 0) \\\n        + (cnfg[mode].get(\"dailyMonetaryConstant\", 0) * cnfg.get(\"mUM\", 1))\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_leg","title":"<code>score_leg(leg, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_leg(self, leg, cnfg):\n    return sum([\n        self.pt_waiting_time_score(leg, cnfg),\n        self.mode_constant_score(leg, cnfg),\n        self.travel_time_score(leg, cnfg),\n        self.travel_distance_score(leg, cnfg)\n    ])\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_person","title":"<code>score_person(person: Person, subpopulation: str = 'subpopulation', plan_costs: Optional[float] = None)</code>","text":"<p>Score a pam.core.Person Plan</p> <p>Parameters:</p> Name Type Description Default <code>subpopulation</code> <code>str</code> <p>person attribute name for subpopulation, Defalts to \"subpopulation\".</p> <code>'subpopulation'</code> <code>plan_costs</code> <code>Optional[float]</code> <p>Optionally add monetary costs such as tolls. Defaults to None.</p> <code>None</code> Source code in <code>pam/scoring.py</code> <pre><code>def score_person(\n    self,\n    person : Person,\n    subpopulation : str = \"subpopulation\",\n    plan_costs : Optional[float] = None\n    ):\n\"\"\"\n    Score a pam.core.Person Plan\n\n    Args:\n        person (Person).\n        subpopulation (str): person attribute name for subpopulation, Defalts to \"subpopulation\".\n        plan_costs (Optional[float], optional): Optionally add monetary costs such as tolls. Defaults to None.\n    \"\"\"\n    subpop = person.attributes[subpopulation]\n    cnfg = self.cnfg[subpop]\n    return self.score_plan(person.plan, plan_cost=plan_costs, cnfg=cnfg)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan","title":"<code>score_plan(plan: Plan, cnfg: dict, plan_cost: Optional[float] = None) -&gt; float</code>","text":"<p>Score a pam.activity.Plan</p> <p>Parameters:</p> Name Type Description Default <code>plan</code> <code>pam.activity.Plan</code> <p>activity plan to be scored.</p> required <code>cnfg</code> <code>dict</code> <p>configuration for plan scoring, refer to self.example_config for example.</p> required <code>plan_cost</code> <code>float</code> <p>Optionally add a plan monetary cost. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Charypar-Nagel score</p> Source code in <code>pam/scoring.py</code> <pre><code>def score_plan(\n    self,\n    plan: Plan,\n    cnfg: dict,\n    plan_cost: Optional[float] = None\n    ) -&gt; float:\n\"\"\"\n    Score a pam.activity.Plan\n\n    Args:\n        plan (pam.activity.Plan): activity plan to be scored.\n        cnfg (dict): configuration for plan scoring, refer to self.example_config for example.\n        plan_cost (float, optional): Optionally add a plan monetary cost. Defaults to None.\n\n    Returns:\n        float: Charypar-Nagel score\n    \"\"\"\n    return self.score_plan_activities(plan, cnfg) \\\n        + self.score_plan_legs(plan, cnfg) \\\n        + self.score_plan_monetary_cost(plan_cost, cnfg) \\\n        + self.score_plan_daily(plan, cnfg)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_activities","title":"<code>score_plan_activities(plan, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_activities(self, plan, cnfg):\n    activities = list(plan.activities)\n    if len(activities) == 1:\n        return self.score_activity(activities[0], cnfg)\n    if activities[0].act != activities[-1].act:\n        # if the first and last activity are not of the same type\n        # then the activities are not wrapped\n        # see https://github.com/matsim-org/matsim-libs/blob/77536f9f05ff70b69bdf54f19604f5732d81949c/matsim/src/main/java/org/matsim/core/scoring/functions/CharyparNagelActivityScoring.java#L241-L265\n        score = sum([self.score_activity(act, cnfg) for act in activities if act.act not in [\"pt interaction\", \"pt_interaction\"]])\n    else:\n        wrapped_activity, other_activities = self.activities_wrapper(activities)\n        score = self.score_activity(wrapped_activity, cnfg) \\\n            + sum([self.score_activity(act, cnfg) for act in other_activities if act.act not in [\"pt interaction\", \"pt_interaction\"]])\n\n    return score\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_daily","title":"<code>score_plan_daily(plan, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_daily(self, plan, cnfg) -&gt; float:\n    modes = plan.mode_classes\n    return sum([self.score_day_mode_use(mode, cnfg) for mode in modes])\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_legs","title":"<code>score_plan_legs(plan, cnfg)</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_legs(self, plan, cnfg):\n    return self.score_pt_interchanges(plan, cnfg) \\\n         + sum([self.score_leg(leg, cnfg) for leg in plan.legs])\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_plan_monetary_cost","title":"<code>score_plan_monetary_cost(plan_cost, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def score_plan_monetary_cost(self, plan_cost, cnfg) -&gt; float:\n    if plan_cost is not None:\n        return cnfg.get(\"mUM\", 1) * plan_cost\n    return 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.score_pt_interchanges","title":"<code>score_pt_interchanges(plan: Plan, cnfg: dict) -&gt; float</code>","text":"<p>Calculates utility of line switch.</p> Source code in <code>pam/scoring.py</code> <pre><code>def score_pt_interchanges(self, plan : Plan, cnfg : dict) -&gt; float:\n\"\"\"\n    Calculates utility of line switch.\n    \"\"\"\n    if not cnfg.get(\"utilityOfLineSwitch\"):\n        return 0.0\n    transits = []\n    in_transit = 0\n    for i in plan:\n        if isinstance(i, Activity):\n            if i.act not in ['pt interaction', 'pt_interaction']:\n                if in_transit &gt; 0:\n                    in_transit -= 1 # the first PT vehicle does not incur a line switch penalty\n                transits.append(in_transit)\n                in_transit = 0\n        elif isinstance(i, Leg):\n            if i.mode in TRANSIT_MODES:\n                # number of PT modes used in each trip\n                in_transit += 1\n    cost = sum(transits) * cnfg.get(\"utilityOfLineSwitch\", 0)\n    return cost\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.summary","title":"<code>summary(person, subpopulation = 'subpopulation')</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def summary(self, person, subpopulation='subpopulation'):\n    print(f\"Total plan score: {self.score_person(person)}\")\n    config = self.cnfg[person.attributes[subpopulation]]\n    print(f\"Total activities score: {self.score_plan_activities(person.plan, cnfg=config)}\")\n    print(f\"Total legs score: {self.score_plan_legs(person.plan, cnfg=config)}\")\n    print(f\"Pt interchanges score: {self.score_pt_interchanges(person.plan, cnfg=config)}\")\n    print(f\"Day score: {self.score_plan_daily(person.plan, cnfg=config)}\")\n    print()\n    for i, component in enumerate(person.plan):\n        if isinstance(component, Activity):\n            print()\n            print(f\"({i}) Activity: {component.act}\")\n            print(f\"\\tDuration: {component.duration}\")\n            if component.act in ['pt interaction', 'pt_interaction']:\n                continue\n            print(f\"\\tScore: {self.score_activity(component, cnfg=config)}\")\n            print(f\"\\tDuration_score: {self.duration_score(component, cnfg=config)}\")\n            print(f\"\\tWaiting_score: {self.waiting_score(component, cnfg=config)}\")\n            print(f\"\\tLate_arrival_score: {self.late_arrival_score(component, cnfg=config)}\")\n            print(f\"\\tEarly_departure_score: {self.early_departure_score(component, cnfg=config)}\")\n            print(f\"\\tToo_short_score: {self.too_short_score(component, cnfg=config)}\")\n\n        if isinstance(component, Leg):\n            print()\n            print(f\"({i}) Leg: {component.mode}\")\n            print(f\"\\tDistance: {component.distance} Duration: {component.duration}\")\n            print(f\"\\tScore: {self.score_leg(component, cnfg=config)}\")\n            print(f\"\\tPt_waiting_time_score: {self.pt_waiting_time_score(component, cnfg=config)}\")\n            print(f\"\\tConstant: {self.mode_constant_score(component, cnfg=config)}\")\n            print(f\"\\tTravel_time_score: {self.travel_time_score(component, cnfg=config)}\")\n            print(f\"\\tTravel_distance_score: {self.travel_distance_score(component, cnfg=config)}\")\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.too_short_score","title":"<code>too_short_score(activity, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def too_short_score(self, activity, cnfg) -&gt; float:\n    if cnfg[activity.act].get(\"minimalDuration\") \\\n        and cnfg.get(\"earlyDeparture\"):\n        minimal_duration = utils.matsim_duration_to_hours(\n            cnfg[activity.act][\"minimalDuration\"]\n            )\n        if activity.hours &lt; minimal_duration:\n            return cnfg['earlyDeparture'] * (minimal_duration - activity.hours)\n    return 0.0\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.travel_distance_score","title":"<code>travel_distance_score(leg, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def travel_distance_score(self, leg, cnfg) -&gt; float:\n    return leg.distance * (cnfg[leg.mode].get(\"marginalUtilityOfDistance\", 0.0) \\\n         + (cnfg.get(\"mUM\", 1.0) * cnfg[leg.mode].get(\"monetaryDistanceRate\", 0.0)))\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.travel_time_score","title":"<code>travel_time_score(leg, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def travel_time_score(self, leg, cnfg) -&gt; float:\n    duration = leg.hours\n    if cnfg.get(\"waitingPt\") and leg.boarding_time:\n        duration -= ((leg.boarding_time - leg.start_time) / td(hours = 1))\n    return duration * cnfg[leg.mode].get(\"marginalUtilityOfTravelling\", 0.0)\n</code></pre>"},{"location":"api/scoring/#pam.scoring.CharyparNagelPlanScorer.waiting_score","title":"<code>waiting_score(activity, cnfg) -&gt; float</code>","text":"Source code in <code>pam/scoring.py</code> <pre><code>def waiting_score(self, activity, cnfg) -&gt; float:\n    waiting = cnfg[\"waiting\"]\n    if not waiting:\n        return 0.0\n    opening_time = cnfg[activity.act].get(\"openingTime\")\n    if opening_time is None:\n        return 0.0\n    opening_dt = utils.matsim_time_to_datetime(opening_time)\n    start_dt = activity.start_time\n    if start_dt.time() &lt; opening_dt.time():\n        return waiting * ((opening_dt - start_dt)  / td(hours = 1))\n    return 0.0\n</code></pre>"},{"location":"api/vehicle/","title":"pam.vehicle","text":""},{"location":"api/vehicle/#pam.vehicle.CapacityType","title":"<code>CapacityType</code>  <code>dataclass</code>","text":""},{"location":"api/vehicle/#pam.vehicle.CapacityType.seats","title":"<code>seats: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.CapacityType.standingRoomInPersons","title":"<code>standingRoomInPersons: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.CapacityType.from_xml_elem","title":"<code>from_xml_elem(elem)</code>  <code>classmethod</code>","text":"Source code in <code>pam/vehicle.py</code> <pre><code>@classmethod\ndef from_xml_elem(cls, elem):\n    attribs = {k: int(v) for k, v in elem.attrib.items()}\n    return cls(**attribs)\n</code></pre>"},{"location":"api/vehicle/#pam.vehicle.CapacityType.to_xml","title":"<code>to_xml(xf)</code>","text":"Source code in <code>pam/vehicle.py</code> <pre><code>def to_xml(self, xf):\n    xf.write(et.Element(\"capacity\",\n                        {'seats': str(self.seats), 'standingRoomInPersons': str(self.standingRoomInPersons)}))\n</code></pre>"},{"location":"api/vehicle/#pam.vehicle.ElectricVehicle","title":"<code>ElectricVehicle</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Vehicle</code></p>"},{"location":"api/vehicle/#pam.vehicle.ElectricVehicle.battery_capacity","title":"<code>battery_capacity: float = 60</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.ElectricVehicle.charger_types","title":"<code>charger_types: str = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.ElectricVehicle.initial_soc","title":"<code>initial_soc: float = battery_capacity</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.ElectricVehicle.vehicle_type","title":"<code>vehicle_type: VehicleType = VehicleType(id='defaultElectricVehicleType')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.ElectricVehicle.to_e_xml","title":"<code>to_e_xml(xf)</code>","text":"Source code in <code>pam/vehicle.py</code> <pre><code>def to_e_xml(self, xf):\n    xf.write(\n        et.Element(\"vehicle\",\n                   {'id': str(self.id), 'battery_capacity': str(self.battery_capacity),\n                    'initial_soc': str(self.initial_soc), 'charger_types': str(self.charger_types),\n                    'vehicle_type': str(self.vehicle_type.id)}\n                   )\n    )\n</code></pre>"},{"location":"api/vehicle/#pam.vehicle.Vehicle","title":"<code>Vehicle</code>  <code>dataclass</code>","text":""},{"location":"api/vehicle/#pam.vehicle.Vehicle.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.Vehicle.vehicle_type","title":"<code>vehicle_type: VehicleType = VehicleType()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.Vehicle.to_xml","title":"<code>to_xml(xf)</code>","text":"Source code in <code>pam/vehicle.py</code> <pre><code>def to_xml(self, xf):\n    xf.write(et.Element(\"vehicle\", {'id': str(self.id), 'type': str(self.vehicle_type.id)}))\n</code></pre>"},{"location":"api/vehicle/#pam.vehicle.VehicleType","title":"<code>VehicleType</code>  <code>dataclass</code>","text":""},{"location":"api/vehicle/#pam.vehicle.VehicleType.capacity","title":"<code>capacity: CapacityType = CapacityType()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.VehicleType.description","title":"<code>description: str = 'personal_vehicle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.VehicleType.flowEfficiencyFactor","title":"<code>flowEfficiencyFactor: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.VehicleType.id","title":"<code>id: str = 'defaultVehicleType'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.VehicleType.length","title":"<code>length: float = 7.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.VehicleType.networkMode","title":"<code>networkMode: str = 'car'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.VehicleType.passengerCarEquivalents","title":"<code>passengerCarEquivalents: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.VehicleType.width","title":"<code>width: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/vehicle/#pam.vehicle.VehicleType.from_xml_elem","title":"<code>from_xml_elem(elem)</code>  <code>classmethod</code>","text":"Source code in <code>pam/vehicle.py</code> <pre><code>@classmethod\ndef from_xml_elem(cls, elem):\n    attribs = {attrib.tag.replace('{http://www.matsim.org/files/dtd}', ''): attrib for attrib in elem}\n    return cls(\n        id=elem.get('id'),\n        length=float(attribs[\"length\"].attrib['meter']),\n        width=float(attribs[\"width\"].attrib['meter']),\n        passengerCarEquivalents=float(attribs[\"passengerCarEquivalents\"].attrib['pce']),\n        networkMode=attribs[\"networkMode\"].attrib['networkMode'],\n        flowEfficiencyFactor=float(attribs[\"flowEfficiencyFactor\"].attrib['factor']),\n        capacity=CapacityType.from_xml_elem(attribs['capacity']),\n        description=attribs['description'].text\n    )\n</code></pre>"},{"location":"api/vehicle/#pam.vehicle.VehicleType.to_xml","title":"<code>to_xml(xf)</code>","text":"Source code in <code>pam/vehicle.py</code> <pre><code>def to_xml(self, xf):\n    with xf.element(\"vehicleType\", {'id': self.id}):\n        rec = et.Element(\"description\")\n        rec.text = self.description\n        xf.write(rec)\n        self.capacity.to_xml(xf)\n        xf.write(et.Element(\"length\", {'meter': str(self.length)}))\n        xf.write(et.Element(\"width\", {'meter': str(self.width)}))\n        xf.write(et.Element(\"passengerCarEquivalents\", {'pce': str(self.passengerCarEquivalents)}))\n        xf.write(et.Element(\"networkMode\", {'networkMode': str(self.networkMode)}))\n        xf.write(et.Element(\"flowEfficiencyFactor\", {'factor': str(self.flowEfficiencyFactor)}))\n</code></pre>"},{"location":"api/activity/","title":"pam.activity","text":""},{"location":"api/activity/#pam.activity.Activity","title":"<code>Activity(seq = None, act = None, area = None, link = None, loc = None, start_time = None, end_time = None, freq = None)</code>","text":"<p>         Bases: <code>PlanComponent</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(\n        self,\n        seq=None,\n        act=None,\n        area=None,\n        link=None,\n        loc=None,\n        start_time=None,\n        end_time=None,\n        freq=None,\n):\n    self.seq = seq\n    self.act = act\n    self.location = Location(loc=loc, link=link, area=area)\n    self.start_time = start_time\n    self.end_time = end_time\n    self.freq=freq\n</code></pre>"},{"location":"api/activity/#pam.activity.Activity.act","title":"<code>act = act</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.end_time","title":"<code>end_time = end_time</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.freq","title":"<code>freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.location","title":"<code>location = Location(loc=loc, link=link, area=area)</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.seq","title":"<code>seq = seq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.start_time","title":"<code>start_time = start_time</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Activity.is_exact","title":"<code>is_exact(other)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def is_exact(self, other):\n    return (self.location == other.location) and (self.act == other.act) \\\n           and (self.start_time == other.start_time) and (self.end_time == other.end_time)\n</code></pre>"},{"location":"api/activity/#pam.activity.Activity.isin_exact","title":"<code>isin_exact(activities: list)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def isin_exact(self, activities: list):\n    for other in activities:\n        if self.is_exact(other):\n            return True\n    return False\n</code></pre>"},{"location":"api/activity/#pam.activity.Activity.validate_matsim","title":"<code>validate_matsim() -&gt; None</code>","text":"<p>Checks if activity has required fields for a valid matsim plan.</p> Source code in <code>pam/activity.py</code> <pre><code>def validate_matsim(self) -&gt; None:\n\"\"\"Checks if activity has required fields for a valid matsim plan.\"\"\"\n    if self.act is None:\n        raise InvalidMATSimError(\"Activity requires a type.\")\n    if self.start_time is None and self.end_time is None:\n        raise InvalidMATSimError(\"Activity requires either start time or end_time.\")\n    if self.location.loc is None and self.location.link is None:\n        raise InvalidMATSimError(\"Activity requires link id or x,y coordinates.\")\n</code></pre>"},{"location":"api/activity/#pam.activity.Leg","title":"<code>Leg(seq = None, mode = None, start_area = None, end_area = None, start_link = None, end_link = None, start_loc = None, end_loc = None, start_time = None, end_time = None, distance = None, purp = None, freq = None, attributes = {}, route = None)</code>","text":"<p>         Bases: <code>PlanComponent</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(\n        self,\n        seq=None,\n        mode=None,\n        start_area=None,\n        end_area=None,\n        start_link=None,\n        end_link=None,\n        start_loc=None,\n        end_loc=None,\n        start_time=None,\n        end_time=None,\n        distance=None,\n        purp=None,\n        freq=None,\n        attributes={},\n        route=None,\n):\n    self.seq = seq\n    self.purp = purp\n    self.mode = mode\n    self.start_location = Location(loc=start_loc, link=start_link, area=start_area)\n    self.end_location = Location(loc=end_loc, link=end_link, area=end_area)\n    self.start_time = start_time\n    self.end_time = end_time\n    self.freq = freq\n    self._distance = distance\n    # relevant for simulated plans\n    self.attributes = attributes\n    if route is not None:\n        self.route = route\n    else:\n        self.route = Route()\n</code></pre>"},{"location":"api/activity/#pam.activity.Leg.act","title":"<code>act = 'travel'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.attributes","title":"<code>attributes = attributes</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.boarding_time","title":"<code>boarding_time</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.d_stop","title":"<code>d_stop</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.distance","title":"<code>distance</code>  <code>property</code>","text":"<p>Distance, assumed to be in m in either case</p>"},{"location":"api/activity/#pam.activity.Leg.end_location","title":"<code>end_location = Location(loc=end_loc, link=end_link, area=end_area)</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.end_time","title":"<code>end_time = end_time</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.euclidean_distance","title":"<code>euclidean_distance</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.freq","title":"<code>freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.mode","title":"<code>mode = mode</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.network_route","title":"<code>network_route</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.o_stop","title":"<code>o_stop</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.purp","title":"<code>purp = purp</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.route","title":"<code>route = route</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.route_id","title":"<code>route_id</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.seq","title":"<code>seq = seq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.service_id","title":"<code>service_id</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Leg.start_location","title":"<code>start_location = Location(loc=start_loc, link=start_link, area=start_area)</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Leg.start_time","title":"<code>start_time = start_time</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan","title":"<code>Plan(home_area = None, home_location: Optional[Location] = None, home_loc: Optional[Location] = None, freq: Optional[Location] = None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def __init__(\n    self,\n    home_area=None,\n    home_location: Optional[Location] = None,\n    home_loc=None,\n    freq=None\n    ):\n    self.day = []\n    if home_location:\n        self.home_location = home_location\n    else:\n        self.home_location = Location()\n    if home_area:\n        self.home_location.area = home_area\n    if home_loc:\n        self.home_location.loc = home_loc\n    self.logger = logging.getLogger(__name__)\n    self.plan_freq = freq\n    self.score = None\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.activities","title":"<code>activities</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.closed","title":"<code>closed</code>  <code>property</code>","text":"<p>Check if plan starts and stops at the same facility (based on activity and location) :return: Bool</p>"},{"location":"api/activity/#pam.activity.Plan.day","title":"<code>day = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.first","title":"<code>first</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.home","title":"<code>home</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.home_based","title":"<code>home_based</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.home_location","title":"<code>home_location = home_location</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.is_valid","title":"<code>is_valid</code>  <code>property</code>","text":"<p>Check for sequence, time and location structure and consistency. Note that this also checks that plan ends at END_OF_DAY. :return: bool</p>"},{"location":"api/activity/#pam.activity.Plan.last","title":"<code>last</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.legs","title":"<code>legs</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.length","title":"<code>length</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Plan.plan_freq","title":"<code>plan_freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.score","title":"<code>score = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Plan.valid_end_of_day_time","title":"<code>valid_end_of_day_time</code>  <code>property</code>","text":"<p>Check that start and end time of Activities and Legs are consistent. :return: bool</p>"},{"location":"api/activity/#pam.activity.Plan.valid_locations","title":"<code>valid_locations</code>  <code>property</code>","text":"<p>Check that locations are consistent across Activities and Legs. :return: bool</p>"},{"location":"api/activity/#pam.activity.Plan.valid_sequence","title":"<code>valid_sequence</code>  <code>property</code>","text":"<p>Check sequence of Activities and Legs. :return: bool</p>"},{"location":"api/activity/#pam.activity.Plan.valid_start_of_day_time","title":"<code>valid_start_of_day_time</code>  <code>property</code>","text":"<p>Check that start and end time of Activities and Legs are consistent. :return: bool</p>"},{"location":"api/activity/#pam.activity.Plan.valid_time_sequence","title":"<code>valid_time_sequence</code>  <code>property</code>","text":"<p>Check that start and end time of Activities and Legs are consistent. :return: bool</p>"},{"location":"api/activity/#pam.activity.Plan.activity_tours","title":"<code>activity_tours()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def activity_tours(self):\n    tours = []\n    tour = []\n    for act in self.activities:\n        if act.act == 'home':\n            if tour:\n                tours.append(tour)\n            tour = []\n        else:\n            tour.append(act)\n    if tour:\n        tours.append(tour)\n    return tours\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.add","title":"<code>add(p)</code>","text":"<p>Safely add a new component to the plan. :param p: :return:</p> Source code in <code>pam/activity.py</code> <pre><code>def add(self, p):\n\"\"\"\n    Safely add a new component to the plan.\n    :param p:\n    :return:\n    \"\"\"\n    if isinstance(p, list):\n        for c in p:\n            self.add(c)\n\n    elif isinstance(p, Activity):\n        if self.day and isinstance(self.day[-1], Activity):  # enforce act-leg-act seq\n            raise PAMSequenceValidationError(f\"Failed to add to plan, next component must be a Trip or Leg.\")\n        self.day.append(p)\n\n    elif isinstance(p, Leg) or isinstance(p, Trip):\n        if not self.day:\n            raise PAMSequenceValidationError(f\"Failed to add to plan, first component must be Activity instance.\")\n        if not isinstance(self.day[-1], Activity):  # enforce act-leg-act seq\n            raise PAMSequenceValidationError(f\"Failed to add to plan, next component must be Activity instance.\")\n        self.day.append(p)\n\n    else:\n        raise UserWarning(f\"Cannot add type: {type(p)} to plan.\")\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.autocomplete_matsim","title":"<code>autocomplete_matsim()</code>","text":"<p>complete leg start and end locations</p> Source code in <code>pam/activity.py</code> <pre><code>def autocomplete_matsim(self):\n\"\"\"\n    complete leg start and end locations\n    \"\"\"\n    for seq, component in enumerate(self):\n        if isinstance(component, Leg):\n            self.day[seq].start_location = self.day[seq-1].location\n            self.day[seq].end_location = self.day[seq+1].location\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.change_duration","title":"<code>change_duration(seq, shift_duration)</code>","text":"<p>Change the duration of a leg and shift subsequent activities/legs forward :params int seq: leg index in self.day :params timedelta shift_duration: the number of seconds to change the leg duration by:</p> <p>:return: None</p> Source code in <code>pam/activity.py</code> <pre><code>def change_duration(self, seq, shift_duration):\n\"\"\"\n    Change the duration of a leg and shift subsequent activities/legs forward\n    :params int seq: leg index in self.day\n    :params timedelta shift_duration: the number of seconds to change the leg duration by:\n\n    :return: None\n    \"\"\"\n\n    #change leg duration\n    self.day[seq].end_time = self.day[seq].end_time + shift_duration\n\n    #shift all subsequent legs and activities\n    for idx in range(seq+1, len(self.day)):\n        start_time = self.day[idx].start_time\n        self.day[idx].shift_start_time(start_time + shift_duration)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.clear","title":"<code>clear()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def clear(self):\n    self.day = []\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.closed_duration","title":"<code>closed_duration(idx)</code>","text":"<p>Check duration of plan component at idx, if closed plan, combine first and last durations</p> Source code in <code>pam/activity.py</code> <pre><code>def closed_duration(self, idx):\n\"\"\"\n    Check duration of plan component at idx, if closed plan, combine first and last durations\n    \"\"\"\n    if self.closed and (idx == 0 or idx == self.length - 1):\n        return self.day[0].duration + self.day[-1].duration\n    return self.day[idx].duration\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.combine_matching_activities","title":"<code>combine_matching_activities(idx_start, idx_end)</code>","text":"<p>Combine two given activities into same activity, remove surplus Legs :param idx_start: :param idx_end: :return:</p> Source code in <code>pam/activity.py</code> <pre><code>def combine_matching_activities(self, idx_start, idx_end):\n\"\"\"\n    Combine two given activities into same activity, remove surplus Legs\n    :param idx_start:\n    :param idx_end:\n    :return:\n    \"\"\"\n    self.day[idx_start].end_time = self.day[idx_end].end_time  # extend proceeding act\n    self.day.pop(idx_end)  # remove subsequent activity\n    self.day.pop(idx_end - 1)  # remove subsequent leg\n    self.day.pop(idx_start + 1)  # remove proceeding leg\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.combine_wrapped_activities","title":"<code>combine_wrapped_activities(idx_start, idx_end)</code>","text":"<p>Combine two given activities that will wrap around day, remove surplus Legs :param idx_start: :param idx_end: :return:</p> Source code in <code>pam/activity.py</code> <pre><code>def combine_wrapped_activities(self, idx_start, idx_end):\n\"\"\"\n    Combine two given activities that will wrap around day, remove surplus Legs\n    :param idx_start:\n    :param idx_end:\n    :return:\n    \"\"\"\n    # extend proceeding act to end of day\n    self.day[idx_start].end_time = pam.variables.END_OF_DAY\n    # extend subsequent act to start of day\n    self.day[idx_end].start_time = pam.utils.minutes_to_datetime(0)\n    self.day.pop(idx_start + 1)  # remove proceeding leg\n    self.day.pop(idx_end - 1)  # remove subsequent leg\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.crop","title":"<code>crop()</code>","text":"<p>Crop a plan to end of day (END_OF_DAY). Plan components that start after this time are removed. Activities that end after this time are trimmed. If the last component is a Leg, this leg is removed and the previous activity extended.</p> Source code in <code>pam/activity.py</code> <pre><code>def crop(self):\n\"\"\"\n    Crop a plan to end of day (END_OF_DAY). Plan components that start after this\n    time are removed. Activities that end after this time are trimmed. If the last component\n    is a Leg, this leg is removed and the previous activity extended.\n    \"\"\"\n    # crop plan beyond end of day\n    for idx, component in list(self.reversed()):\n        if component.start_time &gt; pam.variables.END_OF_DAY:\n            self.logger.debug(f\"Cropping plan components\")\n            self.day = self.day[:idx]\n            break\n\n    # crop plan that is out of sequence\n    for idx in range(1, self.length):\n        if self[idx].start_time &lt; self[idx-1].end_time:\n            self.logger.debug(f\"Cropping plan components\")\n            self.day = self.day[:idx]\n            break\n        if self[idx].start_time &gt; self[idx].end_time:\n            self.logger.debug(f\"Cropping plan components\")\n            self.day = self.day[:idx+1]\n            break\n\n    # deal with last component\n    if isinstance(self.day[-1], Activity):\n        self.day[-1].end_time = pam.variables.END_OF_DAY\n    else:\n        self.logger.debug(f\"Cropping plan ending in Leg\")\n        self.day.pop(-1)\n        self.day[-1].end_time = pam.variables.END_OF_DAY\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.expand","title":"<code>expand(pivot_idx)</code>","text":"<p>Fill plan by expanding a pivot activity. :param pivot_idx: int :return: None</p> Source code in <code>pam/activity.py</code> <pre><code>def expand(self, pivot_idx):\n\"\"\"\n    Fill plan by expanding a pivot activity.\n    :param pivot_idx: int\n    :return: None\n    \"\"\"\n    # todo this isn't great - just pushes other activities to edges of day\n\n    new_time = pam.utils.minutes_to_datetime(0)\n    for seq in range(pivot_idx+1):  # push forward pivot and all proceeding components\n        new_time = self.day[seq].shift_start_time(new_time)\n\n    new_time = pam.variables.END_OF_DAY\n    for seq in range(self.length-1, pivot_idx, -1):  # push back all subsequent components\n        new_time = self.day[seq].shift_end_time(new_time)\n\n    self.day[pivot_idx].end_time = new_time  # expand pivot\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.fill_plan","title":"<code>fill_plan(idx_start, idx_end, default = 'home')</code>","text":"<p>Fill a plan after Activity has been removed. Plan is filled between given remaining activity locations (idx_start and idx_end). Note that the plan will also have legs that need to be removed. :param idx_start: location of previous Activity :param idx_end: location of subsequent Activity :param default: Not Used :return: True</p> Source code in <code>pam/activity.py</code> <pre><code>def fill_plan(self, idx_start, idx_end, default='home'):\n\"\"\"\n    Fill a plan after Activity has been removed. Plan is filled between given remaining\n    activity locations (idx_start and idx_end). Note that the plan will also have legs that\n    need to be removed.\n    :param idx_start: location of previous Activity\n    :param idx_end: location of subsequent Activity\n    :param default: Not Used\n    :return: True\n    \"\"\"\n    self.logger.debug(f\" fill_plan, {idx_start}-&gt;{idx_end}\")\n\n    if idx_start is None and idx_end is None:  # Assume stay at home\n        self.stay_at_home()\n        return True\n\n    if idx_start is None:  # start of day non wrapping\n        self.day.pop(0)\n        self.expand(idx_end - 1)  # shifted because we popped index 0\n        return True\n\n    if idx_end is None:  # end of day non wrapping\n        self.day.pop(-1)\n        self.expand(idx_start)\n        return True\n\n    if idx_start == idx_end:  # this is a single remaining activity -&gt; stay at home\n\n        if self.position_of(target='home') is None:\n            raise ValueError(\n                \"Require home activity\"\n            )\n        self.stay_at_home()\n        return True\n\n    if self.day[idx_start] == self.day[idx_end]:  # combine activities\n\"\"\"\n        These activities are the same (based on type and location), so can be combined,\n        but there are 2 sub cases:\n        i) idx_start &lt; idx_end -&gt; wrapped combine\n        ii) else -&gt; regular combine can ignore wrapping\n        \"\"\"\n\n        if idx_end &lt; idx_start:  # this is a wrapped activity --&gt; close it\n            # todo probably don't need to pass the idx - know that it must be first and last\n            self.combine_wrapped_activities(idx_start, idx_end)\n            return True\n\n        # this is a regular non wrapped mid plan activity -&gt; combine acts\n        self.combine_matching_activities(idx_start, idx_end)\n        return True\n\n\"\"\"\n    Remaining are plans where the activities are different so fill not be combined, instread\n    we will use 'expand' to refill the plan. There are 2 sub cases:\n    i) idx_start &lt; idx_end -&gt; wrapped combine\n    ii) else -&gt; regular combine can ignore wrapping\n    \"\"\"\n\n    if idx_end &lt; idx_start:  # this is a wrapped activity --&gt; close it\n        self.day.pop(0)  # remove start leg\n        self.day.pop(-1)  # remove end leg\n\n        pivot_idx = self.position_of(target='home')\n        if pivot_idx is None:\n            self.logger.warning(f\"Unable to find home activity, changing plan to stay at home\")\n            self.stay_at_home()\n            return True\n\n        self.expand(pivot_idx)\n        return True\n\n    # need to change first leg for new destination\n    self.join_activities(idx_start, idx_end)\n    return True\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.finalise_activity_end_times","title":"<code>finalise_activity_end_times()</code>","text":"<p>Add activity end times based on start time of next activity.</p> Source code in <code>pam/activity.py</code> <pre><code>def finalise_activity_end_times(self):\n\"\"\"\n    Add activity end times based on start time of next activity.\n    \"\"\"\n    if len(self.day) &gt; 1:\n        for seq in range(0, len(self.day)-1, 2):  # activities excluding last one\n            self.day[seq].end_time = self.day[seq+1].start_time\n    self.day[-1].end_time = pam.variables.END_OF_DAY\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.fix","title":"<code>fix(crop = True, times = True, locations = True)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def fix(self, crop=True, times=True, locations=True):\n    if crop:\n        self.crop()\n    if times:\n        self.fix_time_consistency()\n    if locations:\n        self.fix_location_consistency()\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.fix_location_consistency","title":"<code>fix_location_consistency()</code>","text":"<p>Force plan locations consistency by adjusting leg locations.</p> Source code in <code>pam/activity.py</code> <pre><code>def fix_location_consistency(self):\n\"\"\"\n    Force plan locations consistency by adjusting leg locations.\n    \"\"\"\n    for i in range(1, self.length-1):\n        component = self.day[i]\n\n        if isinstance(component, Leg):\n            component.start_location = copy(self.day[i-1].location)\n            component.end_location = copy(self.day[i+1].location)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.fix_time_consistency","title":"<code>fix_time_consistency()</code>","text":"<p>Force plan component time consistency.</p> Source code in <code>pam/activity.py</code> <pre><code>def fix_time_consistency(self):\n\"\"\"\n    Force plan component time consistency.\n    \"\"\"\n    for i in range(self.length - 1):\n        self.day[i+1].start_time = self.day[i].end_time\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.get","title":"<code>get(idx, default = None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def get(self, idx, default=None):\n    if -self.length &lt;= idx &lt; self.length:\n        return self.day[idx]\n    return default\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.get_home_duration","title":"<code>get_home_duration()</code>","text":"<p>Get the total duration of home activities.</p> Source code in <code>pam/activity.py</code> <pre><code>def get_home_duration(self):\n\"\"\"\n    Get the total duration of home activities.\n    \"\"\"\n    #total time spent at home\n    home_duration = timedelta(0)\n    for plan in self.day:\n        if plan.act=='home':\n            home_duration+=plan.duration\n\n    return home_duration\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.get_leg_tour","title":"<code>get_leg_tour(seq)</code>","text":"<p>Get the tour of a leg :params int seq: plan sequence. Must be a leg sequence.</p> <p>:return: a list of activities in a tour</p> Source code in <code>pam/activity.py</code> <pre><code>def get_leg_tour(self, seq):\n\"\"\"\n    Get the tour of a leg\n    :params int seq: plan sequence. Must be a leg sequence.\n\n    :return: a list of activities in a tour\n    \"\"\"\n    assert isinstance(self.day[seq], Leg)\n\n    act_from = self.day[seq-1]\n    act_to = self.day[seq+1]\n\n    for tour in self.activity_tours():\n        for tour_act in tour:\n            if act_from.is_exact(tour_act) or act_to.is_exact(tour_act):\n                return tour\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.infer_activities_from_tour_purpose","title":"<code>infer_activities_from_tour_purpose()</code>","text":"<p>Infer and set activity types based on trip purpose. Algorithm works like breadth first search, initiated from inferred home locations. Search takes place in two stages, first pass forward, the backward. The next activity type is set based on the trip purpose. Pass forward is exhausted first, because it's assumed that this is how the diary is originally filled in.</p> Source code in <code>pam/activity.py</code> <pre><code>def infer_activities_from_tour_purpose(self):\n\"\"\"\n    Infer and set activity types based on trip purpose. Algorithm works like breadth first search,\n    initiated from inferred home locations. Search takes place in two stages, first pass forward,\n    the backward. The next activity type is set based on the trip purpose. Pass forward is exhausted\n    first, because it's assumed that this is how the diary is originally filled in.\n    \"\"\"\n    #find home activities\n    home_idxs = self.infer_activity_idxs(target=self.home)\n    for idx in home_idxs:\n        self.day[idx].act = 'home'\n\n    area_map = {}\n    remaining = set(range(0, self.length, 2)) - set(home_idxs)\n\n    # forward traverse\n    queue = [idx+2 for idx in home_idxs if idx+2 &lt; self.length]  # add next act idxs to queue\\\n    last_act = None\n\n    while queue:  # traverse from home\n        idx = queue.pop()\n\n        if self.day[idx].act is None:\n            act = self.day[idx-1].purp.lower()\n            location = str(self.day[idx].location.min)\n\n            if act == last_act and location in area_map:\n                act = area_map[location]\n\n            self.day[idx].act = act\n            remaining -= {idx}\n            last_act = act\n            area_map[location] = act\n\n            if idx+2 in remaining:\n                queue.append(idx+2)\n\n    queue = []\n    for location, activity in area_map.items():\n        candidates = self.infer_activity_idxs(target=Location(area=location), default=False)\n        for idx in candidates:\n            if idx in remaining:\n                self.day[idx].act = activity\n                remaining -= {idx}\n                if idx+2 in remaining:\n                    queue.append(idx+2)\n\n    while queue:\n        idx = queue.pop()\n\n        if self.day[idx].act is None:\n            act = self.day[idx-1].purp.lower()\n            location = self.day[idx].location.min\n\n            if act == last_act and location in area_map:\n                act = area_map[location]\n\n            self.day[idx].act = act\n            remaining -= {idx}\n            last_act = act\n            area_map[location] = act\n\n            if idx+2 &lt; self.length:\n                queue.append(idx+2)\n\n    # backward traverse\n    queue = list(remaining)  # add next act idxs to queue\n\n    while queue:  # traverse from home\n        idx = queue.pop()\n\n        if self.day[idx].act is None:\n            act = self.day[idx+1].purp.lower()\n            location = self.day[idx].location.min\n\n            if act == last_act and location in area_map:\n                act = area_map[location]\n\n            self.day[idx].act = act\n            remaining -= {idx}\n            last_act = act\n            area_map[location] = act\n\n            if idx-2 &gt;= 0:\n                queue.append(idx-2)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.infer_activity_idxs","title":"<code>infer_activity_idxs(target, default = True)</code>","text":"<p>Infer idxs of home activity based on location. First pass looks to exclude other acts at home location, second pass looks adds home idxs. If a leg is found to start and end at the home location then the one with maximum duration is included.</p> Source code in <code>pam/activity.py</code> <pre><code>def infer_activity_idxs(self, target, default=True):\n\"\"\"\n    Infer idxs of home activity based on location. First pass looks to exclude other acts at home\n    location, second pass looks adds home idxs.\n    If a leg is found to start and end at the home location then the one with maximum duration\n    is included.\n    \"\"\"\n    # todo untested for more than three possible home activities in a row.\n    candidates = set()\n    exclude = set()\n\n    for idx, leg in enumerate(self.legs):\n        prev_act_idx = 2 * idx\n        next_act_idx = prev_act_idx + 2\n        if leg.start_location == leg.end_location == target:  # check for larger duration\n            if self.closed_duration(prev_act_idx) &gt; self.closed_duration(next_act_idx):\n                exclude.add(next_act_idx)\n            else:\n                exclude.add(prev_act_idx)\n\n    for idx, act in enumerate(self.activities):\n        if act.location == target and (idx*2) not in exclude:\n            candidates.add(idx*2)\n\n    if default and not candidates:  # assume first activity (and last if closed)\n        if self.closed:\n            return set([0, self.length-1])\n        return set([0])\n\n    return candidates\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.join_activities","title":"<code>join_activities(idx_start, idx_end)</code>","text":"<p>Join together two Activities with new Leg, expand last home activity. :param idx_start: :param idx_end: :return:</p> Source code in <code>pam/activity.py</code> <pre><code>def join_activities(self, idx_start, idx_end):\n\"\"\"\n    Join together two Activities with new Leg, expand last home activity.\n    :param idx_start:\n    :param idx_end:\n    :return:\n    \"\"\"\n    self.day[idx_start + 1].end_location = self.day[idx_end - 1].end_location\n    self.day[idx_start + 1].purp= self.day[idx_end - 1].purp\n    self.day.pop(idx_end - 1)  # remove second leg\n\n    # todo add logic to change mode and time of leg\n\n    # press plans away from pivoting activity\n    pivot_idx = self.position_of(target='home')\n    if pivot_idx is None:\n        self.logger.warning(f\"Unable to find home activity, changing plan to stay at home\")\n        self.stay_at_home()\n        return None\n\n    self.expand(pivot_idx)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.mode_shift","title":"<code>mode_shift(seq, new_mode = 'walk', mode_speed = {'car': 37, 'bus': 10, 'walk': 4, 'cycle': 14, 'pt': 23, 'rail': 37}, update_duration = False)</code>","text":"<p>Changes mode for a leg, along with any legs in the same tour. Leg durations are adjusted to mode speed, and home activity durations revisited to fit within the 24-hr plan. Default speed values are from National Travel Survey data (NTS0303)</p> <p>:params int seq: leg index in self.day :params string new_mode: default mode shift :params dict mode_speed: a dictionary of average mode speeds (kph) :params bool update_duration: whether to update leg durations based on mode speed</p> <p>:return: None</p> Source code in <code>pam/activity.py</code> <pre><code>def mode_shift(self, seq, new_mode='walk', mode_speed = {'car':37, 'bus':10, 'walk':4, 'cycle': 14, 'pt':23, 'rail':37}, update_duration = False):\n\"\"\"\n    Changes mode for a leg, along with any legs in the same tour.\n    Leg durations are adjusted to mode speed, and home activity durations revisited to fit within the 24-hr plan.\n    Default speed values are from National Travel Survey data (NTS0303)\n\n    :params int seq: leg index in self.day\n    :params string new_mode: default mode shift\n    :params dict mode_speed: a dictionary of average mode speeds (kph)\n    :params bool update_duration: whether to update leg durations based on mode speed\n\n    :return: None\n    \"\"\"\n    assert isinstance(self.day[seq], Leg)\n\n    tour = self.get_leg_tour(seq)\n    for seq, plan in enumerate(self.day):\n        if isinstance(plan, Leg):\n            act_from = self.day[seq-1]\n            act_to = self.day[seq+1]\n            for other_act in tour:\n                #if any of the trip ends belongs in the tour change the mode\n                if act_from.is_exact(other_act) or act_to.is_exact(other_act):\n                    if update_duration:\n                        shift_duration = ((mode_speed[plan.mode] / mode_speed[new_mode]) * plan.duration) - plan.duration #calculate any trip duration changes due to mode shift\n                    plan.mode = new_mode #change mode\n                    if update_duration:\n                        self.change_duration(seq=seq, shift_duration=shift_duration) #change the duration of the trip\n\n    if update_duration:\n        #adjust home activities time in order fit revised legs/activities within a 24hr day\n        home_duration = self.get_home_duration()\n        home_duration_factor = (self.day[-1].end_time - END_OF_DAY)/home_duration #factor to adjust home activity time by\n\n        for seq, plan in enumerate(self.day):\n            if plan.act=='home':\n                shift_duration = -home_duration_factor*plan.duration\n                shift_duration = timedelta(seconds=round(shift_duration/timedelta(seconds=1))) #round to second\n                self.change_duration(seq=seq,shift_duration=shift_duration)\n\n        #make sure the last activity ends in the end of day (ie remove potential rounding errors)\n        if self.day[-1].end_time != END_OF_DAY:\n            self.day[-1].end_time = END_OF_DAY\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.move_activity","title":"<code>move_activity(seq, default = 'home', new_mode = 'walk')</code>","text":"<p>Changes Activity location and associated journeys :param seq:         :param default: 'home' or pam.activity.Location         :param new_mode: access/egress journey switching to this mode. Ie 'walk' :return: None</p> Source code in <code>pam/activity.py</code> <pre><code>    def move_activity(self, seq, default='home', new_mode='walk'):\n\"\"\"\n        Changes Activity location and associated journeys\n        :param seq:\n\t\t:param default: 'home' or pam.activity.Location\n\t\t:param new_mode: access/egress journey switching to this mode. Ie 'walk'\n        :return: None\n        \"\"\"\n        assert isinstance(self.day[seq], Activity)\n\n        # decide on the new location\n        if default == 'home':\n            new_location = self.home\n        else:\n            assert isinstance(default, Location)\n            new_location = default\n\n        # actually update the location\n        self.day[seq].location = new_location\n        if seq != 0:\n            # if it's not the first activity of plan\n            # update leg that leads to activity at seq\n            self.day[seq - 1].end_location = new_location\n            self.mode_shift(seq - 1, new_mode)\n        if seq != len(self.day) - 1:\n            # if it's not the last activity of plan\n            # update leg that leads to activity at seq\n            self.day[seq + 1].start_location = new_location\n            self.mode_shift(seq + 1, new_mode)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.plot","title":"<code>plot(kwargs = None)</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def plot(self, kwargs=None):\n    plot.plot_plan(self, kwargs)\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.position_of","title":"<code>position_of(target = 'home', search = 'last')</code>","text":"<p>Return position of target activity type (either first or last depending on search). Return None if not found. :param target: str :param search: str {'first', 'last'} :return: {int, None}</p> Source code in <code>pam/activity.py</code> <pre><code>def position_of(self, target='home', search='last'):\n\"\"\"\n    Return position of target activity type (either first or last depending on search).\n    Return None if not found.\n    :param target: str\n    :param search: str {'first', 'last'}\n    :return: {int, None}\n    \"\"\"\n\n    if search == 'last':\n        last = None\n        for seq, act in enumerate(self.day):\n            if act.act.lower() == target:\n                last = seq\n        return last\n\n    if search == 'first':\n        for seq, act in enumerate(self.day):\n            if act.act.lower() == target:\n                return seq\n\n    raise UserWarning(\"Method only supports search types 'first' or 'last'.\")\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.print","title":"<code>print()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def print(self):\n    for seq, component in enumerate(self):\n        print(f\"{seq}:\\t{component}\")\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.remove_activity","title":"<code>remove_activity(seq)</code>","text":"<p>Remove an activity from plan at given seq. Does not remove adjacent legs Will also check if an activity is wrapped and remove accordingly. Returns (adjusted) idx of previous (p_idx) and subsequent (s_idx) activities as a tuple. If there is no previous or subsequent activity, ie a removed activity is at the start or end of an open plan, then None can be returned. If all activities are removed then None, None is returned. :param seq: int :return: tuple</p> Source code in <code>pam/activity.py</code> <pre><code>def remove_activity(self, seq):\n\"\"\"\n    Remove an activity from plan at given seq. Does not remove adjacent legs\n    Will also check if an activity is wrapped and remove accordingly. Returns (adjusted) idx\n    of previous (p_idx) and subsequent (s_idx) activities as a tuple. If there is no previous\n    or subsequent activity, ie a removed activity is at the start or end of an open plan,\n    then None can be returned. If all activities are removed then None, None is returned.\n    :param seq: int\n    :return: tuple\n    \"\"\"\n    assert isinstance(self.day[seq], Activity)\n\n    if seq == 0 and seq == self.length - 1:  # remove activity that is entire plan\n        self.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}, plan now empty\")\n        self.day.pop(0)\n        return None, None\n\n    if (seq == 0 or seq == self.length - 1) and self.closed:  # remove activity that wraps\n        self.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}, wraps\")\n        self.day.pop(0)\n        self.day.pop(self.length - 1)\n        if self.length == 1:  # all activities have been removed\n            self.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}, now empty\")\n            return None, None\n        return self.length-2, 1\n\n    if seq == 0:  # remove first activity\n        self.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}, first activity\")\n        self.day.pop(seq)\n        return None, 1\n\n    if seq == self.length - 1:  # remove last activity\n        self.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}, last activity\")\n        self.day.pop(seq)\n        return self.length-2, None\n\n    else:  # remove activity somewhere in middle of plan\n        self.logger.debug(f\" remove_activity, idx:{seq} type:{self.day[seq].act}\")\n        self.day.pop(seq)\n        return seq-2, seq+1\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.reversed","title":"<code>reversed()</code>","text":"<p>Reverse iterate through plan, yield idx and component.</p> Source code in <code>pam/activity.py</code> <pre><code>def reversed(self):\n\"\"\"\n    Reverse iterate through plan, yield idx and component.\n    \"\"\"\n    for i in range(self.length-1, -1, -1):\n        yield i, self[i]\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.set_leg_purposes","title":"<code>set_leg_purposes()</code>","text":"<p>Set leg purposes to destination activity. Skip 'pt interaction' activities.</p> Source code in <code>pam/activity.py</code> <pre><code>def set_leg_purposes(self):\n\"\"\"\n    Set leg purposes to destination activity.\n    Skip 'pt interaction' activities.\n    \"\"\"\n    for seq, component in enumerate(self):\n        if isinstance(component, Leg):\n            for j in range(seq+1, len(self.day)-1, 2):\n                act = self.day[j].act\n                if not act == \"pt interaction\":\n                    self.day[seq].purp = act\n                    break\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.simplify_pt_trips","title":"<code>simplify_pt_trips()</code>","text":"<p>Remove pt interaction events (resulting from complex matsim plans), simplify legs to single leg with mode = pt</p> Source code in <code>pam/activity.py</code> <pre><code>def simplify_pt_trips(self):\n\"\"\"\n    Remove pt interaction events (resulting from complex matsim plans), simplify legs\n    to single leg with mode = pt\n    \"\"\"\n    pt_trip = False\n    for idx, component in list(self.reversed()):\n        if component.act == \"pt interaction\":  # this is a pt trip\n            if not pt_trip:  # this is a new pt leg\n                trip_end_time = self[idx+1].end_time\n                trip_end_location = self[idx+1].end_location\n\n            pt_trip = True\n            self.day.pop(idx+1)\n            self.day.pop(idx)\n        else:\n            if pt_trip:  # this is the start of the pt trip - modify the first leg\n                self[idx].mode = 'pt'\n                self[idx].end_time = trip_end_time\n                self[idx].end_location = trip_end_location\n            pt_trip = False\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.stay_at_home","title":"<code>stay_at_home()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def stay_at_home(self):\n    self.logger.debug(f\" stay_at_home, location:{self.home}\")\n    self.day = [\n        Activity(\n            seq=1,\n            act='home',\n            area=self.home.area,\n            start_time=pam.utils.minutes_to_datetime(0),\n            end_time=pam.variables.END_OF_DAY,\n        )\n    ]\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.trip_legs","title":"<code>trip_legs(ignore = ['pt interaction', 'pt_interaction']) -&gt; str</code>","text":"<p>Yield plan trips as lists of legs based on ignoring certain activities.</p> Source code in <code>pam/activity.py</code> <pre><code>def trip_legs(self, ignore=[\"pt interaction\", \"pt_interaction\"]) -&gt; str:\n\"\"\"\n    Yield plan trips as lists of legs based on ignoring certain activities.\n    \"\"\"\n    if self.day:\n        legs = []\n        for component in self[1:]:\n            if isinstance(component, Leg):\n                legs.append(component)\n            elif component.act not in ignore:\n                yield legs\n                legs = []\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.trips","title":"<code>trips(ignore = ['pt interaction', 'pt_interaction']) -&gt; str</code>","text":"<p>Yield plan trips based on ignoring certain activities.</p> Source code in <code>pam/activity.py</code> <pre><code>def trips(self, ignore=[\"pt interaction\", \"pt_interaction\"]) -&gt; str:\n\"\"\"\n    Yield plan trips based on ignoring certain activities.\n    \"\"\"\n    if self.day:\n        seq = 0\n        modes = {}\n        start_location = self.day[0].location\n        start_time = self.day[0].end_time\n        distance = 0\n        for component in self[1:]:\n            if isinstance(component, Leg):\n                modes[component.mode] = modes.get(component.mode, 0) + component.distance\n                distance += component.distance\n            elif component.act not in ignore:\n                yield Trip(\n                    seq = seq,\n                    mode = max(modes, key=modes.get),\n                    start_area = start_location.area,\n                    end_area = component.location.area,\n                    start_link = start_location.link,\n                    end_link = component.location.link,\n                    start_loc = start_location.loc,\n                    end_loc = component.location.loc,\n                    start_time = start_time,\n                    end_time = component.start_time,\n                    distance = distance,\n                    purp = component.act,\n                )\n                modes = {}\n                start_location = component.location\n                start_time = component.end_time\n                distance = 0\n                seq += 1\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.validate","title":"<code>validate()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate(self):\n    self.validate_sequence()\n    self.validate_times()\n    self.validate_locations()\n    return True\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.validate_locations","title":"<code>validate_locations()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate_locations(self):\n    if not self.valid_locations:\n        raise PAMValidationLocationsError()\n    return True\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.validate_sequence","title":"<code>validate_sequence()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate_sequence(self):\n    if not self.valid_sequence:\n        raise PAMSequenceValidationError()\n    return True\n</code></pre>"},{"location":"api/activity/#pam.activity.Plan.validate_times","title":"<code>validate_times()</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def validate_times(self):\n    if not self.valid_time_sequence:\n        raise PAMInvalidTimeSequenceError(\"Plan activity and trips times are not consistent\")\n    return True\n</code></pre>"},{"location":"api/activity/#pam.activity.PlanComponent","title":"<code>PlanComponent</code>","text":""},{"location":"api/activity/#pam.activity.PlanComponent.duration","title":"<code>duration</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.PlanComponent.hours","title":"<code>hours</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.PlanComponent.shift_duration","title":"<code>shift_duration(new_duration, new_start_time = None)</code>","text":"<p>Given a new duration and optionally start time, set start time, set end time based on duration and return new end time. :param new_duration: timedelta :param new_start_time: datetime :return: datetime</p> Source code in <code>pam/activity.py</code> <pre><code>def shift_duration(self, new_duration, new_start_time=None):\n\"\"\"\n    Given a new duration and optionally start time, set start time, set end time based on duration and\n    return new end time.\n    :param new_duration: timedelta\n    :param new_start_time: datetime\n    :return: datetime\n    \"\"\"\n    if new_start_time is not None:\n        self.start_time = new_start_time\n    self.end_time = self.start_time + new_duration\n    return self.end_time\n</code></pre>"},{"location":"api/activity/#pam.activity.PlanComponent.shift_end_time","title":"<code>shift_end_time(new_end_time)</code>","text":"<p>Given a new end time, set end time, set start time based on previous duration and return new start time. :param new_end_time: datetime :return: datetime</p> Source code in <code>pam/activity.py</code> <pre><code>def shift_end_time(self, new_end_time):\n\"\"\"\n    Given a new end time, set end time, set start time based on previous duration and\n    return new start time.\n    :param new_end_time: datetime\n    :return: datetime\n    \"\"\"\n    duration = self.duration\n    self.end_time = new_end_time\n    self.start_time = new_end_time - duration\n    return self.start_time\n</code></pre>"},{"location":"api/activity/#pam.activity.PlanComponent.shift_start_time","title":"<code>shift_start_time(new_start_time)</code>","text":"<p>Given a new start time, set start time, set end time based on previous duration and return new end time. :param new_start_time: datetime :return: datetime</p> Source code in <code>pam/activity.py</code> <pre><code>def shift_start_time(self, new_start_time):\n\"\"\"\n    Given a new start time, set start time, set end time based on previous duration and\n    return new end time.\n    :param new_start_time: datetime\n    :return: datetime\n    \"\"\"\n    duration = self.duration\n    self.start_time = new_start_time\n    self.end_time = new_start_time + duration\n    return self.end_time\n</code></pre>"},{"location":"api/activity/#pam.activity.Route","title":"<code>Route(xml_elem = None) -&gt; None</code>","text":"<p>xml element wrapper for leg routes, in the simplest case of a leg with no route, this will behave as an empty dictionary. For routed legs this provides some convenience properties such as is_transit, and transit_route.</p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(self, xml_elem=None) -&gt; None:\n    if xml_elem:\n        self.xml = xml_elem[0]\n    else:\n        self.xml = {}  # this allows an empty route to behave as an empty dict\n</code></pre>"},{"location":"api/activity/#pam.activity.Route.distance","title":"<code>distance: float</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.exists","title":"<code>exists: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.is_routed","title":"<code>is_routed: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.is_teleported","title":"<code>is_teleported: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.is_transit","title":"<code>is_transit: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.network_route","title":"<code>network_route: list</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.transit","title":"<code>transit: dict</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.type","title":"<code>type</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Route.xml","title":"<code>xml = xml_elem[0]</code>  <code>instance-attribute</code>","text":""},{"location":"api/activity/#pam.activity.Route.get","title":"<code>get(key, default = None) -&gt; str</code>","text":"Source code in <code>pam/activity.py</code> <pre><code>def get(self, key, default=None) -&gt; str:\n    return self.xml.get(key, default)\n</code></pre>"},{"location":"api/activity/#pam.activity.RouteV11","title":"<code>RouteV11(xml_elem) -&gt; None</code>","text":"<p>         Bases: <code>Route</code></p> Source code in <code>pam/activity.py</code> <pre><code>def __init__(self, xml_elem) -&gt; None:\n    super().__init__(xml_elem)\n</code></pre>"},{"location":"api/activity/#pam.activity.RouteV11.is_transit","title":"<code>is_transit: bool</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.RouteV11.transit","title":"<code>transit: dict</code>  <code>property</code>","text":""},{"location":"api/activity/#pam.activity.Trip","title":"<code>Trip</code>","text":"<p>         Bases: <code>Leg</code></p>"},{"location":"api/core/","title":"pam.core","text":""},{"location":"api/core/#pam.core.Household","title":"<code>Household(hid, attributes = {}, freq = None, location: Optional[Location] = None, area: Optional[Location] = None, loc: Optional[Location] = None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def __init__(\n    self,\n    hid,\n    attributes={},\n    freq=None,\n    location: Optional[Location] = None,\n    area=None,\n    loc=None,\n):\n    self.hid = hid\n    self.people = {}\n    self.attributes = attributes\n    self.hh_freq = freq\n    if location:\n        self._location = location\n    else:\n        self._location = Location()\n    if area:  # potential overwrite\n        self._location.area = area\n    if loc:  # potential overwrite\n        self._location.loc = loc\n</code></pre>"},{"location":"api/core/#pam.core.Household.activities","title":"<code>activities</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.attributes","title":"<code>attributes = attributes</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.av_person_freq","title":"<code>av_person_freq</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.freq","title":"<code>freq</code>  <code>property</code>","text":"<p>Return hh_freq, else if None, return the average frequency of household members. TODO: note this assumes we are basing hh freq on person freq. TODO: replace this with something better.</p>"},{"location":"api/core/#pam.core.Household.hh_freq","title":"<code>hh_freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.hid","title":"<code>hid = hid</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.legs","title":"<code>legs</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.location","title":"<code>location</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.people","title":"<code>people = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Household.subpopulation","title":"<code>subpopulation</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Household.add","title":"<code>add(person)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def add(self, person):\n    if isinstance(person, list):\n        for p in person:\n            self.add(p)\n    elif isinstance(person, Person):\n        self.people[person.pid] = person\n    else:\n        raise UserWarning(f\"Expected instance of Person, not: {type(person)}\")\n</code></pre>"},{"location":"api/core/#pam.core.Household.build_travel_geodataframe","title":"<code>build_travel_geodataframe(**kwargs) -&gt; gpd.GeoDataFrame</code>","text":"<p>Builds geopandas.GeoDataFrame for travel Legs found for agents within a Household</p> <p>Keyword arguments for pam.plot.plans.build_person_travel_geodataframe</p> Name Type Description <code>from_epsg</code> <code>str</code> <p>coordinate system the plans are currently in</p> <code>to_epsg</code> <code>str</code> <p>coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid)</p> Source code in <code>pam/core.py</code> <pre><code>def build_travel_geodataframe(self, **kwargs) -&gt; gpd.GeoDataFrame:\n\"\"\"\n    Builds geopandas.GeoDataFrame for travel Legs found for agents within a Household\n    Keyword Args: Keyword arguments for pam.plot.plans.build_person_travel_geodataframe\n        from_epsg (str): coordinate system the plans are currently in\n        to_epsg (str): coordinate system you want the geo dataframe to be projected to, optional, you need to specify\n            from_epsg as well to use this.\n    Returns:\n        geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid)\n    \"\"\"\n    gdf = None\n    for _, person in self:\n        _gdf = person.build_travel_geodataframe(**kwargs)\n        _gdf[\"hid\"] = self.hid\n        if gdf is None:\n            gdf = _gdf\n        else:\n            gdf = gdf.append(_gdf)\n    gdf = gdf.sort_values([\"pid\", \"seq\"]).reset_index(drop=True)\n    return gdf\n</code></pre>"},{"location":"api/core/#pam.core.Household.fix_plans","title":"<code>fix_plans(crop = True, times = True, locations = True)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def fix_plans(self, crop=True, times=True, locations=True):\n    for _, person in self:\n        if crop:\n            person.plan.crop()\n        if times:\n            person.plan.fix_time_consistency()\n        if locations:\n            person.plan.fix_location_consistency()\n</code></pre>"},{"location":"api/core/#pam.core.Household.get","title":"<code>get(pid, default = None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def get(self, pid, default=None):\n    return self.people.get(pid, default)\n</code></pre>"},{"location":"api/core/#pam.core.Household.get_attribute","title":"<code>get_attribute(key) -&gt; set</code>","text":"<p>Get set of attribute values for given key, First searches hh attributes then occupants.</p> Source code in <code>pam/core.py</code> <pre><code>def get_attribute(self, key) -&gt; set:\n\"\"\"\n    Get set of attribute values for given key, First searches hh attributes then occupants.\n    \"\"\"\n    if key in self.attributes:\n        return {self.attributes[key]}\n    attributes = set()\n    for _, person in self:\n        attributes.add(person.attributes.get(key))\n    return attributes\n</code></pre>"},{"location":"api/core/#pam.core.Household.pickle","title":"<code>pickle(path)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def pickle(self, path):\n    with open(path, \"wb\") as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"api/core/#pam.core.Household.plot","title":"<code>plot(**kwargs)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def plot(self, **kwargs):\n    plot.plot_household(self, **kwargs)\n</code></pre>"},{"location":"api/core/#pam.core.Household.plot_travel_plotly","title":"<code>plot_travel_plotly(epsg: str = 'epsg:4326', **kwargs: str) -&gt; None</code>","text":"<p>Uses plotly's Scattermapbox to plot agents' travel</p> <p>Parameters:</p> Name Type Description Default <code>epsg</code> <code>str</code> <p>coordinate system the plans spatial information is in, e.g. 'epsg:27700'</p> <code>'epsg:4326'</code> <p>Keyword arguments for plot.plot_travel_plans</p> Name Type Description <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>generated by build_person_travel_geodataframe</p> <code>groupby</code> <p>optional argument for splitting traces in the plot</p> <code>colour_by</code> <p>argument for specifying what the colour should correspond to in the plot, travel mode by default</p> <code>cmap</code> <p>optional argument, useful to pass if generating a number of plots and want to keep colour scheme</p> <code>mapbox_access_token</code> <p>required to generate the plot https://docs.mapbox.com/help/how-mapbox-works/access-tokens/</p> Source code in <code>pam/core.py</code> <pre><code>def plot_travel_plotly(self, epsg: str = \"epsg:4326\", **kwargs) -&gt; None:\n\"\"\"\n    Uses plotly's Scattermapbox to plot agents' travel\n    Args:\n        epsg (str): coordinate system the plans spatial information is in, e.g. 'epsg:27700'\n    Keyword Args: Keyword arguments for plot.plot_travel_plans\n        gdf (geopandas.GeoDataFrame): generated by build_person_travel_geodataframe\n        groupby: optional argument for splitting traces in the plot\n        colour_by: argument for specifying what the colour should correspond to in the plot, travel mode by default\n        cmap: optional argument, useful to pass if generating a number of plots and want to keep colour scheme\n        consistent\n        mapbox_access_token: required to generate the plot https://docs.mapbox.com/help/how-mapbox-works/access-tokens/\n    \"\"\"\n    return plot.plot_travel_plans(\n        gdf=self.build_travel_geodataframe(from_epsg=epsg, to_epsg=\"epsg:4326\"),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/core/#pam.core.Household.print","title":"<code>print()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def print(self):\n    print(self)\n    print(self.attributes)\n    for _, person in self:\n        person.print()\n</code></pre>"},{"location":"api/core/#pam.core.Household.random_person","title":"<code>random_person()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def random_person(self):\n    return self.people[random.choice(list(self.people))]\n</code></pre>"},{"location":"api/core/#pam.core.Household.reindex","title":"<code>reindex(prefix: str)</code>","text":"<p>Safely reindex all person identifiers in household using a prefix.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to add.</p> required Source code in <code>pam/core.py</code> <pre><code>def reindex(self, prefix: str):\n\"\"\"\n    Safely reindex all person identifiers in household using a prefix.\n    Args:\n        prefix (str): Prefix to add.\n    \"\"\"\n    self.hid = prefix + self.hid\n    for pid in list(self.people):\n        person = self.people[pid]\n        new_pid = prefix + pid\n        if new_pid in self.people:\n            raise KeyError(f\"Duplicate person identifier (pid): {new_pid}\")\n        person.reindex(prefix)\n        self.people[new_pid] = person\n        del self.people[pid]\n</code></pre>"},{"location":"api/core/#pam.core.Household.set_area","title":"<code>set_area(area)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_area(self, area):\n    self._location.area = area\n    for _, person in self:\n        person.set_area(area)\n</code></pre>"},{"location":"api/core/#pam.core.Household.set_freq","title":"<code>set_freq(freq)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_freq(self, freq):\n    self.hh_freq = freq\n</code></pre>"},{"location":"api/core/#pam.core.Household.set_loc","title":"<code>set_loc(loc)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_loc(self, loc):\n    self._location.loc = loc\n    for _, person in self:\n        person.set_loc(loc)\n</code></pre>"},{"location":"api/core/#pam.core.Household.set_location","title":"<code>set_location(location: Location)</code>","text":"<p>Set both hh and person home_location, but note that hhs and their persons do not share location object.</p> Source code in <code>pam/core.py</code> <pre><code>def set_location(self, location: Location):\n\"\"\"\n    Set both hh and person home_location, but note that hhs and\n    their persons do not share location object.\n    \"\"\"\n    self._location = location\n    for _, person in self:\n        person.set_location(location.copy())\n</code></pre>"},{"location":"api/core/#pam.core.Household.shared_activities","title":"<code>shared_activities()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def shared_activities(self):\n    shared_activities = []\n    household_activities = []\n    for pid, person in self.people.items():\n        for activity in person.activities:\n            if activity.isin_exact(household_activities):\n                shared_activities.append(activity)\n            if not activity.isin_exact(household_activities):\n                household_activities.append(activity)\n    return shared_activities\n</code></pre>"},{"location":"api/core/#pam.core.Household.size","title":"<code>size()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def size(self):\n    return len(self.people)\n</code></pre>"},{"location":"api/core/#pam.core.Person","title":"<code>Person(pid, freq = None, attributes = {}, home_location: Optional[Location] = None, home_area: Optional[Location] = None, home_loc: Optional[Location] = None, vehicle: Vehicle = None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def __init__(\n    self,\n    pid,\n    freq=None,\n    attributes={},\n    home_location: Optional[Location] = None,\n    home_area=None,\n    home_loc=None,\n    vehicle: Vehicle = None,\n):\n    self.pid = pid\n    self.person_freq = freq\n    self.attributes = attributes\n    if home_location is not None:\n        self.home_location = home_location\n    else:\n        self.home_location = Location()\n    if home_area:\n        self.home_location.area = home_area\n    if home_loc:\n        self.home_location.loc = home_loc\n    # person and their plan share Location\n    self.plan = activity.Plan(home_location=self.home_location)\n    self.plans_non_selected = []\n    self.vehicle = None\n    if vehicle:\n        self.assign_vehicle(vehicle)\n</code></pre>"},{"location":"api/core/#pam.core.Person.activities","title":"<code>activities</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.acts","title":"<code>acts</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.attributes","title":"<code>attributes = attributes</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.av_activity_freq","title":"<code>av_activity_freq</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.av_trip_freq","title":"<code>av_trip_freq</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.closed_plan","title":"<code>closed_plan</code>  <code>property</code>","text":"<p>Check if plan starts and stops at the same facility (based on activity and location) :return: Bool</p>"},{"location":"api/core/#pam.core.Person.first_activity","title":"<code>first_activity</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.freq","title":"<code>freq</code>  <code>property</code>","text":"<p>Return person_freq, else if None, return the average frequency of legs. TODO consider passing parent hh on creation so that we can retrieve hh freq if required.</p>"},{"location":"api/core/#pam.core.Person.has_valid_plan","title":"<code>has_valid_plan</code>  <code>property</code>","text":"<p>Check sequence of Activities and Legs. :return: True</p>"},{"location":"api/core/#pam.core.Person.home","title":"<code>home</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.home_based","title":"<code>home_based</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.home_location","title":"<code>home_location = home_location</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.last_activity","title":"<code>last_activity</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.last_component","title":"<code>last_component</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.last_leg","title":"<code>last_leg</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.legs","title":"<code>legs</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.length","title":"<code>length</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.num_activities","title":"<code>num_activities</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.num_legs","title":"<code>num_legs</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.person_freq","title":"<code>person_freq = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.pid","title":"<code>pid = pid</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.plan","title":"<code>plan = activity.Plan(home_location=self.home_location)</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.plans_non_selected","title":"<code>plans_non_selected = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.subpopulation","title":"<code>subpopulation</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Person.vehicle","title":"<code>vehicle = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Person.add","title":"<code>add(p)</code>","text":"<p>Safely add a new component to the plan.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <p>component to add</p> required Source code in <code>pam/core.py</code> <pre><code>def add(self, p):\n\"\"\"\n    Safely add a new component to the plan.\n    Args:\n        p: component to add\n    \"\"\"\n    self.plan.add(p)\n</code></pre>"},{"location":"api/core/#pam.core.Person.assign_vehicle","title":"<code>assign_vehicle(vehicle: Vehicle) -&gt; None</code>","text":"<p>Give a Vehicle or ElectricVehicle to an agent.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>Vehicle</code> required Source code in <code>pam/core.py</code> <pre><code>def assign_vehicle(self, vehicle: Vehicle) -&gt; None:\n\"\"\"\n    Give a Vehicle or ElectricVehicle to an agent.\n    Args:\n        vehicle (Vehicle):\n    \"\"\"\n    if vehicle.id != self.pid:\n        raise PAMVehicleIdError(\n            f\"Vehicle with ID: {vehicle.id} does not match Person ID: {self.pid}\"\n        )\n    self.vehicle = vehicle\n</code></pre>"},{"location":"api/core/#pam.core.Person.build_travel_geodataframe","title":"<code>build_travel_geodataframe(**kwargs) -&gt; gpd.GeoDataFrame</code>","text":"<p>Builds geopandas.GeoDataFrame for Person's Legs</p> <p>Keyword arguments for plot.build_person_travel_geodataframe,</p> Name Type Description <code>from_epsg</code> <p>coordinate system the plans are currently in</p> <code>to_epsg</code> <p>coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame with columns for person id (pid)</p> Source code in <code>pam/core.py</code> <pre><code>def build_travel_geodataframe(self, **kwargs) -&gt; gpd.GeoDataFrame:\n\"\"\"\n    Builds geopandas.GeoDataFrame for Person's Legs\n    Keyword Args: Keyword arguments for plot.build_person_travel_geodataframe,\n        from_epsg: coordinate system the plans are currently in\n        to_epsg: coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.\n    Returns:\n        geopandas.GeoDataFrame with columns for person id (pid)\n    \"\"\"\n    return plot.build_person_travel_geodataframe(self, **kwargs)\n</code></pre>"},{"location":"api/core/#pam.core.Person.clear_plan","title":"<code>clear_plan()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def clear_plan(self):\n    self.plan.clear()\n</code></pre>"},{"location":"api/core/#pam.core.Person.fill_plan","title":"<code>fill_plan(p_idx, s_idx, default: str = 'home') -&gt; bool</code>","text":"<p>Fill a plan after Activity has been removed.</p> <p>Parameters:</p> Name Type Description Default <code>p_idx</code> <p>location of previous Activity</p> required <code>s_idx</code> <p>location of subsequent Activity</p> required <code>default</code> <code>str</code> <p>Defaults to \"home\"</p> <code>'home'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> Source code in <code>pam/core.py</code> <pre><code>def fill_plan(self, p_idx, s_idx, default: str = \"home\") -&gt; bool:\n\"\"\"\n    Fill a plan after Activity has been removed.\n    Args:\n        p_idx: location of previous Activity\n        s_idx: location of subsequent Activity\n        default (str, optional): Defaults to \"home\"\n    Returns:\n        bool:\n    \"\"\"\n    return self.plan.fill_plan(p_idx, s_idx, default=default)\n</code></pre>"},{"location":"api/core/#pam.core.Person.finalise","title":"<code>finalise()</code>","text":"<p>Add activity end times based on start time of next activity.</p> Source code in <code>pam/core.py</code> <pre><code>def finalise(self):\n\"\"\"\n    Add activity end times based on start time of next activity.\n    \"\"\"\n    self.plan.finalise_activity_end_times()\n</code></pre>"},{"location":"api/core/#pam.core.Person.fix_plan","title":"<code>fix_plan(crop = True, times = True, locations = True)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def fix_plan(self, crop=True, times=True, locations=True):\n    if crop:\n        self.plan.crop()\n    if times:\n        self.plan.fix_time_consistency()\n    if locations:\n        self.plan.fix_location_consistency()\n</code></pre>"},{"location":"api/core/#pam.core.Person.move_activity","title":"<code>move_activity(seq, default: str = 'home', new_mode: str = 'walk') -&gt; None</code>","text":"<p>Move an activity from plan at given seq to default location.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> required <code>default</code> <code>str</code> <p>'home' or pam.activity.Location. Defaults to \"home\".</p> <code>'home'</code> <code>new_mode</code> <code>str</code> <p>access/egress journey switching to this mode. Ie 'walk'. Defaults to \"walk\".</p> <code>'walk'</code> Source code in <code>pam/core.py</code> <pre><code>def move_activity(self, seq, default: str = \"home\", new_mode: str = \"walk\") -&gt; None:\n\"\"\"\n    Move an activity from plan at given seq to default location.\n    Args:\n        seq:\n        default (str, optional):\n            'home' or pam.activity.Location.\n            Defaults to \"home\".\n        new_mode (str, optional):\n            access/egress journey switching to this mode. Ie 'walk'.\n            Defaults to \"walk\".\n    \"\"\"\n    return self.plan.move_activity(seq, default, new_mode)\n</code></pre>"},{"location":"api/core/#pam.core.Person.pickle","title":"<code>pickle(path)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def pickle(self, path):\n    with open(path, \"wb\") as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"api/core/#pam.core.Person.plot","title":"<code>plot(**kwargs)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def plot(self, **kwargs):\n    plot.plot_person(self, **kwargs)\n</code></pre>"},{"location":"api/core/#pam.core.Person.plot_travel_plotly","title":"<code>plot_travel_plotly(epsg: str = 'epsg:4326', **kwargs: str) -&gt; go.Figure</code>","text":"<p>Uses plotly's Scattermapbox to plot agents' travel</p> <p>Parameters:</p> Name Type Description Default <code>epsg</code> <code>str</code> <p>coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <p>Keyword arguments for plot.plot_travel_plans</p> Name Type Description <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>generated by build_person_travel_geodataframe</p> <code>groupby</code> <p>optional argument for splitting traces in the plot</p> <code>colour_by</code> <p>argument for specifying what the colour should correspond to in the plot, travel mode by default</p> <code>cmap</code> <p>optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent</p> <code>mapbox_access_token</code> <p>required to generate the plot</p> <code>https</code> <p>//docs.mapbox.com/help/how-mapbox-works/access-tokens/</p> <p>Returns:</p> Type Description <code>go.Figure</code> <p>go.Figure: Plotly figure object</p> Source code in <code>pam/core.py</code> <pre><code>def plot_travel_plotly(self, epsg: str = \"epsg:4326\", **kwargs) -&gt; go.Figure:\n\"\"\"\n    Uses plotly's Scattermapbox to plot agents' travel\n    Args:\n        epsg (str, optional): coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".\n    Keyword Args: Keyword arguments for plot.plot_travel_plans\n        gdf (geopandas.GeoDataFrame): generated by build_person_travel_geodataframe\n        groupby: optional argument for splitting traces in the plot\n        colour_by: argument for specifying what the colour should correspond to in the plot, travel mode by default\n        cmap: optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent\n        mapbox_access_token: required to generate the plot\n        https://docs.mapbox.com/help/how-mapbox-works/access-tokens/\n    Returns:\n        go.Figure: Plotly figure object\n    \"\"\"\n    return plot.plot_travel_plans(\n        gdf=self.build_travel_geodataframe(from_epsg=epsg, to_epsg=\"epsg:4326\"),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/core/#pam.core.Person.print","title":"<code>print()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def print(self):\n    print(self)\n    print(self.attributes)\n    self.plan.print()\n</code></pre>"},{"location":"api/core/#pam.core.Person.reindex","title":"<code>reindex(prefix: str)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def reindex(self, prefix: str):\n    self.pid = prefix + self.pid\n</code></pre>"},{"location":"api/core/#pam.core.Person.remove_activity","title":"<code>remove_activity(seq) -&gt; tuple</code>","text":"<p>Remove an activity from plan at given seq. Check for wrapped removal.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>(adjusted) idx of previous and subsequent activities as a tuple</p> Source code in <code>pam/core.py</code> <pre><code>def remove_activity(self, seq) -&gt; tuple:\n\"\"\"\n    Remove an activity from plan at given seq.\n    Check for wrapped removal.\n\n    Args:\n        seq:\n    Returns:\n        tuple: (adjusted) idx of previous and subsequent activities as a tuple\n    \"\"\"\n    return self.plan.remove_activity(seq)\n</code></pre>"},{"location":"api/core/#pam.core.Person.set_area","title":"<code>set_area(area)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_area(self, area):\n    self.home_location.area = area\n    self.plan.home_location.area = area\n</code></pre>"},{"location":"api/core/#pam.core.Person.set_freq","title":"<code>set_freq(freq)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_freq(self, freq):\n    self.person_freq = freq\n</code></pre>"},{"location":"api/core/#pam.core.Person.set_loc","title":"<code>set_loc(loc)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_loc(self, loc):\n    self.home_location.loc = loc\n    self.plan.home_location.loc = loc\n</code></pre>"},{"location":"api/core/#pam.core.Person.set_location","title":"<code>set_location(location: Location)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def set_location(self, location: Location):\n    self.home_location = location\n    self.plan.home_location = location\n</code></pre>"},{"location":"api/core/#pam.core.Person.stay_at_home","title":"<code>stay_at_home()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def stay_at_home(self):\n    self.plan.stay_at_home()\n</code></pre>"},{"location":"api/core/#pam.core.Person.validate","title":"<code>validate()</code>","text":"<p>Validate plan.</p> Source code in <code>pam/core.py</code> <pre><code>def validate(self):\n\"\"\"\n    Validate plan.\n    \"\"\"\n    self.plan.validate()\n    return True\n</code></pre>"},{"location":"api/core/#pam.core.Person.validate_locations","title":"<code>validate_locations()</code>","text":"<p>Check sequence of Activity and Leg locations. :return: True</p> Source code in <code>pam/core.py</code> <pre><code>def validate_locations(self):\n\"\"\"\n    Check sequence of Activity and Leg locations.\n    :return: True\n    \"\"\"\n    if not self.plan.valid_locations:\n        raise PAMValidationLocationsError(\n            f\"Person {self.pid} has invalid plan locations\"\n        )\n\n    return True\n</code></pre>"},{"location":"api/core/#pam.core.Person.validate_sequence","title":"<code>validate_sequence()</code>","text":"<p>Check sequence of Activities and Legs. :return: True</p> Source code in <code>pam/core.py</code> <pre><code>def validate_sequence(self):\n\"\"\"\n    Check sequence of Activities and Legs.\n    :return: True\n    \"\"\"\n    if not self.plan.valid_sequence:\n        raise PAMSequenceValidationError(\n            f\"Person {self.pid} has invalid plan sequence\"\n        )\n\n    return True\n</code></pre>"},{"location":"api/core/#pam.core.Person.validate_times","title":"<code>validate_times()</code>","text":"<p>Check sequence of Activity and Leg times. :return: True</p> Source code in <code>pam/core.py</code> <pre><code>def validate_times(self):\n\"\"\"\n    Check sequence of Activity and Leg times.\n    :return: True\n    \"\"\"\n    if not self.plan.valid_time_sequence:\n        raise PAMInvalidTimeSequenceError(\n            f\"Person {self.pid} has invalid plan times\"\n        )\n\n    return True\n</code></pre>"},{"location":"api/core/#pam.core.Population","title":"<code>Population(name: str = None) -&gt; None</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of population. Defaults to None.</p> <code>None</code> Source code in <code>pam/core.py</code> <pre><code>def __init__(self, name: str = None) -&gt; None:\n\"\"\"\n\n    Args:\n        name (str, optional): Name of population. Defaults to None.\n    \"\"\"\n    self.name = name\n    self.logger = logging.getLogger(__name__)\n    self.households = {}\n</code></pre>"},{"location":"api/core/#pam.core.Population.activity_classes","title":"<code>activity_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.attributes","title":"<code>attributes: dict</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.freq","title":"<code>freq</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.has_electric_vehicles","title":"<code>has_electric_vehicles</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.has_uniquely_indexed_vehicle_types","title":"<code>has_uniquely_indexed_vehicle_types</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.has_vehicles","title":"<code>has_vehicles</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.households","title":"<code>households = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Population.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Population.mode_classes","title":"<code>mode_classes</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#pam.core.Population.num_households","title":"<code>num_households</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.population","title":"<code>population</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.size","title":"<code>size</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.stats","title":"<code>stats</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.subpopulations","title":"<code>subpopulations</code>  <code>property</code>","text":""},{"location":"api/core/#pam.core.Population.add","title":"<code>add(target: list[Union[Household, Person, list]]) -&gt; None</code>","text":"<p>Add houeshold/person, or a list of households/persons to the population</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>list[Union[Household, Person, list]]</code> <p>Can be any arbitrary nesting of lists, as long as the deepest nesting includes only Houeshold and Person objects</p> required <p>Raises:</p> Type Description <code>UserWarning</code> <p>Only Household and Person objects allowed</p> Source code in <code>pam/core.py</code> <pre><code>def add(self, target: list[Union[Household, Person, list]]) -&gt; None:\n\"\"\"\n    Add houeshold/person, or a list of households/persons to the population\n\n    Args:\n        target (list[Union[Household, Person, list]]):\n            Can be any arbitrary nesting of lists, as long as the deepest nesting includes only Houeshold and Person objects\n\n    Raises:\n        UserWarning: Only Household and Person objects allowed\n    \"\"\"\n    if isinstance(target, list):\n        for hh in target:\n            self.add(hh)\n    elif isinstance(target, Household):\n        self.households[target.hid] = target\n    elif isinstance(target, Person):\n        self.logger.warning(\n            (\n                \"Directly adding a Person to a Population requires a Household.\",\n                f\"Auto creating a household {target.pid} for person {target.pid}, check this is intended.\",\n            )\n        )\n        self.add(Household(hid=target.pid))\n        self.households[target.pid].add(target)\n    else:\n        raise UserWarning(\n            f\"Expected instance of Household, list or Person, not: {type(target)}\"\n        )\n</code></pre>"},{"location":"api/core/#pam.core.Population.add_fields","title":"<code>add_fields(df: pd.DataFrame) -&gt; None</code>  <code>staticmethod</code>","text":"<p>add extra fields used for benchmarking in place.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> required Source code in <code>pam/core.py</code> <pre><code>@staticmethod\ndef add_fields(df: pd.DataFrame) -&gt; None:\n\"\"\"add extra fields used for benchmarking in place.\n\n    Args:\n        df (pd.DataFrame):\n    \"\"\"\n\n    df[\"personhrs\"] = df[\"freq\"] * df[\"duration\"] / 60\n    df[\"departure_hour\"] = df.tst.apply(lambda x: x.hour)\n    df[\"arrival_hour\"] = df.tet.apply(lambda x: x.hour)\n    df[\"euclidean_distance_category\"] = pd.cut(\n        df.euclidean_distance,\n        bins=[0, 1, 5, 10, 25, 50, 100, 200, 999999],\n        labels=[\n            \"0 to 1 km\",\n            \"1 to 5 km\",\n            \"5 to 10 km\",\n            \"10 to 25 km\",\n            \"25 to 50 km\",\n            \"50 to 100 km\",\n            \"100 to 200 km\",\n            \"200+ km\",\n        ],\n    )\n    df[\"duration_category\"] = pd.cut(\n        df.duration,\n        bins=[0, 5, 10, 15, 30, 45, 60, 90, 120, 999999],\n        labels=[\n            \"0 to 5 min\",\n            \"5 to 10 min\",\n            \"10 to 15 min\",\n            \"15 to 30 min\",\n            \"30 to 45 min\",\n            \"45 to 60 min\",\n            \"60 to 90 min\",\n            \"90 to 120 min\",\n            \"120+ min\",\n        ],\n    )\n</code></pre>"},{"location":"api/core/#pam.core.Population.build_travel_geodataframe","title":"<code>build_travel_geodataframe(**kwargs) -&gt; gpd.GeoDataFrame</code>","text":"<p>Builds geopandas.GeoDataFrame for travel Legs found for all agents in the Population.</p> <p>Keyword arguments for plot.build_person_travel_geodataframe.</p> Name Type Description <code>from_epsg</code> <code>str</code> <p>coordinate system the plans are currently in</p> <code>to_epsg</code> <code>str</code> <p>coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid)</p> Source code in <code>pam/core.py</code> <pre><code>def build_travel_geodataframe(self, **kwargs) -&gt; gpd.GeoDataFrame:\n\"\"\"\n    Builds geopandas.GeoDataFrame for travel Legs found for all agents in the Population.\n\n    Keyword Args: Keyword arguments for plot.build_person_travel_geodataframe.\n        from_epsg (str): coordinate system the plans are currently in\n        to_epsg (str): coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this.\n\n    Returns:\n        geopandas.GeoDataFrame:  with columns for household id (hid) and person id (pid)\n    \"\"\"\n\n    gdf = None\n    for hid, household in self.households.items():\n        _gdf = household.build_travel_geodataframe(**kwargs)\n        if gdf is None:\n            gdf = _gdf\n        else:\n            gdf = gdf.append(_gdf)\n    gdf = gdf.sort_values([\"hid\", \"pid\", \"seq\"]).reset_index(drop=True)\n    return gdf\n</code></pre>"},{"location":"api/core/#pam.core.Population.combine","title":"<code>combine(other, prefix = '')</code>","text":"<p>Safe addition with assignment by adding a prefix to create unique pids and hids.</p> Source code in <code>pam/core.py</code> <pre><code>def combine(self, other, prefix=\"\"):\n\"\"\"\n    Safe addition with assignment by adding a prefix to create unique pids and hids.\n    \"\"\"\n    prefix = str(prefix)\n\n    if isinstance(other, Population):\n        other.reindex(prefix)\n        self += other\n        return None\n    if isinstance(other, Household):\n        other.reindex(prefix)\n        self += other\n        return None\n    if isinstance(other, Person):\n        hh = Household(other.pid)  # we create a new hh for single person\n        hh.add(other)\n        hh.reindex(prefix)\n        self += hh\n        return None\n    raise TypeError(\n        f\"Object for addition must be a Population Household or Person object, not {type(other)}\"\n    )\n</code></pre>"},{"location":"api/core/#pam.core.Population.electric_vehicle_charger_types","title":"<code>electric_vehicle_charger_types()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def electric_vehicle_charger_types(self):\n    chargers = set()\n    for v in self.electric_vehicles():\n        chargers |= set(v.charger_types.split(\",\"))\n    return chargers\n</code></pre>"},{"location":"api/core/#pam.core.Population.electric_vehicles","title":"<code>electric_vehicles()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def electric_vehicles(self):\n    for v in self.vehicles():\n        if isinstance(v, ElectricVehicle):\n            yield v\n</code></pre>"},{"location":"api/core/#pam.core.Population.fix_plans","title":"<code>fix_plans(crop: bool = True, times: bool = True, locations: bool = True)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def fix_plans(self, crop: bool = True, times=True, locations=True):\n    for _, _, person in self.people():\n        if crop:\n            person.plan.crop()\n        if times:\n            person.plan.fix_time_consistency()\n        if locations:\n            person.plan.fix_location_consistency()\n</code></pre>"},{"location":"api/core/#pam.core.Population.get","title":"<code>get(hid, default = None)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def get(self, hid, default=None):\n    return self.households.get(hid, default)\n</code></pre>"},{"location":"api/core/#pam.core.Population.legs_df","title":"<code>legs_df() -&gt; pd.DataFrame</code>","text":"<p>Extract tabular record of population legs.</p> Source code in <code>pam/core.py</code> <pre><code>def legs_df(self) -&gt; pd.DataFrame:\n\"\"\"\n\n    Extract tabular record of population legs.\n\n    Returns: record of legs\n    \"\"\"\n    df = []\n    for hid, pid, person in self.people():\n        for seq, leg in enumerate(person.legs):\n            record = {\n                \"pid\": pid,\n                \"hid\": hid,\n                \"hzone\": person.home,\n                \"ozone\": leg.start_location.area,\n                \"dzone\": leg.end_location.area,\n                \"oloc\": leg.start_location,\n                \"dloc\": leg.end_location,\n                \"seq\": seq,\n                \"purp\": leg.purp,\n                \"mode\": leg.mode,\n                \"tst\": leg.start_time.time(),\n                \"tet\": leg.end_time.time(),\n                # duration in minutes\n                \"duration\": leg.duration / pd.Timedelta(minutes=1),\n                \"euclidean_distance\": leg.euclidean_distance,\n                \"freq\": person.freq,\n            }\n            # add person attributes\n            record = {**record, **dict(person.attributes)}\n            df.append(record)\n    df = pd.DataFrame(df)\n    self.add_fields(df)\n    return df\n</code></pre>"},{"location":"api/core/#pam.core.Population.people","title":"<code>people()</code>","text":"<p>Iterator for people in poulation, returns hid, pid and Person</p> Source code in <code>pam/core.py</code> <pre><code>def people(self):\n\"\"\"\n    Iterator for people in poulation, returns hid, pid and Person\n    \"\"\"\n    for hid, household in self.households.items():\n        for pid, person in household.people.items():\n            yield hid, pid, person\n</code></pre>"},{"location":"api/core/#pam.core.Population.pickle","title":"<code>pickle(path: str)</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def pickle(self, path: str):\n    with open(path, \"wb\") as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"api/core/#pam.core.Population.plans","title":"<code>plans() -&gt; Generator[activity.Plan, None, None]</code>","text":"<p>Iterator for plans in poulation</p> Source code in <code>pam/core.py</code> <pre><code>def plans(self) -&gt; Generator[activity.Plan, None, None]:\n\"\"\"\n    Iterator for plans in poulation\n    \"\"\"\n    for hid, household in self.households.items():\n        for pid, person in household.people.items():\n            yield person.plan\n</code></pre>"},{"location":"api/core/#pam.core.Population.plot_travel_plotly","title":"<code>plot_travel_plotly(epsg: str = 'epsg:4326', **kwargs: str) -&gt; go.Figure</code>","text":"<p>Parameters:</p> Name Type Description Default <code>epsg</code> <code>str</code> <p>coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <p>Keyword arguments for plot.plot_travel_plans</p> Name Type Description <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>geopandas.GeoDataFrame generated by build_person_travel_geodataframe</p> <code>groupby</code> <p>optional argument for splitting traces in the plot</p> <code>colour_by</code> <p>argument for specifying what the colour should correspond to in the plot, travel mode by default</p> <code>cmap</code> <p>optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent</p> <code>mapbox_access_token</code> <p>required to generate the plot https://docs.mapbox.com/help/how-mapbox-works/access-tokens/</p> <p>Returns:</p> Type Description <code>go.Figure</code> <p>go.Figure: Plotly figure object.</p> Source code in <code>pam/core.py</code> <pre><code>def plot_travel_plotly(self, epsg: str = \"epsg:4326\", **kwargs) -&gt; go.Figure:\n\"\"\"\n    Args:\n        epsg (str, optional): coordinate system the plans spatial information is in, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".\n    Keyword Args: Keyword arguments for plot.plot_travel_plans\n        gdf (geopandas.GeoDataFrame): geopandas.GeoDataFrame generated by build_person_travel_geodataframe\n        groupby: optional argument for splitting traces in the plot\n        colour_by: argument for specifying what the colour should correspond to in the plot, travel mode by default\n        cmap: optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent\n        mapbox_access_token: required to generate the plot https://docs.mapbox.com/help/how-mapbox-works/access-tokens/\n    Returns:\n        go.Figure: Plotly figure object.\n    \"\"\"\n    return plot.plot_travel_plans(\n        gdf=self.build_travel_geodataframe(from_epsg=epsg, to_epsg=\"epsg:4326\"),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/core/#pam.core.Population.print","title":"<code>print()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def print(self):\n    print(self)\n    for _, household in self:\n        household.print()\n</code></pre>"},{"location":"api/core/#pam.core.Population.random_household","title":"<code>random_household()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def random_household(self):\n    return self.households[random.choice(list(self.households))]\n</code></pre>"},{"location":"api/core/#pam.core.Population.random_person","title":"<code>random_person()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def random_person(self):\n    hh = self.random_household()\n    return hh.random_person()\n</code></pre>"},{"location":"api/core/#pam.core.Population.reindex","title":"<code>reindex(prefix: str)</code>","text":"<p>Safely reindex all household and person identifiers in population using a prefix.</p> Source code in <code>pam/core.py</code> <pre><code>def reindex(self, prefix: str):\n\"\"\"\n    Safely reindex all household and person identifiers in population using a prefix.\n    \"\"\"\n    for hid in list(self.households):\n        hh = self.households[hid]\n        new_hid = prefix + str(hid)\n        if new_hid in self.households:\n            raise KeyError(f\"Duplicate household identifier (hid): {new_hid}\")\n\n        hh.reindex(prefix)\n\n        self.households[new_hid] = hh\n        del self.households[hid]\n</code></pre>"},{"location":"api/core/#pam.core.Population.sample_locs","title":"<code>sample_locs(sampler, long_term_activities: list = None, joint_trips_prefix: str = 'escort_', location_override: bool = True)</code>","text":"<p>WIP Sample household plan locs using a sampler.</p> <p>Sampler uses activity types and areas to sample locations. Note that households share locations for activities of the same type within the same area. Trivially this includes household location. But also, for example, shopping activities if they are in the same area.</p> <p>We treat escort activities (ie those prefixed by \"escort_\") as the escorted activity. For example, the sampler treats \"escort_education\" and \"education\" equally. Note that this shared activity sampling of location models shared facilities, but does not explicitly infer or model shared transport. For example there is no consideration of if trips to shared locations take place at the same time or from the same locations.</p> <p>After sampling Location objects are shared between shared activity locations and corresponding trips start and end locations. These objects are mutable, so care must be taken if making changes as these will impact all other persons shared locations in the household. Often this behaviour might be expected. For example if we change the location of the household home activity, all persons and home activities are impacted.</p> <p>Parameters:</p> Name Type Description Default <code>long_term_activities</code> <code>list</code> <p>a list of activities for which location is only assigned once (per zone). Defaults to None</p> <code>None</code> <code>joint_trips_prefix</code> <code>str</code> <p>a purpose prefix used to identify escort/joint trips. Defaults to \"escort_\"</p> <code>'escort_'</code> <code>location_override</code> <code>bool</code> <p>if False, the facility sampler will retain any already-existing locations in the population.. Defaults to True</p> <code>True</code> Source code in <code>pam/core.py</code> <pre><code>def sample_locs(\n    self,\n    sampler,\n    long_term_activities: list = None,\n    joint_trips_prefix: str = \"escort_\",\n    location_override: bool = True,\n):\n\"\"\"\n    WIP Sample household plan locs using a sampler.\n\n    Sampler uses activity types and areas to sample locations. Note that households share\n    locations for activities of the same type within the same area. Trivially this includes\n    household location. But also, for example, shopping activities if they are in the same area.\n\n    We treat escort activities (ie those prefixed by \"escort_\") as the escorted activity. For\n    example, the sampler treats \"escort_education\" and \"education\" equally. Note that this shared\n    activity sampling of location models shared facilities, but does not explicitly infer or\n    model shared transport. For example there is no consideration of if trips to shared locations\n    take place at the same time or from the same locations.\n\n    After sampling Location objects are shared between shared activity locations and corresponding\n    trips start and end locations. These objects are mutable, so care must be taken if making changes\n    as these will impact all other persons shared locations in the household. Often this behaviour\n    might be expected. For example if we change the location of the household home activity, all\n    persons and home activities are impacted.\n\n    Args:\n        long_term_activities (list, optional): a list of activities for which location is only assigned once (per zone). Defaults to None\n        joint_trips_prefix (str, optional): a purpose prefix used to identify escort/joint trips. Defaults to \"escort_\"\n        location_override (bool, optional): if False, the facility sampler will retain any already-existing locations in the population.. Defaults to True\n    \"\"\"\n    if long_term_activities is None:\n        long_term_activities = variables.LONG_TERM_ACTIVITIES\n\n    for _, household in self.households.items():\n        home_loc = activity.Location(\n            area=household.location.area,\n            loc=sampler.sample(household.location.area, \"home\"),\n        )\n\n        unique_locations = {(household.location.area, \"home\"): home_loc}\n\n        for __, person in household.people.items():\n            for act in person.activities:\n                # remove escort prefix from activity types.\n                if act.act[: len(joint_trips_prefix)] == joint_trips_prefix:\n                    target_act = act.act[(len(joint_trips_prefix)) :]\n                else:\n                    target_act = act.act\n\n                # assign any unique locations\n                if (act.location.area, target_act) in unique_locations:\n                    location = unique_locations[(act.location.area, target_act)]\n                    act.location = location\n                # sample facility\n                elif location_override or act.location.loc is None:\n                    location = activity.Location(\n                        area=act.location.area,\n                        loc=sampler.sample(act.location.area, target_act),\n                    )\n                    if target_act in long_term_activities:\n                        # one location per zone for long-term choices (only)\n                        # short-term activities, such as shopping can visit multiple locations in the same zone\n                        unique_locations[(act.location.area, target_act)] = location\n                    act.location = location\n\n            # complete the alotting activity locations to the trip starts and ends.\n            for idx in range(person.plan.length):\n                component = person.plan[idx]\n                if isinstance(component, activity.Leg):\n                    component.start_location = person.plan[idx - 1].location\n                    component.end_location = person.plan[idx + 1].location\n</code></pre>"},{"location":"api/core/#pam.core.Population.sample_locs_complex","title":"<code>sample_locs_complex(sampler, long_term_activities: list = None, joint_trips_prefix: str = 'escort_')</code>","text":"<p>Extends sample_locs method to enable more complex and rules-based sampling. Keeps track of the last location and transport mode, to apply distance- and mode-based sampling rules. It is generally slower than sample_locs, as it loops through both activities and legs.</p> <p>Parameters:</p> Name Type Description Default <code>long_term_activities</code> <code>list</code> <p>a list of activities for which location is only assigned once (per zone). Defaults to None.</p> <code>None</code> <code>joint_trips_prefix</code> <code>str</code> <p>a purpose prefix used to identify escort/joint trips. Defaults to \"escort_\".</p> <code>'escort_'</code> Source code in <code>pam/core.py</code> <pre><code>def sample_locs_complex(\n    self,\n    sampler,\n    long_term_activities: list = None,\n    joint_trips_prefix: str = \"escort_\",\n):\n\"\"\"\n    Extends sample_locs method to enable more complex and rules-based sampling.\n    Keeps track of the last location and transport mode, to apply distance- and mode-based sampling rules.\n    It is generally slower than sample_locs, as it loops through both activities and legs.\n    Args:\n        long_term_activities (list, optional):\n            a list of activities for which location is only assigned once (per zone).\n            Defaults to None.\n        joint_trips_prefix (str, optional):\n            a purpose prefix used to identify escort/joint trips.\n            Defaults to \"escort_\".\n    \"\"\"\n    if long_term_activities is None:\n        long_term_activities = variables.LONG_TERM_ACTIVITIES\n\n    for _, household in self.households.items():\n        home_loc = activity.Location(\n            area=household.location.area,\n            loc=sampler.sample(\n                household.location.area,\n                \"home\",\n                mode=None,\n                previous_duration=None,\n                previous_loc=None,\n            ),\n        )\n        mode = None\n\n        unique_locations = {(household.location.area, \"home\"): home_loc}\n\n        for _, person in household.people.items():\n            mode = None\n            previous_duration = None\n            previous_loc = None\n\n            for idx, component in enumerate(person.plan):\n                # loop through all plan elements\n\n                if isinstance(component, activity.Leg):\n                    mode = component.mode  # keep track of last mode\n                    previous_duration = component.duration\n\n                elif isinstance(component, activity.Activity):\n                    act = component\n\n                    # remove \"escort_\" from activity types.\n                    # TODO: model joint trips\n                    if act.act[: len(joint_trips_prefix)] == joint_trips_prefix:\n                        target_act = act.act[(len(joint_trips_prefix)) :]\n                    else:\n                        target_act = act.act\n\n                    if (act.location.area, target_act) in unique_locations:\n                        location = unique_locations[(act.location.area, target_act)]\n                        act.location = location\n\n                    else:\n                        location = activity.Location(\n                            area=act.location.area,\n                            loc=sampler.sample(\n                                act.location.area,\n                                target_act,\n                                mode=mode,\n                                previous_duration=previous_duration,\n                                previous_loc=previous_loc,\n                            ),\n                        )\n                        if target_act in long_term_activities:\n                            unique_locations[\n                                (act.location.area, target_act)\n                            ] = location\n                        act.location = location\n\n                    previous_loc = location.loc  # keep track of previous location\n\n            # complete the alotting activity locations to the trip starts and ends.\n            for idx in range(person.plan.length):\n                component = person.plan[idx]\n                if isinstance(component, activity.Leg):\n                    component.start_location = person.plan[idx - 1].location\n                    component.end_location = person.plan[idx + 1].location\n</code></pre>"},{"location":"api/core/#pam.core.Population.to_csv","title":"<code>to_csv(dir: str, crs: str = None, to_crs: str = 'EPSG:4326')</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def to_csv(self, dir: str, crs=None, to_crs: str = \"EPSG:4326\"):\n    write.to_csv(self, dir, crs, to_crs)\n</code></pre>"},{"location":"api/core/#pam.core.Population.trips_df","title":"<code>trips_df() -&gt; pd.DataFrame</code>","text":"<p>Extract tabular record of population legs.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: record of legs</p> Source code in <code>pam/core.py</code> <pre><code>def trips_df(self) -&gt; pd.DataFrame:\n\"\"\"\n    Extract tabular record of population legs.\n\n    Returns:\n        pd.DataFrame: record of legs\n    \"\"\"\n    df = []\n    for hid, pid, person in self.people():\n        for seq, trip in enumerate(person.plan.trips()):\n            record = {\n                \"pid\": pid,\n                \"hid\": hid,\n                \"hzone\": person.home,\n                \"ozone\": trip.start_location.area,\n                \"dzone\": trip.end_location.area,\n                \"oloc\": trip.start_location,\n                \"dloc\": trip.end_location,\n                \"seq\": seq,\n                \"purp\": trip.purp,\n                \"mode\": trip.mode,\n                \"tst\": trip.start_time.time(),\n                \"tet\": trip.end_time.time(),\n                # duration in minutes\n                \"duration\": trip.duration / pd.Timedelta(minutes=1),\n                \"euclidean_distance\": trip.euclidean_distance,\n                \"freq\": person.freq,\n            }\n            # add person attributes\n            record = {**record, **dict(person.attributes)}\n            df.append(record)\n\n    df = pd.DataFrame(df)\n    self.add_fields(df)\n    return df\n</code></pre>"},{"location":"api/core/#pam.core.Population.validate","title":"<code>validate()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def validate(self):\n    for hid, pid, person in self.people():\n        person.validate()\n</code></pre>"},{"location":"api/core/#pam.core.Population.vehicle_types","title":"<code>vehicle_types()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def vehicle_types(self):\n    v_types = {\n        p.vehicle.vehicle_type for _, _, p in self.people() if p.vehicle is not None\n    }\n    for vt in v_types:\n        yield vt\n</code></pre>"},{"location":"api/core/#pam.core.Population.vehicles","title":"<code>vehicles()</code>","text":"Source code in <code>pam/core.py</code> <pre><code>def vehicles(self):\n    for _, _, p in self.people():\n        v = p.vehicle\n        if v is not None:\n            yield v\n</code></pre>"},{"location":"api/location/","title":"pam.location","text":""},{"location":"api/location/#pam.location.Location","title":"<code>Location(loc = None, link = None, area = None)</code>","text":"Source code in <code>pam/location.py</code> <pre><code>def __init__(self, loc=None, link=None, area=None):\n    self.loc = loc\n    self.link = link\n    self.area = area\n</code></pre>"},{"location":"api/location/#pam.location.Location.area","title":"<code>area = area</code>  <code>instance-attribute</code>","text":""},{"location":"api/location/#pam.location.Location.exists","title":"<code>exists</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.link","title":"<code>link = link</code>  <code>instance-attribute</code>","text":""},{"location":"api/location/#pam.location.Location.loc","title":"<code>loc = loc</code>  <code>instance-attribute</code>","text":""},{"location":"api/location/#pam.location.Location.max","title":"<code>max</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.min","title":"<code>min</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.x","title":"<code>x</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.y","title":"<code>y</code>  <code>property</code>","text":""},{"location":"api/location/#pam.location.Location.copy","title":"<code>copy()</code>","text":"Source code in <code>pam/location.py</code> <pre><code>def copy(self):\n    return Location(loc=self.loc, link=self.link, area=self.area)\n</code></pre>"},{"location":"api/utils/","title":"pam.utils","text":""},{"location":"api/utils/#pam.utils.DEFAULT_GZIP_COMPRESSION","title":"<code>DEFAULT_GZIP_COMPRESSION = 6</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#pam.utils.create_crs_attribute","title":"<code>create_crs_attribute(coordinate_reference_system)</code>","text":"<p>Create a CRS attribute as expected by MATSim's ProjectionUtils.getCRS</p> Source code in <code>pam/utils.py</code> <pre><code>def create_crs_attribute(coordinate_reference_system):\n\"\"\"Create a CRS attribute as expected by MATSim's ProjectionUtils.getCRS\"\"\"\n    attributes_element = et.Element('attributes')\n    crs_attribute = et.SubElement(attributes_element, 'attribute', {'class': 'java.lang.String', 'name': 'coordinateReferenceSystem'})\n    crs_attribute.text = str(coordinate_reference_system)\n    return attributes_element\n</code></pre>"},{"location":"api/utils/#pam.utils.create_local_dir","title":"<code>create_local_dir(directory)</code>","text":"Source code in <code>pam/utils.py</code> <pre><code>def create_local_dir(directory):\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n</code></pre>"},{"location":"api/utils/#pam.utils.datetime_string_to_datetime","title":"<code>datetime_string_to_datetime(string: str)</code>","text":"<p>Convert datetime formatted string to datetime :param string: str \"%Y-%m-%d %H:%M:%S\" :return: datetime</p> Source code in <code>pam/utils.py</code> <pre><code>def datetime_string_to_datetime(string: str):\n\"\"\"\n    Convert datetime formatted string to datetime\n    :param string: str \"%Y-%m-%d %H:%M:%S\"\n    :return: datetime\n    \"\"\"\n    return datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n</code></pre>"},{"location":"api/utils/#pam.utils.datetime_to_matsim_time","title":"<code>datetime_to_matsim_time(dt)</code>","text":"<p>Convert datetime to matsim format time (08:27:33) Datetimes beyond 1 day will be converted to hours, eg 25:00:00, for 1am the next day. return dt.strftime(\"%H:%M:%S\")</p> Source code in <code>pam/utils.py</code> <pre><code>def datetime_to_matsim_time(dt):\n\"\"\"\n    Convert datetime to matsim format time (08:27:33)\n    Datetimes beyond 1 day will be converted to hours, eg 25:00:00, for 1am the next day.\n    return dt.strftime(\"%H:%M:%S\")\n    \"\"\"\n    return timedelta_to_matsim_time(dt - START_OF_DAY)\n</code></pre>"},{"location":"api/utils/#pam.utils.dt_to_s","title":"<code>dt_to_s(dt)</code>","text":"<p>Convert datetime to seconds since start of day.</p> Source code in <code>pam/utils.py</code> <pre><code>def dt_to_s(dt):\n\"\"\"\n    Convert datetime to seconds since start of day.\n    \"\"\"\n    return (((dt.hour * 60) + dt.minute) * 60) + dt.second\n</code></pre>"},{"location":"api/utils/#pam.utils.get_elems","title":"<code>get_elems(path, tag)</code>","text":"<p>Wrapper for unzipping and dealing with xml namespaces :param path: xml path string :param tag: The tag type to extract , e.g. 'link' :return: Generator of elements</p> Source code in <code>pam/utils.py</code> <pre><code>def get_elems(path, tag):\n\"\"\"\n    Wrapper for unzipping and dealing with xml namespaces\n    :param path: xml path string\n    :param tag: The tag type to extract , e.g. 'link'\n    :return: Generator of elements\n    \"\"\"\n    target = try_unzip(path)\n    tag = get_tag(target, tag)\n    target = try_unzip(path)  # need to repeat :(\n    return parse_elems(target, tag)\n</code></pre>"},{"location":"api/utils/#pam.utils.get_linestring","title":"<code>get_linestring(from_point, to_point)</code>","text":"<p>Makes a shapely.geometry.LineString out of two points :param from_point: shapely.geometry.Point or s2sphere.CellId :param to_point: shapely.geometry.Point or s2sphere.CellId :return:</p> Source code in <code>pam/utils.py</code> <pre><code>def get_linestring(from_point, to_point):\n\"\"\"\n    Makes a shapely.geometry.LineString out of two points\n    :param from_point: shapely.geometry.Point or s2sphere.CellId\n    :param to_point: shapely.geometry.Point or s2sphere.CellId\n    :return:\n    \"\"\"\n    if all(isinstance(p, CellId) for p in [from_point, to_point]):\n        from_point = from_point.to_lat_lng()\n        from_point = Point(from_point.lng().degrees, from_point.lat().degrees)\n        to_point = to_point.to_lat_lng()\n        to_point = Point(to_point.lng().degrees, to_point.lat().degrees)\n\n    if not all(isinstance(p, Point) for p in [from_point, to_point]):\n        raise TypeError(f'You need to pass points of type {type(Point)} or {type(CellId)}.'\n                        f'Types passed: type(from_point)={type(from_point)} and type(to_point)={type(to_point)}')\n    return LineString([from_point, to_point])\n</code></pre>"},{"location":"api/utils/#pam.utils.get_tag","title":"<code>get_tag(target, tag)</code>","text":"<p>Check for namespace declaration. If they exists return tag string with namespace [''] ie {namespaces['']}tag. If no namespaces declared return original tag TODO Not working with iterparse, generated elem also have ns which is dealt with later</p> Source code in <code>pam/utils.py</code> <pre><code>def get_tag(target, tag):\n\"\"\"\n    Check for namespace declaration. If they exists return tag string\n    with namespace [''] ie {namespaces['']}tag. If no namespaces declared\n    return original tag\n    TODO Not working with iterparse, generated elem also have ns which is dealt with later\n    \"\"\"\n    nsmap = {}\n    doc = etree.iterparse(target, events=('end', 'start-ns',))\n    count = 0\n    for event, element in doc:\n        count += 1\n        if event == 'start-ns':\n            nsmap[element[0]] = element[1]\n        if count == 10:  # assume namespace declared at top so can break early\n            del doc\n            break\n    if not nsmap:\n        return tag\n    else:\n        tag = '{' + nsmap[''] + '}' + tag\n        return tag\n</code></pre>"},{"location":"api/utils/#pam.utils.is_gzip","title":"<code>is_gzip(location)</code>","text":"Source code in <code>pam/utils.py</code> <pre><code>def is_gzip(location):\n    suffix = Path(location).suffix.lower()\n    return suffix == \".gz\" or suffix == \".gzip\"\n</code></pre>"},{"location":"api/utils/#pam.utils.is_xml","title":"<code>is_xml(location)</code>","text":"Source code in <code>pam/utils.py</code> <pre><code>def is_xml(location):\n    return Path(location).suffix.lower() == \".xml\"\n</code></pre>"},{"location":"api/utils/#pam.utils.matsim_duration_to_hours","title":"<code>matsim_duration_to_hours(mt)</code>","text":"Source code in <code>pam/utils.py</code> <pre><code>def matsim_duration_to_hours(mt):\n    mt = mt.split(\":\")\n    return int(mt.pop()) / 3600 + int(mt.pop()) / 60 + int(mt.pop())\n</code></pre>"},{"location":"api/utils/#pam.utils.matsim_time_to_datetime","title":"<code>matsim_time_to_datetime(string: str) -&gt; datetime</code>","text":"<p>Convert matsim format time (08:27:33) to datetime. Can read MATSim times for any day of a simulation (ie 25:00:00 is read as 01:00:00 of the next day).</p> <p>:param string: Time from start of the simulation (%H:%M:%S)</p> Source code in <code>pam/utils.py</code> <pre><code>def matsim_time_to_datetime(string : str) -&gt; datetime:\n\"\"\"\n    Convert matsim format time (08:27:33) to datetime.\n    Can read MATSim times for any day of a simulation (ie 25:00:00 is read as 01:00:00 of the next day).\n\n    :param string: Time from start of the simulation (%H:%M:%S)\n    \"\"\"\n    return safe_strptime(string)\n</code></pre>"},{"location":"api/utils/#pam.utils.minutes_to_datetime","title":"<code>minutes_to_datetime(minutes: int)</code>","text":"<p>Convert minutes to datetime :param minutes: int :return: datetime</p> Source code in <code>pam/utils.py</code> <pre><code>def minutes_to_datetime(minutes: int):\n\"\"\"\n    Convert minutes to datetime\n    :param minutes: int\n    :return: datetime\n    \"\"\"\n    days, remainder = divmod(minutes, 24 * 60)\n    hours, minutes = divmod(remainder, 60)\n    return datetime(1900, 1, 1+days, hours, minutes)\n</code></pre>"},{"location":"api/utils/#pam.utils.minutes_to_timedelta","title":"<code>minutes_to_timedelta(minutes: int)</code>","text":"<p>Convert minutes to timedelta :param minutes: int :return: timedelta</p> Source code in <code>pam/utils.py</code> <pre><code>def minutes_to_timedelta(minutes: int):\n\"\"\"\n    Convert minutes to timedelta\n    :param minutes: int\n    :return: timedelta\n    \"\"\"\n    return timedelta(minutes=minutes)\n</code></pre>"},{"location":"api/utils/#pam.utils.parse_elems","title":"<code>parse_elems(target, tag)</code>","text":"<p>Traverse the given XML tree, retrieving the elements of the specified tag. :param target: Target xml, either BytesIO object or string path :param tag: The tag type to extract , e.g. 'link' :return: Generator of elements</p> Source code in <code>pam/utils.py</code> <pre><code>def parse_elems(target, tag):\n\"\"\"\n    Traverse the given XML tree, retrieving the elements of the specified tag.\n    :param target: Target xml, either BytesIO object or string path\n    :param tag: The tag type to extract , e.g. 'link'\n    :return: Generator of elements\n    \"\"\"\n    doc = etree.iterparse(target, tag=tag)\n    for _, element in doc:\n        yield element\n        element.clear()\n        while element.getprevious() is not None:\n            del element.getparent()[0]\n    del doc\n</code></pre>"},{"location":"api/utils/#pam.utils.parse_time","title":"<code>parse_time(time)</code>","text":"Source code in <code>pam/utils.py</code> <pre><code>def parse_time(time):\n    if isinstance(time, int) or isinstance(time, np.int64):\n        return minutes_to_datetime(time)\n    if isinstance(time, str):\n        return datetime_string_to_datetime(time)\n    raise UserWarning(f\"Cannot parse {time} of type {type(time)} that is not int (assuming minutes) or str (%Y-%m-%d %H:%M:%S)\")\n</code></pre>"},{"location":"api/utils/#pam.utils.safe_strptime","title":"<code>safe_strptime(mt)</code>","text":"<p>safely parse string into datetime, can cope with time strings in format hh:mm:ss if hh &gt; 23 then adds a day</p> Source code in <code>pam/utils.py</code> <pre><code>def safe_strptime(mt):\n\"\"\"\n    safely parse string into datetime, can cope with time strings in format hh:mm:ss\n    if hh &gt; 23 then adds a day\n    \"\"\"\n    h, m, s = mt.split(\":\")\n    return START_OF_DAY + timedelta(hours = int(h), minutes = int(m), seconds = int(s))\n</code></pre>"},{"location":"api/utils/#pam.utils.strip_namespace","title":"<code>strip_namespace(elem)</code>","text":"<p>Strips namespaces from given xml element :param elem: xml element :return: xml element</p> Source code in <code>pam/utils.py</code> <pre><code>def strip_namespace(elem):\n\"\"\"\n    Strips namespaces from given xml element\n    :param elem: xml element\n    :return: xml element\n    \"\"\"\n    if elem.tag.startswith(\"{\"):\n        elem.tag = elem.tag.split('}', 1)[1]  # strip namespace\n    for k in elem.attrib.keys():\n        if k.startswith(\"{\"):\n            k2 = k.split('}', 1)[1]\n            elem.attrib[k2] = elem.attrib[k]\n            del elem.attrib[k]\n    for child in elem:\n        strip_namespace(child)\n</code></pre>"},{"location":"api/utils/#pam.utils.td_to_s","title":"<code>td_to_s(td)</code>","text":"<p>Convert timedelta to seconds since start of day.</p> Source code in <code>pam/utils.py</code> <pre><code>def td_to_s(td):\n\"\"\"\n    Convert timedelta to seconds since start of day.\n    \"\"\"\n    return (td.days * 86400) + td.seconds\n</code></pre>"},{"location":"api/utils/#pam.utils.timedelta_to_hours","title":"<code>timedelta_to_hours(td)</code>","text":"Source code in <code>pam/utils.py</code> <pre><code>def timedelta_to_hours(td):\n    return td.total_seconds() / 3600\n</code></pre>"},{"location":"api/utils/#pam.utils.timedelta_to_matsim_time","title":"<code>timedelta_to_matsim_time(td)</code>","text":"<p>Convert datetime timedelta object to matsim string format (00:00:00)</p> Source code in <code>pam/utils.py</code> <pre><code>def timedelta_to_matsim_time(td):\n\"\"\"\n    Convert datetime timedelta object to matsim string format (00:00:00)\n    \"\"\"\n    hours, remainder = divmod(td.total_seconds(), 3600)\n    minutes, seconds = divmod(remainder, 60)\n    return f\"{int(hours):02}:{int(minutes):02}:{int(seconds):02}\"\n</code></pre>"},{"location":"api/utils/#pam.utils.try_unzip","title":"<code>try_unzip(path)</code>","text":"<p>Attempts to unzip xml at given path, if fails, returns path :param path: xml path string :return: either BytesIO object or string path</p> Source code in <code>pam/utils.py</code> <pre><code>def try_unzip(path):\n\"\"\"\n    Attempts to unzip xml at given path, if fails, returns path\n    :param path: xml path string\n    :return: either BytesIO object or string path\n    \"\"\"\n    try:\n        with gzip.open(path) as unzipped:\n            xml = unzipped.read()\n            target = BytesIO(xml)\n            return target\n    except OSError:\n        return path\n</code></pre>"},{"location":"api/utils/#pam.utils.xml_tree","title":"<code>xml_tree(content)</code>","text":"Source code in <code>pam/utils.py</code> <pre><code>def xml_tree(content):\n    tree = etree.tostring(content,\n                       pretty_print=True,\n                       xml_declaration=False,\n                       encoding='UTF-8')\n    return tree\n</code></pre>"},{"location":"api/write/matrices/","title":"pam.write.matrices","text":""},{"location":"api/write/matrices/#pam.write.matrices.write_od_matrices","title":"<code>write_od_matrices(population, path: str, leg_filter: Optional[str] = None, person_filter: Optional[str] = None, time_minutes_filter: Optional[List[Tuple[int]]] = None) -&gt; None</code>","text":"<p>Write a core population object to tabular O-D weighted matrices. Optionally segment matrices by leg attributes(mode/ purpose), person attributes or specific time periods. A single filter can be applied each time. TODO include freq (assume hh)</p> <p>:param population: core.Population :param path: directory to write OD matrix files :param leg_filter: select between 'Mode', 'Purpose' :param person_filter: select between given attribute categories (column names) from person attribute data :param time_minutes_filter: a list of tuples to slice times, e.g. [(start_of_slicer_1, end_of_slicer_1), (start_of_slicer_2, end_of_slicer_2), ... ]</p> Source code in <code>pam/write/matrices.py</code> <pre><code>def write_od_matrices(\n        population,\n        path : str,\n        leg_filter : Optional[str] = None,\n        person_filter : Optional[str] = None,\n        time_minutes_filter : Optional[List[Tuple[int]]] = None\n        ) -&gt; None:\n\n\"\"\"\n    Write a core population object to tabular O-D weighted matrices.\n    Optionally segment matrices by leg attributes(mode/ purpose), person attributes or specific time periods.\n    A single filter can be applied each time.\n    TODO include freq (assume hh)\n\n    :param population: core.Population\n    :param path: directory to write OD matrix files\n    :param leg_filter: select between 'Mode', 'Purpose'\n    :param person_filter: select between given attribute categories (column names) from person attribute data\n    :param time_minutes_filter: a list of tuples to slice times,\n    e.g. [(start_of_slicer_1, end_of_slicer_1), (start_of_slicer_2, end_of_slicer_2), ... ]\n    \"\"\"\n    create_local_dir(path)\n\n    legs = []\n\n    for hid, household in population.households.items():\n        for pid, person in household.people.items():\n            for leg in person.legs:\n                data = {\n                    'Household ID': hid,\n                    'Person ID': pid,\n                    'Origin':leg.start_location.area,\n                    'Destination': leg.end_location.area,\n                    'Purpose': leg.purp,\n                    'Mode': leg.mode,\n                    'Sequence': leg.seq,\n                    'Start time': leg.start_time,\n                    'End time': leg.end_time,\n                    'Freq': household.freq,\n                    }\n                if person_filter:\n                    legs.append({**data, **person.attributes})\n                else:\n                    legs.append(data)\n\n    df_total = pd.DataFrame(data=legs, columns = ['Origin','Destination']).set_index('Origin')\n    matrix = df_total.pivot_table(values='Destination', index='Origin', columns='Destination', fill_value=0, aggfunc=len)\n    matrix.to_csv(os.path.join(path, 'total_od.csv'))\n\n    data_legs = pd.DataFrame(data=legs)\n\n    if leg_filter:\n        data_legs_grouped=data_legs.groupby(leg_filter)\n        for filter, leg in data_legs_grouped:\n            df = pd.DataFrame(data=leg, columns = ['Origin','Destination']).set_index('Origin')\n            matrix = df.pivot_table(values='Destination', index='Origin', columns='Destination', fill_value=0, aggfunc=len)\n            matrix.to_csv(os.path.join(path, filter+'_od.csv'))\n        return None\n\n    elif person_filter:\n        data_legs_grouped=data_legs.groupby(person_filter)\n        for filter, leg in data_legs_grouped:\n            df = pd.DataFrame(data=leg, columns = ['Origin','Destination']).set_index('Origin')\n            matrix = df.pivot_table(values='Destination', index='Origin', columns='Destination', fill_value=0, aggfunc=len)\n            matrix.to_csv(os.path.join(path, filter+'_od.csv'))\n        return None\n\n    elif time_minutes_filter:\n        periods = []\n        for time in time_minutes_filter:\n            periods.append(time)\n        for start_time, end_time in periods:\n            file_name = str(start_time) +'_to_'+ str(end_time)\n            start_time = mtdt(start_time)\n            end_time = mtdt(end_time)\n            data_time = data_legs[(data_legs['Start time']&gt;= start_time)&amp;(data_legs['Start time']&lt; end_time)]\n            df = pd.DataFrame(data=data_time, columns = ['Origin','Destination']).set_index('Origin')\n            matrix = df.pivot_table(values='Destination', index='Origin', columns='Destination', fill_value=0, aggfunc=len)\n            matrix.to_csv(os.path.join(path, 'time_'+file_name+'_od.csv'))\n        return None\n</code></pre>"},{"location":"api/write/diary/","title":"pam.write.diary","text":""},{"location":"api/write/diary/#pam.write.diary.dump","title":"<code>dump(population, dir: str, crs: Optional[str] = None, to_crs: Optional[str] = 'EPSG:4326') -&gt; None</code>","text":"<p>Write a population to disk as tabular data in csv format. Outputs are: - households.csv: household ids and attributes - people.csv: agent ids and attributes - legs.csv: activity plan trip records - activities.csv: corresponding plan activities If activity locs (shapely.geometry.Point) data is available then geojsons will also be written. :param population: core.Population :param dir: str, path to output directory :param crs: str, population coordinate system (generally we use local grid systems) :param to_crs: str, default 'EPSG:4326', output crs, defaults for use in kepler</p> Source code in <code>pam/write/diary.py</code> <pre><code>def dump(\n    population,\n    dir : str,\n    crs : Optional[str] = None,\n    to_crs : Optional[str] = \"EPSG:4326\"\n    ) -&gt; None:\n\"\"\"\n    Write a population to disk as tabular data in csv format. Outputs are:\n    - households.csv: household ids and attributes\n    - people.csv: agent ids and attributes\n    - legs.csv: activity plan trip records\n    - activities.csv: corresponding plan activities\n    If activity locs (shapely.geometry.Point) data is available then geojsons will also be written.\n    :param population: core.Population\n    :param dir: str, path to output directory\n    :param crs: str, population coordinate system (generally we use local grid systems)\n    :param to_crs: str, default 'EPSG:4326', output crs, defaults for use in kepler\n    \"\"\"\n    to_csv(\n        population = population,\n        dir = dir,\n        crs = crs,\n        to_crs = to_crs\n    )\n</code></pre>"},{"location":"api/write/diary/#pam.write.diary.save_csv","title":"<code>save_csv(df, path)</code>","text":"<p>Write GeoDataFrame as csv by dropping geometry column</p> Source code in <code>pam/write/diary.py</code> <pre><code>def save_csv(df, path):\n\"\"\"Write GeoDataFrame as csv by dropping geometry column\"\"\"\n    if 'geometry' in df.columns:\n        df = df.drop('geometry', axis=1)\n    df.to_csv(path)\n</code></pre>"},{"location":"api/write/diary/#pam.write.diary.save_geojson","title":"<code>save_geojson(df, crs, to_crs, path)</code>","text":"Source code in <code>pam/write/diary.py</code> <pre><code>def save_geojson(df, crs, to_crs, path):\n    if 'geometry' in df.columns:\n        df = gp.GeoDataFrame(df, geometry='geometry')\n        if crs is not None:\n            df.crs = crs\n            df.to_crs(to_crs, inplace=True)\n        df.to_file(path, driver='GeoJSON')\n</code></pre>"},{"location":"api/write/diary/#pam.write.diary.to_csv","title":"<code>to_csv(population, dir: str, crs: Optional[str] = None, to_crs: Optional[str] = 'EPSG:4326') -&gt; None</code>","text":"<p>Write a population to disk as tabular data in csv format. Outputs are: - households.csv: household ids and attributes - people.csv: agent ids and attributes - legs.csv: activity plan trip records - activities.csv: corresponding plan activities If activity locs (shapely.geometry.Point) data is available then geojsons will also be written. :param population: core.Population :param dir: str, path to output directory :param crs: str, population coordinate system (generally we use local grid systems) :param to_crs: str, default 'EPSG:4326', output crs, defaults for use in kepler</p> Source code in <code>pam/write/diary.py</code> <pre><code>def to_csv(\n    population,\n    dir : str,\n    crs : Optional[str] = None,\n    to_crs : Optional[str] = \"EPSG:4326\"\n    ) -&gt; None:\n\"\"\"\n    Write a population to disk as tabular data in csv format. Outputs are:\n    - households.csv: household ids and attributes\n    - people.csv: agent ids and attributes\n    - legs.csv: activity plan trip records\n    - activities.csv: corresponding plan activities\n    If activity locs (shapely.geometry.Point) data is available then geojsons will also be written.\n    :param population: core.Population\n    :param dir: str, path to output directory\n    :param crs: str, population coordinate system (generally we use local grid systems)\n    :param to_crs: str, default 'EPSG:4326', output crs, defaults for use in kepler\n    \"\"\"\n\n    create_local_dir(dir)\n\n    hhs = []\n    people = []\n    acts = []\n    legs = []\n\n    for hid, hh in population.households.items():\n        hh_data = {\n            'hid': hid,\n            'freq': hh.freq,\n            'hzone': hh.location.area,\n        }\n        if isinstance(hh.attributes, dict):\n            hh_data.update(hh.attributes)\n        # if hh.location.area is not None:\n        #     hh_data['area'] = hh.location.area\n        if hh.location.loc is not None:\n            hh_data['geometry'] = hh.location.loc\n\n        hhs.append(hh_data)\n\n        for pid, person in hh.people.items():\n            people_data = {\n                'pid': pid,\n                'hid': hid,\n                'freq': person.freq,\n                'hzone': hh.location.area,\n            }\n            if isinstance(person.attributes, dict):\n                people_data.update(person.attributes)\n            if hh.location.loc is not None:\n                people_data['geometry'] = hh.location.loc\n\n            people.append(people_data)\n\n            for seq, component in enumerate(person.plan):\n                if isinstance(component, Leg):\n                    leg_data = {\n                        'pid': pid,\n                        'hid': hid,\n                        'freq': component.freq,\n                        'ozone': component.start_location.area,\n                        'dzone': component.end_location.area,\n                        'purp': component.purp,\n                        'origin activity': person.plan[seq-1].act,\n                        'destination activity': person.plan[seq+1].act,\n                        'mode': component.mode,\n                        'seq': component.seq,\n                        'tst': component.start_time,\n                        'tet': component.end_time,\n                        'duration': str(component.duration),\n                    }\n                    if component.start_location.loc is not None and component.end_location.loc is not None:\n                        leg_data['geometry'] = LineString((component.start_location.loc, component.end_location.loc))\n\n                    legs.append(leg_data)\n\n                if isinstance(component, Activity):\n                    act_data = {\n                        'pid': pid,\n                        'hid': hid,\n                        'freq': component.freq,\n                        'activity': component.act,\n                        'seq': component.seq,\n                        'start time': component.start_time,\n                        'end time': component.end_time,\n                        'duration': str(component.duration),\n                        'zone': component.location.area,\n                    }\n                    if component.location.loc is not None:\n                        act_data['geometry'] = component.location.loc\n\n                    acts.append(act_data)\n\n    hhs = pd.DataFrame(hhs).set_index('hid')\n    save_geojson(hhs, crs, to_crs, os.path.join(dir, 'households.geojson'))\n    save_csv(hhs, os.path.join(dir, 'households.csv'))\n\n    people = pd.DataFrame(people).set_index('pid')\n    save_geojson(people, crs, to_crs, os.path.join(dir, 'people.geojson'))\n    save_csv(people, os.path.join(dir, 'people.csv'))\n\n    legs = pd.DataFrame(legs)\n    save_geojson(legs, crs, to_crs, os.path.join(dir, 'legs.geojson'))\n    save_csv(legs, os.path.join(dir, 'legs.csv'))\n\n    acts = pd.DataFrame(acts)\n    save_geojson(acts, crs, to_crs, os.path.join(dir, 'activities.geojson'))\n    save_csv(acts, os.path.join(dir, 'activities.csv'))\n</code></pre>"},{"location":"api/write/diary/#pam.write.diary.write_population_csvs","title":"<code>write_population_csvs(list_of_populations: list, dir: str, crs: Optional[str] = None, to_crs: Optional[str] = 'EPSG:4326') -&gt; None</code>","text":"<p>\" Write a list of populations to disk as tabular data in csv format. Outputs are: - populations.csv: summary of populations - households.csv: household ids and attributes - people.csv: agent ids and attributes - legs.csv: activity plan trip records - activities.csv: corresponding plan activities If activity locs (shapely.geometry.Point) data is available then geojsons will also be written. :param population: core.Population :param dir: str, path to output directory :param crs: str, population coordinate system (generally we use local grid systems) :param to_crs: str, default 'EPSG:4326', output crs, defaults for use in kepler</p> Source code in <code>pam/write/diary.py</code> <pre><code>def write_population_csvs(\n    list_of_populations : list,\n    dir : str,\n    crs : Optional[str] = None,\n    to_crs : Optional[str] = \"EPSG:4326\"\n    ) -&gt; None:\n\"\"\"\"\n    Write a list of populations to disk as tabular data in csv format. Outputs are:\n    - populations.csv: summary of populations\n    - households.csv: household ids and attributes\n    - people.csv: agent ids and attributes\n    - legs.csv: activity plan trip records\n    - activities.csv: corresponding plan activities\n    If activity locs (shapely.geometry.Point) data is available then geojsons will also be written.\n    :param population: core.Population\n    :param dir: str, path to output directory\n    :param crs: str, population coordinate system (generally we use local grid systems)\n    :param to_crs: str, default 'EPSG:4326', output crs, defaults for use in kepler\n    \"\"\"\n    create_local_dir(dir)\n\n    populations = []\n    for idx, population in enumerate(list_of_populations):\n        if population.name is None:\n            population.name = idx\n        populations.append({\n                'population_id': idx,\n                'population_name': population.name\n            })\n        to_csv(\n            population=population,\n            dir= os.path.join(dir, population.name),\n            crs=crs,\n            to_crs=to_crs\n            )\n\n    pd.DataFrame(populations).to_csv(\n        os.path.join(dir, 'populations.csv'),\n        index=False\n        )\n</code></pre>"},{"location":"api/write/matsim/","title":"pam.write.matsim","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer","title":"<code>Writer(path: str, household_key: Optional[str] = 'hid', comment: Optional[str] = None, keep_non_selected: bool = False, coordinate_reference_system: str = None) -&gt; None</code>","text":"<p>Context Manager for writing to xml. Designed to handle the boilerplate xml. For example: <code>with pam.write.matsim.Writer(PATH) as writer:     for hid, household in population:         writer.add_hh(household)</code> For example: <code>with pam.write.matsim.Writer(OUT_PATH) as writer:     for person in pam.read.matsim.stream_matsim_persons(IN_PATH):         pam.samplers.time.apply_jitter_to_plan(person.plan)         writer.add_person(household)</code></p> Source code in <code>pam/write/matsim.py</code> <pre><code>def __init__(\n    self,\n    path: str,\n    household_key: Optional[str] = 'hid',\n    comment: Optional[str] = None,\n    keep_non_selected: bool = False,\n    coordinate_reference_system: str = None\n) -&gt; None:\n\n    if os.path.dirname(path):\n        create_local_dir(os.path.dirname(path))\n    self.path = path\n    self.household_key = household_key\n    self.comment = comment\n    self.keep_non_selected = keep_non_selected\n    self.coordinate_reference_system = coordinate_reference_system\n    self.compression = DEFAULT_GZIP_COMPRESSION if is_gzip(path) else 0\n    self.xmlfile = None\n    self.writer = None\n    self.population_writer = None\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.Writer.comment","title":"<code>comment = comment</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.compression","title":"<code>compression = DEFAULT_GZIP_COMPRESSION if is_gzip(path) else 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.coordinate_reference_system","title":"<code>coordinate_reference_system = coordinate_reference_system</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.household_key","title":"<code>household_key = household_key</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.keep_non_selected","title":"<code>keep_non_selected = keep_non_selected</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.path","title":"<code>path = path</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.population_writer","title":"<code>population_writer = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.writer","title":"<code>writer = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.xmlfile","title":"<code>xmlfile = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/write/matsim/#pam.write.matsim.Writer.add_hh","title":"<code>add_hh(household) -&gt; None</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def add_hh(self, household) -&gt; None:\n    for _, person in household:\n        if self.household_key is not None:\n            person.attributes[\n                self.household_key\n            ] = household.hid  # force add hid as an attribute\n        self.add_person(person)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.Writer.add_person","title":"<code>add_person(person) -&gt; None</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def add_person(self, person) -&gt; None:\n    e = create_person_element(person.pid, person, self.keep_non_selected)\n    self.writer.write(e, pretty_print=True)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.add_attribute","title":"<code>add_attribute(attributes, k, v)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def add_attribute(attributes, k, v):\n    if type(v) == bool:\n        attribute = et.SubElement(attributes, 'attribute', {\n                                  'class': 'java.lang.Boolean', 'name': str(k)})\n    elif type(v) == int:\n        attribute = et.SubElement(attributes, 'attribute', {\n                                  'class': 'java.lang.Integer', 'name': str(k)})\n    elif type(v) == float:\n        attribute = et.SubElement(attributes, 'attribute', {\n                                  'class': 'java.lang.Double', 'name': str(k)})\n    else:\n        attribute = et.SubElement(attributes, 'attribute', {\n                                  'class': 'java.lang.String', 'name': str(k)})\n    attribute.text = str(v)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.create_person_element","title":"<code>create_person_element(pid, person, keep_non_selected: bool = False)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def create_person_element(pid, person, keep_non_selected: bool = False):\n    person_xml = et.Element('person', {'id': str(pid)})\n\n    attributes = et.SubElement(person_xml, 'attributes', {})\n    for k, v in person.attributes.items():\n        if k == \"vehicles\":  # todo make something more robust for future 'special' classes\n            attribute = et.SubElement(\n                attributes, 'attribute', {\n                    'class': 'org.matsim.vehicles.PersonVehicles', 'name': str(k)}\n            )\n            attribute.text = str(v)\n        else:\n            add_attribute(attributes, k, v)\n\n    write_plan(\n        person_xml,\n        person.plan,\n        selected=True,\n    )\n    if keep_non_selected:\n        for plan in person.plans_non_selected:\n            write_plan(\n                person_xml,\n                plan,\n                selected=False,\n            )\n    return person_xml\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.object_attributes_dtd","title":"<code>object_attributes_dtd()</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def object_attributes_dtd():\n    dtd_path = os.path.abspath(\n        os.path.join(\n            os.path.dirname(__file__),\n            \"..\", \"fixtures\", \"dtd\", \"objectattributes_v1.dtd\"\n        )\n    )\n    return et.DTD(dtd_path)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.population_v6_dtd","title":"<code>population_v6_dtd()</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def population_v6_dtd():\n    dtd_path = os.path.abspath(\n        os.path.join(\n            os.path.dirname(__file__),\n            \"..\", \"fixtures\", \"dtd\", \"population_v6.dtd\"\n        )\n    )\n    return et.DTD(dtd_path)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.write_all_vehicles","title":"<code>write_all_vehicles(output_dir, vehicles: Set[Vehicle], vehicle_types: Set[VehicleType], file_name: Set[VehicleType] = 'all_vehicles.xml')</code>","text":"<p>Writes all_vehicles file following format https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd for MATSim :param output_dir: output directory for all_vehicles file :param vehicles: collection of vehicles to write :param vehicle_types: collection of vehicle types to write :param file_name: name of output file, defaults to 'all_vehicles.xml` :return: None</p> Source code in <code>pam/write/matsim.py</code> <pre><code>def write_all_vehicles(\n        output_dir,\n        vehicles: Set[Vehicle],\n        vehicle_types: Set[VehicleType],\n        file_name=\"all_vehicles.xml\"):\n\"\"\"\n    Writes all_vehicles file following format https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd\n    for MATSim\n    :param output_dir: output directory for all_vehicles file\n    :param vehicles: collection of vehicles to write\n    :param vehicle_types: collection of vehicle types to write\n    :param file_name: name of output file, defaults to 'all_vehicles.xml`\n    :return: None\n    \"\"\"\n    path = os.path.join(output_dir, file_name)\n    logging.info(f'Writing all vehicles to {path}')\n\n    with et.xmlfile(path, encoding=\"utf-8\") as xf:\n        xf.write_declaration()\n        vehicleDefinitions_attribs = {\n            'xmlns': \"http://www.matsim.org/files/dtd\",\n            'xmlns:xsi': \"http://www.w3.org/2001/XMLSchema-instance\",\n            'xsi:schemaLocation': \"http://www.matsim.org/files/dtd \"\n                                  \"http://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd\"}\n        with xf.element(\"vehicleDefinitions\", vehicleDefinitions_attribs):\n            for vehicle_type in set(vehicle_types):\n                vehicle_type.to_xml(xf)\n            vehicles = list(vehicles)\n            vehicles.sort()\n            for vehicle in vehicles:\n                vehicle.to_xml(xf)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.write_electric_vehicles","title":"<code>write_electric_vehicles(output_dir, vehicles: Set[ElectricVehicle], file_name: Set[ElectricVehicle] = 'electric_vehicles.xml')</code>","text":"<p>Writes electric_vehicles file following format https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd for MATSim :param output_dir: output directory for electric_vehicles file :param vehicles: collection of electric vehicles to write :param file_name: name of output file, defaults to 'electric_vehicles.xml` :return: None</p> Source code in <code>pam/write/matsim.py</code> <pre><code>def write_electric_vehicles(\n        output_dir,\n        vehicles: Set[ElectricVehicle],\n        file_name=\"electric_vehicles.xml\"):\n\"\"\"\n    Writes electric_vehicles file following format https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd\n    for MATSim\n    :param output_dir: output directory for electric_vehicles file\n    :param vehicles: collection of electric vehicles to write\n    :param file_name: name of output file, defaults to 'electric_vehicles.xml`\n    :return: None\n    \"\"\"\n    path = os.path.join(output_dir, file_name)\n    logging.info(f'Writing electric vehicles to {path}')\n\n    with et.xmlfile(path, encoding=\"utf-8\") as xf:\n        xf.write_declaration(\n            doctype='&lt;!DOCTYPE vehicles SYSTEM \"http://matsim.org/files/dtd/electric_vehicles_v1.dtd\"&gt;')\n        with xf.element(\"vehicles\"):\n            vehicles = list(vehicles)\n            vehicles.sort()\n            for vehicle in vehicles:\n                vehicle.to_e_xml(xf)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.write_matsim","title":"<code>write_matsim(population, plans_path: str, attributes_path: Optional[str] = None, vehicles_dir: Optional[str] = None, version: int = None, comment: Optional[str] = None, household_key: Optional[str] = 'hid', keep_non_selected: bool = False, coordinate_reference_system: str = None) -&gt; None</code>","text":"<p>Write a core population to matsim population v6 xml format. Note that this requires activity locs to be set (shapely.geometry.Point).</p> <p>:param population: core.Population, population to be writen to disk :param plans_path: {str, Path}, output path (.xml or .xml.gz) :param attributes_path: legacy parameter, does not have an effect :param vehicles_dir: {str, None}, default None, path to output directory for vehicle files :param version: legacy parameter, does not have an effect :param comment: {str, None}, default None, optionally add a comment string to the xml outputs :param household_key: {str, None}, optionally add household id to person attributes, default 'hid' :param keep_non_selected: bool, default False :param coordinate_reference_system: {str, None}, default None, optionally add CRS attribute to xml outputs :return: None</p> Source code in <code>pam/write/matsim.py</code> <pre><code>def write_matsim(\n    population,\n    plans_path: str,\n    attributes_path: Optional[str] = None,\n    vehicles_dir: Optional[str] = None,\n    version: int = None,\n    comment: Optional[str] = None,\n    household_key: Optional[str] = 'hid',\n    keep_non_selected: bool = False,\n    coordinate_reference_system: str = None,\n) -&gt; None:\n\"\"\"\n    Write a core population to matsim population v6 xml format.\n    Note that this requires activity locs to be set (shapely.geometry.Point).\n\n    :param population: core.Population, population to be writen to disk\n    :param plans_path: {str, Path}, output path (.xml or .xml.gz)\n    :param attributes_path: legacy parameter, does not have an effect\n    :param vehicles_dir: {str, None}, default None, path to output directory for vehicle files\n    :param version: legacy parameter, does not have an effect\n    :param comment: {str, None}, default None, optionally add a comment string to the xml outputs\n    :param household_key: {str, None}, optionally add household id to person attributes, default 'hid'\n    :param keep_non_selected: bool, default False\n    :param coordinate_reference_system: {str, None}, default None, optionally add CRS attribute to xml outputs\n    :return: None\n    \"\"\"\n\n    if version is not None:\n        logging.warning(\n            'parameter \"version\" is no longer supported by write_matsim()')\n    if attributes_path is not None:\n        logging.warning(\n            'parameter \"attributes_path\" is no longer supported by write_matsim()')\n\n    write_matsim_population_v6(\n        population=population,\n        path=plans_path,\n        comment=comment,\n        household_key=household_key,\n        keep_non_selected=keep_non_selected,\n        coordinate_reference_system=coordinate_reference_system,\n    )\n\n    # write vehicles\n    if population.has_vehicles:\n        logging.info('Population includes vehicles')\n        if vehicles_dir is None:\n            raise UserWarning(\n                \"Please provide a vehicles_dir to write vehicle files\")\n        else:\n            logging.info(f'Saving vehicles to {vehicles_dir}')\n            write_vehicles(output_dir=vehicles_dir, population=population)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.write_matsim_population_v6","title":"<code>write_matsim_population_v6(population, path: str, household_key: Optional[str] = 'hid', comment: Optional[str] = None, keep_non_selected: bool = False, coordinate_reference_system: str = None) -&gt; None</code>","text":"<p>Write matsim population v6 xml (persons plans and attributes combined). :param population: core.Population, population to be writen to disk :param path: str, output path (.xml or .xml.gz) :param comment: {str, None}, default None, optionally add a comment string to the xml outputs :param household_key: {str, None}, default 'hid' :param keep_non_selected: bool, default False</p> Source code in <code>pam/write/matsim.py</code> <pre><code>def write_matsim_population_v6(\n    population,\n    path: str,\n    household_key: Optional[str] = 'hid',\n    comment: Optional[str] = None,\n    keep_non_selected: bool = False,\n    coordinate_reference_system: str = None,\n) -&gt; None:\n\"\"\"\n    Write matsim population v6 xml (persons plans and attributes combined).\n    :param population: core.Population, population to be writen to disk\n    :param path: str, output path (.xml or .xml.gz)\n    :param comment: {str, None}, default None, optionally add a comment string to the xml outputs\n    :param household_key: {str, None}, default 'hid'\n    :param keep_non_selected: bool, default False\n    \"\"\"\n\n    with Writer(\n        path=path,\n        household_key=household_key,\n        comment=comment,\n        keep_non_selected=keep_non_selected,\n        coordinate_reference_system=coordinate_reference_system,\n    ) as writer:\n        for _, household in population:\n            writer.add_hh(household)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.write_plan","title":"<code>write_plan(person_xml: et.SubElement, plan: Plan, selected: Optional[bool] = None)</code>","text":"Source code in <code>pam/write/matsim.py</code> <pre><code>def write_plan(\n    person_xml: et.SubElement,\n    plan: Plan,\n    selected: Optional[bool] = None,\n):\n    plan_attributes = {}\n    if selected is not None:\n        plan_attributes['selected'] = {True: 'yes', False: 'no'}[selected]\n    if plan.score is not None:\n        plan_attributes['score'] = str(plan.score)\n\n    plan_xml = et.SubElement(person_xml, 'plan', plan_attributes)\n    for component in plan:\n        if isinstance(component, Activity):\n            component.validate_matsim()\n            act_data = {\n                'type': component.act,\n            }\n            if component.start_time is not None:\n                act_data['start_time'] = dttm(component.start_time)\n            if component.end_time is not None:\n                act_data['end_time'] = dttm(component.end_time)\n            if component.location.link is not None:\n                act_data['link'] = str(component.location.link)\n            if component.location.x is not None:\n                act_data['x'] = str(component.location.x)\n            if component.location.y is not None:\n                act_data['y'] = str(component.location.y)\n            et.SubElement(plan_xml, 'activity', act_data)\n\n        if isinstance(component, Leg):\n            leg = et.SubElement(plan_xml, 'leg', {\n                'mode': component.mode,\n                'trav_time': tdtm(component.duration)})\n\n            if component.attributes:\n                attributes = et.SubElement(leg, 'attributes')\n                for k, v in component.attributes.items():\n                    if k == 'enterVehicleTime':  # todo make something more robust for future 'special' classes\n                        attribute = et.SubElement(\n                            attributes, 'attribute', {\n                                'class': 'java.lang.Double', 'name': str(k)}\n                        )\n                        attribute.text = str(v)\n                    else:\n                        add_attribute(attributes, k, v)\n\n            if component.route.exists:\n                leg.append(component.route.xml)\n</code></pre>"},{"location":"api/write/matsim/#pam.write.matsim.write_vehicles","title":"<code>write_vehicles(output_dir, population, all_vehicles_filename = 'all_vehicles.xml', electric_vehicles_filename = 'electric_vehicles.xml')</code>","text":"Writes <ul> <li>all_vehicles file following format https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd</li> <li>electric_vehicles file following format https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd</li> </ul> <p>given a population in which Persons have been assigned vehicles. :param output_dir: output directory for all_vehicles file :param population: pam.core.Population :param all_vehicles_filename: name of output all vehicles file, defaults to 'all_vehicles.xml<code>:param electric_vehicles_filename: name of output electric vehicles file, defaults to 'electric_vehicles.xml</code> :return:</p> Source code in <code>pam/write/matsim.py</code> <pre><code>def write_vehicles(output_dir,\n                   population,\n                   all_vehicles_filename=\"all_vehicles.xml\",\n                   electric_vehicles_filename=\"electric_vehicles.xml\"):\n\"\"\"\n    Writes:\n        - all_vehicles file following format https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd\n        - electric_vehicles file following format https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd\n    given a population in which Persons have been assigned vehicles.\n    :param output_dir: output directory for all_vehicles file\n    :param population: pam.core.Population\n    :param all_vehicles_filename: name of output all vehicles file, defaults to 'all_vehicles.xml`\n    :param electric_vehicles_filename: name of output electric vehicles file, defaults to 'electric_vehicles.xml`\n    :return:\n    \"\"\"\n    if population.has_vehicles:\n        if population.has_uniquely_indexed_vehicle_types:\n            write_all_vehicles(\n                output_dir,\n                vehicles=population.vehicles(),\n                vehicle_types=population.vehicle_types(),\n                file_name=all_vehicles_filename)\n            if population.has_electric_vehicles:\n                logging.info('Population includes electric vehicles')\n                electric_vehicles = set(population.electric_vehicles())\n                write_electric_vehicles(\n                    output_dir,\n                    vehicles=electric_vehicles,\n                    file_name=electric_vehicles_filename\n                )\n                electric_vehicle_charger_types = population.electric_vehicle_charger_types()\n                logging.info(f'Found {len(electric_vehicles)} electric vehicles '\n                             f'with unique charger types: {electric_vehicle_charger_types}. '\n                             \"Ensure you generate a chargers xml file: https://www.matsim.org/files/dtd/chargers_v1.dtd \"\n                             \"if you're running a simulation using org.matsim.contrib.ev\")\n            else:\n                logging.info(\n                    'Provided population does not have electric vehicles')\n        else:\n            logging.warning('The vehicle types in provided population do not have unique indices. Current Vehicle '\n                            f'Type IDs: {[vt.id for vt in population.vehicle_types()]}')\n    else:\n        logging.warning('Provided population does not have vehicles')\n</code></pre>"},{"location":"api/plot/stats/","title":"pam.plot.stats","text":""},{"location":"api/plot/stats/#pam.plot.stats.calculate_activity_duration_by_act","title":"<code>calculate_activity_duration_by_act(population, exclude = None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_activity_duration_by_act(population, exclude = None):\n    all_activities = []\n    for hid, pid, person in population.people():\n            for seq, activity in enumerate(person.activities):\n                all_activities.append({\n                    'act': activity.act,\n                    'duration_hours': activity.duration.days*24 + activity.duration.seconds/3600\n                })\n    all_activities_df = pd.DataFrame(all_activities)\n    outputs_df = all_activities_df.groupby('act', as_index = False).agg({'duration_hours': 'sum'})\n    outputs_df.insert(0, 'scenario', population.name, True)\n    if(exclude != None):\n        outputs_df = outputs_df[outputs_df.act != exclude]\n    return outputs_df\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.calculate_leg_duration_by_mode","title":"<code>calculate_leg_duration_by_mode(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_leg_duration_by_mode(population):\n    all_legs = []\n    for hid, pid, person in population.people():\n            for seq, leg in enumerate(person.legs):\n                all_legs.append({\n                    'leg mode': leg.mode,\n                    'duration_hours': leg.duration.days*24 + leg.duration.seconds/3600\n                })\n    all_legs_df = pd.DataFrame(all_legs)\n    outputs_df = all_legs_df.groupby('leg mode', as_index = False).agg({'duration_hours': 'sum'})\n    outputs_df.insert(0, 'scenario', population.name, True)\n    return outputs_df\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.calculate_total_activity_duration","title":"<code>calculate_total_activity_duration(population, exclude = None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_total_activity_duration(population, exclude = None):\n    total_activity_duration = timedelta(minutes=0)\n    for hid, pid, person in population.people():\n            for seq, activity in enumerate(person.activities):\n                if(activity.act != exclude):\n                    total_activity_duration = total_activity_duration + activity.duration\n    total_activity_duration_hours = total_activity_duration.days*24 + total_activity_duration.seconds/3600\n    return total_activity_duration_hours\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.calculate_total_leg_duration","title":"<code>calculate_total_leg_duration(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def calculate_total_leg_duration(population):\n    total_leg_duration = timedelta(minutes=0)\n    for hid, pid, person in population.people():\n            for seq, leg in enumerate(person.legs):\n                total_leg_duration = total_leg_duration + leg.duration\n    total_leg_duration_hours = total_leg_duration.days*24 + total_leg_duration.seconds/3600\n    return total_leg_duration_hours\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.extract_activity_log","title":"<code>extract_activity_log(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def extract_activity_log(population):\n    log = []\n    for hid, pid, person in population.people():\n        for activity in person.activities:\n            log.append({\n                'act': activity.act,\n                'start': dt_to_s(activity.start_time),\n                'end': dt_to_s(activity.end_time),\n                'duration': td_to_s(activity.duration)\n            })\n\n    return pd.DataFrame(log)\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.extract_leg_log","title":"<code>extract_leg_log(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def extract_leg_log(population):\n    log = []\n    for hid, pid, person in population.people():\n        for leg in person.legs:\n            log.append({\n                'mode': leg.mode,\n                'start': dt_to_s(leg.start_time),\n                'end': dt_to_s(leg.end_time),\n                'duration': td_to_s(leg.duration)\n            })\n\n    return pd.DataFrame(log)\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_activity_duration","title":"<code>plot_activity_duration(list_of_populations, exclude = None, axis = None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_activity_duration(list_of_populations, exclude = None, axis = None):\n    x = []\n    y = []\n    for idx, population in enumerate(list_of_populations):\n        x.append(population.name)\n        y.append(calculate_total_activity_duration(population, exclude))\n\n    outputs_df = pd.DataFrame({'scenario': x, 'activity duration (hours)': y})\n    x_label_rotation = 90\n    if(exclude != None):\n        title = 'activities (excl '+ exclude + ')'\n    else:\n        title = 'activities'\n\n    if(axis == None):\n        plt.bar(x, y)\n        plt.xticks(rotation= x_label_rotation)\n        plt.ylabel('duration (hours)')\n        plt.title(title)    \n        plt.show\n\n    else:\n        axis.bar(x,y)\n        axis.plot()\n        axis.set_title(title)\n        axis.set_xlabel('')\n        axis.set_xticklabels(x, rotation=x_label_rotation)\n    return outputs_df\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_activity_duration_by_act","title":"<code>plot_activity_duration_by_act(list_of_populations, exclude = None, axis = None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_activity_duration_by_act(list_of_populations, exclude = None, axis = None):\n    population_act_df = pd.DataFrame()\n    for idx, population in enumerate(list_of_populations):\n        population_act_df = population_act_df.append(\n            calculate_activity_duration_by_act(population, exclude), ignore_index = True)\n    pivot_for_chart = population_act_df.pivot(\n        index='scenario', \n        columns='act', \n        values='duration_hours'\n    )\n\n    if(exclude != None):\n        title = 'activities by type (excl '+ exclude + ')'\n    else: \n        title = 'activities by type'\n\n    if axis == None:\n        pivot_for_chart.plot.bar(stacked=True)\n        plt.ylabel('duration (hours)')\n        plt.title(title)\n        plt.show\n    else:\n        pivot_for_chart.plot.bar(stacked=True, ax = axis)\n        axis.set_xlabel('')\n        axis.set_title(title)\n    return pivot_for_chart\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_activity_times","title":"<code>plot_activity_times(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_activity_times(population):\n    acts = extract_activity_log(population)\n    fig = plot_time_bins(acts, sub_col='act')\n    # fig.suptitle(\"Activity Time Bins\")\n    return fig\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_leg_duration","title":"<code>plot_leg_duration(list_of_populations, axis = None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_leg_duration(list_of_populations, axis = None):\n    x = []\n    y = []\n    for idx, population in enumerate(list_of_populations):\n        x.append(population.name)\n        y.append(calculate_total_leg_duration(population))\n\n    outputs_df = pd.DataFrame({'scenario': x, 'leg duration (hours)': y})\n    title = 'legs'\n    x_label_rotation = 90\n    if axis == None: \n        plt.bar(x, y)\n        plt.xticks(rotation= x_label_rotation)\n        plt.ylabel('duration (hours)')\n        plt.title(title)\n    else:\n        axis.bar(x,y)\n        axis.plot()\n        axis.set_title(title)\n        axis.set_xlabel('')\n        axis.set_xticklabels(x, rotation=x_label_rotation)\n    return outputs_df\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_leg_duration_by_mode","title":"<code>plot_leg_duration_by_mode(list_of_populations, axis = None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_leg_duration_by_mode(list_of_populations, axis = None):\n    population_mode_df = pd.DataFrame()\n    for idx, population in enumerate(list_of_populations):\n        population_mode_df = population_mode_df.append(\n            calculate_leg_duration_by_mode(population), ignore_index = True)\n    pivot_for_chart = population_mode_df.pivot(\n        index='scenario', \n        columns='leg mode', \n        values='duration_hours'\n    )\n    title = 'legs by mode'\n\n    if axis == None:\n        pivot_for_chart.plot.bar(stacked=True)\n        plt.title(title)\n        plt.ylabel('duration (hours)')\n    else:\n        pivot_for_chart.plot.bar(stacked=True, ax = axis)\n        axis.set_xlabel('')\n        axis.set_title(title)\n    return pivot_for_chart\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_leg_times","title":"<code>plot_leg_times(population)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_leg_times(population):\n    legs = extract_leg_log(population)\n    fig = plot_time_bins(legs, sub_col='mode')\n    # fig.suptitle(\"Travel Time Bins\")\n    return fig\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_population_comparisons","title":"<code>plot_population_comparisons(list_of_populations, activity_to_exclude = None)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_population_comparisons(list_of_populations, activity_to_exclude = None):\n\n    fig1, ax = plt.subplots(nrows=1, ncols=2, tight_layout=True, sharey = True)\n    legs = plot_leg_duration(list_of_populations, ax[0])\n    leg_modes = plot_leg_duration_by_mode(list_of_populations, ax[1])\n    ax[0].set_ylabel('duration (hours)')\n\n    fig2, ax2 = plt.subplots(nrows=1, ncols=2, tight_layout=True, sharey = True)\n    activities = plot_activity_duration(list_of_populations, activity_to_exclude, ax2[0])\n    activity_types = plot_activity_duration_by_act(list_of_populations, activity_to_exclude, ax2[1])\n    ax2[0].set_ylabel('duration (hours)')\n\n    leg_modes['TOTAL'] = leg_modes.sum(axis=1)\n    activity_types['TOTAL'] = activity_types.sum(axis=1)\n    print(leg_modes, '\\n', activity_types)\n\n    return fig1, fig2, leg_modes, activity_types\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.plot_time_bins","title":"<code>plot_time_bins(data, sub_col, width = 12, height_factor = 1.2)</code>","text":"Source code in <code>pam/plot/stats.py</code> <pre><code>def plot_time_bins(data, sub_col, width=12, height_factor=1.2):\n\n    subs = set(data[sub_col])\n    fig, axs = plt.subplots(\n        len(subs),\n        figsize=(width, 1.2*len(subs)),\n        sharex=False\n        )\n    if not isinstance(axs, np.ndarray):\n        axs = [axs]\n\n    for ax, sub in zip(axs, subs):\n        binned = time_binner(data.loc[data[sub_col] == sub])\n        ax.pcolormesh(binned.T, cmap='cool', edgecolors='white', linewidth=1)\n        ax.set_xticks([i for i in range(0,97,8)])\n        ax.set_xticklabels([f\"{h:02}:00\" for h in range(0,25,2)])\n        ax.set_yticks([0.5,1.5,2.5])\n        ax.set_yticklabels(['Duration', 'End time', 'Start time'])\n        ax.grid(which='minor', color='w', linestyle='-', linewidth=2)\n        for pos in ['right','top','bottom','left']:\n            ax.spines[pos].set_visible(False)\n        ax.set_title(sub.title(), fontsize='medium', rotation=0)\n    fig.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/plot/stats/#pam.plot.stats.time_binner","title":"<code>time_binner(data)</code>","text":"<p>Bin start and end times and durations, return freq table for 24 hour period, 15min intervals.</p> Source code in <code>pam/plot/stats.py</code> <pre><code>def time_binner(data):\n\"\"\"\n    Bin start and end times and durations, return freq table for 24 hour period, 15min intervals.\n    \"\"\"\n    bins = list(range(0, 24*60*60+1, 15*60))\n    bins[-1] = 100*60*60\n    labels = pd.timedelta_range(start='00:00:00', periods=96, freq='15min')  \n    binned = pd.DataFrame(index=pd.timedelta_range(start='00:00:00', periods=96, freq='15min'))\n    binned['duration'] = pd.cut(data.duration, bins, labels=labels, right=False).value_counts()\n    binned['end'] = pd.cut(data.end, bins, labels=labels, right=False).value_counts()\n    binned['start'] = pd.cut(data.start, bins, labels=labels, right=False).value_counts()\n    binned = binned / binned.max()\n    return binned\n</code></pre>"},{"location":"api/plot/plans/","title":"pam.plot.plans","text":""},{"location":"api/plot/plans/#pam.plot.plans.build_cmap","title":"<code>build_cmap(df)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def build_cmap(df):\n    colors = plt.cm.Set3.colors[::-1]\n    activities_unique = df['act'].unique()\n    # repeat colours if unique items &gt; 1\n    len_factor = (len(activities_unique) // len(colors)) + 1\n    d_color = dict(zip(activities_unique, colors*len_factor))\n    d_color['Travel'] = (.3,.3,.3)\n    return d_color\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.build_person_df","title":"<code>build_person_df(person)</code>","text":"<p>Loop through a persons plan, creating a pandas dataframe defining activities for plotting.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def build_person_df(person):\n\"\"\"\n    Loop through a persons plan, creating a pandas dataframe defining activities for plotting.\n    \"\"\"\n    data = {\n        \"act\" : [],\n        \"modes\": [],\n        \"start_time\": [],\n        \"end_time\": [],\n        \"dur\": [],\n    }\n    for component in person.plan.day:\n        data[\"act\"].append(component.act.lower().title())\n        if isinstance(component, activity.Leg):\n            data[\"modes\"].append(component.mode.lower().title())\n        else:\n            data[\"modes\"].append(None)\n        data[\"start_time\"].append(component.start_time.hour + component.start_time.minute/60)\n        data[\"end_time\"].append(component.end_time.hour + component.end_time.minute/60)\n        data[\"dur\"].append(component.duration.total_seconds()/3600)\n    df = pd.DataFrame(data)\n    df['pid'] = person.pid\n\n    return df\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.build_person_travel_geodataframe","title":"<code>build_person_travel_geodataframe(person, from_epsg = None, to_epsg = None)</code>","text":"<p>Loop through a persons legs, creating a geopandas GeoDataFrame defining travel for plotting. :param person: pam.core.Person object :param from_epsg: coordinate system the plans are currently in, optional :param to_epsg: coordinate system you want the geo dataframe to be projected to, optional, you need to specify from_epsg as well to use this. :return:</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def build_person_travel_geodataframe(person, from_epsg=None, to_epsg=None):\n\"\"\"\n    Loop through a persons legs, creating a geopandas GeoDataFrame defining travel for plotting.\n    :param person: pam.core.Person object\n    :param from_epsg: coordinate system the plans are currently in, optional\n    :param to_epsg: coordinate system you want the geo dataframe to be projected to, optional, you need to specify\n    from_epsg as well to use this.\n    :return:\n    \"\"\"\n    df = pd.DataFrame()\n    for leg in person.legs:\n        if (leg.start_location.loc is None) or (leg.end_location.loc is None):\n            raise AttributeError(\n\"\"\"\nTo create a geopandas.DataFrame you need specific locations. Make sure Legs have\nloc attribute defined with a shapely.Point or s2sphere.CellId.\n\"\"\"\n)\n        geometry = utils.get_linestring(leg.start_location.loc, leg.end_location.loc)\n        _leg_dict = {\n            'mode': leg.mode,\n            'purp': leg.purp,\n            'seq': leg.seq,\n            'freq': leg.freq,\n            'start_time': leg.start_time,\n            'end_time': leg.end_time,\n            'start_location': geometry.coords[0],\n            'end_location': geometry.coords[-1],\n            'geometry': geometry,\n            'distance': leg.distance,\n            'service_id': leg.route.transit.get('transitLineId'),\n            'route_id': leg.route.transit.get('transitRouteId'),\n            'o_stop': leg.route.transit.get('accessFacilityId'),\n            'd_stop': leg.route.transit.get('egressFacilityId'),\n            'network_route': leg.route.network_route,\n        }\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\", category=ShapelyDeprecationWarning)\n            df = df.append(pd.Series(_leg_dict), ignore_index=True)\n\n    df['pid'] = person.pid\n    df = GeoDataFrame(df, geometry='geometry')\n    if from_epsg:\n        df.crs = from_epsg\n        if to_epsg:\n            df = df.to_crs(to_epsg)\n\n    return df\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.build_plan_df","title":"<code>build_plan_df(plan, pid = 'sample')</code>","text":"<p>Loop through a plan, creating a pandas dataframe defining activities for plotting.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def build_plan_df(plan, pid='sample'):\n\"\"\"\n    Loop through a plan, creating a pandas dataframe defining activities for plotting.\n    \"\"\"\n    data = {\n        \"act\" : [],\n        \"modes\": [],\n        \"start_time\": [],\n        \"end_time\": [],\n        \"dur\": [],\n    }\n    for component in plan.day:\n        data[\"act\"].append(component.act.lower().title())\n        if isinstance(component, activity.Leg) and component.mode is not None:\n            data[\"modes\"].append(component.mode.lower().title())\n        else:\n            data[\"modes\"].append(None)\n        data[\"start_time\"].append(component.start_time.hour + component.start_time.minute/60)\n        data[\"end_time\"].append(component.end_time.hour + component.end_time.minute/60)\n        data[\"dur\"].append(component.duration.total_seconds()/3600)\n    df = pd.DataFrame(data)\n    df['pid'] = pid\n\n    return df\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.build_rgb_travel_cmap","title":"<code>build_rgb_travel_cmap(df, colour_by)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def build_rgb_travel_cmap(df, colour_by):\n    colors = [(int(tup[0]*255), int(tup[1]*255), int(tup[2]*255)) for tup in plt.cm.Set3.colors[::-1]]\n    colour_by_unique = df[colour_by].unique()\n    # repeat colours if unique items &gt; 12\n    len_factor = (len(colour_by_unique) // len(colors)) + 1\n    d_color = dict(zip(colour_by_unique, colors*len_factor))\n    return d_color\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_activities","title":"<code>plot_activities(df, **kwargs)</code>","text":"<p>Plot activity plans from pandas dataframe.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_activities(df, **kwargs):\n\"\"\"\n    Plot activity plans from pandas dataframe.\n    \"\"\"\n    if \"cmap\" not in kwargs:\n        cmap = build_cmap(df)\n    else:\n        cmap=kwargs[\"cmap\"]\n\n    df['color'] = df['act'].map(cmap)\n    pids = df['pid'].unique()\n\n    fig, axs = plt.subplots(\n        len(pids), 1,\n        figsize=(\n            16,\n            3 + (1 * (len(pids)-1))  # fudge to keep proportions about right\n            ),\n        sharex=True\n        )\n\n    for idx, pid in enumerate(pids):\n        person_data = df.loc[df.pid == pid]\n        label_x, label_y, labels = [], [], []\n\n        if len(pids) == 1:\n            ax = axs\n        else:\n            ax = axs[idx]\n\n        for i in range(len(person_data)):\n            y = 1\n            data = person_data.iloc[i]\n            ax.barh(y,\n                    width='dur',\n                    data=data,\n                    left='start_time',\n                    label='act',\n                    color='color',\n                    edgecolor='black',\n                    linewidth=2\n                )\n\n            #Populate Labelling Params\n            label_x.append(data['start_time'] + data['dur'] / 2)\n            label_y.append(y)\n            labels.append(data.act)\n\n        # Labels\n        rects = ax.patches\n        for x, y, rect, label in zip(label_x, label_y, rects, labels):\n            if label == 'Travel':\n                color = 'white'\n            else:\n                color = 'black'\n\n            if rect.get_width() &gt;= 2:\n                ax.text(x, y, label, ha='center', va='center',\n                        fontdict={\n                            'color':color, 'size':10, 'weight':'regular'\n                            }\n                            )\n                continue\n            if rect.get_width() &gt;= .5:\n                ax.text(x, y, label, ha='center', va='center',\n                        fontdict={\n                            'color':color, 'size':10, 'weight':'regular', 'rotation':90\n                            }\n                            )\n\n        ax.set_title(f\"Person ID: {pid}\")\n        ax.get_yaxis().set_visible(False)\n        for side in ['top', 'right', 'bottom', 'left']:\n            ax.spines[side].set_visible(False)\n\n    if kwargs.get(\"legend\", True) == True:\n        legend_elements = []\n        for act, color in cmap.items():\n            legend_elements.append(\n                Patch(facecolor=color, edgecolor='black', label=act)\n            )\n        plt.legend(\n            handles=legend_elements, ncol=len(legend_elements),\n            prop={'size':12}, frameon=False,\n            bbox_to_anchor=(.5, -.5), loc='upper center', borderaxespad=0.\n            )\n\n    plt.xticks(range(25))\n    plt.xlim(right=24)\n\n    plt.tight_layout()\n\n    if kwargs.get(\"path\") is not None:\n        plt.savefig(kwargs[\"path\"])\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_activity_breakdown_area","title":"<code>plot_activity_breakdown_area(plans: List[Plan], activity_classes: Optional[List[str]] = None, plans_encoder: Optional[List[str]] = None, normalize: bool = False, legend: bool = True, ax: bool = None, colormap: bool = 'tab20')</code>","text":"<p>Area plot of the breakdown of activities taking place every minute.</p> <p>:param plans: A list of PAM plans :param activity_classes: A list of the activity labels. :param encoder: Alternative to passing activity_classes:      a PlansEncoder from pam.planner.encode. :param normalize: Whether to convert the y-axis to perncentages. :param legend: Whether to include the legend of activities in the plot: :param ax: A matplotlib axis. :param colormap: The colormap to use in the plot.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_activity_breakdown_area(\n        plans: List[Plan],\n        activity_classes: Optional[List[str]] = None,\n        plans_encoder = None,\n        normalize: bool = False,\n        legend: bool = True,\n        ax = None,\n        colormap = 'tab20'\n):\n\"\"\"\n    Area plot of the breakdown of activities taking place every minute.\n\n    :param plans: A list of PAM plans\n    :param activity_classes: A list of the activity labels.\n    :param encoder: Alternative to passing activity_classes: \n        a PlansEncoder from pam.planner.encode.\n    :param normalize: Whether to convert the y-axis to perncentages.\n    :param legend: Whether to include the legend of activities in the plot:\n    :param ax: A matplotlib axis.\n    :param colormap: The colormap to use in the plot. \n\n    \"\"\"\n    if activity_classes is not None:\n        plans_encoder = encoder.PlansOneHotEncoder(\n            activity_classes=activity_classes)\n    elif plans_encoder is None:\n        raise ValueError('Please provide a list of activity classes or a plans encoder.')\n\n    labels = plans_encoder.plan_encoder.activity_encoder.labels\n    freqs = plans_encoder.encode(plans).\\\n        sum(axis=0)\n\n    if normalize:\n        freqs = freqs.astype(float) / freqs.sum(0)\n\n    if ax is None:\n        fig, ax = plt.subplots(1, 1)\n\n    n_labels = len(labels)\n    cmap = cm.get_cmap(colormap, n_labels)\n    colors = [cmap(x) for x in range(n_labels)]\n\n    ax.stackplot(range(freqs.shape[1]), *freqs, colors=colors)\n\n    if legend:\n        ax.legend(labels, loc='lower left',\n                    bbox_to_anchor=(1.0, 0), frameon=False)\n\n    if normalize:\n        ax.yaxis.set_major_formatter(\n            mtick.FuncFormatter(lambda x, _: '{:.0%}'.format(x))\n        )\n\n    ax.set_xlim(0, freqs.shape[1])\n    ax.set_ylim(0, freqs.sum(0).max())\n\n    return ax\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_activity_breakdown_area_tiles","title":"<code>plot_activity_breakdown_area_tiles(plans: Dict[List[Plan]], activity_classes: List[str], figsize: List[str] = (10, 8), **kwargs: List[str])</code>","text":"<p>Tiled area plot of the breakdown of activities taking place every minute.</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_activity_breakdown_area_tiles(\n        plans: Dict[List[Plan]],\n        activity_classes: List[str],\n        figsize=(10, 8),\n        **kwargs\n    ):\n\"\"\"\n    Tiled area plot of the breakdown of activities taking place every minute.\n    \"\"\"\n    plans_encoder = encoder.PlansOneHotEncoder(\n        activity_classes=activity_classes)\n    labels = plans_encoder.plan_encoder.activity_encoder.labels\n    nrows = int(np.ceil(len(plans)/2))\n    irow = 0\n    icol = 0\n    fig, axs = plt.subplots(nrows, 2, figsize=figsize,\n                            sharex=True, sharey=True)\n    fig.tight_layout(pad=2)\n    for k, v in plans.items():\n        n = len(v)\n        if nrows&gt;1:\n            ax = axs[irow, icol]\n        else:\n            ax = axs[icol]\n        print(ax)\n        plot_activity_breakdown_area(\n            plans=v, ax=ax, legend=False, normalize=True, \n            plans_encoder=plans_encoder, **kwargs)\n        ax.set_title(f'Cluster {k} - {n} plans')\n        irow += icol\n        icol = (icol+1) % 2\n\n    ax.legend(labels, loc='lower left',\n                bbox_to_anchor=(1.0, 0), frameon=False)\n\n    return axs\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_household","title":"<code>plot_household(household, **kwargs)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_household(household, **kwargs):\n    df = pd.concat([build_person_df(person) for person in household.people.values()])\n    plot_activities(df, **kwargs)\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_person","title":"<code>plot_person(person, **kwargs)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_person(person, **kwargs):\n    df = build_person_df(person)\n    plot_activities(df, **kwargs)\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_persons","title":"<code>plot_persons(persons, kwargs = None)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_persons(persons, kwargs=None):\n    df = pd.concat([build_person_df(person) for person in persons])\n    plot_activities(df, **kwargs)\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_plan","title":"<code>plot_plan(plan, kwargs = None)</code>","text":"Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_plan(plan, kwargs=None):\n    df = build_plan_df(plan)\n    if kwargs is not None:\n        plot_activities(df, **kwargs)\n    else:\n        plot_activities(df)\n</code></pre>"},{"location":"api/plot/plans/#pam.plot.plans.plot_travel_plans","title":"<code>plot_travel_plans(gdf, groupby: list = None, colour_by: str = 'mode', cmap: dict = None, mapbox_access_token: str = '')</code>","text":"<p>Uses plotly's Scattermapbox to plot travel GeoDataFrame :param gdf: geopandas.GeoDataFrame generated by build_person_travel_geodataframe :param groupby: optional argument for splitting traces in the plot :param colour_by: argument for specifying what the colour should correspond to in the plot, travel mode by default :param cmap: optional argument, useful to pass if generating a number of plots and want to keep colour scheme consistent :param mapbox_access_token: required to generate the plot https://docs.mapbox.com/help/how-mapbox-works/access-tokens/ :return:</p> Source code in <code>pam/plot/plans.py</code> <pre><code>def plot_travel_plans(gdf, groupby: list = None, colour_by: str = 'mode', cmap: dict = None,\n                      mapbox_access_token: str = ''):\n\"\"\"\n    Uses plotly's Scattermapbox to plot travel GeoDataFrame\n    :param gdf: geopandas.GeoDataFrame generated by build_person_travel_geodataframe\n    :param groupby: optional argument for splitting traces in the plot\n    :param colour_by: argument for specifying what the colour should correspond to in the plot, travel mode by default\n    :param cmap: optional argument, useful to pass if generating a number of plots and want to keep colour scheme\n    consistent\n    :param mapbox_access_token: required to generate the plot\n    https://docs.mapbox.com/help/how-mapbox-works/access-tokens/\n    :return:\n    \"\"\"\n    if not mapbox_access_token:\n        raise Warning('You need to pass `mapbox_access_token` for the plot to appear.')\n    _gdf = gdf.copy()\n    _gdf['start_time'] = _gdf['start_time'].dt.strftime('%H:%M:%S')\n    _gdf['end_time'] = _gdf['end_time'].dt.strftime('%H:%M:%S')\n    _gdf['seq'] = _gdf['seq'].astype(int)\n\n    if cmap is None:\n        cmap = build_rgb_travel_cmap(gdf, colour_by)\n\n    data = []\n    all_coords = []\n\n    if groupby is None:\n        groupby = []\n    for name, group in _gdf.groupby([colour_by] + groupby):\n        if len(groupby) &gt; 0:\n            colour_by_item = name[0]\n        else:\n            colour_by_item = name\n        colour = 'rgb({},{},{})'.format(cmap[colour_by_item][0], cmap[colour_by_item][1], cmap[colour_by_item][2])\n\n        lat = []\n        lon = []\n        hovertext = []\n        for idx in group.index:\n            coords = group.loc[idx, 'geometry'].coords\n            all_coords.extend(coords)\n            lat = lat + [point[1] for point in coords] + [float('nan')]\n            lon = lon + [point[0] for point in coords] + [float('nan')]\n            _hovertext = [''] * (len(coords) + 1)\n            _hovertext[0] = 'pid: {}&lt;br&gt;start time: {}&lt;br&gt;trip seq: {}&lt;br&gt;mode: {}'.format(\n                group.loc[idx, 'pid'], group.loc[idx, 'start_time'], group.loc[idx, 'seq'], group.loc[idx, 'mode'])\n            _hovertext[-2] = 'pid: {}&lt;br&gt;end time: {}&lt;br&gt;trip seq: {}&lt;br&gt;mode: {}'.format(\n                group.loc[idx, 'pid'], group.loc[idx, 'end_time'], group.loc[idx, 'seq'], group.loc[idx, 'mode'])\n            hovertext = hovertext + _hovertext\n\n        data.append(go.Scattermapbox(\n            lat=lat,\n            lon=lon,\n            hovertext=hovertext,\n            hoverinfo='text',\n            mode='lines+markers',\n            marker=dict(\n                size=10,\n                color=colour,\n                opacity=0.75\n            ),\n            line=dict(\n                color=colour\n            ),\n            name='{}'.format(name)\n        ))\n\n    if all_coords:\n        c_lat = sum([point[1] for point in all_coords]) / len(all_coords)\n        c_lon = sum([point[0] for point in all_coords]) / len(all_coords)\n    else:\n        c_lat = 0\n        c_lon = 0\n\n    layout = go.Layout(\n        title='',\n        autosize=True,\n        hovermode='closest',\n        mapbox=go.layout.Mapbox(\n            accesstoken=mapbox_access_token,\n            bearing=0,\n            center=go.layout.mapbox.Center(\n                lat=c_lat,\n                lon=c_lon\n            ),\n            pitch=0,\n            zoom=10,\n            style='dark'\n        )\n    )\n    fig = go.Figure(data=data, layout=layout)\n    return fig\n</code></pre>"},{"location":"api/optimise/grid/","title":"pam.optimise.grid","text":""},{"location":"api/optimise/grid/#pam.optimise.grid.Recorder","title":"<code>Recorder(initial_score, initial_plan) -&gt; None</code>","text":"Source code in <code>pam/optimise/grid.py</code> <pre><code>def __init__(self, initial_score, initial_plan) -&gt; None:\n    self.best_plan = initial_plan\n    self.best_score = initial_score\n</code></pre>"},{"location":"api/optimise/grid/#pam.optimise.grid.Recorder.best_plan","title":"<code>best_plan = initial_plan</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/grid/#pam.optimise.grid.Recorder.best_score","title":"<code>best_score = initial_score</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/grid/#pam.optimise.grid.Recorder.update","title":"<code>update(score, plan)</code>","text":"Source code in <code>pam/optimise/grid.py</code> <pre><code>def update(self, score, plan):\n    if score &gt;= self.best_score:\n        self.best_score = score\n        self.best_plan = deepcopy(plan)\n</code></pre>"},{"location":"api/optimise/grid/#pam.optimise.grid.grid_search","title":"<code>grid_search(plan: Plan, plans_scorer: Plan = CharyparNagelPlanScorer, config: dict = {}, step: int = 300)</code>","text":"Source code in <code>pam/optimise/grid.py</code> <pre><code>def grid_search(\n    plan: Plan,\n    plans_scorer = CharyparNagelPlanScorer,\n    config : dict = {},\n    step : int = 300,\n    ):\n    best_score = plans_scorer.score_plan(plan, config)\n    recorder = Recorder(best_score, plan)\n\n    traverse(\n        scorer = plans_scorer,\n        config = config,\n        plan = plan,\n        earliest=0,\n        step=step,\n        leg_index=0,\n        recorder=recorder\n        )\n\n    return recorder.best_score, recorder.best_plan\n</code></pre>"},{"location":"api/optimise/grid/#pam.optimise.grid.latest_start_time","title":"<code>latest_start_time(plan, leg_index)</code>","text":"Source code in <code>pam/optimise/grid.py</code> <pre><code>def latest_start_time(plan, leg_index):\n    allowance = 24*60*60\n    for c in plan[leg_index*2 + 1::2]:\n        allowance -= c.duration.seconds\n    return allowance\n</code></pre>"},{"location":"api/optimise/grid/#pam.optimise.grid.traverse","title":"<code>traverse(scorer, config, plan, step, earliest, leg_index, recorder)</code>","text":"Source code in <code>pam/optimise/grid.py</code> <pre><code>def traverse(scorer, config, plan, step, earliest, leg_index, recorder):\n\n    if leg_index*2+1 == len(plan):\n        recorder.update(scorer.score_plan(plan, cnfg=config), plan)\n        return None\n\n    latest = latest_start_time(plan, leg_index)\n    for start in range(earliest, latest+step, step):\n        activity = plan[leg_index*2]\n        leg = plan[leg_index*2+1]\n        next_activity = plan[leg_index*2+2]\n        activity.end_time = activity.start_time + timedelta(seconds=start)\n        leg.end_time = leg.shift_start_time(activity.end_time)\n        next_activity.start_time = leg.end_time\n\n        traverse(\n            scorer = scorer,\n            config = config,\n            plan = plan,\n            earliest = start + plan[leg_index*2+1].duration.seconds,\n            leg_index = leg_index+1,\n            step = step,\n            recorder=recorder\n            )\n</code></pre>"},{"location":"api/optimise/random/","title":"pam.optimise.random","text":""},{"location":"api/optimise/random/#pam.optimise.random.Stopper","title":"<code>Stopper(horizon = 5, sensitivity = 0.01) -&gt; None</code>","text":"Source code in <code>pam/optimise/random.py</code> <pre><code>def __init__(self, horizon=5, sensitivity=0.01) -&gt; None:\n    self.record = []\n    self.horizon = horizon\n    self.sensitivity=sensitivity\n</code></pre>"},{"location":"api/optimise/random/#pam.optimise.random.Stopper.horizon","title":"<code>horizon = horizon</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/random/#pam.optimise.random.Stopper.record","title":"<code>record = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/random/#pam.optimise.random.Stopper.sensitivity","title":"<code>sensitivity = sensitivity</code>  <code>instance-attribute</code>","text":""},{"location":"api/optimise/random/#pam.optimise.random.Stopper.ok","title":"<code>ok(score)</code>","text":"Source code in <code>pam/optimise/random.py</code> <pre><code>def ok(self, score):\n    self.record.append(score)\n    if len(self.record) &gt; self.horizon:\n        self.record.pop(0)\n        if self.record[-1] - self.record[0] &lt; self.sensitivity:\n            print(\"Stopping early\")\n            return False\n    return True\n</code></pre>"},{"location":"api/optimise/random/#pam.optimise.random.random_mutate_activity_durations","title":"<code>random_mutate_activity_durations(plan: Plan, copy: Plan = True)</code>","text":"Source code in <code>pam/optimise/random.py</code> <pre><code>def random_mutate_activity_durations(plan: Plan, copy=True):\n    allowance = 24*60*60  # seconds\n    for leg in plan.legs:\n        allowance -= leg.duration.total_seconds()\n    n_activities = len(list(plan.activities))\n    activity_durations = [timedelta(seconds=int(random.random() * allowance / n_activities)) for n in range(n_activities)]\n    if copy:\n        plan = deepcopy(plan)\n    time = plan.day[0].shift_duration(new_duration=activity_durations.pop(0))\n    idx = 1\n    for activity_duration, leg_duration in zip(activity_durations, [leg.duration for leg in plan.legs]):\n        time = plan.day[idx].shift_duration(new_start_time=time, new_duration=leg_duration)\n        time = plan.day[idx+1].shift_duration(new_start_time=time, new_duration=activity_duration)\n        idx += 2\n    plan.day[-1].end_time = END_OF_DAY\n    return plan\n</code></pre>"},{"location":"api/optimise/random/#pam.optimise.random.reschedule","title":"<code>reschedule(plan: Plan, plans_scorer: Plan = CharyparNagelPlanScorer, config: dict = {}, horizon: int = 5, sensitivity: float = 0.01, patience: int = 1000)</code>","text":"Source code in <code>pam/optimise/random.py</code> <pre><code>def reschedule(\n    plan: Plan,\n    plans_scorer = CharyparNagelPlanScorer,\n    config : dict = {},\n    horizon : int = 5,\n    sensitivity : float = 0.01,\n    patience : int = 1000\n    ):\n    best_score = plans_scorer.score_plan(plan, config)\n    print(f\"Initial best score at iteration 0: {best_score}\")\n    best_scores = {0:best_score}\n    stopper = Stopper(horizon=horizon ,sensitivity=sensitivity)\n    for n in range(patience):\n        proposed_plan = random_mutate_activity_durations(plan, copy=True)\n        score = plans_scorer.score_plan(proposed_plan, config)\n        if score &gt; best_score:\n            print(f\"New best score at iteration {n}: {score}\")\n            best_scores[n] = score\n            best_score = score\n            plan = proposed_plan\n            if not stopper.ok(score):\n                return plan, best_scores \n    return plan, best_scores \n</code></pre>"},{"location":"api/array/encode/","title":"pam.array.encode","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical","title":"<code>PlansToCategorical(bin_size: int = 3600, duration: int = 86400) -&gt; None</code>","text":"<p>Tool for converting pam.core.plans to integer arrays, eg: |&lt;----A----&gt;||&lt;----B----&gt;||||&lt;----A----&gt;| =&gt; [0,0,0,1,1,1,2,0,0,0] Where 0 represends a time bin of activity A, 1 of B and so on. The axis represents time, binnned according to bin_size and total duration, both given in seconds. A mapping between the array values (indexes) and plan activities can be accessed via self.index_to_act and self.act_to_index. Note that Leg components will have the encoding \"travel\" which will be included in the mapping. Location and mode information is lost. Some plan components may be lost if their durations are less than the chosen bin six. Plan components beyond 24 hours are cropped. <p>:param int bin_size: description, defaults to 3600 :param int duration: description, defaults to 86400</p> Source code in <code>pam/array/encode.py</code> <pre><code>def __init__(\n    self,\n    bin_size:int=3600,\n    duration:int=86400\n) -&gt; None:\n\"\"\"\n    Tool for converting pam.core.plans to integer arrays, eg:\n    |&lt;----A----&gt;||&lt;----B----&gt;||&lt;C&gt;||&lt;----A----&gt;|\n    =&gt; [0,0,0,1,1,1,2,0,0,0]\n    Where 0 represends a time bin of activity A, 1 of B and so on.\n    The axis represents time, binnned according to bin_size and total duration, both\n    given in seconds.\n    A mapping between the array values (indexes) and plan activities can be accessed\n    via self.index_to_act and self.act_to_index.\n    Note that Leg components will have the encoding \"travel\" which will be included\n    in the mapping. Location and mode information is lost. Some plan components may\n    be lost if their durations are less than the chosen bin six. Plan components\n    beyond 24 hours are cropped.\n\n    :param int bin_size: _description_, defaults to 3600\n    :param int duration: _description_, defaults to 86400\n    \"\"\"\n    self.bin_size = bin_size\n    self.duration = duration\n    self.bins = int(self.duration / self.bin_size)\n    self.index_to_act = {}\n    self.act_to_index = {}\n</code></pre>"},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.act_to_index","title":"<code>act_to_index = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.bin_size","title":"<code>bin_size = bin_size</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.bins","title":"<code>bins = int(self.duration / self.bin_size)</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.duration","title":"<code>duration = duration</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.index_to_act","title":"<code>index_to_act = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.encode","title":"<code>encode(plan: Plan) -&gt; np.array</code>","text":"<p>Transform a pam.activity.Plan into a categorical integer array.</p> <p>Parameters:</p> Name Type Description Default <code>plan</code> <code>Plan</code> <p>input Plan object to be encoded as one-hot</p> required <p>Returns:</p> Type Description <code>np.array</code> <p>np.array: encoded plan</p> Source code in <code>pam/array/encode.py</code> <pre><code>def encode(\n    self,\n    plan: Plan,\n    ) -&gt; np.array:\n\"\"\"\n    Transform a pam.activity.Plan into a categorical integer array.\n\n    Args:\n        plan (Plan): input Plan object to be encoded as one-hot\n\n    Returns:\n        np.array: encoded plan\n    \"\"\"\n\n    encoded = np.zeros((self.bins))\n    start_bin = 0\n    reference_time = plan.day[0].start_time\n    for component in plan.day:\n        act = component.act\n        if act not in self.act_to_index:\n            index = len(self.act_to_index)\n            self.act_to_index[act] = index\n            self.index_to_act[index] = act\n        index = self.act_to_index[act]\n        end_bin = round(td_to_s(component.end_time - reference_time) / self.bin_size)\n\n        if end_bin &gt;= self.duration:  # deal with last component\n            end_bin = self.duration\n            encoded[start_bin:end_bin] = index\n            break\n\n        encoded[start_bin:end_bin] = index\n        start_bin = end_bin\n\n    return encoded\n</code></pre>"},{"location":"api/array/encode/#pam.array.encode.PlansToCategorical.get_act","title":"<code>get_act(index)</code>","text":"Source code in <code>pam/array/encode.py</code> <pre><code>def get_act(self, index):\n    return self.index_to_act.get(index)\n</code></pre>"},{"location":"api/array/encode/#pam.array.encode.plan_to_one_hot","title":"<code>plan_to_one_hot(plan: Plan, mapping: dict, bin_size: int = 3600, duration: int = 86400) -&gt; np.array</code>","text":"<p>Transform a pam.activity.Plan into a one-hot encoded array. Output array is two dimensional. First axis represents time, binnned according to bin_size given in seconds. Seconds axis is a one-hot endcoding of activity type based on the given mapping. Note that Leg components will have the encoding \"travel\" which should be included in the mapping. Location and mode information is lost. Some plan components may be lost if their durations are less than the chosen bin six. Plan components beyond 24 hours are cropped.</p> <p>Parameters:</p> Name Type Description Default <code>plan</code> <code>Plan</code> <p>input Plan object to be encoded as one-hot</p> required <code>mapping</code> <code>dict</code> <p>dictionary mapping of activity types to one-hot index, eg {\"home\":0, \"travel\":1}</p> required <code>bin_size</code> <code>int</code> <p>time bin size (in seconds). Defaults to 3600.</p> <code>3600</code> <code>duration</code> <code>int</code> <p>day_duration (in seconds). Defaults to 86400.</p> <code>86400</code> <p>Returns:</p> Type Description <code>np.array</code> <p>np.array: one-hot encoded plan</p> Source code in <code>pam/array/encode.py</code> <pre><code>def plan_to_one_hot(\n    plan: Plan,\n    mapping:dict,\n    bin_size:int=3600,\n    duration:int=86400\n    ) -&gt; np.array:\n\"\"\"\n    Transform a pam.activity.Plan into a one-hot encoded array. Output array is two dimensional.\n    First axis represents time, binnned according to bin_size given in seconds.\n    Seconds axis is a one-hot endcoding of activity type based on the given mapping. Note that Leg\n    components will have the encoding \"travel\" which should be included in the mapping. Location and\n    mode information is lost. Some plan components may be lost if their durations are less than\n    the chosen bin six. Plan components beyond 24 hours are cropped.\n\n    Args:\n        plan (Plan): input Plan object to be encoded as one-hot\n        mapping (dict): dictionary mapping of activity types to one-hot index, eg {\"home\":0, \"travel\":1}\n        bin_size (int, optional): time bin size (in seconds). Defaults to 3600.\n        duration (int, optional): day_duration (in seconds). Defaults to 86400.\n\n    Returns:\n        np.array: one-hot encoded plan\n    \"\"\"\n    bins = int(duration / bin_size)\n    encoded = np.zeros((bins,len(mapping)))\n\n    start_bin = 0\n    reference_time = plan.day[0].start_time\n    for component in plan.day:\n        index = mapping.get(component.act, None)\n        end_bin = round(td_to_s(component.end_time - reference_time) / bin_size)\n\n        if end_bin &gt;= duration:  # deal with last component\n            end_bin = duration\n            encoded[start_bin:end_bin, index] = 1.0\n            break\n\n        encoded[start_bin:end_bin, index] = 1.0\n        start_bin = end_bin\n\n    return encoded\n</code></pre>"},{"location":"api/array/distance/","title":"pam.array.distance","text":""},{"location":"api/array/distance/#pam.array.distance.accuracy","title":"<code>accuracy(actual: np.array, predicted: np.array) -&gt; float</code>","text":"Source code in <code>pam/array/distance.py</code> <pre><code>def accuracy(actual:np.array, predicted:np.array) -&gt; float:\n    assert actual.shape == predicted.shape\n    correct = 0\n    for ia, ib in zip(actual, predicted):\n        if np.argmax(ia) == np.argmax(ib):\n            correct += 1\n    return correct / len(predicted)\n</code></pre>"},{"location":"api/array/distance/#pam.array.distance.cross_entropy","title":"<code>cross_entropy(actual: np.array, predicted: np.array) -&gt; float</code>","text":"Source code in <code>pam/array/distance.py</code> <pre><code>def cross_entropy(actual:np.array, predicted:np.array) -&gt; float:\n    assert actual.shape == predicted.shape\n    epsilon = 1e-12\n    predicted = np.clip(predicted, epsilon, 1. - epsilon)\n    return -np.sum(actual * np.log(predicted)) / actual.shape[0]\n</code></pre>"},{"location":"api/array/decode/","title":"pam.array.decode","text":""},{"location":"api/array/decode/#pam.array.decode.add_end_times","title":"<code>add_end_times(plan: list, end_of_day: list = END_OF_DAY)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def add_end_times(plan:list, end_of_day=END_OF_DAY):\n    # add end_times\n    for i in range(len(plan)-1):\n        plan[i].end_time = plan[i+1].start_time\n    plan[-1].end_time = end_of_day\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.fix_missing_components","title":"<code>fix_missing_components(plan: list, bin_size: list = 3600, default_leg_mode: list = 'car', default_activity: list = 'other')</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def fix_missing_components(plan:list, bin_size=3600, default_leg_mode=\"car\", default_activity=\"other\"):\n    for i in range(len(plan)-1):\n        if type(plan[i]) is type(plan[i+1]):\n            start_time = plan[i].end_time - timedelta(seconds=int(bin_size/4))\n            end_time = plan[i].end_time + timedelta(seconds=int(bin_size/4))\n\n            if isinstance(plan[i], Activity):  # add missing Leg\n                plan.insert(\n                    i+1,\n                    Leg(\n                        mode=default_leg_mode,\n                        start_time=start_time,\n                        end_time=end_time\n                    )\n                )\n                plan[i].end_time = start_time\n                plan[i+2].start_time = end_time\n\n            if isinstance(plan[i], Leg):  # add missing Activity\n                plan.insert(\n                    i+1,\n                    Activity(\n                        act=default_activity,\n                        start_time=start_time,\n                        end_time=end_time\n                    )\n                )\n                plan[i].end_time = start_time\n                plan[i+2].start_time = end_time\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.fix_missing_end_activity","title":"<code>fix_missing_end_activity(plan: list, end_of_day: list = END_OF_DAY, bin_size: list = 3600)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def fix_missing_end_activity(plan:list, end_of_day=END_OF_DAY, bin_size=3600):\n    if not isinstance(plan[-1], Activity):\n        start_time = end_of_day - timedelta(seconds=int(bin_size/2))  # expected duration\n        plan.append(\n            Activity(\n                act=\"home\",  # sensible assumption\n                start_time=start_time,\n                end_time=end_of_day\n            ))\n        plan[-2].end_time = start_time\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.fix_missing_start_activity","title":"<code>fix_missing_start_activity(plan: list, start_of_day: list = START_OF_DAY, bin_size: list = 3600)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def fix_missing_start_activity(plan:list, start_of_day=START_OF_DAY, bin_size=3600):\n    if not isinstance(plan[0], Activity):\n        end_time = start_of_day + timedelta(seconds=int(bin_size/2))  # expected duration\n        plan.insert(\n            0,\n            Activity(\n                act=\"home\",  # sensible assumption\n                start_time=start_of_day,\n                end_time=end_time\n            ))\n        plan[1].start_time = end_time\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.iter_array","title":"<code>iter_array(array, mapping, start_of_day = START_OF_DAY, bin_size = 3600)</code>","text":"Source code in <code>pam/array/decode.py</code> <pre><code>def iter_array(array, mapping, start_of_day=START_OF_DAY, bin_size=3600):\n    prev = None\n    for i, time_bin in enumerate(array):\n        if (prev is None) or (not np.array_equal(time_bin, prev)):  # new component class\n            component_class = mapping.get(np.argmax(time_bin))\n            if component_class is None:\n                raise UserWarning(f\"Not found index of {np.argmax(time_bin)} in supplied mapping: {mapping}.\")\n            yield component_class, start_of_day + timedelta(seconds=(i * bin_size))\n        prev = time_bin\n</code></pre>"},{"location":"api/array/decode/#pam.array.decode.one_hot_to_plan","title":"<code>one_hot_to_plan(array: np.array, mapping: dict, bin_size: int = 3600, duration: int = 86400, start_of_day: datetime = START_OF_DAY, end_of_day: datetime = END_OF_DAY, leg_encoding: str = 'travel', default_leg_mode: str = 'car', default_activity: str = 'other') -&gt; Plan</code>","text":"<p>Decode a one-hot encoded plan array for a given mapping. Attempts to create a valid plan sequence by assuming obviously missing components. Does not support locations, these must be created manually.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.array</code> <p>input one-hot encoded plan.</p> required <code>mapping</code> <code>dict</code> <p>encoding index to activity, eg {0: 'home', 1:'travel'}.</p> required <code>bin_size</code> <code>int</code> <p>in seconds. Defaults to 3600.</p> <code>3600</code> <code>duration</code> <code>int</code> <p>in seconds. Defaults to 86400.</p> <code>86400</code> <code>start_of_day</code> <code>datetime</code> <p>start datetime of first activity. Defaults to START_OF_DAY.</p> <code>START_OF_DAY</code> <code>end_of_day</code> <code>datetime</code> <p>end time of last activity. Defaults to END_OF_DAY.</p> <code>END_OF_DAY</code> <code>leg_encoding</code> <code>str</code> <p>activity encoding for travel components. Defaults to \"travel\".</p> <code>'travel'</code> <code>default_leg_mode</code> <code>str</code> <p>assumed leg mode when unknown. Defaults to \"car\".</p> <code>'car'</code> <code>default_activity</code> <code>str</code> <p>assumed activity when unknown. Defaults to \"other\".</p> <code>'other'</code> <p>Raises:</p> Type Description <code>UserWarning</code> <p>may raise a UserWarning if bin_size and duration are not consistent with array size.</p> <p>Returns:</p> Name Type Description <code>Plan</code> <code>Plan</code> <p>pam.activity.Plan</p> Source code in <code>pam/array/decode.py</code> <pre><code>def one_hot_to_plan(\n    array:np.array,\n    mapping:dict,\n    bin_size:int=3600,\n    duration:int=86400,\n    start_of_day:datetime=START_OF_DAY,\n    end_of_day:datetime=END_OF_DAY,\n    leg_encoding:str=\"travel\",\n    default_leg_mode:str=\"car\",\n    default_activity:str=\"other\"\n    ) -&gt; Plan:\n\"\"\"\n    Decode a one-hot encoded plan array for a given mapping. Attempts to create a valid plan sequence\n    by assuming obviously missing components. Does not support locations, these must be created\n    manually.\n\n    Args:\n        array (np.array): input one-hot encoded plan.\n        mapping (dict): encoding index to activity, eg {0: 'home', 1:'travel'}.\n        bin_size (int, optional): in seconds. Defaults to 3600.\n        duration (int, optional): in seconds. Defaults to 86400.\n        start_of_day (datetime, optional): start datetime of first activity. Defaults to START_OF_DAY.\n        end_of_day (datetime, optional): end time of last activity. Defaults to END_OF_DAY.\n        leg_encoding (str, optional): activity encoding for travel components. Defaults to \"travel\".\n        default_leg_mode (str, optional): assumed leg mode when unknown. Defaults to \"car\".\n        default_activity (str, optional): assumed activity when unknown. Defaults to \"other\".\n\n    Raises:\n        UserWarning: may raise a UserWarning if bin_size and duration are not consistent with array size.\n\n    Returns:\n        Plan: pam.activity.Plan\n    \"\"\"\n    bins = int(duration / bin_size)\n    if not len(array) == bins:\n        raise UserWarning(\"Specified plan duration and bin lengths do not match given array length.\")\n\n    proposed_plan = []\n    for act, start_time in iter_array(\n        array=array,\n        mapping=mapping,\n        start_of_day=start_of_day,\n        bin_size=bin_size\n        ):\n        if act == leg_encoding:  # add leg\n            proposed_plan.append(Leg(mode=default_leg_mode, start_time=start_time))\n        else:\n            proposed_plan.append(Activity(act=act, start_time=start_time))\n\n    add_end_times(proposed_plan, end_of_day)\n    fix_missing_start_activity(proposed_plan, start_of_day, bin_size)\n    fix_missing_end_activity(proposed_plan, end_of_day, bin_size)\n    fix_missing_components(proposed_plan, default_leg_mode, default_activity)\n\n    plan = Plan()\n    plan.day = proposed_plan\n    return plan\n</code></pre>"},{"location":"api/planner/od/","title":"pam.planner.od","text":"<p>Manages origin-destination data required by the planner module.</p>"},{"location":"api/planner/od/#pam.planner.od.Labels","title":"<code>Labels</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Data labels for the origin-destination dataset</p>"},{"location":"api/planner/od/#pam.planner.od.Labels.destination_zones","title":"<code>destination_zones: List</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.Labels.mode","title":"<code>mode: List</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.Labels.origin_zones","title":"<code>origin_zones: List</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.Labels.vars","title":"<code>vars: List</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.OD","title":"<code>OD(data: np.ndarray, labels: Union[Labels, List, dict]) -&gt; None</code>","text":"<p>Holds origin-destination matrices for a number of modes and variables.</p> <p>:param data: A multi-dimensional numpy array of the origin-destination data.     - First dimension: variable (ie travel time, distance, etc)     - Second dimension: origin zone     - Third dimension: destination zone     - Fourth dimension: mode (ie car, bus, etc)</p> Source code in <code>pam/planner/od.py</code> <pre><code>def __init__(\n    self,\n    data: np.ndarray,\n    labels: Union[Labels, List, dict]\n) -&gt; None:\n\"\"\"\n    :param data: A multi-dimensional numpy array of the origin-destination data.\n        - First dimension: variable (ie travel time, distance, etc)\n        - Second dimension: origin zone\n        - Third dimension: destination zone\n        - Fourth dimension: mode (ie car, bus, etc)\n    \"\"\"\n    self.data = data\n    self.labels = self.parse_labels(labels)\n    self.data_checks()\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.OD.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.OD.labels","title":"<code>labels = self.parse_labels(labels)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.OD.data_checks","title":"<code>data_checks()</code>","text":"<p>Check the integrity of input data and labels.</p> Source code in <code>pam/planner/od.py</code> <pre><code>def data_checks(self):\n\"\"\"\n    Check the integrity of input data and labels.\n    \"\"\"\n    assert self.data.ndim == 4, \\\n        \"The number of matrix dimensions should be 4 (mode, variable, origin, destination)\"\n    for i, (key, labels) in enumerate(zip(self.labels._fields, self.labels)):\n        assert len(labels) == self.data.shape[i], \\\n            f\"The number of {key} labels should match the number of elements\" \\\n            f\"in dimension {i} of the OD dataset\"\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.OD.parse_labels","title":"<code>parse_labels(labels: Union[Labels, List, dict]) -&gt; Labels</code>  <code>staticmethod</code>","text":"<p>Parse labels as a named tuple.</p> Source code in <code>pam/planner/od.py</code> <pre><code>@staticmethod\ndef parse_labels(labels: Union[Labels, List, dict]) -&gt; Labels:\n\"\"\"\n    Parse labels as a named tuple.\n    \"\"\"\n    if not isinstance(labels, Labels):\n        if isinstance(labels, list):\n            return Labels(*labels)\n        elif isinstance(labels, dict):\n            return Labels(**labels)\n        else:\n            raise ValueError('Please provide a valid label type')\n    return labels\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.ODFactory","title":"<code>ODFactory</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODFactory.check","title":"<code>check(matrices: List[ODMatrix], labels: Labels) -&gt; None</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/od.py</code> <pre><code>@staticmethod\ndef check(matrices: List[ODMatrix], labels: Labels) -&gt; None:\n    # all matrices follow the same zoning system and are equal size\n    for mat in matrices:\n        assert mat.origin_zones == labels.origin_zones, \\\n            'Please check zone labels'\n        assert mat.destination_zones == labels.destination_zones, \\\n            'Please check zone labels'\n        assert mat.matrix.shape == matrices[0].matrix.shape, \\\n            'Please check matrix dimensions'\n\n    # all possible combinations are provided\n    combinations_matrices = [(var, trmode)\n                             for (var, trmode, *others) in matrices]\n    combinations_labels = list(itertools.product(labels.vars, labels.mode))\n    for combination in combinations_labels:\n        assert combination in combinations_matrices, \\\n            f'Combination {combination} missing from the input matrices'\n\n    # no duplicate combinations\n    assert len(combinations_matrices) == len(set(combinations_matrices)), \\\n        'No duplicate keys are allowed'\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.ODFactory.from_matrices","title":"<code>from_matrices(matrices: List[ODMatrix]) -&gt; OD</code>  <code>classmethod</code>","text":"<p>Creates an OD instance from a list of ODMatrices</p> Source code in <code>pam/planner/od.py</code> <pre><code>@classmethod\ndef from_matrices(cls, matrices: List[ODMatrix]) -&gt; OD:\n\"\"\"\n    Creates an OD instance from a list of ODMatrices\n    \"\"\"\n    # collect dimensions\n    labels = cls.prepare_labels(matrices)\n\n    cls.check(matrices, labels)\n\n    # create ndarray\n    od = np.zeros(shape=[len(x) for x in labels])\n    for mat in matrices:\n        od[\n            labels.vars.index(mat.var), :, :,\n            labels.mode.index(mat.mode)\n        ] = mat.matrix\n\n    return OD(data=od, labels=labels)\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.ODFactory.prepare_labels","title":"<code>prepare_labels(matrices: List[ODMatrix]) -&gt; Labels</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/od.py</code> <pre><code>@staticmethod\ndef prepare_labels(matrices: List[ODMatrix]) -&gt; Labels:\n    labels = Labels(\n        vars=list(pd.unique([mat.var for mat in matrices])),\n        origin_zones=matrices[0].origin_zones,\n        destination_zones=matrices[0].destination_zones,\n        mode=list(pd.unique([mat.mode for mat in matrices])),\n    )\n    return labels\n</code></pre>"},{"location":"api/planner/od/#pam.planner.od.ODMatrix","title":"<code>ODMatrix</code>","text":"<p>         Bases: <code>NamedTuple</code></p>"},{"location":"api/planner/od/#pam.planner.od.ODMatrix.destination_zones","title":"<code>destination_zones: tuple</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODMatrix.matrix","title":"<code>matrix: np.array</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODMatrix.mode","title":"<code>mode: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODMatrix.origin_zones","title":"<code>origin_zones: tuple</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/od/#pam.planner.od.ODMatrix.var","title":"<code>var: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/","title":"pam.planner.clustering","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters","title":"<code>PlanClusters(population: Population, n_cores: int = 1) -&gt; None</code>","text":"<p>Groups activity plans into clusters. Plan similarity is defined using the edit distance      of character-encoded plan sequences.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def __init__(\n    self,\n    population: Population,\n    n_cores: int = 1\n) -&gt; None:\n    self.population = population\n    self.plans = list(population.plans())\n    self.n_cores = n_cores\n    self._distances = None\n    self.model = None\n\n    # encodings\n    self.activity_classes = sorted(\n        list(population.activity_classes) + ['travel']\n    )\n    self.plans_encoder = PlansCharacterEncoder(\n        activity_classes=self.activity_classes)\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.activity_classes","title":"<code>activity_classes = sorted(list(population.activity_classes) + ['travel'])</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.distances","title":"<code>distances: np.array</code>  <code>property</code>","text":"<p>Levenshtein distances between activity plans.</p>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.distances_no_diagonal","title":"<code>distances_no_diagonal: np.array</code>  <code>property</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.model","title":"<code>model = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.n_cores","title":"<code>n_cores = n_cores</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plans","title":"<code>plans = list(population.plans())</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plans_encoded","title":"<code>plans_encoded: List[str]</code>  <code>cached</code> <code>property</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plans_encoder","title":"<code>plans_encoder = PlansCharacterEncoder(activity_classes=self.activity_classes)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.population","title":"<code>population = population</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.fit","title":"<code>fit(n_clusters: int, clustering_method: str = 'agglomerative', linkage: Optional[str] = 'complete') -&gt; None</code>","text":"<p>Fit an agglomerative clustering model.</p> <p>:param n_clusters: The number of clusters to use. :param linkage: Linkage criterion. :param clustering_method: The clustering method to use.     The currently-supported methods are 'agglomerative' and 'spectral'.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def fit(\n        self,\n        n_clusters: int,\n        clustering_method: str = 'agglomerative',\n        linkage: Optional[str] = 'complete',\n) -&gt; None:\n\"\"\"\n    Fit an agglomerative clustering model.\n\n    :param n_clusters: The number of clusters to use.\n    :param linkage: Linkage criterion.\n    :param clustering_method: The clustering method to use.\n        The currently-supported methods are 'agglomerative' and 'spectral'.\n    \"\"\"\n    if clustering_method == 'agglomerative':\n        model = AgglomerativeClustering(\n            n_clusters=n_clusters,\n            linkage=linkage,\n            affinity='precomputed'  # change argument to \"metric\" for sklearn version&gt;=1.4\n        )\n        model.fit((self.distances))\n    elif clustering_method == 'spectral':\n        model = SpectralClustering(\n            n_clusters=n_clusters,\n            affinity='precomputed'\n        )\n        model.fit((1-self.distances))\n    else:\n        raise ValueError(\"Please select a valid clustering_method ('agglomerative' or 'spectral')\")\n\n    self.model = model\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.get_closest_matches","title":"<code>get_closest_matches(plan, n) -&gt; List[Plan]</code>","text":"<p>Get the n closest matches of a PAM activity schedule.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_closest_matches(self, plan, n) -&gt; List[Plan]:\n\"\"\"\n    Get the n closest matches of a PAM activity schedule.\n    \"\"\"\n    idx = self.plans.index(plan)\n    idx_closest = np.argsort(self.distances_no_diagonal[idx])[:n]\n    return [self.plans[x] for x in idx_closest]\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.get_cluster_membership","title":"<code>get_cluster_membership() -&gt; dict</code>","text":"<p>Get the cluster membership of each person in the population. Returns a dictionary where the index values are (hid, pid) tuples,     and the values are the correponding agents' clusters.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_cluster_membership(self) -&gt; dict:\n\"\"\"\n    Get the cluster membership of each person in the population.\n    Returns a dictionary where the index values are (hid, pid) tuples,\n        and the values are the correponding agents' clusters.\n    \"\"\"\n    ids = [(hid, pid) for hid, pid, person in self.population.people()]\n    return dict(zip(ids, self.model.labels_))\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.get_cluster_plans","title":"<code>get_cluster_plans(cluster: int)</code>","text":"<p>Get the plans that belong in a specific cluster.</p> <p>:param cluster: The cluster index.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_cluster_plans(self, cluster: int):\n\"\"\"\n    Get the plans that belong in a specific cluster.\n\n    :param cluster: The cluster index.\n    \"\"\"\n    return list(\n        itertools.compress(self.plans, self.model.labels_ == cluster)\n    )\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.get_cluster_sizes","title":"<code>get_cluster_sizes() -&gt; pd.Series</code>","text":"<p>Get the number of plans in each cluster.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def get_cluster_sizes(self) -&gt; pd.Series:\n\"\"\"\n    Get the number of plans in each cluster.\n    \"\"\"\n    return pd.Series(self.model.labels_).value_counts()\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plot_plan_breakdowns","title":"<code>plot_plan_breakdowns(ax = None, cluster = None, activity_classes: Optional[List[str]] = None, **kwargs: Optional[List[str]])</code>","text":"<p>Area plot of the breakdown of activities taking place every minute     for a specific cluster.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def plot_plan_breakdowns(\n        self,\n        ax=None,\n        cluster=None,\n        activity_classes: Optional[List[str]] = None,\n        **kwargs\n):\n\"\"\"\n    Area plot of the breakdown of activities taking place every minute\n        for a specific cluster.\n    \"\"\"\n    if cluster is not None:\n        plans = self.get_cluster_plans(cluster)\n    else:\n        plans = self.plans\n\n    if activity_classes is None:\n        activity_classes = self.activity_classes\n\n    return plot_activity_breakdown_area(\n        plans=plans,\n        activity_classes=self.activity_classes,\n        ax=ax,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.PlanClusters.plot_plan_breakdowns_tiles","title":"<code>plot_plan_breakdowns_tiles(n: Optional[int] = None, **kwargs: Optional[int])</code>","text":"<p>Tiled area plot of the breakdown of activities taking place every minute,     for the clusters with the top n number of plans.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def plot_plan_breakdowns_tiles(self, n: Optional[int] = None, **kwargs):\n\"\"\"\n    Tiled area plot of the breakdown of activities taking place every minute,\n        for the clusters with the top n number of plans.\n    \"\"\"\n    if n is None:\n        n = len(set(self.model.labels_))\n\n    clusters = self.get_cluster_sizes().head(n).index\n    plans = {\n        cluster: self.get_cluster_plans(cluster) for cluster in clusters\n    }\n\n    return plot_activity_breakdown_area_tiles(\n        plans=plans,\n        activity_classes=self.activity_classes,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/planner/clustering/#pam.planner.clustering.calc_levenshtein_matrix","title":"<code>calc_levenshtein_matrix(x: List[str], y: List[str], n_cores: List[str] = 1) -&gt; np.array</code>","text":"<p>Create a levenshtein distance matrix from two lists of strings.</p> Source code in <code>pam/planner/clustering.py</code> <pre><code>def calc_levenshtein_matrix(x: List[str], y: List[str], n_cores=1) -&gt; np.array:\n\"\"\"\n    Create a levenshtein distance matrix from two lists of strings.\n    \"\"\"\n    levenshtein_distance = np.vectorize(_levenshtein_distance)\n    if n_cores == 1:\n        distances = levenshtein_distance(\n            np.array(x).reshape(-1, 1), np.array(y))\n    else:\n        xs = np.array_split(x, n_cores)\n        xs = [x.reshape(-1, 1) for x in xs]\n        calc_levenshtein_matrix_partial = partial(levenshtein_distance, b=y)\n        with Pool(n_cores) as p:\n            distances = np.concatenate(\n                p.map(calc_levenshtein_matrix_partial, xs))\n\n    return distances\n</code></pre>"},{"location":"api/planner/encoder/","title":"pam.planner.encoder","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder","title":"<code>Encoder(labels: List[str], travel_act: List[str] = 'travel') -&gt; None</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, labels: List[str], travel_act='travel') -&gt; None:\n    self.labels = set(labels)\n    if travel_act not in self.labels:\n        self.labels.add(travel_act)\n    self.label_code = self.get_mapping(self.labels)\n    self.code_label = {v: k for k, v in self.label_code.items()}\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.code_label","title":"<code>code_label = {v: k for (k, v) in self.label_code.items()}</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.label_code","title":"<code>label_code = self.get_mapping(self.labels)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.labels","title":"<code>labels = set(labels)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.decode","title":"<code>decode(code: Union[int, str]) -&gt; str</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, code: Union[int, str]) -&gt; str:\n    return self.code_label[code]\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.encode","title":"<code>encode(label: str) -&gt; Union[int, str]</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, label: str) -&gt; Union[int, str]:\n    return self.label_code[label]\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.Encoder.get_mapping","title":"<code>get_mapping(labels: List[str])</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_mapping(labels: List[str]):\n    raise NotImplementedError\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder","title":"<code>PlanCharacterEncoder</code>","text":"<p>         Bases: <code>PlanEncoder</code></p>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.activity_encoder_class","title":"<code>activity_encoder_class = StringCharacterEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.encode","title":"<code>encode(plan: Plan) -&gt; np.array</code>","text":"<p>Convert a pam plan to a character sequence</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plan: Plan) -&gt; np.array:\n\"\"\"\n    Convert a pam plan to a character sequence\n    \"\"\"\n    encoded = ''\n    for act in plan.day:\n        duration = int(act.duration / td(minutes=1))\n        encoded = encoded + \\\n            (self.activity_encoder.encode(act.act)*duration)\n\n    return encoded\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanCharacterEncoder.get_seq","title":"<code>get_seq(x)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_seq(x):\n    return x\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder","title":"<code>PlanEncoder(activity_encoder: Optional[StringCharacterEncoder] = None, labels: Optional[List[str]] = None) -&gt; None</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(\n        self,\n        activity_encoder: Optional[StringCharacterEncoder] = None,\n        labels: Optional[List[str]] = None\n) -&gt; None:\n    if activity_encoder is not None:\n        self.activity_encoder = activity_encoder\n    elif labels is not None:\n        self.activity_encoder = self.activity_encoder_class(labels)\n    else:\n        raise ValueError(\n            'Please provide appropriate activity labels or encodings')\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.activity_encoder","title":"<code>activity_encoder = activity_encoder</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.activity_encoder_class","title":"<code>activity_encoder_class = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.add_plan_component","title":"<code>add_plan_component(plan: Plan, seq: Plan, act: Plan, start_time: Plan, duration: Plan) -&gt; None</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef add_plan_component(plan: Plan, seq, act, start_time, duration) -&gt; None:\n    if act == 'travel':\n        plan.add(\n            activity.Leg(\n                seq=seq,\n                start_time=start_time,\n                end_time=start_time+duration\n            )\n        )\n    else:\n        plan.add(\n            activity.Activity(\n                seq=seq,\n                act=act,\n                start_time=start_time,\n                end_time=start_time+duration\n            )\n        )\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.decode","title":"<code>decode(encoded_plan: np.array) -&gt; Plan</code>","text":"<p>Decode a sequence to a new PAM plan.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def decode(self, encoded_plan: np.array) -&gt; Plan:\n\"\"\"\n    Decode a sequence to a new PAM plan.\n    \"\"\"\n    start_time = START_OF_DAY\n    plan = activity.Plan()\n    # for every activity/leg:\n    for seq, (k, g) in enumerate(groupby(self.get_seq(encoded_plan))):\n        duration = td(minutes=len(list(g)))\n        act = self.activity_encoder.decode(k)\n        # add to the plan and advance start time\n        self.add_plan_component(\n            plan=plan, seq=seq, act=act, start_time=start_time, duration=duration)\n        start_time += duration\n\n    return plan\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.encode","title":"<code>encode()</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self):\n    raise NotImplementedError\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanEncoder.get_seq","title":"<code>get_seq(x)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_seq(x):\n    raise NotImplementedError\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder","title":"<code>PlanOneHotEncoder</code>","text":"<p>         Bases: <code>PlanEncoder</code></p>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.activity_encoder_class","title":"<code>activity_encoder_class = StringIntEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.encode","title":"<code>encode(plan: Plan) -&gt; np.array</code>","text":"<p>Encode a PAM plan into a 2D numpy boolean array,      where the row indicates the activity     and the column indicates the minute of the day.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plan: Plan) -&gt; np.array:\n\"\"\"\n    Encode a PAM plan into a 2D numpy boolean array, \n        where the row indicates the activity\n        and the column indicates the minute of the day.\n    \"\"\"    \n    duration = int((plan.day[-1].end_time - START_OF_DAY) / td(minutes=1))\n    encoded = np.zeros(\n        shape=(len(self.activity_encoder.labels), duration),\n        dtype=bool\n    )\n    for act in plan.day:\n        start_minute = int((act.start_time - START_OF_DAY) / td(minutes=1))\n        end_minute = int((act.end_time - START_OF_DAY) / td(minutes=1))\n        idx = self.activity_encoder.encode(act.act)\n        encoded[idx, start_minute: end_minute] = True\n\n    return encoded\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlanOneHotEncoder.get_seq","title":"<code>get_seq(x)</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_seq(x):\n    return x.argmax(axis=0)\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansCharacterEncoder","title":"<code>PlansCharacterEncoder</code>","text":"<p>         Bases: <code>PlansEncoder</code></p>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansCharacterEncoder.plans_encoder_class","title":"<code>plans_encoder_class = PlanCharacterEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder","title":"<code>PlansEncoder(activity_classes: set) -&gt; None</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>def __init__(self, activity_classes: set) -&gt; None:\n    self.plan_encoder = self.plans_encoder_class(labels=activity_classes)\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder.dtype","title":"<code>dtype = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder.plan_encoder","title":"<code>plan_encoder = self.plans_encoder_class(labels=activity_classes)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder.plans_encoder_class","title":"<code>plans_encoder_class = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.PlansEncoder.encode","title":"<code>encode(plans: List[Plan]) -&gt; np.ndarray</code>","text":"<p>Encode all plans to a stacked numpy array.</p> Source code in <code>pam/planner/encoder.py</code> <pre><code>def encode(self, plans: List[Plan]) -&gt; np.ndarray:\n\"\"\"\n    Encode all plans to a stacked numpy array.\n    \"\"\"\n    plans_encoded = np.stack([\n        self.plan_encoder.encode(x) for x in plans\n    ])\n    return plans_encoded\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansOneHotEncoder","title":"<code>PlansOneHotEncoder</code>","text":"<p>         Bases: <code>PlansEncoder</code></p> <p>Encode plans to a 3D numpy array,     where the first axis indicates the person,     the second indicates the activity,     and the third indicates the minute of the day.</p>"},{"location":"api/planner/encoder/#pam.planner.encoder.PlansOneHotEncoder.plans_encoder_class","title":"<code>plans_encoder_class = PlanOneHotEncoder</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/encoder/#pam.planner.encoder.StringCharacterEncoder","title":"<code>StringCharacterEncoder</code>","text":"<p>         Bases: <code>Encoder</code></p> <p>Encodes strings as single characters.</p>"},{"location":"api/planner/encoder/#pam.planner.encoder.StringCharacterEncoder.get_mapping","title":"<code>get_mapping(labels: List[str]) -&gt; dict</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_mapping(labels: List[str]) -&gt; dict:\n    encoded = {}\n    for i, act in enumerate(labels):\n        encoded[act] = chr(i+65)\n    return encoded\n</code></pre>"},{"location":"api/planner/encoder/#pam.planner.encoder.StringIntEncoder","title":"<code>StringIntEncoder</code>","text":"<p>         Bases: <code>Encoder</code></p> <p>Encodes strings as integers.</p>"},{"location":"api/planner/encoder/#pam.planner.encoder.StringIntEncoder.get_mapping","title":"<code>get_mapping(labels: List[str]) -&gt; dict</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/encoder.py</code> <pre><code>@staticmethod\ndef get_mapping(labels: List[str]) -&gt; dict:\n    encoded = {label: i for i, label in enumerate(labels)}\n    return encoded\n</code></pre>"},{"location":"api/planner/utils_planner/","title":"pam.planner.utils_planner","text":""},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.apply_mode_to_home_chain","title":"<code>apply_mode_to_home_chain(act: Activity, trmode: str)</code>","text":"<p>Apply a transport mode across a home-based trip chain, which comprises the specified activity.</p> <p>:param act: The activity that is part of the trip chain. :param trmode: The mode to apply to each leg of the chain.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def apply_mode_to_home_chain(act: Activity, trmode: str):\n\"\"\"\n    Apply a transport mode across a home-based trip chain,\n    which comprises the specified activity.\n\n    :param act: The activity that is part of the trip chain.\n    :param trmode: The mode to apply to each leg of the chain.\n    \"\"\"\n    if not 'next' in act.__dict__:\n        raise KeyError('Plan is not linked. Please use `pam.operations.cropping.link_plan` to link activities and legs.')\n\n    # apply forwards\n    elem = act.next\n    while (elem is not None) and (elem.act != 'home'):\n        if isinstance(elem, Leg):\n            elem.mode = trmode            \n        elem = elem.next\n\n    # apply backwards\n    elem = act.previous\n    while (elem is not None) and (elem.act != 'home'):\n        if isinstance(elem, Leg):\n            elem.mode = trmode            \n        elem = elem.previous\n</code></pre>"},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.calculate_mnl_probabilities","title":"<code>calculate_mnl_probabilities(x: Union[np.array, List]) -&gt; np.array</code>","text":"<p>Calculates MNL probabilities from a set of alternatives.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def calculate_mnl_probabilities(x: Union[np.array, List]) -&gt; np.array:\n\"\"\"\n    Calculates MNL probabilities from a set of alternatives.\n    \"\"\"\n    return np.exp(x)/np.exp(x).sum()\n</code></pre>"},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.get_trip_chains","title":"<code>get_trip_chains(plan: Plan, act: str = 'home') -&gt; List[List[Union[Activity, Leg]]]</code>","text":"<p>Get trip chains starting and/or ending at a long-term activity</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def get_trip_chains(\n    plan: Plan,\n    act: str = 'home'\n) -&gt; List[List[Union[Activity, Leg]]]:\n\"\"\"\n    Get trip chains starting and/or ending at a long-term activity \n    \"\"\"\n    chains = []\n    chain = []\n    for elem in plan.day:\n        if isinstance(elem, Activity) and elem.act == act:\n            if len(chain) &gt; 0:\n                chains.append(chain+[elem])\n                chain = []\n        chain.append(elem)\n\n    if len(chain) &gt; 1:\n        chains += [chain]  # add any remaining trips until the end of the day\n\n    return chains\n</code></pre>"},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.get_validate","title":"<code>get_validate(obj, name: str)</code>","text":"<p>Get an object's attribute, or raise an error if its value is None.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def get_validate(obj, name: str):\n\"\"\"\n    Get an object's attribute, or raise an error if its value is None.\n    \"\"\"\n    attr = getattr(obj, name)\n    if attr is None:\n        raise ValueError(f'Attribute {name} has not been set yet')\n    return attr\n</code></pre>"},{"location":"api/planner/utils_planner/#pam.planner.utils_planner.sample_weighted","title":"<code>sample_weighted(weights: np.array) -&gt; int</code>","text":"<p>Weighted sampling.  Returns the index of the selection.</p> Source code in <code>pam/planner/utils_planner.py</code> <pre><code>def sample_weighted(weights: np.array) -&gt; int:\n\"\"\"\n    Weighted sampling. \n    Returns the index of the selection.\n    \"\"\"\n    return random.choices(range(len(weights)), weights=weights, k=1)[0]\n</code></pre>"},{"location":"api/planner/choice_location/","title":"pam.planner.choice_location","text":"<p>Location and mode choice models for activity modelling</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration","title":"<code>ChoiceConfiguration</code>  <code>dataclass</code>","text":"<p>:param u: The utility function specification, defined as a string.      The string may point to household, person, act, leg,          od, or zone data.      It can also include values and/or mathematical operations.     Parameters may be passed as single values, or as lists          (with each element in the list corresponding to one of the modes in the OD object)     For example: u='-[0,1] - (2 * od['time']) - (od['time'] * person.attributes['age']&gt;60) :param scope: The scope of the function (for example, work activities). :param func_probabilities: The function for calculating the probability of each alternative :param func_sampling: The function for sampling across alternatives, ie softmax</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.func_probabilities","title":"<code>func_probabilities: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.func_sampling","title":"<code>func_sampling: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.scope","title":"<code>scope: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.u","title":"<code>u: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceConfiguration.validate","title":"<code>validate(vars: List[str]) -&gt; None</code>","text":"<p>Return an error if a value has not been set</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def validate(self, vars: List[str]) -&gt; None:\n\"\"\"\n    Return an error if a value has not been set\n    \"\"\"\n    for var in vars:\n        if getattr(self, var) is None:\n            raise ValueError(f'Setting {var} has not been set yet')\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx","title":"<code>ChoiceIdx</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Choice set index</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.act","title":"<code>act: Activity</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.hid","title":"<code>hid: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.pid","title":"<code>pid: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceIdx.seq","title":"<code>seq: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceLabel","title":"<code>ChoiceLabel</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Destination and mode choice labels of a selected option</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceLabel.destination","title":"<code>destination: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceLabel.mode","title":"<code>mode: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceMNL","title":"<code>ChoiceMNL(population: Population, od: OD, zones: pd.DataFrame) -&gt; None</code>","text":"<p>         Bases: <code>ChoiceModel</code></p> <p>Applies a Multinomial Logit Choice model.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(self, population: Population, od: OD, zones: pd.DataFrame) -&gt; None:\n    super().__init__(population, od, zones)\n    self.configure(\n        func_probabilities=calculate_mnl_probabilities,\n        func_sampling=sample_weighted\n    )\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel","title":"<code>ChoiceModel(population: Population, od: OD, zones: Union[pd.DataFrame, Zones]) -&gt; None</code>","text":"<p>Choice model interface.</p> <p>:param population: A PAM population. :param od: An object holding origin-destination. :param zones: Zone-level data.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def __init__(\n        self,\n        population: Population,\n        od: OD,\n        zones: Union[pd.DataFrame, Zones]\n) -&gt; None:\n\"\"\"\n    Choice model interface.\n\n    :param population: A PAM population.\n    :param od: An object holding origin-destination.\n    :param zones: Zone-level data.\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.population = population\n    link_population(self.population)\n    self.od = od\n    self.zones = self.parse_zone_data(zones)\n    self.zones.data = self.zones.data.loc[list(od.labels.destination_zones)]\n    self.configuration = ChoiceConfiguration()\n    self._selections = None\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.configuration","title":"<code>configuration = ChoiceConfiguration()</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.od","title":"<code>od = od</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.population","title":"<code>population = population</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.selections","title":"<code>selections: SelectionSet</code>  <code>property</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.zones","title":"<code>zones = self.parse_zone_data(zones)</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.apply","title":"<code>apply(apply_location = True, apply_mode = True, once_per_agent = True, apply_mode_to = 'chain')</code>","text":"<p>Apply the choice model to the PAM population,     updating the activity locations and mode choices in scope.</p> <p>:param apply_location: Whether to update activities' location :param apply_mode: Whether to update travel modes :param once_per_agent: If True, the same selected option     is applied to all activities within scope of an agent.  :param apply_mode_to: <code>chain</code> or <code>previous_leg</code>:     Whether to apply the mode to the entire trip chain      that contains the activity,     or the leg preceding the activity.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def apply(self, apply_location=True, apply_mode=True, once_per_agent=True,\n          apply_mode_to='chain'):\n\"\"\"\n    Apply the choice model to the PAM population,\n        updating the activity locations and mode choices in scope.\n\n    :param apply_location: Whether to update activities' location\n    :param apply_mode: Whether to update travel modes\n    :param once_per_agent: If True, the same selected option\n        is applied to all activities within scope of an agent. \n    :param apply_mode_to: `chain` or `previous_leg`:\n        Whether to apply the mode to the entire trip chain \n        that contains the activity,\n        or the leg preceding the activity.\n    \"\"\"\n    self.logger.info('Applying choice model...')\n    self.logger.info(f'Configuration: \\n{self.configuration}')\n\n    pid = None\n    destination = None\n    trmode = None\n\n    # update location and mode\n    for idx, selection in zip(self.selections.choice_set.idxs, self.selections.selections):\n        if not (once_per_agent and (pid == idx.pid)):\n            destination = selection.destination\n            trmode = selection.mode\n\n        pid = idx.pid\n        act = idx.act\n\n        if apply_location:\n            act.location.area = destination\n\n        if apply_mode and (act.previous is not None):\n            if apply_mode_to == 'chain':\n                apply_mode_to_home_chain(act, trmode)\n            elif apply_mode_to == 'previous_leg':\n                act.previous.mode = trmode\n            else:\n                raise ValueError(f'Invalid option {apply_mode_to}')\n\n    self.logger.info('Choice model application complete.')\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.configure","title":"<code>configure(**kwargs) -&gt; None</code>","text":"<p>Specify the model.</p> <p>:Keyword Arguments: Parameters of the ChoiceConfiguration class.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def configure(self, **kwargs) -&gt; None:\n\"\"\"\n    Specify the model.\n\n    :Keyword Arguments: Parameters of the ChoiceConfiguration class.\n    \"\"\"\n    for k, v in kwargs.items():\n        if type(v) == str:\n            v = v.replace(' ', '')\n        setattr(self.configuration, k, v)\n    self.logger.info('Updated model configuration')\n    self.logger.info(self.configuration)\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.get_choice_set","title":"<code>get_choice_set() -&gt; ChoiceSet</code>","text":"<p>Construct an agent's choice set for each activity/leg within scope.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def get_choice_set(self) -&gt; ChoiceSet:\n\"\"\"\n    Construct an agent's choice set for each activity/leg within scope.\n    \"\"\"\n    self.configuration.validate(['u', 'scope'])\n    od = self.od\n    zones = self.zones\n    u = self.configuration.u\n    scope = self.configuration.scope\n\n    idxs = []\n    u_choices = []\n    choice_labels = list(itertools.product(\n        od.labels.destination_zones,\n        od.labels.mode\n    ))\n    choice_labels = [ChoiceLabel(*x) for x in choice_labels]\n\n    # iterate across activities\n    for hid, hh in self.population:\n        for pid, person in hh:\n            for i, act in enumerate(person.activities):\n                if eval(scope):\n                    idx_act = ChoiceIdx(\n                        pid=pid,\n                        hid=hid,\n                        seq=i,\n                        act=act\n                    )\n                    # calculate utilities for each alternative\n                    u_act = eval(u)\n                    # flatten location-mode combinations\n                    u_act = u_act.flatten()\n\n                    u_choices.append(u_act)\n                    idxs.append(idx_act)\n\n    u_choices = np.array(u_choices)\n\n    # check dimensions\n    assert u_choices.shape[1] == len(choice_labels)\n    assert u_choices.shape[0] == len(idxs)\n\n    return ChoiceSet(idxs=idxs, u_choices=u_choices, choice_labels=choice_labels)\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceModel.parse_zone_data","title":"<code>parse_zone_data(zones: Union[pd.DataFrame, Zones]) -&gt; Zones</code>  <code>staticmethod</code>","text":"Source code in <code>pam/planner/choice_location.py</code> <pre><code>@staticmethod\ndef parse_zone_data(zones: Union[pd.DataFrame, Zones]) -&gt; Zones:\n    if isinstance(zones, Zones):\n        return deepcopy(zones)\n    elif isinstance(zones, pd.DataFrame):\n        return Zones(data=zones.copy())\n</code></pre>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceSet","title":"<code>ChoiceSet</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>MNL Choice set</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceSet.choice_labels","title":"<code>choice_labels: List[ChoiceLabel]</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceSet.idxs","title":"<code>idxs: List[ChoiceIdx]</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.ChoiceSet.u_choices","title":"<code>u_choices: np.array</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet","title":"<code>SelectionSet</code>  <code>dataclass</code>","text":"<p>Calculate probabilities and select alternative</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.choice_set","title":"<code>choice_set: ChoiceSet</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.func_probabilities","title":"<code>func_probabilities: Callable</code>  <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.func_sampling","title":"<code>func_sampling: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.probabilities","title":"<code>probabilities: np.array</code>  <code>property</code>","text":"<p>Probabilities for each alternative.</p>"},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.selections","title":"<code>selections: List[ChoiceLabel]</code>  <code>property</code>","text":""},{"location":"api/planner/choice_location/#pam.planner.choice_location.SelectionSet.sample","title":"<code>sample() -&gt; List</code>","text":"<p>Sample from a set of alternative options.</p> Source code in <code>pam/planner/choice_location.py</code> <pre><code>def sample(self) -&gt; List:\n\"\"\"\n    Sample from a set of alternative options.\n    \"\"\"\n    sampled = np.apply_along_axis(\n        func1d=self.func_sampling,\n        axis=1,\n        arr=self.probabilities\n    )\n    sampled_labels = [self.choice_set.choice_labels[x] for x in sampled]\n    self._selections = sampled_labels\n    return sampled_labels\n</code></pre>"},{"location":"api/planner/zones/","title":"pam.planner.zones","text":"<p>Manages zone-level data required by the planner module.</p>"},{"location":"api/planner/zones/#pam.planner.zones.Zones","title":"<code>Zones(data: pd.DataFrame) -&gt; None</code>","text":"<p>:param data: A dataframe with variables as columns and the zone as index</p> Source code in <code>pam/planner/zones.py</code> <pre><code>def __init__(\n    self,\n    data: pd.DataFrame\n) -&gt; None:\n\"\"\"\n    :param data: A dataframe with variables as columns and the zone as index\n    \"\"\"\n    self.data = data\n</code></pre>"},{"location":"api/planner/zones/#pam.planner.zones.Zones.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"api/read/diary/","title":"pam.read.diary","text":""},{"location":"api/read/diary/#pam.read.diary.add_hhs_from_hhs_attributes","title":"<code>add_hhs_from_hhs_attributes(population: core.Population, hhs_attributes: Optional[pd.DataFrame] = None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_hhs_from_hhs_attributes(\n    population: core.Population,\n    hhs_attributes: Optional[pd.DataFrame] = None\n    ):\n    logger = logging.getLogger(__name__)\n\n    if hhs_attributes is None:\n        return None\n\n    logger.info(\"Adding hhs from hhs_attributes\")\n    for hid, hh in hhs_attributes.groupby('hid'):\n        if hid not in population.households:\n            hh_attributes = hhs_attributes.loc[hid].to_dict()\n            household = core.Household(\n                hid,\n                attributes=hh_attributes,\n                freq=hh_attributes.pop(\"freq\", None),\n                area=hh_attributes.pop(\"hzone\", None)\n                )\n            population.add(household)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.add_hhs_from_persons_attributes","title":"<code>add_hhs_from_persons_attributes(population: core.Population, persons_attributes: Optional[pd.DataFrame] = None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_hhs_from_persons_attributes(\n    population: core.Population,\n    persons_attributes: Optional[pd.DataFrame] = None\n    ):\n    logger = logging.getLogger(__name__)\n\n    if persons_attributes is None or 'hid' not in persons_attributes.columns:\n        return None\n\n    if 'hzone' in persons_attributes.columns:\n        hzone_lookup = persons_attributes.groupby('hid').head(1).set_index('hid').hzone.to_dict()\n    else:\n        hzone_lookup = {}\n\n    logger.info(\"Adding hhs from persons_attributes\")\n    for hid, hh_data in persons_attributes.groupby('hid'):\n        if hid not in population.households:\n            hzone = hzone_lookup.get(hid)\n            household = core.Household(\n                hid,\n                area=hzone\n                )\n            population.add(household)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.add_hhs_from_trips","title":"<code>add_hhs_from_trips(population: core.Population, trips: Optional[pd.DataFrame] = None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_hhs_from_trips(\n    population: core.Population,\n    trips: Optional[pd.DataFrame] = None,\n    ):\n    logger = logging.getLogger(__name__)\n\n    if trips is None or 'hid' not in trips.columns:\n        return None\n\n    logger.info(\"Adding hhs from trips\")\n    for hid, hh_data in trips.groupby('hid'):\n        if hid not in population.households:\n            hzone = hh_data.iloc[0].to_dict().get(\"hzone\")\n            household = core.Household(\n                hid,\n                area=hzone\n                )\n            population.add(household)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.add_persons_from_persons_attributes","title":"<code>add_persons_from_persons_attributes(population: core.Population, persons_attributes: Optional[pd.DataFrame] = None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_persons_from_persons_attributes(\n    population: core.Population,\n    persons_attributes: Optional[pd.DataFrame] = None,\n    ):\n    logger = logging.getLogger(__name__)\n\n    if persons_attributes is None or 'hid' not in persons_attributes.columns:\n        return None\n\n    persons_attributes_dict  = persons_attributes.reset_index().set_index(['hid','pid']).to_dict('index')\n\n    logger.info(\"Adding persons from persons_attributes\")\n    for hid, hh_data in persons_attributes.groupby('hid'):\n        household = population.get(hid)\n        if household is None:\n            logger.warning(f\"Failed to find household {hid} in population - unable to add person.\")\n            continue\n        for pid in hh_data.index:\n            if pid in household.people:\n                continue\n\n            person_attributes = persons_attributes_dict[hid, pid]\n\n            person = core.Person(\n                pid,\n                attributes=person_attributes,\n                home_area=person_attributes.get('hzone', None),\n                freq=person_attributes.pop('freq', None)\n                )\n            household.add(person)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.add_persons_from_trips","title":"<code>add_persons_from_trips(population: core.Population, trips: Optional[pd.DataFrame] = None)</code>","text":"Source code in <code>pam/read/diary.py</code> <pre><code>def add_persons_from_trips(\n    population: core.Population,\n    trips: Optional[pd.DataFrame] = None,\n    ):\n    logger = logging.getLogger(__name__)\n\n    if trips is None or 'hid' not in trips.columns:\n        return None\n\n    logger.info(\"Adding persons from trips\")\n    for (hid, pid), hh_person_data in trips.groupby(['hid', 'pid']):\n        household = population.households.get(hid)\n        if household is None:\n            logger.warning(f\"Failed to find household {hid} in population - unable to add person.\")\n            continue\n        if pid in household.people:\n            continue\n        person = core.Person(\n            pid,\n            home_area=hh_person_data.iloc[0].to_dict().get(\"hzone\"),\n            )\n        household.add(person)\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.build_population","title":"<code>build_population(trips: Optional[pd.DataFrame] = None, persons_attributes: Optional[pd.DataFrame] = None, hhs_attributes: Optional[pd.DataFrame] = None)</code>","text":"<p>Build a population of households and persons (without plans) from available trips, persons_attributes and households_attributes data. Details of required table formats are in the README.</p> <p>Parameters:</p> Name Type Description Default <code>trips</code> <code>Optional[pd.DataFrame]</code> <p>trips table</p> <code>None</code> <code>persons_attributes</code> <code>Optional[pd.DataFrame]</code> <p>persons attributes table</p> <code>None</code> <code>hhs_attributes</code> <code>Optional[pd.DataFrame]</code> <p>households attributes table</p> <code>None</code> <p>Returns:</p> Type Description <p>pam.Population: population object</p> Source code in <code>pam/read/diary.py</code> <pre><code>def build_population(\n    trips: Optional[pd.DataFrame] = None,\n    persons_attributes: Optional[pd.DataFrame] = None,\n    hhs_attributes: Optional[pd.DataFrame] = None\n    ):\n\"\"\"\n    Build a population of households and persons (without plans)\n    from available trips, persons_attributes and households_attributes\n    data.\n    Details of required table formats are in the README.\n\n    Args:\n        trips (Optional[pd.DataFrame]): trips table\n        persons_attributes (Optional[pd.DataFrame]): persons attributes table\n        hhs_attributes (Optional[pd.DataFrame]): households attributes table\n\n    Returns:\n        pam.Population: population object\n    \"\"\"\n    population = core.Population()\n    add_hhs_from_hhs_attributes(population=population, hhs_attributes=hhs_attributes)\n    add_hhs_from_persons_attributes(population=population, persons_attributes=persons_attributes)\n    add_hhs_from_trips(population=population, trips=trips)\n    add_persons_from_persons_attributes(population=population, persons_attributes=persons_attributes)\n    add_persons_from_trips(population=population, trips=trips)\n\n    return population\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.from_to_travel_diary_read","title":"<code>from_to_travel_diary_read(trips: pd.DataFrame, persons_attributes: Union[pd.DataFrame, None] = None, hhs_attributes: Union[pd.DataFrame, None] = None, include_loc: Union[pd.DataFrame, None] = False, sort_by_seq: Union[bool, None] = False)</code>","text":"<p>Turn Diary Plan tabular data inputs (derived from travel survey and attributes) into core population format. This is a variation of the standard load_travel_diary() method because it does not require activity inference or home location. We expect broadly the same data schema except rather than purp (purpose) we use trips oact (origin activity) and dact (destination activity). :param trips: DataFrame :param persons_attributes: DataFrame :param hhs_attributes: DataFrame :return: core.Population :param include_loc=False, bool, optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns) :param sort_by_seq=None, optionally force trip sorting as True or False</p> Source code in <code>pam/read/diary.py</code> <pre><code>def from_to_travel_diary_read(\n    trips: pd.DataFrame,\n    persons_attributes: Union[pd.DataFrame, None] = None,\n    hhs_attributes: Union[pd.DataFrame, None] = None,\n    include_loc = False,\n    sort_by_seq: Union[bool, None] = False,\n    ):\n\"\"\"\n    Turn Diary Plan tabular data inputs (derived from travel survey and attributes) into core population\n    format. This is a variation of the standard load_travel_diary() method because it does not require\n    activity inference or home location.\n    We expect broadly the same data schema except rather than purp (purpose) we use trips oact (origin activity)\n    and dact (destination activity).\n    :param trips: DataFrame\n    :param persons_attributes: DataFrame\n    :param hhs_attributes: DataFrame\n    :return: core.Population\n    :param include_loc=False, bool, optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns)\n    :param sort_by_seq=None, optionally force trip sorting as True or False\n    \"\"\"\n    logger = logging.getLogger(__name__)\n\n    population = build_population(\n        trips=trips,\n        persons_attributes=persons_attributes,\n        hhs_attributes=hhs_attributes\n    )\n\n    if sort_by_seq is None and 'seq' in trips.columns:\n        sort_by_seq = True\n\n    if sort_by_seq:\n        trips = trips.sort_values(['hid','pid','seq'])\n\n    trips_dict = hh_person_df_to_dict(trips, 'hid', 'pid') # convert to dict for faster indexing\n\n    for hid, household in population:\n        for pid, person in household:\n            person_trips = trips_dict.get(hid, {}).get(pid, pd.DataFrame())\n\n            if not len(person_trips):\n                person.stay_at_home()\n                continue\n\n            first_act = person_trips.iloc[0].oact.lower()\n            if not first_act == \"home\":\n                logger.warning(f\" Person pid:{pid} hid:{hid} plan does not start with 'home' activity: {first_act}\")\n\n            loc = None\n            if include_loc:\n                loc = person_trips.start_loc.iloc[0]\n\n            person.add(\n                activity.Activity(\n                    seq=0,\n                    act=first_act,\n                    area=person_trips.iloc[0].ozone,\n                    loc=loc,\n                    start_time=utils.parse_time(0),\n                )\n            )\n\n            for n, trip in person_trips.iterrows():\n\n                start_loc = None\n                end_loc = None\n                if include_loc:\n                    start_loc = trip.start_loc\n                    end_loc = trip.end_loc\n                purpose=trip.dact.lower()\n\n                person.add(\n                    activity.Leg(\n                        seq=n,\n                        purp=purpose,\n                        mode=trip['mode'].lower(),\n                        start_area=trip.ozone,\n                        end_area=trip.dzone,\n                        start_loc=start_loc,\n                        end_loc=end_loc,\n                        start_time=utils.parse_time(trip.tst),\n                        end_time=utils.parse_time(trip.tet),\n                        distance = trip.get('distance')\n                    )\n                )\n\n                person.add(\n                    activity.Activity(\n                        seq=n + 1,\n                        act=purpose,\n                        area=trip.dzone,\n                        loc=end_loc,\n                        start_time=utils.parse_time(trip.tet),\n                    )\n                )\n\n            person.plan.finalise_activity_end_times()\n            household.add(person)\n\n        population.add(household)\n\n    return population\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.hh_person_df_to_dict","title":"<code>hh_person_df_to_dict(df: pd.DataFrame, key_hh: str, key_person: str)</code>","text":"<p>Restructure a dataframe as a nested dictionary of dataframes,     where the first level is the household index,     the second level is the person index,     the value is the dataframe slice corresponding to that person</p> <p>The dictionary structure allows for much faster access to a person's data. :params pd.DataFrame df: the pandas dataframe to reindex :params str key_hh: the household key column name :params str key_person: the person key column name :params boolean values_dict: whether to convert the person data to a dictionary as well</p> Source code in <code>pam/read/diary.py</code> <pre><code>def hh_person_df_to_dict(\n    df: pd.DataFrame,\n    key_hh: str,\n    key_person: str,\n    ):\n\"\"\"\n    Restructure a dataframe as a nested dictionary of dataframes,\n        where the first level is the household index,\n        the second level is the person index,\n        the value is the dataframe slice corresponding to that person\n\n    The dictionary structure allows for much faster access to a person's data.\n    :params pd.DataFrame df: the pandas dataframe to reindex\n    :params str key_hh: the household key column name\n    :params str key_person: the person key column name\n    :params boolean values_dict: whether to convert the person data to a dictionary as well\n    \"\"\"\n    df_dict = {x:{} for x in df[key_hh].unique()}\n    for (hid, pid), person_data in df.groupby([key_hh,key_person]):\n        df_dict[hid][pid] = person_data\n    return df_dict\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.load_travel_diary","title":"<code>load_travel_diary(trips: Union[pd.DataFrame, str], persons_attributes: Union[pd.DataFrame, str, None] = None, hhs_attributes: Union[pd.DataFrame, str, None] = None, sample_perc: Union[float, None] = None, tour_based: bool = True, from_to: bool = False, include_loc: bool = False, sort_by_seq: Union[bool, None] = None, trip_freq_as_person_freq: bool = False, trip_freq_as_hh_freq: bool = False)</code>","text":"<p>Turn standard tabular data inputs (travel survey and attributes) into core population format. :param trips: DataFrame :param persons_attributes: DataFrame :param hhs_attributes: DataFrame :param sample_perc: Float. If different to None, it samples the travel population by the corresponding percentage :param tour_based: bool=True, set to False to force a simpler trip-based purpose parser :param from_to: bool=False, set to True to force the from-to purpose parser (requires 'oact' and 'dact' trips columns) :param include_loc: bool=False, optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' trips columns) :param sort_by_seq=None, optionally force trip sorting as True or False :param trip_freq_as_person_freq:bool=False. :param trip_freq_as_hh_freq:bool=False. :return: core.Population</p> Source code in <code>pam/read/diary.py</code> <pre><code>def load_travel_diary(\n    trips: Union[pd.DataFrame, str],\n    persons_attributes: Union[pd.DataFrame, str, None] = None,\n    hhs_attributes: Union[pd.DataFrame, str, None] = None,\n    sample_perc: Union[float, None] = None,\n    tour_based: bool = True,\n    from_to: bool = False,\n    include_loc: bool = False,\n    sort_by_seq: Union[bool, None] = None,\n    trip_freq_as_person_freq: bool = False,\n    trip_freq_as_hh_freq: bool = False,\n    ):\n\"\"\"\n    Turn standard tabular data inputs (travel survey and attributes) into core population format.\n    :param trips: DataFrame\n    :param persons_attributes: DataFrame\n    :param hhs_attributes: DataFrame\n    :param sample_perc: Float. If different to None, it samples the travel population by the corresponding percentage\n    :param tour_based: bool=True, set to False to force a simpler trip-based purpose parser\n    :param from_to: bool=False, set to True to force the from-to purpose parser (requires 'oact' and 'dact' trips columns)\n    :param include_loc: bool=False, optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' trips columns)\n    :param sort_by_seq=None, optionally force trip sorting as True or False\n    :param trip_freq_as_person_freq:bool=False.\n    :param trip_freq_as_hh_freq:bool=False.\n    :return: core.Population\n    \"\"\"\n    # TODO check for required col headers and give useful error?\n\n    logger = logging.getLogger(__name__)\n\n    if isinstance(trips, str):\n        logger.warning(f\"Attempting to load trips dataframe from path: {trips}\")\n        trips = pd.read_csv(trips)\n\n    if isinstance(persons_attributes, str):\n        logger.warning(f\"Attempting to load trips dataframe from path: {persons_attributes}\")\n        persons_attributes = pd.read_csv(persons_attributes)\n\n    if isinstance(hhs_attributes, str):\n        logger.warning(f\"Attempting to load trips dataframe from path: {hhs_attributes}\")\n        hhs_attributes = pd.read_csv(hhs_attributes)\n\n    if not isinstance(trips, pd.DataFrame):\n        raise UserWarning(\"Unrecognised input for trips input.\")\n\n    if persons_attributes is not None and not isinstance(persons_attributes, pd.DataFrame):\n        raise UserWarning(\"Unrecognised input for person_attributes\")\n\n    if hhs_attributes is not None and not isinstance(hhs_attributes, pd.DataFrame):\n        raise UserWarning(\"Unrecognised input for hh_attributes\")\n\n    # reset indexes if named\n    for table in [trips, persons_attributes, hhs_attributes]:\n        if table is not None and table.index.name is not None:\n            table.reset_index(inplace=True)\n\n    if ('oact' in trips.columns and 'dact' in trips.columns) or from_to:\n        logger.warning(\"Using from-to activity parser using 'oact' and 'dact' columns\")\n        from_to = True\n\n        # check that trips diary has required fields\n        missing = {'pid', 'ozone', 'dzone', 'oact', 'dact', 'mode', 'tst', 'tet'} - set(trips.columns)\n        if missing:\n            raise UserWarning(f\"Input trips_diary missing required column names: {missing}.\")\n\n    else:\n        if tour_based:\n            logger.warning(\"Using tour based purpose parser (recommended)\")\n        else:\n            logger.warning(\n\"\"\"\nUsing simple trip based purpose parser, this assumes first activity is 'home'.\nIf you do not wish to assume this, try setting 'tour_based' = True (default).\n\"\"\"\n                )\n\n        # check that trips diary has required fields\n        missing = {'pid', 'ozone', 'dzone', 'purp', 'mode', 'tst', 'tet'} - set(trips.columns)\n        if missing:\n            raise UserWarning(f\"Input trips_diary missing required column names: {missing}.\")\n\n    if sort_by_seq and 'seq' not in trips.columns:\n        raise UserWarning(\n    f\"\"\"\n    You must include a trips 'seq' column if you wish to sort trips:\n    Either include a 'seq' column or use the existing ordering by\n    setting 'sort_by_seq' = False/None (default).\n    \"\"\"\n    )\n\n    if include_loc and not all(x in trips.columns for x in ['start_loc', 'end_loc']):\n        raise UserWarning(\n    f\"\"\"\n    You must include a trips 'start_loc' and 'end_loc' column if you wish to use precise locations:\n    Either include a 'start_loc' and 'end_loc' column or set 'include_loc' = False (default).\n    Note that these columns must be shapely Point geometries.\n    \"\"\"\n    )\n\n    if trip_freq_as_person_freq:  # use trip freq as person freq\n        if 'freq' not in trips.columns:\n            raise UserWarning(\n                f\"\"\"\n                You have opted to use 'trip_freq_as_person_freq' but cannot build this mapping:\n                Please check 'freq' is included in the trips_diary input.\n                \"\"\"\n                )\n\n        logger.info(\"Loading person freq ('freq') from trips_diary freq input.\")\n        pid_freq_map = dict(zip(trips.pid, trips.freq))  # this will take last freq from trips\n\n        if persons_attributes is None:\n            logger.info(\"Building new person attributes dataframe to hold person frequency.\")\n            persons_attributes = pd.DataFrame({'pid': list(pid_freq_map.keys()), 'freq': list(pid_freq_map.values())})\n        else:\n            logger.info(\"Adding freq to person attributes using trip frequency.\")\n            persons_attributes['freq'] = persons_attributes.pid.map(pid_freq_map)\n\n        trips.drop('freq', axis=1, inplace=True)\n\n    if trip_freq_as_hh_freq:\n        if 'freq' not in trips.columns:\n            raise UserWarning(\n                f\"\"\"\n                You have opted to use 'trip_freq_as_hh_freq' but cannot build this mapping:\n                Please check 'freq' is included in the trips_diary input.\n                \"\"\"\n                )\n        if 'hid' not in trips.columns:\n            raise UserWarning(\n                f\"\"\"\n                You have opted to use 'trip_freq_as_hh_freq' but cannot build this mapping:\n                Please check 'hid' is included in the trips_diary input.\n                \"\"\"\n                )\n\n        logger.info(\"Loading houshold freq ('freq') from trips_diary freq input.\")\n        hid_freq_map = dict(zip(trips.hid, trips.freq))  # this will take last freq from trips\n\n        if hhs_attributes is None:\n            logger.info(\"Building new household attributes dataframe to hold houshold frequency.\")\n            hhs_attributes = pd.DataFrame({'hid': list(hid_freq_map.keys()), 'freq': list(hid_freq_map.values())})\n        else:\n            logger.info(\"Adding freq to household attributes using trip frequency.\")\n            hhs_attributes['freq'] = hhs_attributes.hid.map(hid_freq_map)\n\n        trips.drop('freq', axis=1, inplace=True)\n\n    # add hid to trips if not already added\n    if not 'hid' in trips.columns \\\n        and (persons_attributes is None or 'hid' not in persons_attributes.columns) \\\n        and (hhs_attributes is None or 'pid' not in hhs_attributes.columns):\n        logger.warning(\n\"\"\"\n            No household entities found, households will be composed of individual persons using 'pid':\n            If you wish to correct this, please add 'hid' to either the trips or persons_attributes inputs.\n            \"\"\"\n            )\n        trips['hid'] = trips.pid\n\n\n    # check that person_attributes has required fields if used\n    if persons_attributes is not None:\n        if 'pid' not in persons_attributes.columns and not persons_attributes.index.name == 'pid':\n            raise UserWarning(f\"Input person_attributes dataframe missing required unique identifier column: 'pid'.\")\n\n        if 'hid' not in persons_attributes and 'hid' in trips:\n            logger.warning(\"Adding pid-&gt;hh mapping to persons_attributes from trips.\")\n            mapping = dict(zip(trips.pid, trips.hid))\n            persons_attributes['hid'] = persons_attributes.pid.map(mapping)\n\n        if 'hzone' not in persons_attributes.columns and 'hid' in persons_attributes.columns:\n            if hhs_attributes is not None and 'hzone' in hhs_attributes:\n                logger.warning(\"Adding home locations to persons attributes using hhs_attributes.\")\n                mapping = dict(zip(hhs_attributes.hid, hhs_attributes.hzone))\n                persons_attributes['hzone'] = persons_attributes.hid.map(mapping)\n            elif 'hzone' in trips and 'hid' in trips:\n                logger.warning(\"Adding home locations to persons attributes using trips attributes.\")\n                mapping = dict(zip(trips.hid, trips.hzone))\n                persons_attributes['hzone'] = persons_attributes.hid.map(mapping)\n\n\n    # check if hh_attributes are being used\n    if hhs_attributes is not None:\n        if 'hid' not in hhs_attributes.columns and not hhs_attributes.index.name == 'hid':\n            raise UserWarning(f\"Input hh_attributes dataframe missing required unique identifier column: 'hid'.\")\n\n        if 'hid' in trips.columns:\n            logger.info(\"Using person to household mapping from trips_diary data\")\n            if persons_attributes is not None and 'hid' not in persons_attributes.columns:\n                logger.info(\"Loading person to household mapping for person_attributes from trips data\")\n                person_hh_mapping = dict(zip(trips.pid, trips.hid))\n                persons_attributes['hid'] = persons_attributes.pid.map(person_hh_mapping)\n\n        elif persons_attributes is not None and 'hid' in persons_attributes.columns:\n            logger.info(\"Loading person to household mapping from person_attributes data\")\n            person_hh_mapping = dict(zip(persons_attributes.pid, persons_attributes.hid))\n            trips['hid'] = trips.pid.map(person_hh_mapping)\n\n        else:\n            raise UserWarning(\n            f\"\"\"\n            Household attributes found but failed to build person to household mapping from provided inputs:\n            Please provide a household ID field ('hid') in either the trips_diary or person_attributes inputs.\n            \"\"\"\n            )\n\n        if 'hzone' not in hhs_attributes.columns:\n            if persons_attributes is not None and 'hzone' in persons_attributes and 'hid' in persons_attributes.columns:\n                logger.warning(\"Adding home locations to hhs attributes using persons_attributes.\")\n                mapping = dict(zip(persons_attributes.hid, persons_attributes.hzone))\n                hhs_attributes['hzone'] = hhs_attributes.hid.map(mapping)\n            elif 'hzone' in trips and 'hid' in trips:\n                logger.warning(\"Adding home locations to hhs attributes using trips attributes.\")\n                mapping = dict(zip(trips.hid, trips.hzone))\n                hhs_attributes['hzone'] = hhs_attributes.hid.map(mapping)\n\n    # add hzone to trips_diary\n    if not 'hzone' in trips.columns:\n        if hhs_attributes is not None and 'hzone' in hhs_attributes.columns:\n            logger.info(\"Loading household area ('hzone') from hh_attributes input.\")\n            hh_mapping = dict(zip(hhs_attributes.hid, hhs_attributes.hzone))\n            trips['hzone'] = trips.hid.map(hh_mapping)\n        elif persons_attributes is not None and 'hzone' in persons_attributes.columns and 'hid' in persons_attributes.columns:\n            logger.info(\"Loading household area ('hzone') from person_attributes input.\")\n            hh_mapping = dict(zip(persons_attributes.hid, persons_attributes.hzone))\n            trips['hzone'] = trips.hid.map(hh_mapping)\n        else:\n            logger.warning(\n        f\"\"\"\n        Unable to load household area ('hzone') - not found in trips_diary or unable to build from attributes.\n        Pam will try to infer home location from activities, but this behaviour is not recommended.\n        \"\"\"\n        )\n\n    # Add an empty frequency fields if required\n    if 'freq' not in trips.columns:\n        logger.warning(\"Using freq of 'None' for all trips.\")\n        trips['freq'] = None\n\n    if persons_attributes is not None and 'freq' not in persons_attributes.columns:\n        logger.warning(\"Using freq of 'None' for all persons.\")\n        persons_attributes['freq'] = None\n\n    if hhs_attributes is not None and 'freq' not in hhs_attributes.columns:\n        logger.warning(\"Using freq of 'None' for all households.\")\n        hhs_attributes['freq'] = None\n\n    if sample_perc is not None:\n        if 'freq' not in trips.columns:\n            raise UserWarning(\n                f\"\"\"\n                You have opted to use a sample ({sample_perc}, but this option requires that trips frequencies are set:):\n                Please add a 'freq' column to the trips dataframe or remove sampling (set 'sample_perc' = None).\n                \"\"\"\n                )\n        trips = sample_population(\n            trips=trips,\n            sample_perc=sample_perc,\n            weight_col='freq'\n            )  # sample the travel population\n\n    logger.debug(\"Resetting trips index if required\")\n    if trips.index.name is not None:\n        persons_attributes.reset_index(inplace=True)\n\n    if persons_attributes is not None:\n        logger.debug(\"Setting persons_attributes index to pid\")\n        if persons_attributes.index.name is None:\n            persons_attributes.set_index('pid', inplace=True)\n        elif not persons_attributes.index.name == 'pid':\n            persons_attributes = persons_attributes.reset_index().set_index('pid')\n\n    if hhs_attributes is not None:\n        logger.debug(\"Setting households_attributes index to hid\")\n        if hhs_attributes.index.name is None:\n            hhs_attributes.set_index('hid', inplace=True)\n        elif not hhs_attributes.index.name == 'hid':\n            hhs_attributes = hhs_attributes.reset_index().set_index('hid')\n\n    if from_to:\n        logger.debug(\"Initiating from-to parser.\")\n        return from_to_travel_diary_read(\n            trips = trips,\n            persons_attributes = persons_attributes,\n            hhs_attributes = hhs_attributes,\n            include_loc = include_loc,\n            sort_by_seq  = sort_by_seq,\n        )\n\n    if tour_based:\n        logger.debug(\"Initiating tour-based parser.\")\n        return tour_based_travel_diary_read(\n            trips = trips,\n            persons_attributes = persons_attributes,\n            hhs_attributes = hhs_attributes,\n            include_loc = include_loc,\n            sort_by_seq  = sort_by_seq,\n            )\n\n    logger.debug(\"Initiating trip-based parser.\")\n    return trip_based_travel_diary_read(\n        trips = trips,\n        persons_attributes = persons_attributes,\n        hhs_attributes = hhs_attributes,\n        include_loc = include_loc,\n        sort_by_seq = sort_by_seq,\n        )\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.sample_population","title":"<code>sample_population(trips_df, sample_perc, attributes_df = None, weight_col = 'freq')</code>","text":"<p>Return the trips of a random sample of the travel population. We merge the trips and attribute datasets to enable probability weights based on population demographics.</p> <p>:params DataFrame trips_df: Trips dataset :params DataFrame attributes_df: Population attributes dataset. :params float sample_perc: Sampling percentage :params string weight_col: The field to use for probability weighting</p> <p>:return: Pandas DataFrame, a sampled version of the trips_df dataframe</p> Source code in <code>pam/read/diary.py</code> <pre><code>def sample_population(trips_df, sample_perc, attributes_df=None, weight_col='freq'):\n\"\"\"\n    Return the trips of a random sample of the travel population.\n    We merge the trips and attribute datasets to enable probability weights based on population demographics.\n\n    :params DataFrame trips_df: Trips dataset\n    :params DataFrame attributes_df: Population attributes dataset.\n    :params float sample_perc: Sampling percentage\n    :params string weight_col: The field to use for probability weighting\n\n    :return: Pandas DataFrame, a sampled version of the trips_df dataframe\n    \"\"\"\n    if attributes_df is not None:\n        sample_pids = trips_df.groupby('pid')[['freq']].sum().join(\n            attributes_df, how='left'\n        ).sample(\n            frac=sample_perc, weights=weight_col\n            ).index\n    else:\n        sample_pids = trips_df.groupby('pid')[['freq']].sum().sample(\n            frac=sample_perc, weights=weight_col\n            ).index\n\n    return trips_df[trips_df.pid.isin(sample_pids)]\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.tour_based_travel_diary_read","title":"<code>tour_based_travel_diary_read(trips: pd.DataFrame, persons_attributes: Union[pd.DataFrame, None] = None, hhs_attributes: Union[pd.DataFrame, None] = None, include_loc: Union[pd.DataFrame, None] = False, sort_by_seq: Union[bool, None] = None)</code>","text":"<p>Complex travel diray reader. Will try to infer home activiity and tour based purposes. :param trips: DataFrame :param persons_attributes: DataFrame :param hhs_attributes: DataFrame :param include_loc=False, bool, optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns) :param sort_by_seq=None, optionally force trip sorting as True or False :return: core.Population</p> Source code in <code>pam/read/diary.py</code> <pre><code>def tour_based_travel_diary_read(\n    trips: pd.DataFrame,\n    persons_attributes: Union[pd.DataFrame, None] = None,\n    hhs_attributes: Union[pd.DataFrame, None] = None,\n    include_loc = False,\n    sort_by_seq: Union[bool, None] = None,\n    ):\n\"\"\"\n    Complex travel diray reader. Will try to infer home activiity and tour based purposes.\n    :param trips: DataFrame\n    :param persons_attributes: DataFrame\n    :param hhs_attributes: DataFrame\n    :param include_loc=False, bool, optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns)\n    :param sort_by_seq=None, optionally force trip sorting as True or False\n    :return: core.Population\n    \"\"\"\n\n    population = build_population(\n        trips=trips,\n        persons_attributes=persons_attributes,\n        hhs_attributes=hhs_attributes\n    )\n\n    if sort_by_seq is None and 'seq' in trips.columns:\n        sort_by_seq = True\n\n    if sort_by_seq:\n        trips = trips.sort_values(['hid','pid','seq'])\n\n    trips_dict = hh_person_df_to_dict(trips, 'hid', 'pid') # convert to dict for faster indexing\n\n    for hid, household in population:\n        for pid, person in household:\n            person_trips = trips_dict.get(hid, {}).get(pid, pd.DataFrame())\n\n            if not len(person_trips):\n                person.stay_at_home()\n                continue\n\n            loc = None\n            if include_loc:\n                loc = person_trips.start_loc.iloc[0]\n\n            person = population[hid][pid]\n\n            person.add(\n                activity.Activity(\n                    seq=0,\n                    act=None,\n                    area=person_trips.ozone.iloc[0],\n                    loc=loc,\n                    start_time=utils.parse_time(0),\n                )\n            )\n\n            for n, trip in person_trips.iterrows():\n\n                start_loc = None\n                end_loc = None\n\n                if include_loc:\n                    start_loc = trip.start_loc\n                    end_loc = trip.end_loc\n\n                person.add(\n                    activity.Leg(\n                        seq=n,\n                        purp=trip.purp.lower(),\n                        mode=trip['mode'].lower(),\n                        start_area=trip.ozone,\n                        end_area=trip.dzone,\n                        start_loc=start_loc,\n                        end_loc=end_loc,\n                        start_time=utils.parse_time(trip.tst),\n                        end_time=utils.parse_time(trip.tet),\n                        distance = trip.get('distance'),\n                        freq=trip.freq,\n                    )\n                )\n\n                person.add(\n                    activity.Activity(\n                        seq=n + 1,\n                        act=None,\n                        area=trip.dzone,\n                        loc=end_loc,\n                        start_time=utils.parse_time(trip.tet),\n                    )\n                )\n\n            person.plan.finalise_activity_end_times()\n            person.plan.infer_activities_from_tour_purpose()\n            person.plan.set_leg_purposes()\n\n    return population\n</code></pre>"},{"location":"api/read/diary/#pam.read.diary.trip_based_travel_diary_read","title":"<code>trip_based_travel_diary_read(trips: pd.DataFrame, persons_attributes: Union[pd.DataFrame, None] = None, hhs_attributes: Union[pd.DataFrame, None] = None, include_loc: Union[pd.DataFrame, None] = False, sort_by_seq: Union[bool, None] = None)</code>","text":"<p>Turn Activity Plan tabular data inputs (derived from travel survey and attributes) into core population format. This is a variation of the standard load_travel_diary() method because it does not require activity inference. However all plans are expected to be tour based, so assumed to start and end at home. We expect broadly the same data schema except rather than trip 'purpose' we use trips 'activity'. :param trips: DataFrame :param persons_attributes: DataFrame :param hhs_attributes: DataFrame :param include_loc=False, bool, optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns) :param sort_by_seq=None, optionally force trip sorting as True or False :return: core.Population</p> Source code in <code>pam/read/diary.py</code> <pre><code>def trip_based_travel_diary_read(\n    trips: pd.DataFrame,\n    persons_attributes: Union[pd.DataFrame, None] = None,\n    hhs_attributes: Union[pd.DataFrame, None] = None,\n    include_loc = False,\n    sort_by_seq: Union[bool, None] = None,\n    ):\n\"\"\"\n    Turn Activity Plan tabular data inputs (derived from travel survey and attributes) into core population\n    format. This is a variation of the standard load_travel_diary() method because it does not require\n    activity inference. However all plans are expected to be tour based, so assumed to start and end at home.\n    We expect broadly the same data schema except rather than trip 'purpose' we use trips 'activity'.\n    :param trips: DataFrame\n    :param persons_attributes: DataFrame\n    :param hhs_attributes: DataFrame\n    :param include_loc=False, bool, optionally include location data as shapely Point geometries ('start_loc' and 'end_loc' columns)\n    :param sort_by_seq=None, optionally force trip sorting as True or False\n    :return: core.Population\n    \"\"\"\n\n    population = build_population(\n        trips=trips,\n        persons_attributes=persons_attributes,\n        hhs_attributes=hhs_attributes\n    )\n\n    if sort_by_seq is None and 'seq' in trips.columns:\n        sort_by_seq = True\n\n    if sort_by_seq:\n        trips = trips.sort_values(['hid','pid','seq'])\n\n    trips_dict = hh_person_df_to_dict(trips, 'hid', 'pid') # convert to dict for faster indexing\n\n    for hid, household in population:\n        for pid, person in household:\n            person_trips = trips_dict.get(hid, {}).get(pid, pd.DataFrame())\n\n            if not len(person_trips):\n                person.stay_at_home()\n                continue\n\n            home_area = household.location.area or person_trips.hzone.iloc[0]\n            origin_area = person_trips.ozone.iloc[0]\n\n            loc = None\n            if include_loc:\n                loc = person_trips.start_loc.iloc[0]\n\n            person.add(\n                activity.Activity(\n                    seq=0,\n                    act='home',\n                    area=origin_area,\n                    loc=loc,\n                    start_time=utils.parse_time(0),\n                )\n            )\n\n            for n, trip in person_trips.iterrows():\n\n                start_loc = None\n                end_loc = None\n                if include_loc:\n                    start_loc = trip.start_loc\n                    end_loc = trip.end_loc\n                purpose = trip.purp.lower()\n\n                person.add(\n                    activity.Leg(\n                        seq=n,\n                        purp=purpose,\n                        mode=trip['mode'].lower(),\n                        start_area=trip.ozone,\n                        end_area=trip.dzone,\n                        start_loc=start_loc,\n                        end_loc=end_loc,\n                        start_time=utils.parse_time(trip.tst),\n                        end_time=utils.parse_time(trip.tet),\n                        distance = trip.get('distance')\n                    )\n                )\n\n                person.add(\n                    activity.Activity(\n                        seq=n + 1,\n                        act=purpose,\n                        area=trip.dzone,\n                        loc=end_loc,\n                        start_time=utils.parse_time(trip.tet),\n                    )\n                )\n\n            person.plan.finalise_activity_end_times()\n            household.add(person)\n\n        population.add(household)\n\n    return population\n</code></pre>"},{"location":"api/read/matsim/","title":"pam.read.matsim","text":""},{"location":"api/read/matsim/#pam.read.matsim.get_attributes_from_legs","title":"<code>get_attributes_from_legs(elem)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def get_attributes_from_legs(elem):\n    attributes = {}\n    for attr in elem.xpath('./attributes/attribute'):\n        attributes[attr.get('name')] = attr.text\n    return attributes\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.get_attributes_from_person","title":"<code>get_attributes_from_person(elem)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def get_attributes_from_person(elem):\n    ident = elem.xpath(\"@id\")[0]\n    attributes = {}\n    for attr in elem.xpath('./attributes/attribute'):\n        attributes[attr.get('name')] = attr.text\n    return ident, attributes\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.load_attributes_map","title":"<code>load_attributes_map(attributes_path)</code>","text":"<p>Given path to MATSim attributes input, return dictionary of attributes (as dict)</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def load_attributes_map(attributes_path):\n\"\"\"\n    Given path to MATSim attributes input, return dictionary of attributes (as dict)\n    \"\"\"\n    attributes_map = {}\n    people = utils.get_elems(attributes_path, \"object\")\n    for person in people:\n        att_map = {}\n        for attribute in person:\n            att_map[attribute.get('name')] = attribute.text\n        attributes_map[person.get('id')] = att_map\n\n    return attributes_map\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.load_attributes_map_from_v12","title":"<code>load_attributes_map_from_v12(plans_path)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def load_attributes_map_from_v12(plans_path):\n    return dict(\n        [\n            get_attributes_from_person(elem)\n            for elem in utils.get_elems(plans_path, \"person\")\n        ]\n    )\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.parse_matsim_plan","title":"<code>parse_matsim_plan(plan_xml, person_id: str, version: int, simplify_pt_trips: bool, crop: bool, autocomplete: bool, leg_attributes: bool = True, leg_route: bool = True) -&gt; activity.Plan</code>","text":"<p>Parse a MATSim plan.</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def parse_matsim_plan(\n    plan_xml,\n    person_id : str,\n    version : int,\n    simplify_pt_trips : bool,\n    crop : bool,\n    autocomplete : bool,\n    leg_attributes : bool = True,\n    leg_route : bool = True,\n    ) -&gt; activity.Plan:\n\"\"\"\n    Parse a MATSim plan.\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    act_seq = 0\n    leg_seq = 0\n    arrival_dt = START_OF_DAY\n    departure_dt = None\n    plan = activity.Plan()\n\n    for stage in plan_xml:\n\"\"\"\n        Loop through stages incrementing time and extracting attributes.\n        \"\"\"\n        if stage.tag in ['act', 'activity']:\n            act_seq += 1\n            act_type = stage.get('type')\n\n            loc = None\n            x, y = stage.get('x'), stage.get('y')\n            if x and y:\n                loc = Point(int(float(x)), int(float(y)))\n\n            if act_type == 'pt interaction':\n                departure = stage.get('end_time')\n                if departure is not None:\n                    departure_dt = utils.safe_strptime(departure)\n                else:\n                    departure_dt = arrival_dt + timedelta(seconds=0.)\n\n            else:\n                departure_dt = utils.safe_strptime(\n                    stage.get('end_time', '24:00:00')\n                )\n\n            if departure_dt &lt; arrival_dt:\n                logger.debug(f\"Negative duration activity found at pid={person_id}\")\n\n            plan.add(\n                activity.Activity(\n                    seq=act_seq,\n                    act=act_type,\n                    loc=loc,\n                    link=stage.get('link'),\n                    start_time=arrival_dt,\n                    end_time=departure_dt\n                )\n            )\n\n        if stage.tag == 'leg':\n\n            mode, route, attributes = unpack_leg(stage, version)\n            if not leg_attributes:\n                attributes = {}\n\n            leg_seq += 1\n            trav_time = stage.get('trav_time')\n            if trav_time is not None:\n                h, m, s = trav_time.split(\":\")\n                leg_duration = timedelta(hours=int(h), minutes=int(m), seconds=int(s))\n                arrival_dt = departure_dt + leg_duration\n            else:\n                arrival_dt = departure_dt  # todo this assumes 0 duration unless known\n\n            if not leg_route:\n                # Optionally ignores route info such as links, distance and so on.\n                plan.add(\n                    activity.Leg(\n                        seq=leg_seq,\n                        mode=mode,\n                        start_time = departure_dt,\n                        end_time = arrival_dt,\n                        attributes = attributes,\n                    )\n                )\n\n            else:\n                plan.add(\n                    activity.Leg(\n                        seq=leg_seq,\n                        mode=mode,\n                        start_link = route.get('start_link'),\n                        end_link = route.get('end_link'),\n                        start_time = departure_dt,\n                        end_time = arrival_dt,\n                        distance = route.distance,\n                        attributes = attributes,\n                        route = route\n                    )\n                )\n\n    if simplify_pt_trips:\n        plan.simplify_pt_trips()\n\n    plan.set_leg_purposes()\n\n    score = plan_xml.get('score', None)\n    if score:\n        score = float(score)\n    plan.score = score # experienced plan scores\n\n    if crop:\n        plan.crop()\n    if autocomplete:\n        plan.autocomplete_matsim()\n\n    return plan\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.read_all_vehicles_file","title":"<code>read_all_vehicles_file(path)</code>","text":"<p>Reads all_vehicles file following format https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd :param path: path to matsim all_vehicles xml file :return: dictionary of all vehicles: {ID: pam.vehicle.Vehicle class object}</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def read_all_vehicles_file(path):\n\"\"\"\n    Reads all_vehicles file following format https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd\n    :param path: path to matsim all_vehicles xml file\n    :return: dictionary of all vehicles: {ID: pam.vehicle.Vehicle class object}\n    \"\"\"\n    vehicles = {}\n    vehicle_types = {}\n\n    for vehicle_type_elem in utils.get_elems(path, \"vehicleType\"):\n        vehicle_types[vehicle_type_elem.get('id')] = VehicleType.from_xml_elem(vehicle_type_elem)\n\n    for vehicle_elem in utils.get_elems(path, \"vehicle\"):\n        vehicles[vehicle_elem.get('id')] = Vehicle(id=vehicle_elem.get('id'),\n                                                   vehicle_type=vehicle_types[vehicle_elem.get('type')])\n\n    return vehicles\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.read_electric_vehicles_file","title":"<code>read_electric_vehicles_file(path, vehicles: dict = None)</code>","text":"<p>Reads electric_vehicles file following format https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd :param path: path to matsim electric_vehicles xml :param vehicles: dictionary of {ID: pam.vehicle.Vehicle} objects, some of which may need to be updated to ElectricVehicle     based on contents of the electric_vehicles xml file. Optional, if not passed, vehicles will default to the     VehicleType defaults. :return: dictionary of all vehicles: {ID: pam.vehicle.Vehicle or pam.vehicle.ElectricVehicle class object}</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def read_electric_vehicles_file(path, vehicles: dict = None):\n\"\"\"\n    Reads electric_vehicles file following format https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd\n    :param path: path to matsim electric_vehicles xml\n    :param vehicles: dictionary of {ID: pam.vehicle.Vehicle} objects, some of which may need to be updated to ElectricVehicle\n        based on contents of the electric_vehicles xml file. Optional, if not passed, vehicles will default to the\n        VehicleType defaults.\n    :return: dictionary of all vehicles: {ID: pam.vehicle.Vehicle or pam.vehicle.ElectricVehicle class object}\n    \"\"\"\n    if vehicles is None:\n        logging.warning('All Vehicles dictionary was not passed. This will result in defaults for Vehicle Types'\n                        'Definitions assumed by the Electric Vehicles')\n        vehicles = {}\n    for vehicle_elem in utils.get_elems(path, \"vehicle\"):\n        attribs = dict(vehicle_elem.attrib)\n        id = attribs.pop('id')\n        attribs['battery_capacity'] = float(attribs['battery_capacity'])\n        attribs['initial_soc'] = float(attribs['initial_soc'])\n        if id in vehicles:\n            elem_vehicle_type = attribs.pop('vehicle_type')\n            vehicle_type = vehicles[id].vehicle_type\n            if elem_vehicle_type != vehicle_type.id:\n                raise RuntimeError(f'Electric vehicle: {id} has mis-matched vehicle type '\n                                   f'defined: {elem_vehicle_type} != {vehicle_type.id}')\n        else:\n            vehicle_type = VehicleType(id=attribs.pop('vehicle_type'))\n        vehicles[id] = ElectricVehicle(id=id, vehicle_type=vehicle_type, **attribs)\n    return vehicles\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.read_matsim","title":"<code>read_matsim(plans_path, attributes_path = None, all_vehicles_path = None, electric_vehicles_path = None, weight: int = 100, version: int = 12, household_key: Union[str, None] = None, simplify_pt_trips: bool = False, autocomplete: bool = True, crop: bool = False, keep_non_selected: bool = False, leg_attributes: bool = True, leg_route: bool = True)</code>","text":"<p>Load a MATSim format population into core population format. It is possible to maintain the unity of housholds using a household uid in the attributes input, i.e.: hh_0001 :param plans: path to matsim format xml :param attributes: path to matsim format xml :param all_vehicles_path: path to matsim all_vehicles xml file :param electric_vehicles_path: path to matsim electric_vehicles xml :param weight: int :param version: int {11,12}, default = 12 :param household_key: {str, None} :param simplify_pt_trips: bool, simplify legs in multi-leg trips, defaul t= True :param autocomplete: bool, fills missing leg and activity attributes, default = True :param crop: bool, crop plans that go beyond 24 hours, default = False :param keep_non_selected: Whether to parse non-selected plans (storing them in person.plans_non_selected) :param leg_attributes: Parse leg attributes such as routing mode, default = True :param leg_route: Parse leg route, default = True :return: core.Population</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def read_matsim(\n        plans_path,\n        attributes_path = None,\n        all_vehicles_path = None,\n        electric_vehicles_path = None,\n        weight : int = 100,\n        version : int = 12,\n        household_key : Union[str, None] = None,\n        simplify_pt_trips : bool = False,\n        autocomplete : bool = True,\n        crop : bool = False,\n        keep_non_selected : bool = False,\n        leg_attributes : bool = True,\n        leg_route : bool = True,\n):\n\"\"\"\n    Load a MATSim format population into core population format.\n    It is possible to maintain the unity of housholds using a household uid in\n    the attributes input, i.e.:\n    &lt;attribute class=\"java.lang.String\" name=\"hid\"&gt;hh_0001&lt;/attribute&gt;\n    :param plans: path to matsim format xml\n    :param attributes: path to matsim format xml\n    :param all_vehicles_path: path to matsim all_vehicles xml file\n    :param electric_vehicles_path: path to matsim electric_vehicles xml\n    :param weight: int\n    :param version: int {11,12}, default = 12\n    :param household_key: {str, None}\n    :param simplify_pt_trips: bool, simplify legs in multi-leg trips, defaul t= True\n    :param autocomplete: bool, fills missing leg and activity attributes, default = True\n    :param crop: bool, crop plans that go beyond 24 hours, default = False\n    :param keep_non_selected: Whether to parse non-selected plans (storing them in person.plans_non_selected)\n    :param leg_attributes: Parse leg attributes such as routing mode, default = True\n    :param leg_route: Parse leg route, default = True\n    :return: core.Population\n    \"\"\"\n    logger = logging.getLogger(__name__)\n\n    population = core.Population()\n\n    if attributes_path is not None and version == 12:\n        raise UserWarning(\n\"\"\"\nYou have provided an attributes_path and enabled matsim version 12, but\nv12 does not require an attributes input:\nEither remove the attributes_path arg, or enable version 11.\n\"\"\"\n    )\n\n    if version not in [11, 12]:\n        raise UserWarning(\"Version must be set to 11 or 12.\")\n\n    if version == 11 and not attributes_path:\n        logger.warning(\n\"\"\"\nYou have specified version 11 and not supplied an attributes path, population will not\nhave attributes or be able to use a household attribute id. Check this is intended.\n\"\"\"\n        )\n\n    vehicles = {}\n    if all_vehicles_path:\n        logger.debug(f\"Loading vehicles from {all_vehicles_path}\")\n        vehicles = read_vehicles(all_vehicles_path, electric_vehicles_path)\n        # todo what if we only supply electric vehicles path?\n\n    attributes = {}\n    if attributes_path:\n        logger.debug(f\"Loading attributes from {attributes_path}\")\n        if (version == 12) and (attributes_path is not None):\n            logger.warning(\"It is not required to load attributes from a separate path for version 11.\")\n        attributes = load_attributes_map(attributes_path)\n\n    for person in stream_matsim_persons(\n        plans_path,\n        attributes = attributes,\n        vehicles = vehicles,\n        weight = weight,\n        version = version,\n        simplify_pt_trips = simplify_pt_trips,\n        autocomplete = autocomplete,\n        crop = crop,\n        keep_non_selected = keep_non_selected,\n        leg_attributes=leg_attributes,\n        leg_route=leg_route,\n        ):\n        # Check if using households, then update population accordingly.\n        if household_key and person.attributes.get(household_key):  # using households\n            if population.get(person.attributes.get(household_key)):  # existing household\n                household = population.get(person.attributes.get(household_key))\n                household.add(person)\n            else:  # new household\n                household = core.Household(person.attributes.get(household_key), freq=weight)\n                household.add(person)\n                population.add(household)\n        else:  # not using households, create dummy household\n            household = core.Household(person.pid, freq=weight)\n            household.add(person)\n            population.add(household)\n\n    return population\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.read_vehicles","title":"<code>read_vehicles(all_vehicles_path, electric_vehicles_path = None)</code>","text":"<p>Reads all_vehicles file following format https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd and electric_vehicles file following format https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd :param all_vehicles_path: path to matsim all_vehicles xml file :param electric_vehicles_path: path to matsim electric_vehicles xml (optional) :return: dictionary of all vehicles: {ID: pam.vehicle.Vehicle or pam.vehicle.ElectricVehicle class object}</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def read_vehicles(all_vehicles_path, electric_vehicles_path=None):\n\"\"\"\n    Reads all_vehicles file following format https://www.matsim.org/files/dtd/vehicleDefinitions_v2.0.xsd and\n    electric_vehicles file following format https://www.matsim.org/files/dtd/electric_vehicles_v1.dtd\n    :param all_vehicles_path: path to matsim all_vehicles xml file\n    :param electric_vehicles_path: path to matsim electric_vehicles xml (optional)\n    :return: dictionary of all vehicles: {ID: pam.vehicle.Vehicle or pam.vehicle.ElectricVehicle class object}\n    \"\"\"\n    vehicles = read_all_vehicles_file(all_vehicles_path)\n    if electric_vehicles_path:\n        vehicles = read_electric_vehicles_file(electric_vehicles_path, vehicles)\n    return vehicles\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.selected_plans","title":"<code>selected_plans(plans_path)</code>","text":"<p>Given path to MATSim plans input, yield person id and plan for all selected plans.</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def selected_plans(plans_path):\n\"\"\"\n    Given path to MATSim plans input, yield person id and plan for all selected plans.\n    \"\"\"\n    for person in utils.get_elems(plans_path, \"person\"):\n        for plan in person:\n            if plan.get('selected') == 'yes':\n                yield person.get('id'), plan\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.stream_matsim_persons","title":"<code>stream_matsim_persons(plans_path, attributes = {}, vehicles = {}, weight: int = 100, version: int = 12, simplify_pt_trips: bool = False, autocomplete: bool = True, crop: bool = False, keep_non_selected: bool = False, leg_attributes: bool = True, leg_route: bool = True) -&gt; core.Person</code>","text":"<p>Stream a MATSim format population into core.Person objects. Expects agent attributes (and vehicles) to be supplied as optional dictionaries, this allows this function to support 'version 11' plans. todo: a v12 only method could also stream attributes and would use less memory :param plans: path to matsim format xml :param attributes: {}, map of person attributes, only required for v11 :param vehicles: {}, map of vehciles :param electric_vehicles_path: path to matsim electric_vehicles xml :param weight: int :param version: int {11,12}, default = 12 :param simplify_pt_trips: bool, simplify legs in multi-leg trips, default = True :param autocomplete: bool, fills missing leg and activity attributes, default = True :param crop: bool, crop plans that go beyond 24 hours, default = False :param keep_non_selected: Whether to parse non-selected plans (storing them in person.plans_non_selected). :param leg_attributes: Parse leg attributes such as routing mode, default = True :param leg_route: Parse leg route, default = True :return: core.Person</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def stream_matsim_persons(\n    plans_path,\n    attributes = {},\n    vehicles = {},\n    weight : int = 100,\n    version : int = 12,\n    simplify_pt_trips : bool = False,\n    autocomplete : bool = True,\n    crop : bool = False,\n    keep_non_selected : bool = False,\n    leg_attributes : bool = True,\n    leg_route : bool = True,\n    ) -&gt; core.Person:\n\"\"\"\n    Stream a MATSim format population into core.Person objects.\n    Expects agent attributes (and vehicles) to be supplied as optional dictionaries, this allows this\n    function to support 'version 11' plans.\n    todo: a v12 only method could also stream attributes and would use less memory\n    :param plans: path to matsim format xml\n    :param attributes: {}, map of person attributes, only required for v11\n    :param vehicles: {}, map of vehciles\n    :param electric_vehicles_path: path to matsim electric_vehicles xml\n    :param weight: int\n    :param version: int {11,12}, default = 12\n    :param simplify_pt_trips: bool, simplify legs in multi-leg trips, default = True\n    :param autocomplete: bool, fills missing leg and activity attributes, default = True\n    :param crop: bool, crop plans that go beyond 24 hours, default = False\n    :param keep_non_selected: Whether to parse non-selected plans (storing them in person.plans_non_selected).\n    :param leg_attributes: Parse leg attributes such as routing mode, default = True\n    :param leg_route: Parse leg route, default = True\n    :return: core.Person\n    \"\"\"\n\n    if version not in [11, 12]:\n        raise UserWarning(\"Version must be set to 11 or 12.\")\n\n    for person_xml in utils.get_elems(plans_path, \"person\"):\n\n        if version == 11:\n            person_id = person_xml.xpath(\"@id\")[0]\n            agent_attributes = attributes.get(person_id, {})\n        else:\n            person_id, agent_attributes = get_attributes_from_person(person_xml)\n\n        vehicle = vehicles.get(person_id, None)\n        person = core.Person(person_id, attributes=agent_attributes, freq=weight, vehicle=vehicle)\n\n        for plan_xml in person_xml:\n            if plan_xml.get('selected') == 'yes':\n                person.plan = parse_matsim_plan(\n                    plan_xml=plan_xml,\n                    person_id=person_id,\n                    version=version,\n                    simplify_pt_trips=simplify_pt_trips,\n                    crop=crop,\n                    autocomplete=autocomplete,\n                    leg_attributes=leg_attributes,\n                    leg_route=leg_route,\n                    )\n            elif keep_non_selected and plan_xml.get('selected') == 'no':\n                person.plans_non_selected.append(\n                    parse_matsim_plan(\n                        plan_xml=plan_xml,\n                        person_id=person_id,\n                        version=version,\n                        simplify_pt_trips=simplify_pt_trips,\n                        crop=crop,\n                        autocomplete=autocomplete,\n                        leg_attributes=leg_attributes,\n                        leg_route=leg_route,\n                        )\n                    )\n        yield person\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.unpack_leg","title":"<code>unpack_leg(leg, version)</code>","text":"Source code in <code>pam/read/matsim.py</code> <pre><code>def unpack_leg(leg, version):\n    if version == 12:\n        return unpack_leg_v12(leg)\n    return unpack_route_v11(leg)\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.unpack_leg_v12","title":"<code>unpack_leg_v12(leg)</code>","text":"<p>Extract mode, route and attributes as available.</p> <p>There are four known cases:</p> <p>=== Unrouted ===</p> <p>For example a leg missing both attributes and route elements, this is the case for non experienced or non routed plans:      </p> <p>=== Transit ===</p> This is a transit routed leg with the route encoded as json string and routingMode attribute <p> bus      {\"transitRouteId\":\"work_bound\",\"boardingTime\":\"07:30:00\",\"transitLineId\":\"city_line\",\"accessFacilityId\":\"home_stop_out\",\"egressFacilityId\":\"work_stop_in\"}      </p> <p>Route must be transit i.e. there will not be a network route.</p> Route attributes include <ul> <li>type = \"default_pt\"</li> <li>start_link</li> <li>end_link</li> <li>trav_time</li> <li>distance</li> </ul> <p>=== Network Routed ===</p> <p>This is a network routed mode, eg car:      28680.0 car          4155 5221366345330551489_5221366345327939575 2623 4337 5221366343808222067_5221366343837130911 2984 1636 3671 6110 etc...          </p> Route attributes include <ul> <li>type = \"links\"</li> <li>start_link</li> <li>end_link</li> <li>trav_time</li> <li>distance</li> <li>vehicleRefId</li> </ul> <p>The network route is given as a space seperated sequence of link ids.</p> <p>=== Teleported ===</p> <p>This is a teleported route, eg walk/cycle:      walk </p> Route attributes include <ul> <li>type = \"generic\"</li> <li>start_link</li> <li>end_link</li> <li>trav_time</li> <li>distance</li> </ul> <p>The network route is empty.</p> <p>Returns:</p> Type Description <p>mode (str), route (pam.activity.Route), attributes (dict)</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def unpack_leg_v12(leg):\n\"\"\"\n    Extract mode, route and attributes as available.\n\n    There are four known cases:\n\n    === Unrouted ===\n\n    For example a leg missing both attributes and route elements, this is the case for non experienced or non routed plans:\n        &lt;leg mode=\"car\" dep_time=\"07:00:00\" trav_time=\"00:07:34\"&gt;\n        &lt;/leg&gt;\n\n    === Transit ===\n\n    This is a transit routed leg with the route encoded as json string and routingMode attribute:\n        &lt;leg mode=\"pt\" trav_time=\"00:43:42\"&gt;\n            &lt;attributes&gt;\n                &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;bus&lt;/attribute&gt;\n            &lt;/attributes&gt;\n            &lt;route type=\"default_pt\" start_link=\"1-2\" end_link=\"3-4\" trav_time=\"00:43:42\" distance=\"10100.0\"&gt;\n            {\"transitRouteId\":\"work_bound\",\"boardingTime\":\"07:30:00\",\"transitLineId\":\"city_line\",\"accessFacilityId\":\"home_stop_out\",\"egressFacilityId\":\"work_stop_in\"}\n            &lt;/route&gt;\n        &lt;/leg&gt;\n    Route must be transit i.e. there will not be a network route.\n    Route attributes include:\n        - type = \"default_pt\"\n        - start_link\n        - end_link\n        - trav_time\n        - distance\n\n    === Network Routed ===\n\n    This is a network routed mode, eg car:\n        &lt;leg mode=\"car\" dep_time=\"07:58:00\" trav_time=\"00:04:52\"&gt;\n            &lt;attributes&gt;\n                &lt;attribute name=\"enterVehicleTime\" class=\"java.lang.Double\"&gt;28680.0&lt;/attribute&gt;\n                &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;car&lt;/attribute&gt;\n            &lt;/attributes&gt;\n            &lt;route type=\"links\" start_link=\"4155\" end_link=\"5221366698030330427_5221366698041252619\" trav_time=\"00:04:52\" distance=\"4898.473995989452\" vehicleRefId=\"null\"&gt;\n            4155 5221366345330551489_5221366345327939575 2623 4337 5221366343808222067_5221366343837130911 2984 1636 3671 6110 etc...\n            &lt;/route&gt;\n        &lt;/leg&gt;\n    Route attributes include:\n        - type = \"links\"\n        - start_link\n        - end_link\n        - trav_time\n        - distance\n        - vehicleRefId\n    The network route is given as a space seperated sequence of link ids.\n\n    === Teleported ===\n\n    This is a teleported route, eg walk/cycle:\n        &lt;leg mode=\"walk\" dep_time=\"09:23:00\" trav_time=\"01:54:10\"&gt;\n            &lt;attributes&gt;\n                &lt;attribute name=\"routingMode\" class=\"java.lang.String\"&gt;walk&lt;/attribute&gt;\n            &lt;/attributes&gt;\n            &lt;route type=\"generic\" start_link=\"5221366698030330427_5221366698041252619\" end_link=\"114\" trav_time=\"01:54:10\" distance=\"5710.003987453454\"&gt;&lt;/route&gt;\n        &lt;/leg&gt;\n    Route attributes include:\n        - type = \"generic\"\n        - start_link\n        - end_link\n        - trav_time\n        - distance\n    The network route is empty.\n\n    Args:\n        leg (xml_leg_element)\n\n    Returns:\n        mode (str), route (pam.activity.Route), attributes (dict)\n    \"\"\"\n    mode = leg.get(\"mode\")\n    route = Route(leg.xpath(\"route\"))\n    attributes = get_attributes_from_legs(leg)\n    return mode, route, attributes\n</code></pre>"},{"location":"api/read/matsim/#pam.read.matsim.unpack_route_v11","title":"<code>unpack_route_v11(leg)</code>","text":"<p>Extract mode, network route and transit route as available.</p> <p>Returns:</p> Type Description <code>xml_elem, string, list, dict, dict</code> <p>(route, mode, network route, transit route, attributes)</p> Source code in <code>pam/read/matsim.py</code> <pre><code>def unpack_route_v11(leg):\n\"\"\"\n    Extract mode, network route and transit route as available.\n\n    Args:\n        leg (xml_leg_element)\n\n    Returns:\n        (xml_elem, string, list, dict, dict): (route, mode, network route, transit route, attributes)\n    \"\"\"\n    mode = leg.get(\"mode\")\n    route = RouteV11(leg.xpath(\"route\"))\n    return mode, route, {}\n</code></pre>"},{"location":"api/operations/cropping/","title":"pam.operations.cropping","text":"<p>Methods for cropping plans outside core areas</p>"},{"location":"api/operations/cropping/#pam.operations.cropping.create_leg","title":"<code>create_leg(previous_act: Activity, next_act: Activity, travel_mode: str = 'car') -&gt; Leg</code>","text":"<p>Create a leg between two activities.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def create_leg(previous_act: Activity, next_act: Activity, travel_mode: str = 'car') -&gt; Leg:\n\"\"\"\n    Create a leg between two activities.\n    \"\"\"\n    leg = Leg(\n        start_time=previous_act.end_time,\n        end_time=next_act.start_time,\n        mode=travel_mode,\n        purp=next_act.act\n    )\n    leg.start_location = previous_act.location\n    leg.end_location = next_act.location\n    # link\n    leg.previous = previous_act\n    leg.next = next_act\n    return leg\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.crop_leg","title":"<code>crop_leg(leg: Leg, boundary: Polygon) -&gt; None</code>","text":"<p>Crop a leg to a boundary.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def crop_leg(leg: Leg, boundary: Polygon) -&gt; None:\n\"\"\"\n    Crop a leg to a boundary.\n    \"\"\"\n    path = get_leg_path(leg)\n    path_cropped = path.intersection(boundary)\n    start_location, end_location = path_cropped.boundary.geoms\n    leg.start_location.loc = start_location\n    leg.previous.location.loc = start_location\n    leg.end_location.loc = end_location\n    leg.next.location.loc = end_location\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.crop_plan","title":"<code>crop_plan(plan: Plan, kept_activities: List[Activity]) -&gt; None</code>","text":"<p>Crop a plan in a way that exludes any external-external movement (and the corresponding activities). If no plan components are left in scope, the plan will have a single \"external\" activity.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def crop_plan(plan: Plan, kept_activities: List[Activity]) -&gt; None:\n\"\"\"\n    Crop a plan in a way that exludes any external-external movement (and the corresponding activities).\n    If no plan components are left in scope, the plan will have a single \"external\" activity.\n    \"\"\"\n    if kept_activities:\n        day = list(filter(lambda x: filter_component(\n            x, kept_activities), plan.day))\n    else:\n        day = empty_day()\n    plan.day = day\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.empty_day","title":"<code>empty_day() -&gt; list</code>","text":"Source code in <code>pam/operations/cropping.py</code> <pre><code>def empty_day() -&gt; list:\n    day = [\n        Activity(\n            seq=1,\n            act='external',\n            area='external',\n            start_time=pam.utils.minutes_to_datetime(0),\n            end_time=pam.variables.END_OF_DAY,\n        )\n    ]\n    return day\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.filter_component","title":"<code>filter_component(component, kept_activities: List[Activity]) -&gt; bool</code>","text":"<p>Check if an activity/leg should be kept.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def filter_component(component, kept_activities: List[Activity]) -&gt; bool:\n\"\"\"\n    Check if an activity/leg should be kept.\n    \"\"\"\n    if isinstance(component, Activity):\n        return component in kept_activities\n    elif isinstance(component, Leg):\n        return ((component.previous in kept_activities) and (component.next in kept_activities))\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.get_kept_activities","title":"<code>get_kept_activities(plan: Plan, boundary: Polygon) -&gt; list</code>","text":"<p>Get a list of the activities to keep after cropping external-external movements.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def get_kept_activities(plan: Plan, boundary: Polygon) -&gt; list:\n\"\"\"\n    Get a list of the activities to keep after cropping external-external movements.\n    \"\"\"\n    kept_activities = list()\n    for leg in plan.legs:\n        if leg_intersects(leg, boundary):\n            for act in [leg.previous, leg.next]:\n                if act not in kept_activities:\n                    kept_activities.append(act)\n    return kept_activities\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.get_leg_path","title":"<code>get_leg_path(leg: Leg) -&gt; LineString</code>","text":"<p>Get the (euclidean) geometry of a leg.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def get_leg_path(leg: Leg) -&gt; LineString:\n\"\"\"\n    Get the (euclidean) geometry of a leg.\n    \"\"\"\n    path = LineString([leg.start_location.loc, leg.end_location.loc])\n    return path\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.infill_legs","title":"<code>infill_legs(plan: Plan) -&gt; None</code>","text":"<p>Infill missing legs. If there is no leg between two activities, a new one is created linking them.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def infill_legs(plan: Plan) -&gt; None:\n\"\"\"\n    Infill missing legs.\n    If there is no leg between two activities, a new one is created linking them.\n    \"\"\"\n    i = 0\n    while i &lt; len(plan.day) - 1:\n        component1 = plan.day[i]\n        component2 = plan.day[i+1]\n        if isinstance(component1, Activity) and isinstance(component2, Activity):\n            leg = create_leg(component1, component2)\n            plan.day.insert(i+1, leg)\n            i += 1\n        i += 1\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.leg_intersects","title":"<code>leg_intersects(leg: Leg, boundary: Polygon) -&gt; bool</code>","text":"<p>Check whether a leg touches an area defined by a boundary.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def leg_intersects(leg: Leg, boundary: Polygon) -&gt; bool:\n\"\"\"\n    Check whether a leg touches an area defined by a boundary.\n    \"\"\"\n    path = get_leg_path(leg)\n    return path.intersects(boundary)\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.link_plan","title":"<code>link_plan(plan: Plan) -&gt; None</code>","text":"<p>Link a plan: each activity/leg gets a pointer to the previous/next plan component</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def link_plan(plan: Plan) -&gt; None:\n\"\"\"\n    Link a plan: each activity/leg gets a pointer to the previous/next plan component\n    \"\"\"\n    plan_list = list(plan)\n    act_list = list(plan.activities)\n    leg_list = list(plan.legs)\n\n    for i, p in enumerate(plan_list):\n        p.next = list_get(plan_list, i+1)\n        p.previous = list_get(plan_list, i-1)\n\n    for i, p in enumerate(act_list):\n        p.next_act = list_get(act_list, i+1)\n        p.previous_act = list_get(act_list, i-1)\n\n    for i, p in enumerate(leg_list):\n        p.start_hour = p.start_time.hour\n        p.next_leg = list_get(leg_list, i+1)\n        p.previous_leg = list_get(leg_list, i-1)\n        p.start_location = p.previous.location\n        p.end_location = p.next.location\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.link_population","title":"<code>link_population(population: Population) -&gt; None</code>","text":"<p>Link the plan components of every agent in the population.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def link_population(population: Population) -&gt; None:\n\"\"\"\n    Link the plan components of every agent in the population.\n    \"\"\"\n    for hid, pid, person in population.people():\n        link_plan(person.plan)\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.list_get","title":"<code>list_get(l, i)</code>","text":"Source code in <code>pam/operations/cropping.py</code> <pre><code>def list_get(l, i):\n    if i &lt; len(l) and i &gt;= 0:\n        return l[i]\n    else:\n        return None\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.rename_external","title":"<code>rename_external(plan: Plan, boundary: Polygon) -&gt; None</code>","text":"<p>Rename all external-area activities as \"external\"</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def rename_external(plan: Plan, boundary: Polygon) -&gt; None:\n\"\"\"\n    Rename all external-area activities as \"external\"\n    \"\"\"\n    for act in plan.activities:\n        if not boundary.contains(act.location.loc):\n            act.act = 'external'\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.simplify_external_plans","title":"<code>simplify_external_plans(plan: Plan, boundary: Polygon, snap_to_boundary: Polygon = False, rename_external_activities: Polygon = False) -&gt; None</code>","text":"<p>Simplify any activities happening outside the boundary area.</p> Method <p>1: Identify which legs touch the boundary area 2: Keep the relevant legs/activities and drop the remaining components 3: Infill: create any new legs between external activities as necessary 4: Ensure plan consistency: start/end times, sequences, etc 5 (optional) : Rename activities to \"external\" 6 (optional) : Crop the leg geometries to start/stop at the core area boundaries</p> <p>:param plan: a PAM plan :param boundary: the geometry of the core modelled area :param snap_to_boundary: whether to crop legs to stop at the core area boundary. :param rename_external_activities: whether to rename all external-area activities as \"external\"</p> <p>:return: None</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def simplify_external_plans(\n    plan: Plan,\n    boundary: Polygon,\n    snap_to_boundary=False,\n    rename_external_activities=False\n) -&gt; None:\n\"\"\"\n    Simplify any activities happening outside the boundary area.\n\n    Method:\n     1: Identify which legs touch the boundary area\n     2: Keep the relevant legs/activities and drop the remaining components\n     3: Infill: create any new legs between external activities as necessary\n     4: Ensure plan consistency: start/end times, sequences, etc\n     5 (optional) : Rename activities to \"external\"\n     6 (optional) : Crop the leg geometries to start/stop at the core area boundaries\n\n    :param plan: a PAM plan\n    :param boundary: the geometry of the core modelled area\n    :param snap_to_boundary: whether to crop legs to stop at the core area boundary.\n    :param rename_external_activities: whether to rename all external-area activities as \"external\"\n\n    :return: None\n\n    \"\"\"\n    link_plan(plan)\n    kept_activities = get_kept_activities(plan, boundary)  # activities to keep\n    crop_plan(plan, kept_activities)  # drop external plan components\n    infill_legs(plan)  # infill with any new legs if required\n    stretch_times(plan)  # fix plan time boundaries\n    link_plan(plan)  # re-link plan components\n    if rename_external_activities:\n        rename_external(plan, boundary)  # rename activities to \"external\"\n    if snap_to_boundary:\n        for leg in plan.legs:\n            crop_leg(leg, boundary)  # crop leg geometry\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.simplify_population","title":"<code>simplify_population(population: str, boundary: str, snap_to_boundary: bool = False, rename_external_activities: bool = False) -&gt; None</code>","text":"<p>Simplify external plans across a population</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def simplify_population(\n    population: str,\n    boundary: str,\n    snap_to_boundary: bool = False,\n    rename_external_activities: bool = False,\n) -&gt; None:\n\"\"\"\n    Simplify external plans across a population\n    \"\"\"\n    # simplify plans\n    for hid, pid, person in population.people():\n        simplify_external_plans(\n            person.plan, boundary, snap_to_boundary, rename_external_activities)\n\n    # remove empty person-plans and households\n    remove_persons = []\n    for hid, pid, person in population.people():\n        if len(person.plan) == 1 and person.plan.day[0].act == 'external':\n            remove_persons.append((hid, pid))\n    for hid, pid in remove_persons:\n        del population[hid].people[pid]\n\n    remove_hhs = [hid for hid in population.households if len(\n        population.households[hid].people) == 0]\n    for hid in remove_hhs:\n        del population.households[hid]\n</code></pre>"},{"location":"api/operations/cropping/#pam.operations.cropping.stretch_times","title":"<code>stretch_times(plan: Plan) -&gt; None</code>","text":"<p>Extend start/end activity times to the start/end of day.</p> Source code in <code>pam/operations/cropping.py</code> <pre><code>def stretch_times(plan: Plan) -&gt; None:\n\"\"\"\n    Extend start/end activity times to the start/end of day.\n    \"\"\"\n    plan.day[0].start_time = START_OF_DAY\n    plan.day[-1].end_time = END_OF_DAY\n</code></pre>"},{"location":"api/operations/combine/","title":"pam.operations.combine","text":""},{"location":"api/operations/combine/#pam.operations.combine.pop_combine","title":"<code>pop_combine(inpaths: str, matsim_version: int, household_key: str = 'hid', simplify_pt_trips: bool = False, autocomplete: bool = True, crop: bool = False, leg_attributes: bool = True, leg_route: bool = True, keep_non_selected: bool = True)</code>","text":"<p>Combine two or more populations (e.g. household, freight... etc).</p> Source code in <code>pam/operations/combine.py</code> <pre><code>def pop_combine(\n    inpaths: str,\n    matsim_version: int,\n    household_key: str = \"hid\",\n    simplify_pt_trips: bool = False,\n    autocomplete : bool = True,\n    crop: bool = False,\n    leg_attributes: bool = True,\n    leg_route: bool = True,\n    keep_non_selected = True,\n    ):\n\n\"\"\"\n    Combine two or more populations (e.g. household, freight... etc).\n\n    \"\"\"\n    print(\"==================================================\")\n    print(f\"Combining input populations\")\n\n    combined_population = core.Population()\n\n    for inpath in inpaths:\n\n        population = read.read_matsim(\n            inpath,\n            weight=1,\n            version=matsim_version,\n            household_key=household_key,\n            simplify_pt_trips=simplify_pt_trips,\n            autocomplete=autocomplete,\n            crop=crop,\n            leg_attributes=leg_attributes,\n            leg_route=leg_route,\n            keep_non_selected=keep_non_selected\n            )\n        print(f\"population: {population.stats}\")\n\n        combined_population += population\n\n    return combined_population\n</code></pre>"},{"location":"api/samplers/time/","title":"pam.samplers.time","text":""},{"location":"api/samplers/time/#pam.samplers.time.apply_jitter_to_plan","title":"<code>apply_jitter_to_plan(plan: Plan, jitter: timedelta, min_duration: timedelta)</code>","text":"<p>Apply time jitter to activity durations in a plan, leg durations are kept the same. Activity durations are jittered in sequence order. At each step the activity is jittered according to the maximum jitter and minimum duration of all activities in the plan.</p> <p>Parameters:</p> Name Type Description Default <code>plan</code> <code>Plan</code> <p>plan to be jittered</p> required <code>jitter</code> <code>timedelta</code> <p>maximum jitter</p> required <code>min_duration</code> <code>timedelta</code> <p>minimum activity duration</p> required Source code in <code>pam/samplers/time.py</code> <pre><code>def apply_jitter_to_plan(\n    plan: Plan,\n    jitter: timedelta,\n    min_duration: timedelta\n    ):\n\"\"\"\n    Apply time jitter to activity durations in a plan, leg durations are kept the same.\n    Activity durations are jittered in sequence order. At each step the activity\n    is jittered according to the maximum jitter and minimum duration of all activities\n    in the plan.\n    Args:\n        plan (Plan): plan to be jittered\n        jitter (timedelta): maximum jitter\n        min_duration (timedelta): minimum activity duration\n    \"\"\"\n    if plan.length == 1:  # do nothing\n        return None\n    for i in range(0, plan.length-1, 2):\n        jitter_activity(plan, i, jitter=jitter, min_duration=min_duration)\n</code></pre>"},{"location":"api/samplers/time/#pam.samplers.time.jitter_activity","title":"<code>jitter_activity(plan: Plan, i: int, jitter: timedelta, min_duration: timedelta)</code>","text":"<p>Jitter duration of given activity at index i. Remaining activities and legs after activity are also shifted. Leg durations are not changed. Subsequent activity durations are equally change to maintain 24hr plan.</p> Source code in <code>pam/samplers/time.py</code> <pre><code>def jitter_activity(\n    plan: Plan,\n    i: int,\n    jitter: timedelta,\n    min_duration: timedelta\n    ):\n\"\"\"\n    Jitter duration of given activity at index i. Remaining activities and legs after activity are also shifted.\n    Leg durations are not changed.\n    Subsequent activity durations are equally change to maintain 24hr plan.\n    \"\"\"\n    act = plan[i]\n    if not isinstance(act, Activity):\n        raise UserWarning(f\"Expected type of Activity for act, not {type(act)}\")\n\n    prev_duration = act.duration\n    tail = (len(plan) - i)/2\n\n    min_end = max(act.start_time + min_duration, act.end_time - jitter)\n\n    allowance = plan[-1].end_time - act.end_time\n    for j in range(i+1, len(plan), 2):  # legs\n        allowance =- plan[j].duration\n    for j in range(i+2, len(plan)+1, 2):  # acts\n        allowance =- min_duration\n\n    max_end = min(plan[-1].end_time - allowance, act.end_time + jitter)\n    jitter_range = max((max_end - min_end).seconds,1)\n\n    jitter = timedelta(seconds=randrange(jitter_range))\n    new_duration = min_end - act.start_time + jitter\n    change = (new_duration - prev_duration)/tail\n\n    time = act.shift_duration(new_duration)\n    time = plan[i+1].shift_start_time(time)  # shift first tail leg\n\n    for j in range(i+2, len(plan)-1, 2):  # tail acts\n        time = plan[j].shift_start_time(time)\n        time = plan[j].shift_duration(plan[j].duration-change)\n        time = plan[j+1].shift_start_time(time)  # leg\n\n    # final act\n    time = plan[-1].shift_start_time(time)\n    plan[-1].end_time = END_OF_DAY\n</code></pre>"},{"location":"api/samplers/attributes/","title":"pam.samplers.attributes","text":""},{"location":"api/samplers/attributes/#pam.samplers.attributes.bin_integer_transformer","title":"<code>bin_integer_transformer(features, target, bins, default = None)</code>","text":"<p>Bin a target integer feature based on bins. Where bins are a dict, with keys as a tuple of bin extends (inclusive) and values as the new mapping. Missing ranges will return None. Where features are a dictionary structure of features, eg: {'age':1, ...}</p> Source code in <code>pam/samplers/attributes.py</code> <pre><code>def bin_integer_transformer(features, target, bins, default=None):\n\"\"\"\n    Bin a target integer feature based on bins. Where bins are a dict, with keys as\n    a tuple of bin extends (inclusive) and values as the new mapping. Missing ranges\n    will return None.\n    Where features are a dictionary structure of features, eg: {'age':1, ...}\n    \"\"\"\n    value = features.get(target)\n    if value is None:\n            raise KeyError(f\"Can not find target key: {target} in sampling features: {features}\")\n    for (lower, upper), new_value in bins.items():\n        if lower &lt; int(value) &lt;= upper:\n            return new_value\n    return default\n</code></pre>"},{"location":"api/samplers/attributes/#pam.samplers.attributes.discrete_joint_distribution_sampler","title":"<code>discrete_joint_distribution_sampler(features, mapping, distribution, careful = False, seed: int = None)</code>","text":"<p>Randomly sample from a joint distribution based some discrete features.</p> <p>Where features are a dictionary structure of features, eg: {'gender':'female'}</p> <p>Distribution is a nested dict of probabilities based on possible features, eg: {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': .5}}</p> <p>Mapping provides the feature name for each level of the distribution, eg: ['age', 'gender']</p> <p>Missing keys return False, unless careful is set to True, which will raise an error.</p> <p>:params int seed: seed number for reproducible results (None default - does not fix seed)</p> Source code in <code>pam/samplers/attributes.py</code> <pre><code>def discrete_joint_distribution_sampler(features, mapping, distribution, careful=False, seed:int=None):\n\"\"\"\n    Randomly sample from a joint distribution based some discrete features.\n\n    Where features are a dictionary structure of features, eg: {'gender':'female'}\n\n    Distribution is a nested dict of probabilities based on possible features, eg:\n    {'0-0': {'male': 0, 'female': 0},... , '90-120': {'male': 1, 'female': .5}}\n\n    Mapping provides the feature name for each level of the distribution, eg:\n    ['age', 'gender']\n\n    Missing keys return False, unless careful is set to True, which will raise an error.\n\n    :params int seed: seed number for reproducible results (None default - does not fix seed)\n    \"\"\"\n    # Fix random seed\n    random.seed(seed)\n    p = distribution\n    for key in mapping:\n        value = features.get(key)\n        if value is None:\n            raise KeyError(f\"Can not find mapping: {key} in sampling features: {features}\")\n\n        p = p.get(value)\n        if p is None:\n            if careful:\n                raise KeyError(f\"Can not find feature for {key}: {value} in distribution: {p}\")\n            else:\n                return False\n    return random.random() &lt;= p\n</code></pre>"},{"location":"api/samplers/population/","title":"pam.samplers.population","text":""},{"location":"api/samplers/population/#pam.samplers.population.sample","title":"<code>sample(population: Population, sample: float, seed: int = None, verbose: bool = False) -&gt; Population</code>","text":"<p>Sample a new population from the existing using a sample size, eg 0.1 for a 10% sample. Returns a new pam.core.Population object with households sampled based on input freq. Freq of returned population is set to 1/sample, eg 0.1 -&gt; 10, such that each household and person represents 10 people from input population. Note that in the current implementation frequencies are automatically discovered from the population object households, person and leg weights, in that order. When gathering frequencies, for example for a household from multiple person in that houshold, the household frequency is taken as the average person frequency. Similarly for persons and their legs.</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>Population</code> <p>input population object to sample from using population freq</p> required <code>sample</code> <code>float</code> <p>sample size of new population, eg 0.1 for a 10% sample</p> required <code>verbose</code> <code>bool</code> <p>verbosity</p> <code>False</code> <p>Returns:</p> Type Description <code>Population</code> <p>pam.core.Population</p> Source code in <code>pam/samplers/population.py</code> <pre><code>def sample(\n    population: Population,\n    sample: float,\n    seed: int=None,\n    verbose: bool=False\n    ) -&gt; Population:\n\"\"\"\n    Sample a new population from the existing using a sample size, eg 0.1 for a 10% sample.\n    Returns a new pam.core.Population object with households sampled based on input freq.\n    Freq of returned population is set to 1/sample, eg 0.1 -&gt; 10, such that each household\n    and person represents 10 people from input population.\n    Note that in the current implementation frequencies are automatically discovered from the population object households,\n    person and leg weights, in that order. When gathering frequencies, for\n    example for a household from multiple person in that houshold, the household\n    frequency is taken as the average person frequency. Similarly for persons\n    and their legs.\n    Args:\n        population (Population): input population object to sample from using population freq\n        sample (float): sample size of new population, eg 0.1 for a 10% sample\n        verbose (bool): verbosity\n    Returns:\n        pam.core.Population\n    \"\"\"\n\n    sampled_population = Population()\n    sample_freq = int(1/sample)\n    size = population.size * sample\n    sampled = 0\n\n    for _, hh in population:\n        sampled_count = freq_sample(\n            freq = hh.freq,\n            sample = sample,\n            seed = seed\n        )\n\n        for n in range(sampled_count):  # add sampled hhs (note we provide new unique hid)\n            sampled_hh = deepcopy(hh)\n            sampled_hh.hid = f\"{hh.hid}-{n}\"\n            sampled_hh.people = {}\n            sampled_hh.hh_freq = sample_freq\n\n            # add sampled people (note we provide a new unique pid)\n            for pid, person in hh.people.items():\n                sampled_person = deepcopy(person)\n                sampled_person.pid = f\"{pid}-{n}\"\n                sampled_person.person_freq = sample_freq\n                sampled_hh.add(sampled_person)\n\n            sampled_population.add(sampled_hh)\n\n        if verbose:\n            sampled += sampled_count\n            progress = sampled / size\n            if progress%0.01 == 0:\n                print(f\"Sampled approx. {progress*100}%\")\n\n    if verbose:\n        print(f\"Population sampler completed: {sampled} households from target of {size} sampled\")\n\n    return sampled_population\n</code></pre>"},{"location":"api/samplers/spatial/","title":"pam.samplers.spatial","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler","title":"<code>GeometryRandomSampler(geo_df_file, geometry_name_column, default_region, seed: int = None)</code>","text":"<p>:params int seed: seed number for reproducible results (None default - does not fix seed)</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def __init__(self, geo_df_file, geometry_name_column, default_region, seed:int=None):\n'''\n    :params int seed: seed number for reproducible results (None default - does not fix seed)\n    '''\n\n    self.geo_df = gp.read_file(geo_df_file)\n    self.geometry_name_column = geometry_name_column\n    self.default_region = default_region\n\n    self.geo_df_loc_lookup = {value: key for (key, value) in self.geo_df[geometry_name_column].to_dict().items()}\n\n    #Throws exception if default_region is invalid\n    default_id = self.geo_df_loc_lookup[default_region]\n    self.default_geom = self.geo_df.geometry.loc[default_id]\n\n    # Store random seed\n    self.seed = seed\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.default_geom","title":"<code>default_geom = self.geo_df.geometry.loc[default_id]</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.default_region","title":"<code>default_region = default_region</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.geo_df","title":"<code>geo_df = gp.read_file(geo_df_file)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.geo_df_loc_lookup","title":"<code>geo_df_loc_lookup = {value: key for (key, value) in self.geo_df[geometry_name_column].to_dict().items()}</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.geometry_name_column","title":"<code>geometry_name_column = geometry_name_column</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.seed","title":"<code>seed = seed</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.GeometryRandomSampler.sample_point","title":"<code>sample_point(geo_region, patience = 1000)</code>","text":"<p>**From Mimi Returns randomly placed point within given geometry, using the lsoa_df. Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry. If the method cannot return a valid point within 50 attempts then a RunTimeWarning is raised. :param geo_name: name of a geometry in the object's geopandas dataframe :return: Point object</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point(self, geo_region, patience=1000):\n\"\"\"\n    **From Mimi\n    Returns randomly placed point within given geometry, using the lsoa_df. Note that it uses\n    random sampling within the shape's bounding box then checks if point is within given geometry.\n    If the method cannot return a valid point within 50 attempts then a RunTimeWarning is raised.\n    :param geo_name: name of a geometry in the object's geopandas dataframe\n    :return: Point object\n    \"\"\"\n\n    try:\n        geo_id = self.geo_df_loc_lookup[geo_region]\n        geom = self.geo_df.geometry.loc[geo_id]\n    except KeyError:\n        print('Unknown region: {}, sampling from {}'.format(geo_region, self.default_region))\n        geom = self.default_geom\n\n    # Fix random seed\n    random.seed(self.seed)\n\n    min_x, min_y, max_x, max_y = geom.bounds\n    for attempt in range(patience):\n        random_point = Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))\n        if geom.is_valid:\n            if random_point.within(geom):\n                return random_point\n        else:\n            if random_point.within(geom.buffer(0)):\n                return random_point\n\n    raise RuntimeWarning(f'unable to sample point from geometry:{geo_region} with {patience} attempts')\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler","title":"<code>RandomPointSampler(geoms: Union[gp.GeoSeries, gp.GeoDataFrame], patience: Union[gp.GeoSeries, gp.GeoDataFrame] = 100, fail: Union[gp.GeoSeries, gp.GeoDataFrame] = True, seed: int = None)</code>","text":"<p>Returns randomly placed point within given geometries, as defined by geoms. Note that it uses random sampling within the shape's bounding box then checks if point is within given geometry. If the method cannot return a valid point within 'patience' attempts then either a RunTimeWarning is raised or returns None. :param geoms: GeoPandas or GeoSeries object :param patience: int, number of tries to sample point :param fail: Bool, option to raise error rather than return None :params int seed: seed number for reproducible results (None default - does not fix seed)</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def __init__(self, geoms: Union[gp.GeoSeries, gp.GeoDataFrame], patience=100, fail=True, seed:int=None):\n\"\"\"\n    Returns randomly placed point within given geometries, as defined by geoms. Note that it uses\n    random sampling within the shape's bounding box then checks if point is within given geometry.\n    If the method cannot return a valid point within 'patience' attempts then either a RunTimeWarning\n    is raised or returns None.\n    :param geoms: GeoPandas or GeoSeries object\n    :param patience: int, number of tries to sample point\n    :param fail: Bool, option to raise error rather than return None\n    :params int seed: seed number for reproducible results (None default - does not fix seed)\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n\n    self.index = list(geoms.index)\n\n    if isinstance(geoms, gp.GeoSeries):\n        self.geoms = geoms\n\n    elif isinstance(geoms, gp.GeoDataFrame):\n        self.geoms = geoms.geometry\n\n    else:\n        raise UserWarning(f\"Unknown datatype: {type(geoms)}, please use GeoSeries or GeoDataFrame\")\n\n    self.patience = patience\n    self.fail = fail\n    # Store random seed\n    self.seed = seed\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.fail","title":"<code>fail = fail</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.geoms","title":"<code>geoms = geoms</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.index","title":"<code>index = list(geoms.index)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.patience","title":"<code>patience = patience</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.seed","title":"<code>seed = seed</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample","title":"<code>sample(idx: Union[int, str], activity: Union[int, str])</code>","text":"<p>:param idx: index for geom index :return: Point object or None</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample(self, idx: Union[int, str], activity):\n\"\"\"\n    :param idx: index for geom index\n    :return: Point object or None\n    \"\"\"\n\n    if not idx in self.index:\n        if self.fail:\n            raise IndexError(f'Cannot find idx: {idx} in geoms index')\n        self.logger.warning(f'Cannot find idx:{idx}, returning None')\n        return None\n\n    geom = self.geoms[idx]\n\n    if not geom.is_valid:\n        geom.buffer(0)\n\n    if geom.geom_type == \"Polygon\":\n        return self.validate_return(self.sample_point_from_polygon(geom), idx)\n\n    if geom.geom_type == \"MultiPolygon\":\n        return self.validate_return(self.sample_point_from_multipolygon(geom), idx)\n\n    if geom.geom_type == \"LineString\" or geom.geom_type == \"LinearRing\":\n        return self.validate_return(self.sample_point_from_linestring(geom), idx)\n\n    if geom.geom_type == \"MultiLineString\":\n        return self.validate_return(self.sample_point_from_multilinestring(geom), idx)\n\n    if geom.geom_type == \"Point\":\n        return self.validate_return(self.sample_point_from_point(geom), idx)\n\n    if geom.geom_type == \"MultiPoint\":\n        return self.validate_return(self.sample_point_from_multipoint(geom), idx)\n\n    self.logger.warning(f\"Unknown geom type {geom.geom_type}, attempting to sample.\")\n\n    return self.validate_return(self.sample_point_from_polygon(geom), idx)\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_linestring","title":"<code>sample_point_from_linestring(geom)</code>","text":"<p>Also works for linearRing</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_linestring(self, geom):\n\"\"\"\n    Also works for linearRing\n    \"\"\"\n    # Fix random seed\n    random.seed(self.seed)\n    return geom.interpolate(random.random(), True)\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_multilinestring","title":"<code>sample_point_from_multilinestring(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_multilinestring(self, geom):\n    # Fix random seed\n    random.seed(self.seed)\n    line = random.choice(list(geom.geoms))\n    return self.sample_point_from_linestring(line)\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_multipoint","title":"<code>sample_point_from_multipoint(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_multipoint(self, geom):\n    # Fix random seed\n    random.seed(self.seed)\n    return random.choice(list(geom.geoms))\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_multipolygon","title":"<code>sample_point_from_multipolygon(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_multipolygon(self, geom):\n    # Fix random seed\n    random.seed(self.seed)\n    poly = random.choices(geom.geoms, weights=[poly.area for poly in geom.geoms])[0]\n    return self.sample_point_from_polygon(poly)\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_point","title":"<code>sample_point_from_point(geom)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_point(self, geom):\n    return geom\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.sample_point_from_polygon","title":"<code>sample_point_from_polygon(geom)</code>","text":"<p>Return random coordinates within polygon, note that will return float coordinates.</p> Source code in <code>pam/samplers/spatial.py</code> <pre><code>def sample_point_from_polygon(self, geom):\n\"\"\"\n    Return random coordinates within polygon, note that will return float coordinates.\n    \"\"\"\n    # Fix random seed\n    random.seed(self.seed)\n    min_x, min_y, max_x, max_y = geom.bounds\n    for _ in range(self.patience):\n        random_point = Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))\n        if random_point.within(geom):\n            return random_point\n\n    return Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))\n</code></pre>"},{"location":"api/samplers/spatial/#pam.samplers.spatial.RandomPointSampler.validate_return","title":"<code>validate_return(point, idx)</code>","text":"Source code in <code>pam/samplers/spatial.py</code> <pre><code>def validate_return(self, point, idx):\n    if point is None and self.fail:\n        raise TimeoutError(f\"Failed to sample point for geom idx: {idx}\")\n    return point\n</code></pre>"},{"location":"api/samplers/facility/","title":"pam.samplers.facility","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler","title":"<code>FacilitySampler(facilities: gp.GeoDataFrame, zones: gp.GeoDataFrame, activities: list = None, build_xml: bool = True, fail: bool = True, random_default: bool = True, weight_on: str = None, max_walk: float = None, transit_modes: list = None, expected_euclidean_speeds: dict = None, activity_areas_path: str = None, seed: int = None)</code>","text":"<p>Sampler object for facilities. optionally build a facility xml output (for MATSim). Note that if a zone id is missing then the sampler will not be able to default to random sample, so will either return None or fail as per the fail flag. :param facilities: facilities Geodataframe :param zones: zones Geodataframe :param activities: optionally set list of subset of activities to be considered :param build_xml: flag for facility xml output (for MATSim) :param fail: flag hard fail if sample not found :param random_default: flag for defaulting to random sample when activity missing :param weight_on: the column name of the facilities geodataframe which contains facility weights (for sampling) :param max_walk: maximum walking distnace from a transit stop :param list transit_modes: a list of PT modes. If not specified, the default list in variables.TRANSIT_MODES is used :param list expected_euclidean_speeds: a dictionary specifying the euclidean speed of the various modes (m/s). If not specified, the default list in variables.EXPECTED_EUCLIDEAN_SPEEDS is used :param str activity_areas_path: path to the activity areas shapefile (previously exported throught the FacilitySampler.export_activity_areas method) :params int seed: seed number for reproducible results (None default - does not fix seed)</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def __init__(\n    self,\n    facilities: gp.GeoDataFrame,\n    zones: gp.GeoDataFrame,\n    activities: list=None,\n    build_xml: bool=True,\n    fail: bool=True,\n    random_default: bool=True,\n    weight_on: str=None,\n    max_walk: float=None,\n    transit_modes: list=None,\n    expected_euclidean_speeds: dict=None,\n    activity_areas_path: str=None,\n    seed: int=None\n    ):\n\"\"\"\n    Sampler object for facilities. optionally build a facility xml output (for MATSim).\n    Note that if a zone id is missing then the sampler will not be able to default to\n    random sample, so will either return None or fail as per the fail flag.\n    :param facilities: facilities Geodataframe\n    :param zones: zones Geodataframe\n    :param activities: optionally set list of subset of activities to be considered\n    :param build_xml: flag for facility xml output (for MATSim)\n    :param fail: flag hard fail if sample not found\n    :param random_default: flag for defaulting to random sample when activity missing\n    :param weight_on: the column name of the facilities geodataframe which contains facility weights (for sampling)\n    :param max_walk: maximum walking distnace from a transit stop\n    :param list transit_modes: a list of PT modes. If not specified, the default list in variables.TRANSIT_MODES is used\n    :param list expected_euclidean_speeds: a dictionary specifying the euclidean speed of the various modes (m/s). If not specified, the default list in variables.EXPECTED_EUCLIDEAN_SPEEDS is used\n    :param str activity_areas_path: path to the activity areas shapefile (previously exported throught the FacilitySampler.export_activity_areas method)\n    :params int seed: seed number for reproducible results (None default - does not fix seed)\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n\n    # Fix random seed\n    self.seed = seed\n\n    if activities is None:\n        self.activities = list(set(facilities.activity))\n    else:\n        self.activities = activities\n\n    ## overrides for transit mode and speed specifications\n    self.TRANSIT_MODES = transit_modes if transit_modes is not None else variables.TRANSIT_MODES\n    self.EXPECTED_EUCLIDEAN_SPEEDS = expected_euclidean_speeds if expected_euclidean_speeds is not None else variables.EXPECTED_EUCLIDEAN_SPEEDS\n\n    # spatial join\n    if activity_areas_path is None:\n        self.activity_areas = self.spatial_join(facilities, zones)\n        self.activity_areas_dict = self.activity_areas_indexing(self.activity_areas)\n    else:\n        self.load_activity_areas(activity_areas_path)\n\n    # build samplers\n    self.samplers = self.build_facilities_sampler(self.activity_areas_dict, weight_on = weight_on, max_walk = max_walk)\n    self.build_xml = build_xml\n    self.fail = fail\n    self.random_default = random_default\n\n    if random_default:\n        self.random_sampler = RandomPointSampler(geoms=zones, fail=fail, seed=seed)\n\n    self.facilities = {}\n    self.index_counter = 0\n    self.error_counter = 0\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.EXPECTED_EUCLIDEAN_SPEEDS","title":"<code>EXPECTED_EUCLIDEAN_SPEEDS = expected_euclidean_speeds if expected_euclidean_speeds is not None else variables.EXPECTED_EUCLIDEAN_SPEEDS</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.TRANSIT_MODES","title":"<code>TRANSIT_MODES = transit_modes if transit_modes is not None else variables.TRANSIT_MODES</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.activities","title":"<code>activities = list(set(facilities.activity))</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.activity_areas","title":"<code>activity_areas = self.spatial_join(facilities, zones)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.activity_areas_dict","title":"<code>activity_areas_dict = self.activity_areas_indexing(self.activity_areas)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.build_xml","title":"<code>build_xml = build_xml</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.error_counter","title":"<code>error_counter = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.facilities","title":"<code>facilities = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.fail","title":"<code>fail = fail</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.index_counter","title":"<code>index_counter = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.random_default","title":"<code>random_default = random_default</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.random_sampler","title":"<code>random_sampler = RandomPointSampler(geoms=zones, fail=fail, seed=seed)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.samplers","title":"<code>samplers = self.build_facilities_sampler(self.activity_areas_dict, weight_on=weight_on, max_walk=max_walk)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.seed","title":"<code>seed = seed</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.activity_areas_indexing","title":"<code>activity_areas_indexing(activity_areas)</code>","text":"<p>Convert joined zone-activities gdf to a nested dictionary for faster indexing The first index level refers to zones, while the second to activity purposes.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def activity_areas_indexing(self, activity_areas):\n\"\"\"\n    Convert joined zone-activities gdf to a nested dictionary for faster indexing\n    The first index level refers to zones, while the second to activity purposes.\n    \"\"\"\n    activity_areas_dict = {x:{} for x in activity_areas['index_right'].unique()}\n    for (zone, act), facility_data in activity_areas.groupby(['index_right', 'activity']):\n        activity_areas_dict[zone][act] = facility_data\n\n    return activity_areas_dict\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.build_facilities_sampler","title":"<code>build_facilities_sampler(activity_areas, weight_on = None, max_walk = None)</code>","text":"<p>Build facility location sampler from osmfs input. The sampler returns a tuple of (uid, Point) TODO - I do not like having a sjoin and assuming index names here TODO - look to move to more carefully defined input data format for facilities</p> <p>:params str weight_on: a column (name) of the facilities geodataframe to be used as a sampling weight</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def build_facilities_sampler(self, activity_areas, weight_on = None, max_walk = None):\n\"\"\"\n    Build facility location sampler from osmfs input. The sampler returns a tuple of (uid, Point)\n    TODO - I do not like having a sjoin and assuming index names here\n    TODO - look to move to more carefully defined input data format for facilities\n\n    :params str weight_on: a column (name) of the facilities geodataframe to be used as a sampling weight\n    \"\"\"\n    sampler_dict = {}\n\n    self.logger.warning(\"Building sampler, this may take a while.\")\n    for zone in set(activity_areas.keys()):\n        sampler_dict[zone] = {}\n        zone_facs = activity_areas.get(zone, {})\n\n        for act in self.activities:\n            self.logger.debug(f\"Building sampler for zone:{zone} act:{act}.\")\n            facs = zone_facs.get(act, None)\n            if facs is not None:\n                points = list(facs.geometry.items())\n                if weight_on is not None:\n                    # weighted sampler\n                    weights = facs[weight_on]\n                    transit_distance = facs['transit'] if max_walk is not None else None\n                    sampler_dict[zone][act] = inf_yielder(points, weights, transit_distance, max_walk, self.TRANSIT_MODES, self.EXPECTED_EUCLIDEAN_SPEEDS, seed=self.seed)\n                else:\n                    # simple sampler\n                    sampler_dict[zone][act] = inf_yielder(points,seed=self.seed)\n            else:\n                sampler_dict[zone][act] = None\n    return sampler_dict\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.clear","title":"<code>clear()</code>","text":"Source code in <code>pam/samplers/facility.py</code> <pre><code>def clear(self):\n    self.facilities = {}\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.export_activity_areas","title":"<code>export_activity_areas(filepath)</code>","text":"<p>Export the spatially joined facilities-zones geodataframe</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def export_activity_areas(self, filepath):\n\"\"\"\n    Export the spatially joined facilities-zones geodataframe\n    \"\"\"\n    with open(filepath, 'wb') as f:\n        pickle.dump(self.activity_areas_dict, f)\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.load_activity_areas","title":"<code>load_activity_areas(filepath)</code>","text":"<p>Load the spatially joined facilities-zones geodataframe</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def load_activity_areas(self, filepath):\n\"\"\"\n    Load the spatially joined facilities-zones geodataframe\n    \"\"\"\n    with open(filepath, 'rb') as f:\n        self.activity_areas_dict = pickle.load(f)\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.sample","title":"<code>sample(location_idx, activity, mode = None, previous_duration = None, previous_loc = None)</code>","text":"<p>Sample a shapely.Point from the given location and for the given activity. :params str location_idx: the zone to sample from :params str activity: activity purpose :params str mode: transport mode used to access facility :params pd.Timedelta previous_duration: the time duration of the arriving leg :params shapely.Point previous_loc: the location of the last visited activity</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def sample(self, location_idx, activity, mode=None, previous_duration=None, previous_loc=None):\n\"\"\"\n    Sample a shapely.Point from the given location and for the given activity.\n    :params str location_idx: the zone to sample from\n    :params str activity: activity purpose\n    :params str mode: transport mode used to access facility\n    :params pd.Timedelta previous_duration: the time duration of the arriving leg\n    :params shapely.Point previous_loc: the location of the last visited activity\n    \"\"\"\n\n    idx, loc = self.sample_facility(location_idx, activity, mode=mode, previous_duration=previous_duration, previous_loc=previous_loc)\n\n    if idx is not None and self.build_xml:\n        self.facilities[idx] = {'loc': loc, 'act': activity}\n\n    return loc\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.sample_facility","title":"<code>sample_facility(location_idx, activity, patience = 1000, mode = None, previous_duration = None, previous_loc = None)</code>","text":"<p>Sample a facility id and location. If a location idx is missing, can return a random location.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def sample_facility(self, location_idx, activity, patience=1000, mode=None, previous_duration=None, previous_loc=None):\n\"\"\"\n    Sample a facility id and location. If a location idx is missing, can return a random location.\n    \"\"\"\n    if location_idx not in self.samplers:\n        if self.random_default:\n            self.logger.warning(f\"Using random sample for zone:{location_idx}:{activity}\")\n            idx = f\"_{self.index_counter}\"\n            self.index_counter += 1\n            return idx, self.random_sampler.sample(location_idx, activity)\n        if self.fail:\n            raise IndexError(f'Cannot find idx: {location_idx} in facilities sampler')\n        self.logger.warning(f'Missing location idx:{location_idx}')\n        return None, None\n\n    sampler = self.samplers[location_idx][activity]\n\n    if sampler is None:\n        self.error_counter += 1\n        if self.error_counter &gt;= patience:\n            raise UserWarning(f\"Failures to sample, exceeded patience of {patience}.\")\n        if self.random_default:\n            self.logger.warning(f\"Using random sample for zone:{location_idx}:{activity}\")\n            idx = f\"_{self.index_counter}\"\n            self.index_counter += 1\n            return idx, self.random_sampler.sample(location_idx, activity)\n        elif self.fail:\n            raise UserWarning(\n        f'Cannot find activity: {activity} in location: {location_idx}, consider allowing random default.'\n        )\n        else:\n            return None, None\n    else:\n        self.error_counter = 0\n        if isinstance(sampler, GeneratorType):\n            return next(sampler)\n        else:\n            return next(sampler(mode, previous_duration, previous_loc))\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.spatial_join","title":"<code>spatial_join(facilities, zones)</code>","text":"<p>Spatially join facility and zone data</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def spatial_join(self, facilities, zones):\n\"\"\"\n    Spatially join facility and zone data\n    \"\"\"\n    self.logger.warning(\"Joining facilities data to zones, this may take a while.\")\n    activity_areas = gp.sjoin(facilities, zones, how='inner', predicate='intersects')\n    return activity_areas\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.FacilitySampler.write_facilities_xml","title":"<code>write_facilities_xml(path, comment = None, coordinate_reference_system = None)</code>","text":"Source code in <code>pam/samplers/facility.py</code> <pre><code>def write_facilities_xml(self, path, comment=None, coordinate_reference_system=None):\n\n    create_local_dir(os.path.dirname(path))\n\n    compression = DEFAULT_GZIP_COMPRESSION if is_gzip(path) else 0\n    with et.xmlfile(path, encoding=\"utf-8\", compression=compression) as xf:\n        xf.write_declaration()\n        xf.write_doctype(\n            '&lt;!DOCTYPE facilities SYSTEM \"http://matsim.org/files/dtd/facilities_v1.dtd\"&gt;'\n        )\n\n        with xf.element(\"facilities\"):\n            if comment:\n                xf.write(et.Comment(comment), pretty_print=True)\n            # xf.write(et.Comment(f\"Created {datetime.today()}\"))\n\n            if coordinate_reference_system is not None:\n                xf.write(create_crs_attribute(coordinate_reference_system), pretty_print=True)\n\n            for i, data in self.facilities.items():\n                facility_xml = et.Element(\n                    'facility',\n                    {'id':str(i), \"x\" : str(data['loc'].x), \"y\" : str(data['loc'].y)}\n                    )\n                act_xml = et.SubElement(\n                    facility_xml,\n                    'activity',\n                    {\"type\" : data['act']})\n                xf.write(facility_xml, pretty_print=True)\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.euclidean_distance","title":"<code>euclidean_distance(p1, p2)</code>","text":"<p>Calculate euclidean distance between two Activity.location.loc objects</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def euclidean_distance(p1, p2):\n\"\"\"\n    Calculate euclidean distance between two Activity.location.loc objects\n    \"\"\"\n    return ((p1.x-p2.x)**2 + (p1.y-p2.y)**2)**0.5\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.inf_yielder","title":"<code>inf_yielder(candidates, weights = None, transit_distance = None, max_walk = None, transit_modes = None, expected_euclidean_speeds = None, seed: int = None)</code>","text":"<p>Redirect to the appropriate sampler. :params list candidates: a list of tuples, containing candidate facilities and their index: :params pd.Series weights: sampling weights (ie facility floorspace) :params pd.Series transit_distance: distance of each candidate facility from the closest PT stop :params float max_walk: maximum walking distance from a PT stop</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def inf_yielder(candidates, weights = None, transit_distance=None, max_walk=None, transit_modes=None, expected_euclidean_speeds=None, seed:int=None):\n\"\"\"\n    Redirect to the appropriate sampler.\n    :params list candidates: a list of tuples, containing candidate facilities and their index:\n    :params pd.Series weights: sampling weights (ie facility floorspace)\n    :params pd.Series transit_distance: distance of each candidate facility from the closest PT stop\n    :params float max_walk: maximum walking distance from a PT stop\n    \"\"\"\n    if isinstance(weights, pd.Series):\n        return lambda mode = None, previous_duration = None, previous_loc = None: inf_yielder_weighted(\n                candidates = candidates,\n                weights = weights,\n                transit_distance = transit_distance,\n                max_walk = max_walk,\n                transit_modes=transit_modes,\n                expected_euclidean_speeds=expected_euclidean_speeds,\n                mode = mode,\n                previous_duration = previous_duration,\n                previous_loc = previous_loc,\n                seed = seed\n            )\n    else:\n        return inf_yielder_simple(candidates, seed = seed)\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.inf_yielder_simple","title":"<code>inf_yielder_simple(candidates, seed: int = None)</code>","text":"<p>Endlessly yield shuffled candidate items.</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def inf_yielder_simple(candidates, seed:int = None):\n\"\"\"\n    Endlessly yield shuffled candidate items.\n    \"\"\"\n    # Fix random seed\n    random.seed(seed)\n    while True:\n        random.shuffle(candidates)\n        for c in candidates:\n            yield c\n</code></pre>"},{"location":"api/samplers/facility/#pam.samplers.facility.inf_yielder_weighted","title":"<code>inf_yielder_weighted(candidates, weights, transit_distance, max_walk, transit_modes, expected_euclidean_speeds, mode, previous_duration, previous_loc, seed: int = None)</code>","text":"<p>A more complex sampler, which allows for weighted and rule-based sampling (with replacement). :params list candidates: a list of tuples, containing candidate facilities and their index: :params pd.Series weights: sampling weights (ie facility floorspace) :params pd.Series transit_distance: distance of each candidate facility from the closest PT stop :params float max_walk: maximum walking distance from a PT stop :params str mode: transport mode used to access facility :params pd.Timedelta previous_duration: the time duration of the arriving leg :params shapely.Point previous_loc: the location of the last visited activity :params int seed: seed of pseudorandom number generator (default None means that the seed remains unfixed)</p> Source code in <code>pam/samplers/facility.py</code> <pre><code>def inf_yielder_weighted(candidates, weights, transit_distance, max_walk, transit_modes, expected_euclidean_speeds, mode, previous_duration, previous_loc, seed:int=None):\n\"\"\"\n    A more complex sampler, which allows for weighted and rule-based sampling (with replacement).\n    :params list candidates: a list of tuples, containing candidate facilities and their index:\n    :params pd.Series weights: sampling weights (ie facility floorspace)\n    :params pd.Series transit_distance: distance of each candidate facility from the closest PT stop\n    :params float max_walk: maximum walking distance from a PT stop\n    :params str mode: transport mode used to access facility\n    :params pd.Timedelta previous_duration: the time duration of the arriving leg\n    :params shapely.Point previous_loc: the location of the last visited activity\n    :params int seed: seed of pseudorandom number generator (default None means that the seed remains unfixed)\n    \"\"\"\n    # Fix random seed\n    np.random.seed(seed)\n    if isinstance(weights, pd.Series):\n        # if a series of facility weights is provided, perform weighted sampling with replacement\n        while True:\n\n            ## if a transit mode is used and the distance from a stop is longer than the maximum walking distance,\n            ## then replace the weight with a very small value\n            if isinstance(transit_distance, pd.Series) and mode in transit_modes:\n                weights = np.where(\n                    transit_distance &gt; max_walk,\n                    weights * variables.SMALL_VALUE, # if no alternative is found within the acceptable range, the initial weights will be used\n                    weights\n                )\n            else:\n                weights = weights.values\n\n            # if the last location has been passed to the sampler, normalise by (expected) distance\n            if previous_loc is not None:\n\n                # calculate euclidean distance between the last visited location and every candidate location\n                distances = np.array([euclidean_distance(previous_loc, candidate[1]) for candidate in candidates])\n\n                # calculate deviation from \"expected\" distance\n                speed = expected_euclidean_speeds[mode] if mode in expected_euclidean_speeds.keys() else expected_euclidean_speeds['average']\n                expected_distance = (previous_duration / pd.Timedelta(seconds=1)) * speed  # (in meters)\n                distance_weights = np.abs(distances - expected_distance)\n                distance_weights = np.where(distance_weights==0, variables.SMALL_VALUE, distance_weights) # avoid having zero weights\n\n                ## normalise weights by distance\n                # weights = weights / np.exp(distance_weights) # exponentiate distances to reduce the effect very small distances\n                # weights = weights / np.exp(distance_weights/distance_weights.max())\n                # weights = weights / (1 + np.exp(1*(distance_weights - distance_weights.mean()))) # alternative formulation: logistic curve\n                # weights = weights / (1 + np.exp((distance_weights))) # alternative formulation: logistic curve\n                weights = weights / (distance_weights ** 2) # distance decay factor of 2\n\n            weights = weights / weights.sum() # probability weights should add up to 1\n            yield candidates[np.random.choice(len(candidates), p = weights)]\n</code></pre>"},{"location":"api/samplers/basic/","title":"pam.samplers.basic","text":""},{"location":"api/samplers/basic/#pam.samplers.basic.freq_sample","title":"<code>freq_sample(freq: float, sample: float, seed: int = None)</code>","text":"<p>Down or up sample a frequency based on a sample size. Sub unit frequencies are rounded probabalistically. :param freq: pre sampled frequency (integer) :param sample: sample size (float) :params int seed: seed number for reproducible results (None default - does not fix seed)</p> <p>:return: new frequency (integer)</p> Source code in <code>pam/samplers/basic.py</code> <pre><code>def freq_sample(freq: float, sample: float, seed:int=None):\n\"\"\"\n    Down or up sample a frequency based on a sample size. Sub unit frequencies are\n    rounded probabalistically.\n    :param freq: pre sampled frequency (integer)\n    :param sample: sample size (float)\n    :params int seed: seed number for reproducible results (None default - does not fix seed)\n\n    :return: new frequency (integer)\n    \"\"\"\n    # Fix random seed\n    random.seed(seed)\n\n    new_freq = freq * sample\n    remainder = new_freq - int(new_freq)\n    remainder = int(random.random() &lt; remainder)\n    return int(new_freq) + remainder\n</code></pre>"},{"location":"api/samplers/tour/","title":"pam.samplers.tour","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.ActivityDuration","title":"<code>ActivityDuration</code>","text":"<p>Object to estimate the distance, journey time, and stop time of activities.  The last function activity_duration combines these three functions to output parameters that help build tour plans.</p>"},{"location":"api/samplers/tour/#pam.samplers.tour.ActivityDuration.model_activity_duration","title":"<code>model_activity_duration(o_loc, d_loc, end_tm, speed = 50000 / 3600, maxi = 3600, mini = 600)</code>","text":"<p>Returns estimated Activity Duration, which is combination of previous three functions to return parameters  for next activity in Plan. :param o_loc: origin facility :param d_loc: destination facility :param end_tm: most recent end time of previous leg :param speed: speed of vehicle, default at 50km/hr :param maxi: maximum stop time :param mini: minimum stop time :return: stop_duration, start_tm, and end_tm for new activity</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_activity_duration(self, o_loc, d_loc, end_tm, speed=50000/3600, maxi=3600, mini=600):\n\"\"\" \n    Returns estimated Activity Duration, which is combination of previous three functions to return parameters \n    for next activity in Plan.\n    :param o_loc: origin facility\n    :param d_loc: destination facility\n    :param end_tm: most recent end time of previous leg\n    :param speed: speed of vehicle, default at 50km/hr\n    :param maxi: maximum stop time\n    :param mini: minimum stop time\n    :return: stop_duration, start_tm, and end_tm for new activity\n    \"\"\"\n\n    trip_distance = self.model_distance(o_loc, d_loc)\n    trip_duration = self.model_journey_time(trip_distance, speed)\n    stop_duration = self.model_stop_time(trip_duration, maxi, mini)\n\n    start_tm = end_tm\n    end_tm = end_tm + int(trip_duration/60)\n\n    return stop_duration, start_tm, end_tm\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ActivityDuration.model_distance","title":"<code>model_distance(o, d, scale = 1.4)</code>","text":"<p>Models distance between two shapely points</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_distance(self, o, d, scale=1.4):\n\"\"\"\n    Models distance between two shapely points\n    \"\"\"\n    return o.distance(d) * scale                                                                                                                 \n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ActivityDuration.model_journey_time","title":"<code>model_journey_time(distance, speed = 50000 / 3600)</code>","text":"<p>:param distance: in m :param speed: in m/s, default 50km/hr :return: modelled journey time</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_journey_time(self, distance, speed=50000/3600):\n\"\"\"\n    :param distance: in m\n    :param speed: in m/s, default 50km/hr\n    :return: modelled journey time\n    \"\"\"\n    return distance / speed\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ActivityDuration.model_stop_time","title":"<code>model_stop_time(time, maxi = 3600, mini = 600)</code>","text":"<p>Returns a duration that is between the minimum amount of seconds, an input journey time, or maximum time. :param time: in s :param maxi: maximum time for a journey :param mini: minimum time for a journey :return: maximum value between minimum time or the minimum of journey time and maximum time</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def model_stop_time(self, time, maxi=3600, mini=600): \n\"\"\"\n    Returns a duration that is between the minimum amount of seconds, an input journey time, or maximum time.\n    :param time: in s\n    :param maxi: maximum time for a journey\n    :param mini: minimum time for a journey\n    :return: maximum value between minimum time or the minimum of journey time and maximum time\n    \"\"\"\n    return max([mini, min([time, maxi])])\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler","title":"<code>FrequencySampler(dist, freq = None, threshold_matrix = None, threshold_value = None)</code>","text":"<p>Object for initiating and sampling from frequency weighted distributing.  This object includes three samplers: a single sample, multiple samples, or sample based on a threshold value  (requires a threshold matrix).</p> <p>:param dist: a dictionary of an input distribution :param freq: a parameter to weight the samplers :param threshold_matrix: a dataframe that will be reduced based on a specified threshold_value. :param threshold_value: a value to filter the threshold_matrix. This is the maximum allowed value.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(self, dist, freq=None, threshold_matrix=None, threshold_value=None):\n\"\"\"\n    :param dist: a dictionary of an input distribution\n    :param freq: a parameter to weight the samplers\n    :param threshold_matrix: a dataframe that will be reduced based on a specified threshold_value.\n    :param threshold_value: a value to filter the threshold_matrix. This is the maximum allowed value.\n    \"\"\"\n\n    self.distribution = dist\n    self.frequency = freq\n    self.threshold_matrix = threshold_matrix\n    self.threshold_value = threshold_value\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.distribution","title":"<code>distribution = dist</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.frequency","title":"<code>frequency = freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.threshold_matrix","title":"<code>threshold_matrix = threshold_matrix</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.threshold_value","title":"<code>threshold_value = threshold_value</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.sample","title":"<code>sample()</code>","text":"<p>:return: single object or list of objects sampled from distribution</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def sample(self):\n\"\"\"\n    :return: single object or list of objects sampled from distribution\n    \"\"\"\n    return random.choices(self.distribution, weights=self.frequency, k=1)[0]\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.samples","title":"<code>samples(n = 1)</code>","text":"<p>:param n: number of samples to be returned :return: single object or list of objects sampled from distribution</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def samples(self, n=1):\n\"\"\"\n    :param n: number of samples to be returned\n    :return: single object or list of objects sampled from distribution\n    \"\"\"\n    return random.choices(self.distribution, weights=self.frequency, k=n)\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.FrequencySampler.threshold_sample","title":"<code>threshold_sample()</code>","text":"<p>Returns a sampler of a distribution that has been reduced based on a threshold value.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def threshold_sample(self):\n\"\"\"\n    Returns a sampler of a distribution that has been reduced based on a threshold value.\n    \"\"\"\n\n    d_list = self.threshold_matrix\n    d_list = d_list[d_list&lt;=self.threshold_value].index\n    d_threshold = self.distribution[self.distribution.index.isin(d_list)]\n\n    if len(d_threshold) == 0:\n        warnings.warn('No destinations within this threshold value, change threshold')\n        return None\n    else:\n        return random.choices(list(d_threshold.index), weights=list(d_threshold[self.frequency]), k=1)[0]        \n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.PivotDistributionSampler","title":"<code>PivotDistributionSampler(bins, pivots, total = None)</code>","text":"<p>Defines a distribution, a sampler, and plots based on input values. The resulting distribution can be sampled for inputs required to build an agent plan (i.e, time of day, repetition of activities).</p> <p>Builds a dict distribution based on bins (i.e, hours) and pivots (i.e, hourly demand).  The interpolate function defined above is applied to estimate values within the bin range where the input pivot does not specify a value. :param bins: a range or dictionary of values :param pivots: a dictionary of values associated with the bins</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(self, bins, pivots, total=None):\n\"\"\"\n    Builds a dict distribution based on bins (i.e, hours) and pivots (i.e, hourly demand). \n    The interpolate function defined above is applied to estimate values within the bin range where the input pivot does not specify a value.\n    :param bins: a range or dictionary of values\n    :param pivots: a dictionary of values associated with the bins\n    \"\"\"\n\n    self.demand = {}\n\n    if bins[0] not in pivots:\n        pivots[bins[0]] = 0\n    if bins[-1]+1 not in pivots:\n        pivots[bins[-1]+1] = 0\n\n    pivot_keys = sorted(pivots.keys())\n\n    for k in range(len(pivot_keys)-1):\n        ka = pivot_keys[k]\n        kb = pivot_keys[k+1]\n        pivot_a = pivots[ka]\n        pivot_b = pivots[kb]\n        for i in bins:\n            if ka &lt;= i &lt; kb:\n                self.demand[i] = interpolate(i, ka, pivot_a, kb, pivot_b)\n            else:\n                continue       \n\n    if total is not None:\n        dist_sum = sum(self.demand.values())\n        for i in bins:\n            self.demand[i] = (self.demand[i]/dist_sum)*total\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.PivotDistributionSampler.demand","title":"<code>demand = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.PivotDistributionSampler.plot","title":"<code>plot(plot_title, x_label, y_label)</code>","text":"<p>Plots distribution to validate the distribution aligns with expected hourly demand.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot(self, plot_title, x_label, y_label):\n\"\"\"\n    Plots distribution to validate the distribution aligns with expected hourly demand.\n    \"\"\"\n\n    fig, ax = plt.subplots(figsize=(10,4))\n    ax.bar(list(self.demand.keys()), list(self.demand.values()))\n    ax.plot(list(self.demand.keys()), list(self.demand.values()), c = 'orange')\n    ax.set_title(plot_title)\n    ax.set_xlabel(x_label)\n    ax.set_ylabel(y_label)\n\n    return fig\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.PivotDistributionSampler.sample","title":"<code>sample()</code>","text":"Source code in <code>pam/samplers/tour.py</code> <pre><code>def sample(self):\n    return random.choices(list(self.demand.keys()), list(self.demand.values()), k=1)[0]\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner","title":"<code>TourPlanner(stops, hour, minute, o_zone, d_dist, d_freq, facility_sampler, activity_params, threshold_matrix = None, threshold_value = None)</code>","text":"<p>Object to plan the tour of the agent. This includes sequencing the stops and adding the activity and leg via an apply method.</p> <p>:params stops: # of stops :params hour: input of sampled hour :params minute: input of sampled minute :params o_zone: origin zone :params d_dist: distribution of destination zones :params d_freq: frequency value to sample of destination distribution :params facility_sampler: returned object from FacilitySampler :params activity_params: dictionary of str of origin activity (str) and destination activity (str) :params threshold_matrix: dataframe that will be reduced based on threshold value :params threshold_value: maximum threshold value allowed between origin and destination in threshold_matrix.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(self, stops, hour, minute, o_zone, d_dist, d_freq, facility_sampler, activity_params, threshold_matrix=None, threshold_value=None):\n\"\"\"\n    :params stops: # of stops\n    :params hour: input of sampled hour\n    :params minute: input of sampled minute\n    :params o_zone: origin zone\n    :params d_dist: distribution of destination zones\n    :params d_freq: frequency value to sample of destination distribution\n    :params facility_sampler: returned object from FacilitySampler\n    :params activity_params: dictionary of str of origin activity (str) and destination activity (str)\n    :params threshold_matrix: dataframe that will be reduced based on threshold value\n    :params threshold_value: maximum threshold value allowed between origin and destination in threshold_matrix.\n    \"\"\"\n\n    self.stops = stops\n    self.hour = hour\n    self.minute = minute\n    self.o_zone = o_zone\n    self.threshold_matrix = threshold_matrix\n    self.d_dist = d_dist\n    self.d_freq = d_freq\n    self.threshold_value = threshold_value\n    self.facility_sampler = facility_sampler\n    self.o_activity = activity_params['o_activity']\n    self.d_activity = activity_params['d_activity']\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.d_activity","title":"<code>d_activity = activity_params['d_activity']</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.d_dist","title":"<code>d_dist = d_dist</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.d_freq","title":"<code>d_freq = d_freq</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.facility_sampler","title":"<code>facility_sampler = facility_sampler</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.hour","title":"<code>hour = hour</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.minute","title":"<code>minute = minute</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.o_activity","title":"<code>o_activity = activity_params['o_activity']</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.o_zone","title":"<code>o_zone = o_zone</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.stops","title":"<code>stops = stops</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.threshold_matrix","title":"<code>threshold_matrix = threshold_matrix</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.threshold_value","title":"<code>threshold_value = threshold_value</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.add_return_origin","title":"<code>add_return_origin(agent, k, o_loc, d_zone, d_loc, end_tm)</code>","text":"<p>Driver returns to origin, from their most recent stop to the origin location. :params agent: agent for which the leg &amp; activity will be added to Plan :params k: when used in a for loop, k populates the next sequence valuey :params o_loc: origin facility of leg &amp; activity :params d_zone: destination zone of leg &amp; activity :params d_loc: destination facility of leg &amp; activity :params end_tm: obtained from ActivityDuration object :params speed: default setting of 50km/hr :return: end_tm after returning to origin.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def add_return_origin(self, agent, k, o_loc, d_zone, d_loc, end_tm):\n\"\"\" \n    Driver returns to origin, from their most recent stop to the origin location.\n    :params agent: agent for which the leg &amp; activity will be added to Plan\n    :params k: when used in a for loop, k populates the next sequence valuey\n    :params o_loc: origin facility of leg &amp; activity\n    :params d_zone: destination zone of leg &amp; activity\n    :params d_loc: destination facility of leg &amp; activity\n    :params end_tm: obtained from ActivityDuration object\n    :params speed: default setting of 50km/hr\n    :return: end_tm after returning to origin.\n    \"\"\"\n\n    trip_distance = ActivityDuration().model_distance(o_loc, d_loc)\n    trip_duration = ActivityDuration().model_journey_time(trip_distance)\n\n    start_tm = end_tm\n    end_tm = end_tm + int(trip_duration/60)\n\n    end_tm = self.add_tour_leg(agent=agent, k=k, o_zone=d_zone, o_loc=d_loc, d_zone=self.o_zone, d_loc=o_loc, start_tm=start_tm, end_tm=end_tm)\n\n    time_params = {'start_tm':end_tm, 'end_tm':END_OF_DAY}\n    end_tm = self.add_tour_activity(agent=agent, k=k, zone=self.o_zone,loc=o_loc, activity_type='return_origin',time_params=time_params)\n\n    return end_tm\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.add_tour_activity","title":"<code>add_tour_activity(agent, k, zone, loc, activity_type, time_params)</code>","text":"<p>Add activity to tour plan. :params agent: agent for which the activity will be added to Plan :params k: when used in a for loop, k populates the next sequence value :params zone: zone where activity takes place :params loc: facility location where activity takes place :params activity_type: str, this function has specific logic for 'return_origin' :params time_params: dictionary of time_params that may be time samplers or times of previous journeys :return: end_tm of activity</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def add_tour_activity(self, agent, k, zone, loc, activity_type, time_params):\n\"\"\"\n    Add activity to tour plan.\n    :params agent: agent for which the activity will be added to Plan\n    :params k: when used in a for loop, k populates the next sequence value\n    :params zone: zone where activity takes place\n    :params loc: facility location where activity takes place\n    :params activity_type: str, this function has specific logic for 'return_origin'\n    :params time_params: dictionary of time_params that may be time samplers or times of previous journeys\n    :return: end_tm of activity\n    \"\"\"\n\n    if activity_type == self.o_activity:\n        start_tm = 0\n        end_tm = (time_params['hour']*60) + time_params['minute']\n        seq = 1\n        act = activity_type\n    elif activity_type == 'return_origin':\n        start_tm = time_params['start_tm'] # end_tm\n        end_tm = time_params['end_tm']  # END_OF_DAY we'll let pam trim this to 24 hours later\n        seq = k+2\n        act = self.o_activity\n    else:\n        start_tm = time_params['end_tm']\n        end_tm = time_params['end_tm'] + int(time_params['stop_duration']/60)\n        seq = k+2\n        act = activity_type\n\n    # Activity plan requires mtdt format, but int format needs to passed for other functions to calculate new start time.\n    # END_OF_DAY is already in mtdt format, adding an exception to keep set mtdt format when not END_OF_DAY.\n    if end_tm is not END_OF_DAY:\n        end_tm_mtdt = mtdt(end_tm)\n    else:\n        end_tm_mtdt=end_tm\n\n    agent.add(Activity(\n        seq=seq,\n        act=act,\n        area=zone,\n        loc=loc,\n        start_time=mtdt(start_tm),\n        end_time=end_tm_mtdt\n    ))\n\n    return end_tm        \n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.add_tour_leg","title":"<code>add_tour_leg(agent, k, o_zone, o_loc, d_zone, d_loc, start_tm, end_tm)</code>","text":"<p>Leg to Next Delivery. :params agent: agent for which the leg will be added to Plan :params k: when used in a for loop, k populates the next sequence value :params o_zone: origin zone of leg :params o_loc: origin facility of leg :params d_zone: destination zone of leg :params d_loc: destination facility of leg :params start_tm, end_tm: obtained from ActivityDuration object :returns: new end_tm after leg is added to plan</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def add_tour_leg(self, agent, k, o_zone, o_loc, d_zone, d_loc, start_tm, end_tm):\n\"\"\" \n    Leg to Next Delivery.\n    :params agent: agent for which the leg will be added to Plan\n    :params k: when used in a for loop, k populates the next sequence value\n    :params o_zone: origin zone of leg\n    :params o_loc: origin facility of leg\n    :params d_zone: destination zone of leg\n    :params d_loc: destination facility of leg\n    :params start_tm, end_tm: obtained from ActivityDuration object\n    :returns: new end_tm after leg is added to plan\n    \"\"\"\n\n    agent.add(Leg(\n        seq=k+1,\n        mode='car', \n        start_area=o_zone,\n        end_area=d_zone,\n        start_loc=o_loc,\n        end_loc=d_loc,\n        start_time=mtdt(start_tm),\n        end_time=mtdt(end_tm), \n    ))\n\n    return end_tm\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.apply","title":"<code>apply(agent, o_loc, d_zones, d_locs)</code>","text":"<p>Apply the above functions to the agent to build a plan.  :params agent: agent to build a plan fory :params o_loc: origin facility of leg &amp; activity :params d_zones: destination zones of leg &amp; activity :params d_locs: destination facilities of leg &amp; activity</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def apply(self, agent, o_loc, d_zones, d_locs):\n\"\"\"\n    Apply the above functions to the agent to build a plan. \n    :params agent: agent to build a plan fory\n    :params o_loc: origin facility of leg &amp; activity\n    :params d_zones: destination zones of leg &amp; activity\n    :params d_locs: destination facilities of leg &amp; activity\n    \"\"\"\n\n    time_params = {'hour':self.hour, 'minute':self.minute}\n    end_tm = self.add_tour_activity(agent=agent, k=1, zone=self.o_zone, loc=o_loc, activity_type=self.o_activity, time_params=time_params)\n\n    for k in range(self.stops):\n        stop_duration, start_tm, end_tm = ActivityDuration().model_activity_duration(o_loc, d_locs[k], end_tm)\n        if (mtdt(end_tm) &gt;= END_OF_DAY) | (mtdt(end_tm + int(stop_duration/60)) &gt;= END_OF_DAY):\n            break               \n        elif k == 0:\n            end_tm = self.add_tour_leg(agent=agent, k=k, o_zone=self.o_zone, o_loc=o_loc, d_zone=d_zones[k], d_loc=d_locs[k], start_tm=start_tm, end_tm=end_tm)\n\n            time_params = {'end_tm':end_tm, 'stop_duration':stop_duration}\n            end_tm = self.add_tour_activity(agent=agent, k=k, zone=d_zones[k], loc=d_locs[k], activity_type=self.d_activity, time_params=time_params)\n        else: \n            end_tm = self.add_tour_leg(agent=agent, k=k, o_zone=d_zones[k-1], o_loc=d_locs[k-1], d_zone=d_zones[k], d_loc=d_locs[k], start_tm=start_tm, end_tm=end_tm)\n\n            time_params = {'end_tm':end_tm, 'stop_duration':stop_duration}\n            end_tm = self.add_tour_activity(agent=agent, k=k, zone=d_zones[k], loc=d_locs[k], activity_type=self.d_activity, time_params=time_params)\n\n    end_tm = self.add_return_origin(agent=agent, k=self.stops, o_loc=o_loc, d_zone=d_zones[self.stops-1], d_loc=d_locs[self.stops-1], end_tm=end_tm)\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.TourPlanner.sequence_stops","title":"<code>sequence_stops()</code>","text":"<p>Creates a sequence for a number of stops. Sequence is determined by distance from origin.  :returns: o_loc, d_zones and d_locs (dataframe of sequenced destinations)</p> <p>TODO - Method to sequence stops with different logic (i.e, minimise distance between stops).</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def sequence_stops(self):\n\"\"\"\n    Creates a sequence for a number of stops. Sequence is determined by distance from origin. \n    :returns: o_loc, d_zones and d_locs (dataframe of sequenced destinations)\n\n    TODO - Method to sequence stops with different logic (i.e, minimise distance between stops). \n    \"\"\"\n\n    o_loc = self.facility_sampler.sample(self.o_zone, self.o_activity)\n\n    d_seq = []\n\n    for j in range(self.stops):\n        # If threshold matrix is none, sample a random d_zone, else select a d_zone within threshold value\n        if self.threshold_matrix is None:\n            d_zone = FrequencySampler(self.d_dist.index, self.d_dist[self.d_freq]).sample()\n        else:\n            d_zone = FrequencySampler(dist=self.d_dist,\n                                      freq=self.d_freq,\n                                      threshold_matrix=self.threshold_matrix.loc[self.o_zone],\n                                      threshold_value = self.threshold_value\n                                      ).threshold_sample()\n        # once d_zone is selected, select a specific point location for d_activity                          \n        d_facility = self.facility_sampler.sample(d_zone, self.d_activity)\n\n        # append to a dictionary to sequence destinations\n        d_seq.append({\n            'stops': j,\n            'destination_zone': d_zone,\n            'destination_facility': d_facility,\n            'distance': ActivityDuration().model_distance(o_loc, d_facility)\n        })\n\n    # sort distance: furthest facility to closest facility to origin facility. The final stop should be closest to origin.\n    d_seq = sorted(d_seq, key=lambda item: item.get('distance'), reverse=True)\n    d_zones = [item.get('destination_zone') for item in d_seq]\n    d_locs = [item.get('destination_facility') for item in d_seq]\n\n    return o_loc, d_zones, d_locs\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD","title":"<code>ValidateTourOD(trips, zone, o_dist, d_dist, o_activity, d_activity, o_freq, d_freq)</code>","text":"<p>Object to build a dataframe that produces both spatial and statistical plots to validate the tour origin and  destinations align with input data.</p> <p>Create a dataframe that counts the number of origin and destination activities.  Merge this against the density information from the input origin and destination samplers. :params trips: dataframe, the legs.csv output after building population :params zone: zones geodataframe :params o_dist, d_dist: samplers containing origin and destination distributions to be sampled. :params o_activity, d_activity: activities utilised within the o_dist and d_dist :params o_freq, d_freq: frequencies that are used to sample origin and destination distributions.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def __init__(self, trips, zone, o_dist, d_dist, o_activity, d_activity, o_freq, d_freq):\n\"\"\"\n    Create a dataframe that counts the number of origin and destination activities. \n    Merge this against the density information from the input origin and destination samplers.\n    :params trips: dataframe, the legs.csv output after building population\n    :params zone: zones geodataframe\n    :params o_dist, d_dist: samplers containing origin and destination distributions to be sampled.\n    :params o_activity, d_activity: activities utilised within the o_dist and d_dist\n    :params o_freq, d_freq: frequencies that are used to sample origin and destination distributions.\n    \"\"\"\n\n    # Create a dataframe to plot od trips and compare against facility density and flows density.\n    df_trips_o = trips[trips['origin activity']==o_activity].groupby(['ozone']).agg({'pid':'count'}).reset_index()\n    df_trips_o.rename(columns={'pid':'origin_trips'}, inplace=True)\n    df_trips_o.set_index('ozone', inplace=True)\n\n    df_trips_d = trips[trips['destination activity']==d_activity].groupby(['dzone']).agg({'pid':'count'}).reset_index()\n    df_trips_d.rename(columns={'pid':'destination_trips'}, inplace=True)\n    df_trips_d.set_index('dzone', inplace=True)\n\n    self.od_density = zone.copy()\n\n    # Merge in trips information\n    self.od_density = pd.merge(self.od_density, df_trips_o, left_on=self.od_density.index, right_on=df_trips_o.index, how='left')\n    self.od_density = pd.merge(self.od_density, df_trips_d, left_on='key_0', right_on=df_trips_d.index, how='left')\n\n    # Merge in density information\n    o_density = o_dist.reset_index()\n    o_density = o_density.groupby(o_dist.index).agg({o_freq:'sum'})\n    d_density = d_dist.reset_index()\n    d_density = d_density.groupby(d_dist.index).agg({d_freq:'sum'})\n\n    self.od_density[f'{o_activity}_density'] = self.od_density.key_0.map(o_density[o_freq])\n    self.od_density[f'{d_activity}_density'] = self.od_density.key_0.map(d_density[d_freq])\n\n    self.od_density.rename(columns={'key_0':zone.index.name}, inplace=True)\n    self.od_density.set_index(zone.index.name, inplace=True)\n\n    # Add in features for analysis\n    self.od_density = self.od_density.fillna(0)\n    self.od_density['origin_trip_density'] = self.od_density.origin_trips/self.od_density.origin_trips.sum()\n    self.od_density['destination_trip_density'] = self.od_density.destination_trips/self.od_density.destination_trips.sum()\n    self.od_density['origin_diff'] = self.od_density['origin_trip_density'] - self.od_density[f'{o_activity}_density']\n    self.od_density['destination_diff'] = self.od_density['destination_trip_density'] - self.od_density[f'{d_activity}_density']\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD.od_density","title":"<code>od_density = self.od_density.fillna(0)</code>  <code>instance-attribute</code>","text":""},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD.plot_compare_density","title":"<code>plot_compare_density(title_1, title_2, o_activity, d_activity)</code>","text":"<p>Compares density of input origin/destination activities and trips. As density of locations increases, so should trips. :params title_1, title_2: str input for plot title names. :params o_activity, d_activity: str of activities that are used to measure density of locations</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot_compare_density(self, title_1, title_2, o_activity, d_activity):\n\"\"\"\n    Compares density of input origin/destination activities and trips. As density of locations increases, so should trips.\n    :params title_1, title_2: str input for plot title names.\n    :params o_activity, d_activity: str of activities that are used to measure density of locations\n    \"\"\"\n\n    fig, ax = plt.subplots(1, 2, figsize=(15,7))\n\n    m1,b1 = np.polyfit(self.od_density[o_activity], self.od_density.origin_trip_density, 1)\n    m2,b2 = np.polyfit(self.od_density[d_activity], self.od_density.destination_trip_density, 1)\n\n    ax[0].scatter(x=o_activity, y='origin_trip_density', data=self.od_density)\n    ax[0].plot(self.od_density[o_activity], (m1*self.od_density[o_activity] + b1), label = 'y = {:.2f} + {:.2f}*x'.format(m1, b1))\n    ax[0].legend(loc='lower right') \n    ax[0].set_title(title_1)\n\n    ax[1].scatter(x=d_activity, y='destination_trip_density', data=self.od_density)\n    ax[1].plot(self.od_density[o_activity], (m2*self.od_density[o_activity] + b2), label = 'y = {:.2f} + {:.2f}*x'.format(m2, b2))\n    ax[1].legend(loc='lower right') \n    ax[1].set_title(title_2)\n\n    return fig\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD.plot_density_difference","title":"<code>plot_density_difference(title_1, title_2, cmap = 'coolwarm')</code>","text":"<p>Creates a spatial plot of the difference between input and output densities. :params title_1, title_2: str input for plot title names.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot_density_difference(self, title_1, title_2, cmap='coolwarm'):\n\"\"\"\n    Creates a spatial plot of the difference between input and output densities.\n    :params title_1, title_2: str input for plot title names.\n    \"\"\"\n\n    fig, ax = plt.subplots(1, 2, figsize=(20,10))\n\n    self.od_density.plot('origin_diff', ax=ax[0], cmap=cmap)\n    ax[0].axis('off')\n    ax[0].set_title(title_1)\n\n    self.od_density.plot('destination_diff', ax=ax[1], cmap=cmap)\n    ax[1].axis('off')\n    ax[1].set_title(title_2)\n\n    im = plt.gca().get_children()[0]\n    cax = fig.add_axes([1,0.2,0.03,0.6]) \n    plt.colorbar(im, cax=cax)\n\n    return fig\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.ValidateTourOD.plot_validate_spatial_density","title":"<code>plot_validate_spatial_density(title_1, title_2, density_metric, density_trips, cmap = 'coolwarm')</code>","text":"<p>Creates a spatial plot between input densities and resulting trips to validate trips spatially align with input densities. :params title_1, title_2: str input for plot title names. :params density_metric: the measure for density output from the above dataframe, in the format of 'activity_density' :params density_trips: the measure of trips that require validation, either 'origin_trips' or 'destination_trips'.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def plot_validate_spatial_density(self, title_1, title_2, density_metric, density_trips, cmap='coolwarm'):\n\"\"\"\n    Creates a spatial plot between input densities and resulting trips to validate trips spatially align with input densities.\n    :params title_1, title_2: str input for plot title names.\n    :params density_metric: the measure for density output from the above dataframe, in the format of 'activity_density'\n    :params density_trips: the measure of trips that require validation, either 'origin_trips' or 'destination_trips'.\n    \"\"\"\n\n    fig, ax = plt.subplots(1, 2, figsize=(20,10))\n\n    self.od_density.plot(density_metric, ax=ax[0], cmap=cmap)\n    ax[0].axis('off')\n    ax[0].set_title(title_1)\n\n    self.od_density.plot(density_trips, ax=ax[1], cmap=cmap)\n    ax[1].axis('off')\n    ax[1].set_title(title_2)\n\n    im = plt.gca().get_children()[0]\n    cax = fig.add_axes([1,0.2,0.03,0.6]) \n    plt.colorbar(im, cax=cax)\n\n    return fig\n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.create_density_gdf","title":"<code>create_density_gdf(facility_zone, zone, activity, normalise = None)</code>","text":"<p>Returns a geodataframe that calculates the spatial density of input activity. The normalise flag allows for the user to decide what variable to normalise density against. :param facility_zone: a geodataframe that is the spatial join between facility and zone information :param zone: a geodataframe with zones information :param activity: a list of activities (in string format) that are within facility data :return: a geodataframe that measures the density of activities in each zone.</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def create_density_gdf(facility_zone, zone, activity, normalise=None):\n\"\"\"\n    Returns a geodataframe that calculates the spatial density of input activity. The normalise flag\n    allows for the user to decide what variable to normalise density against.\n    :param facility_zone: a geodataframe that is the spatial join between facility and zone information\n    :param zone: a geodataframe with zones information\n    :param activity: a list of activities (in string format) that are within facility data\n    :return: a geodataframe that measures the density of activities in each zone. \n    \"\"\"\n\n    if normalise is not None:\n        density = facility_zone.groupby([facility_zone.index, 'activity', normalise]).agg({'id':'count'}).reset_index()    \n        density.set_index(facility_zone.index.name, inplace=True)\n        density = density[density['activity'].isin(activity)]\n        density['density'] = density['id']/density[normalise]\n        total_density = density[~(density[normalise]==0)]['density'].sum()\n        density['density'] = density['density']/total_density\n    else:\n        density = facility_zone.groupby([facility_zone.index, 'activity']).agg({'id':'count'}).reset_index()    \n        density.set_index(facility_zone.index.name, inplace=True)\n        density = density[density['activity'].isin(activity)]\n        density['density'] = density['id']/density['id'].sum()\n\n    # Convert back to geodataframe for merging.\n    density = pd.merge(density, zone['geometry'], left_on = density.index, right_on=zone.index, how='left')\n    density.rename(columns={'key_0':facility_zone.index.name}, inplace=True)\n    density = gp.GeoDataFrame(data=density, geometry='geometry')\n    density.set_index(facility_zone.index.name, inplace=True)\n\n    if np.isinf(density['density']).sum()&gt;=1:\n        warnings.warn('Your density gdf has infinite values')\n\n    return density \n</code></pre>"},{"location":"api/samplers/tour/#pam.samplers.tour.interpolate","title":"<code>interpolate(i, ai, a, bi, b)</code>","text":"<p>:param i, ai, a, bi, b: input values to build distribution between values a and b</p> Source code in <code>pam/samplers/tour.py</code> <pre><code>def interpolate(i, ai, a, bi, b):\n\"\"\"\n    :param i, ai, a, bi, b: input values to build distribution between values a and b\n    \"\"\"\n    return a + (i-ai) * (b-a) / (bi-ai)\n</code></pre>"},{"location":"api/report/stringify/","title":"pam.report.stringify","text":""},{"location":"api/report/stringify/#pam.report.stringify.ActColour","title":"<code>ActColour(colour = True) -&gt; None</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def __init__(self, colour=True) -&gt; None:\n    if colour:\n        self._queue = inf_yield(self._col_queue)\n    else:\n        self._queue = inf_yield(self._bw_queue)\n</code></pre>"},{"location":"api/report/stringify/#pam.report.stringify.ActColour.mapping","title":"<code>mapping = {'travel': 232}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/stringify/#pam.report.stringify.ActColour.paint","title":"<code>paint(act, text)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def paint(self, act, text):\n    if not act in self.mapping:\n        self.mapping[act] = next(self._queue)\n    return f\"\\033[38;5;{self.mapping[act]}m{text}\\033[0m\"\n</code></pre>"},{"location":"api/report/stringify/#pam.report.stringify.inf_yield","title":"<code>inf_yield(queue: list)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def inf_yield(queue:list):\n    while True:\n        for i in queue:\n            yield i\n</code></pre>"},{"location":"api/report/stringify/#pam.report.stringify.stringify_plan","title":"<code>stringify_plan(plan_array, mapping, colourer)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def stringify_plan(plan_array, mapping, colourer):\n    return ''.join(\n        [colourer.paint(mapping[i], \"\u2587\") for i in plan_array]\n        )\n</code></pre>"},{"location":"api/report/stringify/#pam.report.stringify.stringify_plans","title":"<code>stringify_plans(plans_path, simplify_pt_trips: bool = False, crop: bool = False, colour: bool = True, width: bool = 101)</code>","text":"Source code in <code>pam/report/stringify.py</code> <pre><code>def stringify_plans(\n    plans_path,\n    simplify_pt_trips : bool = False,\n    crop : bool = False,\n    colour=True,\n    width=101\n    ):\n    print(f\"Loading plan sequences from {plans_path}.\")\n    encoder = PlansToCategorical(\n        bin_size=int(86400/width),\n        duration=86400\n    )\n    colourer = ActColour(colour=colour)\n    for person in stream_matsim_persons(\n        plans_path,\n        simplify_pt_trips = simplify_pt_trips,\n        crop = crop,\n        ):\n        apply_jitter_to_plan(\n            plan=person.plan,\n            jitter=timedelta(minutes=30),\n            min_duration=timedelta(minutes=5)\n            )\n        encoded = encoder.encode(person.plan)\n        string = stringify_plan(\n            plan_array=encoded,\n            mapping=encoder.index_to_act,\n            colourer=colourer\n        )\n        print(person.pid, string)\n\n    print()\n    print(\"Key:\")\n    for act in encoder.act_to_index:\n        print(f\"{colourer.paint(act, '\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587\u2587')}: {act}\")\n</code></pre>"},{"location":"api/report/summary/","title":"pam.report.summary","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT","title":"<code>TEXT</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/report/summary/#pam.report.summary.TEXT.BOLD","title":"<code>BOLD = '\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.END","title":"<code>END = '\\x1b[0m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.FAIL","title":"<code>FAIL = '\\x1b[91m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.HEADER","title":"<code>HEADER = '\\x1b[95m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.OKBLUE","title":"<code>OKBLUE = '\\x1b[94m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.OKCYAN","title":"<code>OKCYAN = '\\x1b[96m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.OKGREEN","title":"<code>OKGREEN = '\\x1b[92m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.TITLE","title":"<code>TITLE = '\\n\\x1b[95m\\x1b[4m\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.UNDERLINE","title":"<code>UNDERLINE = '\\x1b[4m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.TEXT.WARNING","title":"<code>WARNING = '\\x1b[93m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/report/summary/#pam.report.summary.activities_summary","title":"<code>activities_summary(population: Population, key: Population = 'subpopulation') -&gt; PrettyTable</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def activities_summary(population: Population, key=\"subpopulation\") -&gt; PrettyTable:\n\n    table = PrettyTable()\n    summary = {}\n    summary[\"total\"] = count_activites(population)\n    slices = []\n\n    if key is not None:\n        slices =  population.attributes.get(key, [])\n        for value in slices:\n            summary[value] = count_activites(population, key, value)\n\n    table.field_names = [\"activities\", \"total\"] + list(slices)\n\n    for stat, total_value in summary[\"total\"].items():\n        row = [stat, total_value]\n        for k in slices:\n            row.append(summary[k].get(stat))\n        table.add_row(row)\n\n    table.align[\"activities\"] = \"r\"\n    return table\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.calc_stats","title":"<code>calc_stats(population: Population, key: Population = None, value: Population = None) -&gt; dict</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def calc_stats(population: Population, key=None, value=None) -&gt; dict:\n    summary = {\n        \"hhs\": 0,\n        \"persons\": 0,\n        }\n    hh_occupants = []\n    for _, hh in population:\n        if key is not None and value not in hh.get_attribute(key):\n            continue\n        summary[\"hhs\"] += hh.freq\n        occupants = 0\n        for _, person in hh:\n            if key is not None and not person.attributes.get(key) == value:\n                continue\n            occupants += 1\n            summary[\"persons\"] += person.freq\n        hh_occupants.append(occupants)\n    if hh_occupants:\n        summary[\"av_occupancy\"] = sum(hh_occupants) / len(hh_occupants)\n    return summary\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.count_activites","title":"<code>count_activites(population: Population, key: Population = None, value: Population = None) -&gt; dict</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def count_activites(population: Population, key=None, value=None) -&gt; dict:\n    classes = population.activity_classes\n    summary = {a: 0 for a in classes}\n    for _, _, person in population.people():\n        if key is not None and not person.attributes.get(key) == value:\n            continue\n        freq = person.freq\n        for act in person.activities:\n            summary[act.act] += freq\n    return summary\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.count_modes","title":"<code>count_modes(population: Population, key: Population = None, value: Population = None) -&gt; dict</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def count_modes(population: Population, key=None, value=None) -&gt; dict:\n    modes = population.mode_classes\n    summary = {m: 0 for m in modes}\n    for _, _, person in population.people():\n        if key is not None and not person.attributes.get(key) == value:\n            continue\n        freq = person.freq\n        for leg in person.legs:\n            summary[leg.mode] += freq\n    return summary\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.get_attributes","title":"<code>get_attributes(population, show: int = 10, key: int = None, value: int = None) -&gt; dict</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def get_attributes(population, show:int=10, key=None, value=None) -&gt; dict:\n    attributes = defaultdict(set)\n    for _, _, person in population.people():\n        if key is not None and not person.attributes.get(key) == value:\n            continue\n        for k, v in person.attributes.items():\n            if k == key:\n                continue\n            attributes[k].add(v)\n    for k, v in attributes.items():\n        if len(v) &gt; show:\n            attributes[k] = \"---\"\n    return dict(attributes)\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.header","title":"<code>header(head: str)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def header(head: str):\n    print(f\"{TEXT.HEADER.value}{head}{TEXT.END.value}\")\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.header_and_text","title":"<code>header_and_text(head: str, text: str)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def header_and_text(head: str, text: str):\n    print(f\"{TEXT.HEADER.value}{head}{TEXT.END.value} {text}\")\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.modes_summary","title":"<code>modes_summary(population: Population, key: Population = 'subpopulation') -&gt; PrettyTable</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def modes_summary(population: Population, key=\"subpopulation\") -&gt; PrettyTable:\n\n    table = PrettyTable()\n    summary = {}\n    summary[\"total\"] = count_modes(population)\n    slices = []\n\n    if key is not None:\n        slices =  population.attributes.get(key, [])\n        for value in slices:\n            summary[value] = count_modes(population, key, value)\n\n    table.field_names = [\"modes\", \"total\"] + list(slices)\n\n    for stat, total_value in summary[\"total\"].items():\n        row = [stat, total_value]\n        for k in slices:\n            row.append(summary[k].get(stat))\n        table.add_row(row)\n\n    table.align[\"modes\"] = \"r\"\n\n    return table\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.pretty_print_summary","title":"<code>pretty_print_summary(population: Population, key: Population = 'subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def pretty_print_summary(population: Population, key=\"subpopulation\"):\n    # stats\n    header(\"Population Stats:\")\n    print(stats_summary(population, key))\n    print()\n\n    #attributes\n    header(\"Population Attributes:\")\n    for k, vs in get_attributes(population).items():\n        subheader_and_text(f\"{k}:\", vs)\n    print()\n\n    if key is not None:\n        for v in population.attributes.get(key, []):\n            header(f\"Attribute: \\033[4m{v}\\033[0m:\")\n            for k, vs in get_attributes(population, key=key, value=v).items():\n                subheader_and_text(f\"{k}:\", vs)\n            print()\n\n    # activites\n    header(\"Activities:\")\n    print(activities_summary(population, key))\n    print()\n\n    # modes\n    header(\"Modes:\")\n    print(modes_summary(population, key))\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.print_summary","title":"<code>print_summary(population: Population, key: Population = 'subpopulation')</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def print_summary(population: Population, key=\"subpopulation\"):\n    # stats\n    print(\"Population Stats:\")\n    print(stats_summary(population, key))\n    print()\n\n    #attributes\n    print(\"Population Attributes:\")\n    for k, vs in get_attributes(population).items():\n        print(f\"{k}:\", vs)\n    print()\n\n    if key is not None:\n        for v in population.attributes.get(key, []):\n            print(f\"Attribute: {v}\")\n            for k, vs in get_attributes(population, key=key, value=v).items():\n                print(f\"{k}:\", vs)\n            print()\n\n    # activites\n    print(\"Activities:\")\n    print(activities_summary(population, key))\n    print()\n\n    # modes\n    print(\"Modes:\")\n    print(modes_summary(population, key))\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.stats_summary","title":"<code>stats_summary(population: Population, key: Population = 'subpopulation') -&gt; PrettyTable</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def stats_summary(population: Population, key=\"subpopulation\") -&gt; PrettyTable:\n\n    table = PrettyTable()\n    summary = {}\n    summary[\"total\"] = calc_stats(population)\n    slices = []\n\n    if key is not None:\n        slices =  population.attributes.get(key, [])\n        for value in slices:\n            summary[value] = calc_stats(population, key, value)\n\n    table.field_names = [\"stat\", \"total\"] + list(slices)\n\n    for stat, total_value in summary[\"total\"].items():\n        row = [stat, total_value]\n        for k in slices:\n            row.append(summary[k].get(stat))\n        table.add_row(row)\n\n    table.align[\"stat\"] = \"r\"\n    return table\n</code></pre>"},{"location":"api/report/summary/#pam.report.summary.subheader_and_text","title":"<code>subheader_and_text(head: str, text: str)</code>","text":"Source code in <code>pam/report/summary.py</code> <pre><code>def subheader_and_text(head: str, text: str):\n    print(f\"{TEXT.OKBLUE.value}{head}{TEXT.END.value} {text}\")\n</code></pre>"},{"location":"api/report/benchmarks/","title":"pam.report.benchmarks","text":""},{"location":"api/report/benchmarks/#pam.report.benchmarks.benchmarks","title":"<code>benchmarks(population)</code>","text":"<p>Yield bms.</p> <p>:param pam.core.Population population: pam.core.Population :yield pandas.DataFrame: benchmark</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def benchmarks(population):\n\"\"\"\n    Yield bms.\n\n    :param pam.core.Population population: pam.core.Population\n    :yield pandas.DataFrame: benchmark\n    \"\"\"\n    bms = [\n        (\n            \"mode_counts.csv\",\n            {'dimensions': ['mode'], 'data_fields': ['freq'], 'colnames': ['mode', 'trips'], 'aggfunc': [sum]}\n            ),\n        (\n            \"distances.csv\",\n            {'dimensions': ['euclidean_distance_category'], 'data_fields': ['freq'], 'colnames': ['distance', 'trips'], 'aggfunc': [sum]}\n            ),\n        (\n            \"mode_distances.csv\",\n            {'dimensions': ['mode', 'euclidean_distance_category'], 'data_fields': ['freq'], 'colnames': ['mode', 'distance', 'trips'], 'aggfunc': [sum]}\n            ),\n        (\n            \"durations.csv\",\n            {'dimensions': ['duration_category'], 'data_fields': ['freq'], 'colnames': ['duration', 'trips'], 'aggfunc': [sum]}\n            ),\n        (\n            \"mode_durations.csv\",\n            {'dimensions': ['mode', 'duration_category'], 'data_fields': ['freq'], 'colnames': ['mode', 'duration', 'trips'], 'aggfunc': [sum]}\n            ),\n        (\n            \"departure_times.csv\",\n            {'dimensions': ['departure_hour'], 'data_fields': ['freq'], 'colnames': ['departure_hour', 'trips'], 'aggfunc': [sum]}\n            ),\n        (\n            \"mode_purposes.csv\",\n            {'dimensions': ['mode', 'purp'], 'data_fields': ['freq'], 'colnames': ['mode', 'purpose', 'trips'], 'aggfunc': [sum]}\n            )\n    ]\n    trips = population.trips_df()\n    for path, kwargs in bms:\n        yield path, create_benchmark(trips.copy(), **kwargs)\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.create_benchmark","title":"<code>create_benchmark(data, dimensions: Optional[List[str]] = None, data_fields: Optional[List[str]] = None, aggfunc: List[Callable] = [len], normalise_by: List[Callable] = None, colnames: List[Callable] = None)</code>","text":"<p>Extract user-specified benchmarks from the population :param pandas.DataFrame data: dataframe of trip or leg logs with required fields :param list dimensions: Dimensions to group by. If None, return the disaggregate dataset :params list data_fields: The data to summarise. If None, simply count the instances of each group :params list of functions aggfunc: A set of functions to apply to each data_field, after grouping by the specified dimensions. For example: [len, sum], [sum, np.mean], [np.sum], etc :params list normalise_by: convert calculated values to percentages across the specified -by this field- dimension(s) :params list colnames: if different to None, rename the columns of the returned dataset</p> <p>:return: pandas.DataFrame</p> Source code in <code>pam/report/benchmarks.py</code> <pre><code>def create_benchmark(\n    data,\n    dimensions : Optional[List[str]] = None,\n    data_fields : Optional[List[str]] = None,\n    aggfunc : List[Callable]= [len],\n    normalise_by = None,\n    colnames = None,\n):\n\"\"\"\n    Extract user-specified benchmarks from the population\n    :param pandas.DataFrame data: dataframe of trip or leg logs with required fields\n    :param list dimensions: Dimensions to group by. If None, return the disaggregate dataset\n    :params list data_fields: The data to summarise. If None, simply count the instances of each group\n    :params list of functions aggfunc: A set of functions to apply to each data_field, after grouping by the specified dimensions. For example: [len, sum], [sum, np.mean], [np.sum], etc\n    :params list normalise_by: convert calculated values to percentages across the specified -by this field- dimension(s)\n    :params list colnames: if different to None, rename the columns of the returned dataset\n\n    :return: pandas.DataFrame\n    \"\"\"\n    df = data.copy()\n\n    ## aggregate across specified dimensions\n    if dimensions != None:\n        if data_fields != None:\n            df = df.groupby(dimensions)[data_fields].agg(aggfunc).fillna(0)\n        else:\n            df = df.value_counts(dimensions)\n\n    ## show as percentages\n    if normalise_by != None:\n        if normalise_by == 'total':\n            df = df / df.sum(axis = 0)\n        else:\n            df = df.groupby(level = normalise_by).transform(lambda x: x / x.sum())\n    df = df.sort_index().reset_index()\n\n    ## flatten column MultiIndex\n    if isinstance(df.columns, pd.MultiIndex):\n        df.columns = df.columns.map('_'.join).str.strip('_')\n\n    ## rename columns\n    if colnames != None:\n        df.columns = colnames\n\n    return df\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.departure_time_counts","title":"<code>departure_time_counts(population)</code>","text":"Source code in <code>pam/report/benchmarks.py</code> <pre><code>def departure_time_counts(population):\n    # number of trips by hour of departure\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions = ['departure_hour'],\n        data_fields= ['freq'],\n        colnames = ['departure_hour', 'trips'],\n        aggfunc = [sum],\n        )\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.distance_counts","title":"<code>distance_counts(population)</code>","text":"Source code in <code>pam/report/benchmarks.py</code> <pre><code>def distance_counts(population):\n    # number of trips by (euclidean) distance category\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions = ['euclidean_distance_category'],\n        data_fields= ['freq'],\n        colnames = ['distance', 'trips'],\n        aggfunc = [sum],\n        )\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.duration_counts","title":"<code>duration_counts(population)</code>","text":"Source code in <code>pam/report/benchmarks.py</code> <pre><code>def duration_counts(population):\n    # number of trips by duration\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions = ['duration_category'],\n        data_fields= ['freq'],\n        colnames = ['duration', 'trips'],\n        aggfunc = [sum],\n        )\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.mode_counts","title":"<code>mode_counts(population)</code>","text":"Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_counts(population):\n    # number of trips by (euclidean) distance category\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions = ['mode'],\n        data_fields= ['freq'],\n        colnames = ['mode', 'trips'],\n        aggfunc = [sum],\n        )\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.mode_distance_counts","title":"<code>mode_distance_counts(population)</code>","text":"Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_distance_counts(population):\n    # number of trips by (euclidean) distance category and mode\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions = ['mode','euclidean_distance_category'],\n        data_fields= ['freq'],\n        colnames = ['mode','distance', 'trips'],\n        aggfunc = [sum],\n        )\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.mode_duration_counts","title":"<code>mode_duration_counts(population)</code>","text":"Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_duration_counts(population):\n    # number of trips by duration and mode\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions = ['mode','duration_category'],\n        data_fields= ['freq'],\n        colnames = ['mode','duration','trips'],\n        aggfunc = [sum],\n        )\n</code></pre>"},{"location":"api/report/benchmarks/#pam.report.benchmarks.mode_purpose_counts","title":"<code>mode_purpose_counts(population)</code>","text":"Source code in <code>pam/report/benchmarks.py</code> <pre><code>def mode_purpose_counts(population):\n    # purpose split for each mode\n    data = population.trips_df()\n    return create_benchmark(\n        data,\n        dimensions = ['mode','purp'],\n        data_fields= ['freq'],\n        colnames = ['mode','purpose','trips'],\n        aggfunc = [sum]\n        )\n</code></pre>"},{"location":"api/policy/probability_samplers/","title":"pam.policy.probability_samplers","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability","title":"<code>ActivityProbability(activities: list, probability: Union[float, int, Callable[[pam.activity.Activity], float]], kwargs: Union[float, int, Callable[[pam.activity.Activity], float]] = None)</code>","text":"<p>         Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which evaluates value of probability at household, person and activity level based on probability for an activity.</p>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability--parameters","title":"Parameters","text":"<p>:param probability A float/int: 0&lt;probability&lt;=1 or a function which given input of pam.core.Activity returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the activity being sampled.</p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(self,\n             activities: list,\n             probability: Union[float, int, Callable[[pam.activity.Activity], float]],\n             kwargs=None):\n    super().__init__(probability)\n    self.activities = activities\n    assert isinstance(self.probability, float) or callable(self.probability)\n    if kwargs is None:\n        self.kwargs = {}\n    else:\n        self.kwargs = kwargs\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.kwargs","title":"<code>kwargs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.compute_probability_for_activity","title":"<code>compute_probability_for_activity(activity)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def compute_probability_for_activity(self, activity):\n    if isinstance(self.probability, float):\n        return self.probability\n    elif callable(self.probability):\n        return self.probability(activity, **self.kwargs)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.is_relevant_activity","title":"<code>is_relevant_activity(act)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def is_relevant_activity(self, act):\n    return act.act.lower() in self.activities\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.ActivityProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\n    if isinstance(x, pam.core.Household):\n        p = 1\n        for pid, person in x.people.items():\n            for act in person.activities:\n                if self.is_relevant_activity(act):\n                    p *= 1 - self.compute_probability_for_activity(act)\n        return 1 - p\n    elif isinstance(x, pam.core.Person):\n        p = 1\n        for act in x.activities:\n            if self.is_relevant_activity(act):\n                p *= 1 - self.compute_probability_for_activity(act)\n        return 1 - p\n    elif isinstance(x, pam.activity.Activity):\n        if self.is_relevant_activity(x):\n            return self.compute_probability_for_activity(x)\n        return 0\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability","title":"<code>HouseholdProbability(probability: Union[float, int, Callable[[pam.core.Household], float]], kwargs: Union[float, int, Callable[[pam.core.Household], float]] = None)</code>","text":"<p>         Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which evaluates value of probability at household level based on probability for a household.</p>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability--parameters","title":"Parameters","text":"<p>:param probability A float/int: 0&lt;probability&lt;=1 or a function which given input of pam.core.Household returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the household being sampled.</p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(self,\n             probability: Union[float, int, Callable[[pam.core.Household], float]],\n             kwargs=None):\n    super().__init__(probability)\n    assert isinstance(self.probability, float) or callable(self.probability)\n    if kwargs is None:\n        self.kwargs = {}\n    else:\n        self.kwargs = kwargs\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.kwargs","title":"<code>kwargs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.compute_probability_for_household","title":"<code>compute_probability_for_household(household)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def compute_probability_for_household(self, household):\n    if isinstance(self.probability, float):\n        return self.probability\n    elif callable(self.probability):\n        return self.probability(household, **self.kwargs)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.HouseholdProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\n    if isinstance(x, pam.core.Household):\n        return self.compute_probability_for_household(x)\n    elif isinstance(x, pam.core.Person):\n        raise NotImplementedError\n    elif isinstance(x, pam.activity.Activity):\n        raise NotImplementedError\n    else:\n        raise TypeError\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability","title":"<code>PersonProbability(probability: Union[float, int, Callable[[pam.core.Person], float]], kwargs: Union[float, int, Callable[[pam.core.Person], float]] = None)</code>","text":"<p>         Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which evaluates value of probability at household and person level based on probability for a person.</p>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability--parameters","title":"Parameters","text":"<p>:param probability A float/int: 0&lt;probability&lt;=1 or a function which given input of pam.core.Person returns a float/int: 0&lt;probability&lt;=1 corresponding to the likelihood of the person being sampled.</p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(self,\n             probability: Union[float, int, Callable[[pam.core.Person], float]],\n             kwargs=None):\n    super().__init__(probability)\n    assert isinstance(self.probability, float) or callable(self.probability)\n    if kwargs is None:\n        self.kwargs = {}\n    else:\n        self.kwargs = kwargs\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.kwargs","title":"<code>kwargs = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.compute_probability_for_person","title":"<code>compute_probability_for_person(person)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def compute_probability_for_person(self, person):\n    if isinstance(self.probability, float):\n        return self.probability\n    elif callable(self.probability):\n        return self.probability(person, **self.kwargs)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.PersonProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\n    if isinstance(x, pam.core.Household):\n        p = 1\n        for pid, person in x.people.items():\n            p *= 1 - self.compute_probability_for_person(person)\n        return 1 - p\n    elif isinstance(x, pam.core.Person):\n        return self.compute_probability_for_person(x)\n    elif isinstance(x, pam.activity.Activity):\n        raise NotImplementedError\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability","title":"<code>SamplingProbability(probability: Union[float, int])</code>","text":"<p>Base class for probabilistic samplers</p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(self,\n             probability: Union[float, int]):\n    if isinstance(probability, int):\n        probability = float(probability)\n    if isinstance(probability, float):\n        assert 0 &lt; probability &lt;= 1\n    self.probability = probability\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.probability","title":"<code>probability = probability</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\n    raise NotImplementedError('{} is a base class'.format(type(SamplingProbability)))\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SamplingProbability.sample","title":"<code>sample(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def sample(self, x):\n    return random.random() &lt; self.p(x)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability","title":"<code>SimpleProbability(probability)</code>","text":"<p>         Bases: <code>SamplingProbability</code></p> <p>A probabilistic sampler which returns value of probability at the same level as the input (household/person/activity)</p>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability--parameters","title":"Parameters","text":"<p>:param probability A float/int: 0&lt;probability&lt;=1</p> Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def __init__(self, probability):\n    super().__init__(probability)\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.SimpleProbability.p","title":"<code>p(x)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def p(self, x):\n    return self.probability\n</code></pre>"},{"location":"api/policy/probability_samplers/#pam.policy.probability_samplers.verify_probability","title":"<code>verify_probability(probability, unacceptable_types = None)</code>","text":"Source code in <code>pam/policy/probability_samplers.py</code> <pre><code>def verify_probability(probability, unacceptable_types=None):\n    if unacceptable_types is None:\n        unacceptable_types = ()\n    if isinstance(probability, int):\n        probability = float(probability)\n    assert not isinstance(probability, unacceptable_types), \\\n        '{} is of type {} which is not accepted. Check your policy\\'s application level.'.format(\n            probability, type(probability))\n    if isinstance(probability, float):\n        assert 0 &lt; probability &lt;= 1\n        probability = SimpleProbability(probability)\n    elif isinstance(probability, list):\n        for i in range(len(probability)):\n            assert not isinstance(probability[i], unacceptable_types), \\\n                '{} is of type {} which is not accepted. Check your policy\\'s application level'.format(\n                    probability[i], type(probability[i]))\n            if isinstance(probability[i], float):\n                probability[i] = SimpleProbability(probability[i])\n    else:\n        assert isinstance(probability, SamplingProbability), \\\n            'Probability passed to a policy needs to be float, integer or {}, not {}'.format(\n                type(SamplingProbability), type(probability))\n    return probability\n</code></pre>"},{"location":"api/policy/modifiers/","title":"pam.policy.modifiers","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.AddActivity","title":"<code>AddActivity(activities: List[str])</code>","text":"<p>         Bases: <code>Modifier</code></p> <p>Adds specified activities.</p>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.AddActivity--parameters","title":"Parameters","text":"<p>:param activities List of activities to be added.</p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: List[str]):\n    super().__init__()\n    self.activities = activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.AddActivity.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.AddActivity.apply_to","title":"<code>apply_to(household, person = None, activities = None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(self, household, person=None, activities=None):\n    raise NotImplementedError('Watch this space')\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.Modifier","title":"<code>Modifier()</code>","text":"<p>Base class for modifiers - these are classes which change activities in a person's plan.</p> <p>In general a modifer should be able to be applied on three levels Household - apply change to all activities in all person's plans in household Person - apply change to all activities in a person's plan Activity - apply change to individual activity in a person's plan</p> <p>Not all modifiers will satisfy this of course, e.g. ReduceSharedActivity only works on a household level as the activites for removal need to be shared within a household.</p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self):\n    super().__init__()\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.Modifier.apply_to","title":"<code>apply_to(household: pam.core.Household, person: pam.core.Person = None, activity: pam.activity.Activity = None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(self, household: pam.core.Household, person: pam.core.Person = None,\n             activity: pam.activity.Activity = None):\n    raise NotImplementedError('{} is a base class'.format(type(Modifier)))\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.Modifier.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation","title":"<code>MoveActivityTourToHomeLocation(activities: List[str], location: str = 'home', new_mode: str = 'walk')</code>","text":"<p>         Bases: <code>Modifier</code></p> <p>Moves a tour of activities to home location. A tour is defined as a list of activities sandwiched between two home activities.</p>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation--parameters","title":"Parameters","text":"<p>:param activities List of activities to be considered in a tour. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.</p> <p>:param location, default 'home' Location to which the tour should be moved.</p> <p>:param new_mode, default 'walk' Mode used in the legs to/from the activity when we relocate the activity</p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: List[str], location: str = 'home', new_mode: str = 'walk'):\n    super().__init__()\n    # list of activities defines the accepted activity tour,\n    # any combination of activities in activities sandwiched\n    # by home activities will be selected\n    self.activities = activities\n    self.default = location\n    self.new_mode = new_mode\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.default","title":"<code>default = location</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.new_mode","title":"<code>new_mode = new_mode</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.apply_to","title":"<code>apply_to(household: pam.core.Household, person: pam.core.Person = None, activities: List[pam.activity.Activity] = None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(self, household: pam.core.Household, person: pam.core.Person = None,\n             activities: List[pam.activity.Activity] = None):\n    new_mode = self.new_mode\n    if activities and person:\n        self.move_individual_activities(person, activities, new_mode)\n    elif person:\n        self.move_person_activities(person, new_mode)\n    elif household and isinstance(household, pam.core.Household):\n        self.move_household_activities(household, new_mode)\n    else:\n        raise NotImplementedError('Types passed incorrectly: {}, {}, {}. You need {} at the very least.'\n                                  ''.format(type(household), type(person), type(activities),\n                                            type(pam.core.Household)))\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.is_part_of_tour","title":"<code>is_part_of_tour(act, tours: list)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def is_part_of_tour(self, act, tours: list):\n    for tour in tours:\n        # more rigorous check if activity in activities; Activity.__eq__ is not sufficient here\n        if act.isin_exact(tour):\n            return True\n    return False\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.matching_activity_tours","title":"<code>matching_activity_tours(plan, p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def matching_activity_tours(self, plan, p):\n    tours = plan.activity_tours()\n    matching_tours = []\n    for tour in tours:\n        if self.tour_matches_activities(tour, p):\n            matching_tours.append(tour)\n    return matching_tours\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_activities","title":"<code>move_activities(person, p, new_mode = 'walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_activities(self, person, p, new_mode='walk'):\n    tours = self.matching_activity_tours(person.plan, p)\n    if tours:\n        for seq in range(len(person.plan)):\n            if isinstance(person.plan[seq], pam.activity.Activity):\n                act = person.plan[seq]\n                if self.is_part_of_tour(act, tours):\n                    person.move_activity(seq, default=self.default, new_mode=new_mode)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_household_activities","title":"<code>move_household_activities(household, new_mode = 'walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_household_activities(self, household, new_mode='walk'):\n    for pid, person in household.people.items():\n        self.move_person_activities(person, new_mode=new_mode)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_individual_activities","title":"<code>move_individual_activities(person, activities, new_mode = 'walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_individual_activities(self, person, activities, new_mode='walk'):\n    def is_a_selected_activity(act):\n        # more rigorous check if activity in activities; Activity.__eq__ is not sufficient here\n        return act.isin_exact(activities)\n\n    self.move_activities(person, p=is_a_selected_activity, new_mode=new_mode)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.move_person_activities","title":"<code>move_person_activities(person, new_mode = 'walk')</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def move_person_activities(self, person, new_mode='walk'):\n    def return_true(act):\n        return True\n\n    self.move_activities(person, p=return_true, new_mode=new_mode)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.MoveActivityTourToHomeLocation.tour_matches_activities","title":"<code>tour_matches_activities(tour, p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def tour_matches_activities(self, tour, p):\n    if set([act.act for act in tour]) - set(self.activities) == set():\n        for act in tour:\n            if p(act):\n                return True\n    return False\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity","title":"<code>ReduceSharedActivity(activities: List[str])</code>","text":"<p>         Bases: <code>Modifier</code></p> <p>Policy that needs to be applied on a household level. For activities shared within a household (Activity.act (type of activity), start/end times and locations match). Randomly assigns a person whose activities will be retained and deletes the shared activities from other persons in household.</p>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity--parameters","title":"Parameters","text":"<p>:param activities List of activities that should be considered for sharing. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.</p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: List[str]):\n    super().__init__()\n    self.activities = activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.apply_to","title":"<code>apply_to(household: pam.core.Household, person: pam.core.Person = None, activities: List[pam.activity.Activity] = None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(self, household: pam.core.Household, person: pam.core.Person = None,\n             activities: List[pam.activity.Activity] = None):\n    if household and isinstance(household, pam.core.Household):\n        self.remove_household_activities(household)\n    else:\n        raise NotImplementedError('Types passed incorrectly: {}, {}, {}. This modifier exists only for Households'\n                                  'you need to pass {}.'\n                                  ''.format(type(household), type(person), type(activities),\n                                            type(pam.core.Household)))\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.is_activity_for_removal","title":"<code>is_activity_for_removal(p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def is_activity_for_removal(self, p):\n    return p.act.lower() in self.activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.people_who_share_activities_for_removal","title":"<code>people_who_share_activities_for_removal(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def people_who_share_activities_for_removal(self, household):\n    shared_activities_for_removal = self.shared_activities_for_removal(household)\n    people_with_shared_acts_for_removal = []\n    for pid, person in household.people.items():\n        for activity in person.activities:\n            if activity.isin_exact(shared_activities_for_removal):\n                people_with_shared_acts_for_removal.append(person)\n    return people_with_shared_acts_for_removal\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.remove_activities","title":"<code>remove_activities(person, shared_activities_for_removal)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_activities(self, person, shared_activities_for_removal):\n    seq = 0\n    while seq &lt; len(person.plan):\n        act = person.plan[seq]\n        # TODO there is a bug here `act in shared_activities_for_removal` should really be\n        # act.in_list_exact(shared_activities_for_removal), but if tthere is more than one\n        # activity in shared_activities_for_removal and  the  activities adjoin the\n        # activities morph and change time, making them not satisfy self.is_exact(other) anymore\n        # in this implementation however, you risk deleting isolated activities that have the\n        # same name and location but aren't shared\n        if isinstance(act, pam.activity.Activity) and act in shared_activities_for_removal:\n            previous_idx, subsequent_idx = person.remove_activity(seq)\n            person.fill_plan(previous_idx, subsequent_idx, default='home')\n        else:\n            seq += 1\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.remove_household_activities","title":"<code>remove_household_activities(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_household_activities(self, household):\n    acts_for_removal = self.shared_activities_for_removal(household)\n    if acts_for_removal:\n        # pick the person that retains activities\n        ppl_sharing_activities = self.people_who_share_activities_for_removal(household)\n        if ppl_sharing_activities:\n            person_retaining_activities = random.choice(self.people_who_share_activities_for_removal(household))\n            for pid, person in household.people.items():\n                if person != person_retaining_activities:\n                    self.remove_activities(person, acts_for_removal)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.ReduceSharedActivity.shared_activities_for_removal","title":"<code>shared_activities_for_removal(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def shared_activities_for_removal(self, household):\n    shared_activities = household.shared_activities()\n    return [act for act in shared_activities if self.is_activity_for_removal(act)]\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity","title":"<code>RemoveActivity(activities: List[str])</code>","text":"<p>         Bases: <code>Modifier</code></p> <p>Removes specified activities.</p>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity--parameters","title":"Parameters","text":"<p>:param activities List of activities to be removed.</p> Source code in <code>pam/policy/modifiers.py</code> <pre><code>def __init__(self, activities: List[str]):\n    super().__init__()\n    self.activities = activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.activities","title":"<code>activities = activities</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.apply_to","title":"<code>apply_to(household: pam.core.Household, person: pam.core.Person = None, activities: List[pam.activity.Activity] = None)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def apply_to(self, household: pam.core.Household, person: pam.core.Person = None,\n             activities: List[pam.activity.Activity] = None):\n    if activities and person:\n        self.remove_individual_activities(person, activities)\n    elif person:\n        self.remove_person_activities(person)\n    elif household and isinstance(household, pam.core.Household):\n        self.remove_household_activities(household)\n    else:\n        raise TypeError('Types passed incorrectly: {}, {}, {}. You need {} at the very least.'\n                        ''.format(type(household), type(person),\n                                  type(activities), type(pam.core.Household)))\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.is_activity_for_removal","title":"<code>is_activity_for_removal(p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def is_activity_for_removal(self, p):\n    return p.act.lower() in self.activities\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_activities","title":"<code>remove_activities(person, p)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_activities(self, person, p):\n    seq = 0\n    while seq &lt; len(person.plan):\n        act = person.plan[seq]\n        if self.is_activity_for_removal(act) and p(act):\n            previous_idx, subsequent_idx = person.remove_activity(seq)\n            person.fill_plan(previous_idx, subsequent_idx, default='home')\n        else:\n            seq += 1\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_household_activities","title":"<code>remove_household_activities(household)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_household_activities(self, household):\n    for pid, person in household.people.items():\n        self.remove_person_activities(person)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_individual_activities","title":"<code>remove_individual_activities(person, activities)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_individual_activities(self, person, activities):\n    def is_a_selected_activity(act):\n        # more rigorous check if activity in activities; Activity.__eq__ is not sufficient here\n        return act.isin_exact(activities)\n\n    self.remove_activities(person, p=is_a_selected_activity)\n</code></pre>"},{"location":"api/policy/modifiers/#pam.policy.modifiers.RemoveActivity.remove_person_activities","title":"<code>remove_person_activities(person)</code>","text":"Source code in <code>pam/policy/modifiers.py</code> <pre><code>def remove_person_activities(self, person):\n    def return_true(act):\n        return True\n\n    self.remove_activities(person, p=return_true)\n</code></pre>"},{"location":"api/policy/policies/","title":"pam.policy.policies","text":""},{"location":"api/policy/policies/#pam.policy.policies.ActivityPolicy","title":"<code>ActivityPolicy(modifier: modifiers.Modifier, probability: Union[float, int, probability_samplers.SamplingProbability], attribute_filter: filters.Filter = None)</code>","text":"<p>         Bases: <code>PolicyLevel</code></p> <p>Policy that is to be applied on an individual activity level</p>"},{"location":"api/policy/policies/#pam.policy.policies.ActivityPolicy--parameters","title":"Parameters","text":"<p>:param modifier A subclass of the 'Modifier' base class - the class which governs the change to be performed to the activities in a person's plan.</p> <p>:param probability A number or a subclass of the 'SamplingProbability' base class. The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.</p> <p>:param attribute_filter, default 'None' Optional argument which helps filter/select activity for policy application based on object attributes.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self,\n             modifier: modifiers.Modifier,\n             probability: Union[float, int, probability_samplers.SamplingProbability],\n             attribute_filter: filters.Filter = None):\n    super().__init__(modifier, attribute_filter)\n    self.probability = probability_samplers.verify_probability(\n        probability,\n        (probability_samplers.HouseholdProbability, probability_samplers.PersonProbability))\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.ActivityPolicy.probability","title":"<code>probability = probability_samplers.verify_probability(probability, (probability_samplers.HouseholdProbability, probability_samplers.PersonProbability))</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.ActivityPolicy.apply_to","title":"<code>apply_to(household, person = None, activities = None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(self, household, person=None, activities=None):\n    for pid, person in household.people.items():\n        if self.attribute_filter.satisfies_conditions(person):\n            activities_to_purge = []\n            for activity in person.activities:\n                if isinstance(self.probability, list):\n                    p = 1\n                    for prob in self.probability:\n                        p *= prob.p(activity)\n                    if random.random() &lt; p:\n                        activities_to_purge.append(activity)\n                elif self.probability.sample(activity):\n                    activities_to_purge.append(activity)\n            if activities_to_purge:\n                self.modifier.apply_to(household, person, activities_to_purge)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdPolicy","title":"<code>HouseholdPolicy(modifier: modifiers.Modifier, probability: Union[float, int, probability_samplers.SamplingProbability], attribute_filter: filters.Filter = None)</code>","text":"<p>         Bases: <code>PolicyLevel</code></p> <p>Policy that is to be applied on a household level</p>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdPolicy--parameters","title":"Parameters","text":"<p>:param modifier A subclass of the 'Modifier' base class - the class which governs the change to be performed to the activities in a person's plan.</p> <p>:param probability A number or a subclass of the 'SamplingProbability' base class. The household policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.</p> <p>:param attribute_filter, default 'None' Optional argument which helps filter/select household for policy application based on object attributes.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self,\n             modifier: modifiers.Modifier,\n             probability: Union[float, int, probability_samplers.SamplingProbability],\n             attribute_filter: filters.Filter = None):\n    super().__init__(modifier, attribute_filter)\n    self.probability = probability_samplers.verify_probability(probability)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdPolicy.probability","title":"<code>probability = probability_samplers.verify_probability(probability)</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.HouseholdPolicy.apply_to","title":"<code>apply_to(household, person = None, activities = None)</code>","text":"<p>uses self.probability to decide if household should be selected :param household: :param person: :param activities: :return:</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(self, household, person=None, activities=None):\n\"\"\"\n    uses self.probability to decide if household should be selected\n    :param household:\n    :param person:\n    :param activities:\n    :return:\n    \"\"\"\n    if self.attribute_filter.satisfies_conditions(household):\n        if isinstance(self.probability, list):\n            p = 1\n            for prob in self.probability:\n                p *= prob.p(household)\n            if random.random() &lt; p:\n                self.modifier.apply_to(household)\n        elif self.probability.sample(household):\n            self.modifier.apply_to(household)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdQuarantined","title":"<code>HouseholdQuarantined(probability)</code>","text":"<p>         Bases: <code>Policy</code></p> <p>Household level Policy which removes all non-home activities for all persons in a household.</p>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdQuarantined--parameters","title":"Parameters","text":"<p>:param probability A number or a subclass of the 'SamplingProbability' base class. This policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self, probability):\n    super().__init__()\n    self.probability = probability_samplers.verify_probability(probability)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.HouseholdQuarantined.probability","title":"<code>probability = probability_samplers.verify_probability(probability)</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.HouseholdQuarantined.apply_to","title":"<code>apply_to(household, person = None, activity = None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(self, household, person=None, activity=None):\n    p = self.probability.p(household)\n    if random.random() &lt; p:\n        for pid, person in household.people.items():\n            person.stay_at_home()\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.MovePersonActivitiesToHome","title":"<code>MovePersonActivitiesToHome(activities: list, probability: Union[float, int, probability_samplers.SamplingProbability], attribute_filter: filters.Filter = None)</code>","text":"<p>         Bases: <code>PersonPolicy</code></p> <p>Pre-packaged person-level policy which moves a tour of activities to home location. A tour is defined as a list of activities sandwiched between two home activities.</p>"},{"location":"api/policy/policies/#pam.policy.policies.MovePersonActivitiesToHome--parameters","title":"Parameters","text":"<p>:param activities List of activities to be considered in a tour. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a person has a tour of only 'shop_food', the location of that activity will be changed.</p> <p>:param probability A number or a subclass of the 'SamplingProbability' base class. The activity policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p>:param attribute_filter, default 'None' Optional argument which helps filter/select household for policy application based on object attributes.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self,\n             activities: list,\n             probability: Union[float, int, probability_samplers.SamplingProbability],\n             attribute_filter: filters.Filter = None):\n    super().__init__(modifiers.MoveActivityTourToHomeLocation(activities), probability, attribute_filter)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PersonPolicy","title":"<code>PersonPolicy(modifier: modifiers.Modifier, probability: Union[float, int, probability_samplers.SamplingProbability], attribute_filter: filters.Filter = None)</code>","text":"<p>         Bases: <code>PolicyLevel</code></p> <p>Policy that is to be applied on a person level</p>"},{"location":"api/policy/policies/#pam.policy.policies.PersonPolicy--parameters","title":"Parameters","text":"<p>:param modifier A subclass of the 'Modifier' base class - the class which governs the change to be performed to the activities in a person's plan.</p> <p>:param probability A number or a subclass of the 'SamplingProbability' base class. The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p>:param attribute_filter, default 'None' Optional argument which helps filter/select person for policy application based on object attributes.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self,\n             modifier: modifiers.Modifier,\n             probability: Union[float, int, probability_samplers.SamplingProbability],\n             attribute_filter: filters.Filter = None):\n    super().__init__(modifier, attribute_filter)\n    self.probability = probability_samplers.verify_probability(\n        probability,\n        (probability_samplers.HouseholdProbability))\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PersonPolicy.probability","title":"<code>probability = probability_samplers.verify_probability(probability, probability_samplers.HouseholdProbability)</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.PersonPolicy.apply_to","title":"<code>apply_to(household, person = None, activities = None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(self, household, person=None, activities=None):\n    for pid, person in household.people.items():\n        if self.attribute_filter.satisfies_conditions(person):\n            if isinstance(self.probability, list):\n                p = 1\n                for prob in self.probability:\n                    p *= prob.p(person)\n                if random.random() &lt; p:\n                    self.modifier.apply_to(household, person)\n            elif self.probability.sample(person):\n                self.modifier.apply_to(household, person)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PersonStayAtHome","title":"<code>PersonStayAtHome(probability)</code>","text":"<p>         Bases: <code>Policy</code></p> <p>Person level Policy which removes all non-home activities for a person.</p>"},{"location":"api/policy/policies/#pam.policy.policies.PersonStayAtHome--parameters","title":"Parameters","text":"<p>:param probability A number or a subclass of the 'SamplingProbability' base class. The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self, probability):\n    super().__init__()\n    self.probability = probability_samplers.verify_probability(\n        probability,\n        (probability_samplers.HouseholdProbability))\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PersonStayAtHome.probability","title":"<code>probability = probability_samplers.verify_probability(probability, probability_samplers.HouseholdProbability)</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.PersonStayAtHome.apply_to","title":"<code>apply_to(household, person = None, activity = None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(self, household, person=None, activity=None):\n    for pid, person in household.people.items():\n        if random.random() &lt; self.probability.p(person):\n            person.stay_at_home()\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.Policy","title":"<code>Policy()</code>","text":"<p>Base class for policies</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self):\n    pass\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.Policy.apply_to","title":"<code>apply_to(household, person = None, activity = None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(self, household, person=None, activity=None):\n    raise NotImplementedError('{} is a base class'.format(type(Policy)))\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.Policy.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PolicyLevel","title":"<code>PolicyLevel(modifier: modifiers.Modifier, attribute_filter: filters.Filter = None)</code>","text":"<p>         Bases: <code>Policy</code></p> <p>Base class to formalise the hierarchy of levels at which a policy should applied at</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self, modifier: modifiers.Modifier, attribute_filter: filters.Filter = None):\n    super().__init__()\n    assert isinstance(modifier, modifiers.Modifier), 'modifier needs to be subclass of {}'.format(\n        type(modifiers.Modifier()))\n    self.modifier = modifier\n    if attribute_filter is None:\n        self.attribute_filter = filters.PersonAttributeFilter({})\n    else:\n        self.attribute_filter = attribute_filter\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.PolicyLevel.attribute_filter","title":"<code>attribute_filter = filters.PersonAttributeFilter({})</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.PolicyLevel.modifier","title":"<code>modifier = modifier</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/policies/#pam.policy.policies.PolicyLevel.apply_to","title":"<code>apply_to(household, person = None, activity = None)</code>","text":"Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_to(self, household, person=None, activity=None):\n    raise NotImplementedError('{} is a base class'.format(type(PolicyLevel)))\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.ReduceSharedHouseholdActivities","title":"<code>ReduceSharedHouseholdActivities(activities: list, probability: Union[float, int, probability_samplers.SamplingProbability], attribute_filter: filters.Filter = None)</code>","text":"<p>         Bases: <code>HouseholdPolicy</code></p> <p>Pre-packaged household-level policy which reduces the number of activities shared within a household (Activity.act (type of activity), start/end times and locations match). Randomly assigns a person whose activities will be retained and deletes the shared activities from other persons in household.</p>"},{"location":"api/policy/policies/#pam.policy.policies.ReduceSharedHouseholdActivities--parameters","title":"Parameters","text":"<p>:param activities List of activities that should be considered for sharing. Does not require an exact match. E.g. if passed ['shop_food', 'shop_other'] if a household has an only 'shop_food' shared activity, that will be reduced.</p> <p>:param probability A number or a subclass of the 'SamplingProbability' base class. The activity policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p>:param attribute_filter, default 'None' Optional argument which helps filter/select household for policy application based on object attributes.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self,\n             activities: list,\n             probability: Union[float, int, probability_samplers.SamplingProbability],\n             attribute_filter: filters.Filter = None):\n    super().__init__(modifiers.ReduceSharedActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.RemoveHouseholdActivities","title":"<code>RemoveHouseholdActivities(activities: list, probability: Union[float, int, probability_samplers.SamplingProbability], attribute_filter: filters.Filter = None)</code>","text":"<p>         Bases: <code>HouseholdPolicy</code></p> <p>Pre-packaged household-level policy which removes specified activities from all person's plans within selected households.</p>"},{"location":"api/policy/policies/#pam.policy.policies.RemoveHouseholdActivities--parameters","title":"Parameters","text":"<p>:param activities List of activities to be removed.</p> <p>:param probability A number or a subclass of the 'SamplingProbability' base class. The household policy accepts all levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Household.</p> <p>:param attribute_filter, default 'None' Optional argument which helps filter/select household for policy application based on object attributes.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self,\n             activities: list,\n             probability: Union[float, int, probability_samplers.SamplingProbability],\n             attribute_filter: filters.Filter = None):\n    super().__init__(modifiers.RemoveActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.RemoveIndividualActivities","title":"<code>RemoveIndividualActivities(activities: list, probability: Union[float, int, probability_samplers.SamplingProbability], attribute_filter: filters.Filter = None)</code>","text":"<p>         Bases: <code>ActivityPolicy</code></p> <p>Pre-packaged activity-level policy which removes specified activities from all person's plans within selected households.</p>"},{"location":"api/policy/policies/#pam.policy.policies.RemoveIndividualActivities--parameters","title":"Parameters","text":"<p>:param activities List of activities to be removed.</p> <p>:param probability A number or a subclass of the 'SamplingProbability' base class. The activity policy accepts all but 'HouseholdProbability' and 'PersonProbability' levels of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Activity.</p> <p>:param attribute_filter, default 'None' Optional argument which helps filter/select household for policy application based on object attributes.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self,\n             activities: list,\n             probability: Union[float, int, probability_samplers.SamplingProbability],\n             attribute_filter: filters.Filter = None):\n    super().__init__(modifiers.RemoveActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.RemovePersonActivities","title":"<code>RemovePersonActivities(activities: list, probability: Union[float, int, probability_samplers.SamplingProbability], attribute_filter: filters.Filter = None)</code>","text":"<p>         Bases: <code>PersonPolicy</code></p> <p>Pre-packaged person-level policy which removes specified activities from all person's plans within selected households.</p>"},{"location":"api/policy/policies/#pam.policy.policies.RemovePersonActivities--parameters","title":"Parameters","text":"<p>:param activities List of activities to be removed.</p> <p>:param probability A number or a subclass of the 'SamplingProbability' base class. The person policy accepts all but 'HouseholdProbability' level of Sampling Probabilities. If probability given as float: 0&lt;probability&lt;=1 then the probability level is assumed to be of the same level as the policy, i.e. Person.</p> <p>:param attribute_filter, default 'None' Optional argument which helps filter/select household for policy application based on object attributes.</p> Source code in <code>pam/policy/policies.py</code> <pre><code>def __init__(self,\n             activities: list,\n             probability: Union[float, int, probability_samplers.SamplingProbability],\n             attribute_filter: filters.Filter = None):\n    super().__init__(modifiers.RemoveActivity(activities), probability, attribute_filter)\n</code></pre>"},{"location":"api/policy/policies/#pam.policy.policies.apply_policies","title":"<code>apply_policies(population, policies: Union[List[Policy], Policy], in_place: Union[List[Policy], Policy] = False)</code>","text":"<p>Method which applies policies to population.</p>"},{"location":"api/policy/policies/#pam.policy.policies.apply_policies--parameters","title":"Parameters","text":"<p>:param population: pam.core.Population object</p> <p>:param policies: A single instance of a sublass of pam.policy.policies.Policy subclasses or a list of them. Policies to be applied to the population.</p> <p>:param in_place: {'True', 'False'}, default 'False' Whether to apply policies to current Population object or return a copy.</p> <ul> <li>True: applies policies to current Population object</li> <li>False: applies policies to a copy of the passed Population object :return: pam.core.Population if in_place=='False'</li> </ul> Source code in <code>pam/policy/policies.py</code> <pre><code>def apply_policies(population, policies: Union[List[Policy], Policy], in_place=False):\n\"\"\"\n    Method which applies policies to population.\n\n    Parameters\n    ----------\n    :param population:\n    pam.core.Population object\n\n    :param policies:\n    A single instance of a sublass of pam.policy.policies.Policy subclasses\n    or a list of them. Policies to be applied to the population.\n\n    :param in_place: {'True', 'False'}, default 'False'\n    Whether to apply policies to current Population object\n    or return a copy.\n\n    * True: applies policies to current Population object\n    * False: applies policies to a copy of the passed Population object\n    :return: pam.core.Population if in_place=='False'\n    \"\"\"\n    if not in_place:\n        pop = deepcopy(population)\n    else:\n        pop = population\n\n    if isinstance(policies, Policy):\n        policies = [policies]\n    for i in range(len(policies)):\n        policy = policies[i]\n        assert isinstance(policy, Policy), \\\n            'Policies need to be of type {}, not {}. Failed for policy {} at list index {}'.format(\n                type(Policy), type(policy), policy, i)\n    for hid, household in pop.households.items():\n        for policy in policies:\n            policy.apply_to(household)\n    if not in_place:\n        return pop\n</code></pre>"},{"location":"api/policy/filters/","title":"pam.policy.filters","text":""},{"location":"api/policy/filters/#pam.policy.filters.Filter","title":"<code>Filter()</code>","text":"<p>Base class for attribute-based filters</p> Source code in <code>pam/policy/filters.py</code> <pre><code>def __init__(self):\n    pass\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.Filter.print","title":"<code>print()</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def print(self):\n    print(self.__str__())\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.Filter.satisfies_conditions","title":"<code>satisfies_conditions(x)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def satisfies_conditions(self, x):\n    raise NotImplementedError('{} is a base class'.format(type(Filter)))\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter","title":"<code>PersonAttributeFilter(conditions: Dict[str, Callable[[str], bool]], how: Dict[str, Callable[[str], bool]] = 'all')</code>","text":"<p>         Bases: <code>Filter</code></p> <p>Helps filtering Person on specified attributes</p>"},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter--parameters","title":"Parameters","text":"<p>:param conditions Dictionary of key = person.attribute key value = function that returns a boolean given the value at person.attribute[key]</p> <p>:param how : {'all', 'any'}, default 'all' The level of rigour used to match conditions</p> <ul> <li>all: means all conditions for a person need to be met</li> <li>any: means at least one condition needs to be met</li> </ul> Source code in <code>pam/policy/filters.py</code> <pre><code>def __init__(self, conditions: Dict[str, Callable[[str], bool]], how='all'):\n    super().__init__()\n    self.conditions = conditions\n    self.how = how\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.conditions","title":"<code>conditions = conditions</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.how","title":"<code>how = how</code>  <code>instance-attribute</code>","text":""},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.household_satisfies_conditions","title":"<code>household_satisfies_conditions(household)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def household_satisfies_conditions(self, household):\n    if not self.conditions:\n        return True\n    for pid, person in household.people.items():\n        if self.person_satisfies_conditions(person):\n            return True\n    return False\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.person_satisfies_conditions","title":"<code>person_satisfies_conditions(person)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def person_satisfies_conditions(self, person):\n    if not self.conditions:\n        return True\n    elif self.how == 'all':\n        satisfies_attribute_conditions = True\n        for attribute_key, attribute_condition in self.conditions.items():\n            satisfies_attribute_conditions &amp;= attribute_condition(person.attributes[attribute_key])\n        return satisfies_attribute_conditions\n    elif self.how == 'any':\n        satisfies_attribute_conditions = False\n        for attribute_key, attribute_condition in self.conditions.items():\n            satisfies_attribute_conditions |= attribute_condition(person.attributes[attribute_key])\n        return satisfies_attribute_conditions\n    else:\n        raise NotImplementedError('{} not implemented, use only `all` or `any`'.format(self.how))\n</code></pre>"},{"location":"api/policy/filters/#pam.policy.filters.PersonAttributeFilter.satisfies_conditions","title":"<code>satisfies_conditions(x)</code>","text":"Source code in <code>pam/policy/filters.py</code> <pre><code>def satisfies_conditions(self, x):\n    if isinstance(x, pam.core.Household):\n        # household satisfies conditions if one person satisfies conditions according to self.how\n        return self.household_satisfies_conditions(x)\n    elif isinstance(x, pam.core.Person):\n        return self.person_satisfies_conditions(x)\n    elif isinstance(x, pam.activity.Activity):\n        raise NotImplementedError\n    else:\n        raise NotImplementedError\n</code></pre>"}]}